{
  "section": {
    "id": "07-scientific-computing-with-python",
    "name": "07-scientific-computing-with-python"
  },
  "challenges": [
    {
      "id": "5e44413e903586ffb414c94e",
      "title": "Build a Budget App Project",
      "challengeType": 23,
      "dashedName": "build-a-budget-app-project",
      "description": "Complete the `Category` class. It should be able to instantiate objects based on different budget categories like *food*, *clothing*, and *entertainment*. When objects are created, they are passed in the name of the category. The class should have an instance variable called `ledger` that is a list. The class should also contain the following methods:\n\n- A `deposit` method that accepts an amount and description. If no description is given, it should default to an empty string. The method should append an object to the ledger list in the form of `{'amount': amount, 'description': description}`.\n- A `withdraw` method that is similar to the `deposit` method, but the amount passed in should be stored in the ledger as a negative number. If there are not enough funds, nothing should be added to the ledger. This method should return `True` if the withdrawal took place, and `False` otherwise.\n- A `get_balance` method that returns the current balance of the budget category based on the deposits and withdrawals that have occurred.\n- A `transfer` method that accepts an amount and another budget category as arguments. The method should add a withdrawal with the amount and the description 'Transfer to [Destination Budget Category]'. The method should then add a deposit to the other budget category with the amount and the description 'Transfer from [Source Budget Category]'. If there are not enough funds, nothing should be added to either ledgers. This method should return `True` if the transfer took place, and `False` otherwise.\n- A `check_funds` method that accepts an amount as an argument. It returns `False` if the amount is greater than the balance of the budget category and returns `True` otherwise. This method should be used by both the `withdraw` method and `transfer` method.\n\nWhen the budget object is printed it should display:\n\n- A title line of 30 characters where the name of the category is centered in a line of `*` characters.\n- A list of the items in the ledger. Each line should show the description and amount. The first 23 characters of the description should be displayed, then the amount. The amount should be right aligned, contain two decimal places, and display a maximum of 7 characters.\n- A line displaying the category total.\n\nHere is an example usage:\n\n```py\nfood = Category('Food')\nfood.deposit(1000, 'deposit')\nfood.withdraw(10.15, 'groceries')\nfood.withdraw(15.89, 'restaurant and more food for dessert')\nclothing = Category('Clothing')\nfood.transfer(50, clothing)\nprint(food)\n```\n\nAnd here is an example of the output:\n\n```bash\n*************Food*************\ninitial deposit        1000.00\ngroceries               -10.15\nrestaurant and more foo -15.89\nTransfer to Clothing    -50.00\nTotal: 923.96\n```\n\nBesides the `Category` class, create a function (outside of the class) called `create_spend_chart` that takes a list of categories as an argument. It should return a string that is a bar chart.\n\nThe chart should show the percentage spent in each category passed in to the function. The percentage spent should be calculated only with withdrawals and not with deposits, and it should be the percentage of the amount spent for each category to the total spent for all categories. Down the left side of the chart should be labels 0 - 100. The 'bars' in the bar chart should be made out of the 'o' character. The height of each bar should be rounded down to the nearest 10. The horizontal line below the bars should go two spaces past the final bar. Each category name should be written vertically below the bar. There should be a title at the top that says 'Percentage spent by category'.\n\nThis function will be tested with up to four categories.\n\nLook at the example output below very closely and make sure the spacing of the output matches the example exactly.\n\n```bash\nPercentage spent by category\n100|          \n 90|          \n 80|          \n 70|          \n 60| o        \n 50| o        \n 40| o        \n 30| o        \n 20| o  o     \n 10| o  o  o  \n  0| o  o  o  \n    ----------\n     F  C  A  \n     o  l  u  \n     o  o  t  \n     d  t  o  \n        h     \n        i     \n        n     \n        g     \n```\n\nNote: open the browser console with F12 to see a more verbose output of the tests.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Category:\n    pass\n\ndef create_spend_chart(categories):\n    pass"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "class Category:\n\n    def __init__(self, name):\n        self.name = name\n        self.ledger = []\n        self.balance = 0\n        self.spent = 0\n\n    def __str__(self):\n        first_line = f'{self.name.center(30, \"*\")}\\n'\n        lines = ''\n        total = f'Total: {format(self.balance, \".2f\")}'\n\n        for n in range(len(self.ledger)):\n            descr = self.ledger[n][\"description\"][:23]\n            am = format(float(self.ledger[n][\"amount\"]), \".2f\")[:7]\n            lines = lines + f'{descr:<23}{am:>7}\\n'\n\n        return f'{first_line}{lines}{total}'\n\n    def deposit(self, amount, description=''):\n        self.ledger.append({\n            'amount': float(amount),\n            'description': description\n        })\n        self.balance = self.balance + float(amount)\n\n    def withdraw(self, amount, description=''):\n        if self.check_funds(amount):\n            self.ledger.append({\n                'amount': -float(amount),\n                'description': description\n            })\n            self.balance = self.balance - float(amount)\n            self.spent = self.spent + float(amount)\n            return True\n        else:\n            return False\n\n    def get_balance(self):\n        return self.balance\n\n    def transfer(self, amount, category):\n        if self.check_funds(amount):\n            # withdraw\n            self.ledger.append({\n                'amount': -float(amount),\n                'description': f'Transfer to {category.name}'\n            })\n            self.balance = self.balance - float(amount)\n            # deposit\n            category.deposit(amount, f'Transfer from {self.name}')\n\n            return True\n        else:\n            return False\n\n    def check_funds(self, amount):\n        if float(amount) > self.balance:\n            return False\n        else:\n            return True\n\n\ndef create_spend_chart(categories):\n    total_expenses = 0\n    obj = {}\n    col1 = []\n    str = []\n    final_str = 'Percentage spent by category\\n'\n    label_max_length = 0\n    label_strings = []\n\n    for category in categories:\n        total_expenses = total_expenses + category.spent\n        obj[category.name] = {'expenses': category.spent}\n        obj[category.name]['label'] = list(category.name)\n        if len(obj[category.name]['label']) > label_max_length:\n            label_max_length = len(obj[category.name]['label'])\n\n    for category in categories:\n        obj[category.name]['percent'] = (\n            (category.spent / total_expenses * 100) // 10) * 10\n        obj[category.name]['column'] = []\n        for i in range(0, 110, 10):\n            if obj[category.name]['percent'] >= i:\n                obj[category.name]['column'].insert(0, 'o')\n            else:\n                obj[category.name]['column'].insert(0, ' ')\n\n    for i in range(0, 110, 10):\n        col1.insert(0, i)\n\n    for i in range(11):\n        str.append(\"\")\n        for key in obj:\n            str[i] += (f'{obj[key][\"column\"][i]}  ')\n        final_str += f'{col1[i]:>3}| {str[i]}\\n'\n    final_str += f'    {\"-\"*(1+3*len(obj))}\\n   '\n\n    for i in range(label_max_length):\n        label_strings.append('  ')\n        for k in obj:\n            if len(obj[k]['label']) < label_max_length:\n                obj[k]['label'].extend(\n                    f'{\" \"*(label_max_length-len(obj[k][\"label\"]))}')\n\n            label_strings[i] += f'{obj[k][\"label\"][i]}  '\n        if i < label_max_length - 1:\n            label_strings[i] += '\\n   '\n        final_str += label_strings[i]\n\n    print(final_str)\n    return (final_str)"
        }
      ],
      "tests": [
        {
          "text": "The `deposit` method should create a specific object in the ledger instance variable.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_deposit(self):\n        self.food.deposit(900, \"deposit\")\n        actual = self.food.ledger[0]\n        expected = {\"amount\": 900, \"description\": \"deposit\"}\n        self.assertEqual(actual, expected, 'Expected \"deposit\" method to create a specific object in the ledger instance variable.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling the `deposit` method with no description should create a blank description.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_deposit_no_description(self):\n        self.food.deposit(45.56)\n        actual = self.food.ledger[0]\n        expected = {\"amount\": 45.56, \"description\": \"\"}\n        self.assertEqual(actual, expected, 'Expected calling \"deposit\" method with no description to create a blank description.')        \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `withdraw` method should create a specific object in the `ledger` instance variable.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_withdraw(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(45.67, \"milk, cereal, eggs, bacon, bread\")\n        actual = self.food.ledger[1]\n        expected = {\"amount\": -45.67, \"description\": \"milk, cereal, eggs, bacon, bread\"}\n        self.assertEqual(actual, expected, 'Expected \"withdraw\" method to create a specific object in the ledger instance variable.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling the `withdraw` method with no description should create a blank description.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_withdraw_no_description(self):\n        self.food.deposit(900, \"deposit\")\n        good_withdraw = self.food.withdraw(45.67)\n        actual = self.food.ledger[1]\n        expected = {\"amount\": -45.67, \"description\": \"\"}\n        self.assertEqual(actual, expected, 'Expected \"withdraw\" method with no description to create a blank description.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `withdraw` method should return `True` if the withdrawal took place.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_withdraw_no_description(self):\n        self.food.deposit(900, \"deposit\")\n        good_withdraw = self.food.withdraw(45.67)\n        self.assertEqual(good_withdraw, True, 'Expected \"withdraw\" method to return \"True\".')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `food.deposit(900, 'deposit')` and `food.withdraw(45.67, 'milk, cereal, eggs, bacon, bread')` should return a balance of `854.33`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_get_balance(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(45.67, \"milk, cereal, eggs, bacon, bread\")\n        actual = self.food.get_balance()\n        expected = 854.33\n        self.assertEqual(actual, expected, 'Expected balance to be 854.33')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling the `transfer` method on a category object should create a specific ledger item in that category object.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n\ndef test_transfer(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(45.67, \"milk, cereal, eggs, bacon, bread\")\n        transfer_amount = 20\n        good_transfer = self.food.transfer(transfer_amount, self.entertainment)\n        actual = self.food.ledger[2]\n        expected = {\"amount\": -transfer_amount, \"description\": \"Transfer to Entertainment\"}\n        self.assertEqual(actual, expected, 'Expected \"transfer\" method to create a specific ledger item in food object.')\n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `transfer` method should return `True` if the transfer took place.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n\ndef test_transfer(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(45.67, \"milk, cereal, eggs, bacon, bread\")\n        transfer_amount = 20 \n        good_transfer = self.food.transfer(transfer_amount, self.entertainment)        \n        self.assertEqual(good_transfer, True, 'Expected \"transfer\" method to return \"True\".')        \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `transfer` on a category object should reduce the balance in the category object.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n\ndef test_transfer(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(45.67, \"milk, cereal, eggs, bacon, bread\")\n        transfer_amount = 20\n        food_balance_before = self.food.get_balance()        \n        good_transfer = self.food.transfer(transfer_amount, self.entertainment)\n        food_balance_after = self.food.get_balance()\n        self.assertEqual(food_balance_before - food_balance_after, transfer_amount, 'Expected \"transfer\" method to reduce balance in food object.')\n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `transfer` method should increase the balance of the category object passed as its argument.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n\ndef test_transfer(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(45.67, \"milk, cereal, eggs, bacon, bread\")\n        transfer_amount = 20        \n        entertainment_balance_before = self.entertainment.get_balance()\n        good_transfer = self.food.transfer(transfer_amount, self.entertainment)        \n        entertainment_balance_after = self.entertainment.get_balance()        \n        self.assertEqual(entertainment_balance_after - entertainment_balance_before, transfer_amount, 'Expected \"transfer\" method to increase balance in entertainment object.')  \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `transfer` method should create a specific ledger item in the category object passed as its argument.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n\ndef test_transfer(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(45.67, \"milk, cereal, eggs, bacon, bread\")\n        transfer_amount = 20        \n        good_transfer = self.food.transfer(transfer_amount, self.entertainment)\n        actual = self.entertainment.ledger[0]\n        expected = {\"amount\": transfer_amount, \"description\": \"Transfer from Food\"}\n        self.assertEqual(actual, expected, 'Expected \"transfer\" method to create a specific ledger item in entertainment object.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `check_funds` method should return `False` if the amount passed to the method is greater than the category balance.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_check_funds(self):\n        self.food.deposit(10, \"deposit\")\n        actual = self.food.check_funds(20)\n        expected = False\n        self.assertEqual(actual, expected, 'Expected \"check_funds\" method to be False')   \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `check_funds` method should return `True` if the amount passed to the method is not greater than the category balance.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_check_funds(self):\n        self.food.deposit(10, \"deposit\")\n        actual = self.food.check_funds(10)\n        expected = True\n        self.assertEqual(actual, expected, 'Expected \"check_funds\" method to be True')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `withdraw` method should return `False` if the withdrawal didn't take place.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_withdraw_no_funds(self):\n        self.food.deposit(100, \"deposit\")\n        good_withdraw = self.food.withdraw(100.10)\n        self.assertEqual(good_withdraw, False, 'Expected \"withdraw\" method to return \"False\".')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `transfer` method should return `False` if the transfer didn't take place.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n\ndef test_transfer_no_funds(self):\n        self.food.deposit(100, \"deposit\")\n        good_transfer = self.food.transfer(200, self.entertainment)\n        self.assertEqual(good_transfer, False, 'Expected \"transfer\" method to return \"False\".')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nPrinting a `Category` instance should give a different string representation of the object.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n\ndef test_to_string(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(45.67, \"milk, cereal, eggs, bacon, bread\")\n        self.food.transfer(20, self.entertainment)\n        actual = str(self.food)\n        expected = \"*************Food*************\\\\ndeposit                 900.00\\\\nmilk, cereal, eggs, bac -45.67\\\\nTransfer to Entertainme -20.00\\\\nTotal: 834.33\"\n        self.assertEqual(actual, expected, 'Expected different string representation of object.')\n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nTitle at the top of `create_spend_chart` chart should say `Percentage spent by category`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_create_spend_chart(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(105.55)\n        chart = budget.create_spend_chart([self.food])\n        expected = \"Percentage spent by category\"\n        self.assertEqual(chart.split(\"\\\\n\")[0], expected, \"Chart should have correct title.\")\n`);\n\nconst testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`create_spend_chart` chart should have correct percentages down the left side.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n\ndef test_create_spend_chart(self):\n        self.food.deposit(900, \"deposit\")\n        self.food.withdraw(105.55)\n        chart = budget.create_spend_chart([self.food])\n        percentages = [\"100|\", \" 90|\", \" 80|\", \" 70|\", \" 60|\", \" 50|\", \" 40|\", \" 30|\", \" 20|\", \" 10|\", \"  0|\"]\n        for line, percent in zip(chart.split(\"\\\\n\")[1:], percentages):\n           self.assertTrue(line.startswith(percent), \"Chart correct percentages in the vertical axis.\")\n`);\n\nconst testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe height of each bar on the `create_spend_chart` chart should be rounded down to the nearest 10.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n        self.business = budget.Category(\"Business\")\n        self.food.deposit(900, \"deposit\")\n        self.entertainment.deposit(900, \"deposit\")\n        self.business.deposit(900, \"deposit\")\n        self.food.withdraw(78)\n        self.entertainment.withdraw(22)\n        self.business.withdraw(8)\n\ndef test_create_spend_chart_rounding_close_to_upper_and_lower_ten(self):\n        chart_lines = budget.create_spend_chart([self.food, self.entertainment]).split(\"\\\\n\")[1:12]\n        result_lines = '''100|\n 90|\n 80|\n 70| o\n 60| o\n 50| o\n 40| o\n 30| o\n 20| o  o\n 10| o  o\n  0| o  o'''.split(\"\\\\n\")\n\nself.assertEqual(len(chart_lines), len(result_lines), \"Lines missing in chart.\")\n        for actual, expected in zip(chart_lines, result_lines):\n            self.assertTrue(actual.startswith(expected), \"Expected different rounding of bars.\")\n\ndef test_create_spend_chart_rounding_single_digit(self):\n        chart_lines = budget.create_spend_chart([self.business, self.food, self.entertainment]).split(\"\\\\n\")[1:12]\n        result_lines = '''100|\n 90|\n 80|\n 70|    o\n 60|    o\n 50|    o\n 40|    o\n 30|    o\n 20|    o  o\n 10|    o  o\n  0| o  o  o'''.split(\"\\\\n\")\n\nself.assertEqual(len(chart_lines), len(result_lines), \"Lines missing in chart.\")\n        for actual, expected in zip(chart_lines, result_lines):\n            self.assertTrue(actual.startswith(expected), \"Expected different rounding of bars.\")\n`);\n\nconst testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nEach line in `create_spend_chart` chart should have the same length. Bars for different categories should be separated by two spaces, with additional two spaces after the final bar.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n        self.business = budget.Category(\"Business\")\n        self.food.deposit(900, \"deposit\")\n        self.entertainment.deposit(900, \"deposit\")\n        self.business.deposit(900, \"deposit\")\n        self.food.withdraw(78)\n        self.entertainment.withdraw(22)\n        self.business.withdraw(8)\n\ndef test_create_spend_chart_chart_lines_have_expected_length(self):\n        chart_categories = [[self.food, self.entertainment], [self.business, self.food, self.entertainment]]\n\nexpected_lengths = [len(line) for line in [\"  0| o  o  \", \"  0| o  o  o  \"]]\n        expected_chart_lines = 11\n\nfor categories, expected_length in zip(chart_categories, expected_lengths):\n            chart_lines = budget.create_spend_chart(categories).split(\"\\\\n\")[1:12]\n\nself.assertEqual(len(chart_lines), expected_chart_lines, \"Lines missing in chart.\")\n            for actual in chart_lines:\n                self.assertEqual(len(actual), expected_length, \"Expected different length of the chart line. Check that all spacing is exact.\")\n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`create_spend_chart` should correctly show horizontal line below the bars. Using three `-` characters for each category, and in total going two characters past the final bar.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n        self.business = budget.Category(\"Business\")\n        self.food.deposit(900, \"deposit\")\n        self.entertainment.deposit(900, \"deposit\")\n        self.business.deposit(900, \"deposit\")\n        self.food.withdraw(105.55)\n        self.entertainment.withdraw(33.40)\n        self.business.withdraw(10.99)\n\ndef test_create_spend_chart_horizontal_bar(self):\n        chart_categories = [[self.business], [self.business, self.food], [self.business, self.food, self.entertainment]]\n        horizontal_lines = [\"    ----\", \"    -------\", \"    ----------\"]\n        for categories, expected in zip(chart_categories, horizontal_lines):\n            actual = budget.create_spend_chart(categories).split(\"\\\\n\")[12]\n            self.assertEqual(actual, expected, \"Expected different horizontal bar. Check that all spacing is exact.\")\n`);\n\nconst testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`create_spend_chart` chart should not have new line character at the end.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n        self.business = budget.Category(\"Business\")\n\ndef test_create_spend_chart_no_ending_new_line(self):\n        self.food.deposit(900, \"deposit\")\n        self.entertainment.deposit(900, \"deposit\")\n        self.business.deposit(900, \"deposit\")\n        self.food.withdraw(105.55)\n        self.entertainment.withdraw(33.40)\n        self.business.withdraw(10.99)\n        actual = budget.create_spend_chart([self.business, self.food, self.entertainment])\n        self.assertFalse(actual.endswith(\"\\\\n\"), \"Expected chart to not have new line at the end.\")\n`);\n\nconst testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`create_spend_chart` chart should have each category name written vertically below the bar. Each line should have the same length, each category should be separated by two spaces, with additional two spaces after the final category.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n        self.business = budget.Category(\"Business\")\n        self.food.deposit(900, \"deposit\")\n        self.entertainment.deposit(900, \"deposit\")\n        self.business.deposit(900, \"deposit\")\n        self.food.withdraw(105.55)\n        self.entertainment.withdraw(33.40)\n        self.business.withdraw(10.99)\n\ndef test_create_spend_chart_names_two_categories(self):\n        chart = budget.create_spend_chart([self.food, self.entertainment])\n        actual = \"\\\\n\".join(chart.split(\"\\\\n\")[13:]).rstrip(\"\\\\n\")\n        expected = \"     F  E  \\\\n     o  n  \\\\n     o  t  \\\\n     d  e  \\\\n        r  \\\\n        t  \\\\n        a  \\\\n        i  \\\\n        n  \\\\n        m  \\\\n        e  \\\\n        n  \\\\n        t  \"\n        self.assertEqual(actual, expected, \"Expected different category names written vertically below the bar. Check that all spacing is exact.\")\n\ndef test_create_spend_chart_names_three_categories(self):\n        chart = budget.create_spend_chart([self.business, self.food, self.entertainment])\n        actual = \"\\\\n\".join(chart.split(\"\\\\n\")[13:]).rstrip(\"\\\\n\")\n        expected = \"     B  F  E  \\\\n     u  o  n  \\\\n     s  o  t  \\\\n     i  d  e  \\\\n     n     r  \\\\n     e     t  \\\\n     s     a  \\\\n     s     i  \\\\n           n  \\\\n           m  \\\\n           e  \\\\n           n  \\\\n           t  \"\n        self.assertEqual(actual, expected, \"Expected different category names written vertically below the bar. Check that all spacing is exact.\")\n`);\n\nconst testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`create_spend_chart` should print a different chart representation. Check that all spacing is exact. Open your browser console with F12 for more details.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/budget.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport budget\nfrom importlib import reload\n\nreload(budget)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.food = budget.Category(\"Food\")\n        self.entertainment = budget.Category(\"Entertainment\")\n        self.business = budget.Category(\"Business\")\n\ndef test_create_spend_chart(self):\n        self.food.deposit(900, \"deposit\")\n        self.entertainment.deposit(900, \"deposit\")\n        self.business.deposit(900, \"deposit\")\n        self.food.withdraw(105.55)\n        self.entertainment.withdraw(33.40)\n        self.business.withdraw(10.99)\n        actual = budget.create_spend_chart([self.business, self.food, self.entertainment])\n        expected = \"Percentage spent by category\\\\n100|          \\\\n 90|          \\\\n 80|          \\\\n 70|    o     \\\\n 60|    o     \\\\n 50|    o     \\\\n 40|    o     \\\\n 30|    o     \\\\n 20|    o  o  \\\\n 10|    o  o  \\\\n  0| o  o  o  \\\\n    ----------\\\\n     B  F  E  \\\\n     u  o  n  \\\\n     s  o  t  \\\\n     i  d  e  \\\\n     n     r  \\\\n     e     t  \\\\n     s     a  \\\\n     s     i  \\\\n           n  \\\\n           m  \\\\n           e  \\\\n           n  \\\\n           t  \"\n        self.assertEqual(actual, expected, 'Expected different chart representation. Check that all spacing is exact.')\n`);\n\nconst testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 462361,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\build-a-budget-app-project\\budget-app.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "build-a-budget-app-project",
        "name": "Build A Budget App Project"
      }
    },
    {
      "id": "5e444147903586ffb414c94f",
      "title": "Build a Polygon Area Calculator Project",
      "challengeType": 23,
      "dashedName": "build-a-polygon-area-calculator-project",
      "description": "In this project you will use object oriented programming to create a `Rectangle` class and a `Square` class. The `Square` class should be a subclass of `Rectangle`, and inherit its methods and attributes.\n\n## Rectangle class\n\nWhen a Rectangle object is created, it should be initialized with `width` and `height` attributes. The class should also contain the following methods:\n\n- `set_width`\n- `set_height`\n- `get_area`: Returns area (`width * height`)\n- `get_perimeter`: Returns perimeter (`2 * width + 2 * height`)\n- `get_diagonal`: Returns diagonal (`(width ** 2 + height ** 2) ** .5`)\n- `get_picture`: Returns a string that represents the shape using lines of '\\*'. The number of lines should be equal to the height and the number of '\\*' in each line should be equal to the width. There should be a new line (`\\n`) at the end of each line. If the width or height is larger than 50, this should return the string: `'Too big for picture.'`.\n- `get_amount_inside`: Takes another shape (square or rectangle) as an argument. Returns the number of times the passed in shape could fit inside the shape (with no rotations). For instance, a rectangle with a width of 4 and a height of 8 could fit in two squares with sides of 4.\n\nAdditionally, if an instance of a `Rectangle` is represented as a string, it should look like: `'Rectangle(width=5, height=10)'`.\n\n## Square class\n\nThe `Square` class should be a subclass of `Rectangle`. When a `Square` object is created, a single side length is passed in. The `__init__` method should store the side length in both the `width` and `height` attributes from the `Rectangle` class.\n\nThe `Square` class should be able to access the `Rectangle` class methods but should also contain a `set_side` method. If an instance of a `Square` is represented as a string, it should look like: `'Square(side=9)'`.\n\nAdditionally, the `set_width` and `set_height` methods on the `Square` class should set both the width and height.\n\n## Usage example\n\n```py\nrect = Rectangle(10, 5)\nprint(rect.get_area())\nrect.set_height(3)\nprint(rect.get_perimeter())\nprint(rect)\nprint(rect.get_picture())\n\nsq = Square(9)\nprint(sq.get_area())\nsq.set_side(4)\nprint(sq.get_diagonal())\nprint(sq)\nprint(sq.get_picture())\n\nrect.set_height(8)\nrect.set_width(16)\nprint(rect.get_amount_inside(sq))\n```\n\nThat code should return:\n\n```bash\n50\n26\nRectangle(width=10, height=3)\n**********\n**********\n**********\n\n81\n5.656854249492381\nSquare(side=4)\n****\n****\n****\n****\n\n8\n```\n\nNote: open the browser console with F12 to see a more verbose output of the tests.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Rectangle:\n    pass\n\nclass Square:\n    pass"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "class Rectangle:\n    def __init__(self, width, height):\n        self.width = width\n        self.height = height\n\n    def __str__(self):\n        return f'Rectangle(width={self.width}, height={self.height})'\n\n    def set_width(self, width):\n        self.width = width\n    \n    def set_height(self, height):\n        self.height = height\n\n    def get_area(self):\n        area = self.width * self.height\n        return area\n\n    def get_perimeter(self):\n        perimeter = self.width * 2 + self.height * 2\n        return perimeter\n    \n    def get_diagonal(self):\n        diagonal = (self.width ** 2 + self.height ** 2) ** 0.5        \n        return diagonal\n    \n    def get_picture(self):\n        if self.width < 50 and self.height < 50:\n            picture = f'{\"*\"*self.width}\\n'*self.height            \n            return picture\n        else:            \n            return 'Too big for picture.'\n    \n    def get_amount_inside(self, polygon):\n        h_number = self.height // polygon.height\n        w_number = self.width // polygon.width\n        repetition = h_number * w_number        \n        return repetition\n        \n\nclass Square(Rectangle):\n    def __init__(self, side):\n        self.width = side\n        self.height = side\n\n    def __str__(self):\n        return f'Square(side={self.width})'\n    \n    def set_width(self, side):\n        self.width = side\n        self.height = side\n    \n    def set_height(self, side):\n        self.height = side\n        self.width = side\n    \n    def set_side(self,side):\n        self.width = side\n        self.height = side"
        }
      ],
      "tests": [
        {
          "text": "The `Square` class should be a subclass of the `Rectangle` class.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n\ndef test_subclass(self):\n        actual = issubclass(shape_calculator.Square, shape_calculator.Rectangle)\n        expected = True\n        self.assertEqual(actual, expected, 'Expected Square class to be a subclass of the Rectangle class.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `Square` class should be a distinct class from the `Rectangle` class.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n\ndef test_distinct_classes(self):\n        actual = shape_calculator.Square is not shape_calculator.Rectangle\n        expected = True\n        self.assertEqual(actual, expected, 'Expected Square class to be a distinct class from the Rectangle class.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nA square object should be an instance of the `Square` class and the `Rectangle` class.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.sq = shape_calculator.Square(5)\n\ndef test_square_is_square_and_rectangle(self):\n        actual = isinstance(self.sq, shape_calculator.Square) and isinstance(self.sq, shape_calculator.Rectangle)\n        expected = True\n        self.assertEqual(actual, expected, 'Expected square object to be an instance of the Square class and the Rectangle class.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe string representation of `Rectangle(3, 6)` should be `'Rectangle(width=3, height=6)'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_rectangle_string(self):\n        actual = str(self.rect)\n        expected = \"Rectangle(width=3, height=6)\"\n        self.assertEqual(actual, expected, 'Expected string representation of rectangle to be \"Rectangle(width=3, height=6)\"')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe string representation of `Square(5)` should be `'Square(side=5)'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.sq = shape_calculator.Square(5)\n\ndef test_square_string(self):\n        actual = str(self.sq)\n        expected = \"Square(side=5)\"\n        self.assertEqual(actual, expected, 'Expected string representation of square to be \"Square(side=5)\"')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Rectangle(3, 6).get_area()` should return `18`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_area(self):\n        actual = self.rect.get_area()\n        expected = 18\n        self.assertEqual(actual, expected, 'Expected area of rectangle to be 18')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Square(5).get_area()` should return `25`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.sq = shape_calculator.Square(5)\n\ndef test_area(self):        \n        actual = self.sq.get_area()\n        expected = 25\n        self.assertEqual(actual, expected, 'Expected area of square to be 25')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Rectangle(3, 6).get_perimeter()` should return `18`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_perimeter(self):\n        actual = self.rect.get_perimeter()\n        expected = 18\n        self.assertEqual(actual, expected, 'Expected perimeter of rectangle to be 18')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Square(5).get_perimeter()` should return `20`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.sq = shape_calculator.Square(5)\n\ndef test_perimeter(self):\n        actual = self.sq.get_perimeter()\n        expected = 20\n        self.assertEqual(actual, expected, 'Expected perimeter of square to be 20')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Rectangle(3, 6).get_diagonal()` should return `6.708203932499369`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_diagonal(self):\n        actual = self.rect.get_diagonal()\n        expected = 6.708203932499369\n        self.assertEqual(actual, expected, 'Expected diagonal of rectangle to be 6.708203932499369')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Square(5).get_diagonal()` should return `7.0710678118654755`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.sq = shape_calculator.Square(5)\n\ndef test_diagonal(self):\n        actual = self.sq.get_diagonal()\n        expected = 7.0710678118654755\n        self.assertEqual(actual, expected, 'Expected diagonal of square to be 7.0710678118654755')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nAn instance of the `Rectangle` class should have a different string representation after setting new values.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_set_attributes(self):\n        self.rect.set_width(7)\n        self.rect.set_height(8)        \n        actual = str(self.rect)\n        expected = \"Rectangle(width=7, height=8)\"\n        self.assertEqual(actual, expected, 'Expected string representation of rectangle after setting new values to be \"Rectangle(width=7, height=8)\"')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nAn instance of the `Square` class should have a different string representation after setting new values by using `.set_side()`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.sq = shape_calculator.Square(5)\n\ndef test_set_attributes(self):        \n        self.sq.set_side(2)        \n        actual = str(self.sq)\n        expected = \"Square(side=2)\"\n        self.assertEqual(actual, expected, 'Expected string representation of square after setting new values to be \"Square(side=2)\"')   \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nAn instance of the `Square` class should have a different string representation after setting new values by using `.set_width()` or `set_height()`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.sq = shape_calculator.Square(5)\n\ndef test_set_attributes(self):        \n        self.sq.set_height(2)        \n        actual = str(self.sq)\n        expected = \"Square(side=2)\"\n        self.assertEqual(actual, expected, 'Expected string representation of square after setting new values to be \"Square(side=2)\"')\n        self.sq.set_width(4)\n        actual = str(self.sq)\n        expected = \"Square(side=4)\"\n        self.assertEqual(actual, expected, 'Expected string representation of square after setting width to be \"Square(side=4)\"')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `.get_picture()` method should return a different string representation of a `Rectangle` instance.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_rectangle_picture(self):\n        self.rect.set_width(7)\n        self.rect.set_height(3)\n        actual = self.rect.get_picture()\n        expected = \"*******\\\\n*******\\\\n*******\\\\n\"\n        self.assertEqual(actual, expected, 'Expected rectangle picture to be different.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `.get_picture()` method should return a different string representation of a `Square` instance.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.sq = shape_calculator.Square(5)\n\ndef test_square_picture(self):\n        self.sq.set_side(2)\n        actual = self.sq.get_picture()\n        expected = \"**\\\\n**\\\\n\"\n        self.assertEqual(actual, expected, 'Expected square picture to be different.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nThe `.get_picture()` method should return the string `'Too big for picture.'` if the `width` or `height` attributes are larger than `50`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_big_picture(self):\n        self.rect.set_width(51)\n        self.rect.set_height(3)\n        actual = self.rect.get_picture()\n        expected = \"Too big for picture.\"\n        self.assertEqual(actual, expected, 'Expected message: \"Too big for picture.\"')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Rectangle(15,10).get_amount_inside(Square(5))` should return `6`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n        self.sq = shape_calculator.Square(5)\n\ndef test_get_amount_inside(self):\n        self.rect.set_height(10)\n        self.rect.set_width(15)\n        actual = self.rect.get_amount_inside(self.sq)\n        expected = 6\n        self.assertEqual(actual, expected, 'Expected \"get_amount_inside\" to return 6.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Rectangle(4,8).get_amount_inside(Rectangle(3, 6))` should return `1`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_get_amount_inside_two_rectangles(self):\n        rect2 = shape_calculator.Rectangle(4, 8)\n        actual = rect2.get_amount_inside(self.rect)\n        expected = 1\n        self.assertEqual(actual, expected, 'Expected \"get_amount_inside\" to return 1.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\n`Rectangle(2,3).get_amount_inside(Rectangle(3, 6))` should return `0`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/shape_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py',`\nimport unittest\nimport shape_calculator\nfrom importlib import reload\nreload(shape_calculator)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def setUp(self):\n        self.rect = shape_calculator.Rectangle(3, 6)\n\ndef test_get_amount_inside_none(self):\n        rect2 = shape_calculator.Rectangle(2, 3)\n        actual = rect2.get_amount_inside(self.rect)\n        expected = 0\n        self.assertEqual(actual, expected, 'Expected \"get_amount_inside\" to return 0.')    \n`);\n    const testCode = `\nfrom unittest import main\nfrom importlib import reload\nimport test_module\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 462363,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\build-a-polygon-area-calculator-project\\polygon-area-calculator.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "build-a-polygon-area-calculator-project",
        "name": "Build A Polygon Area Calculator Project"
      }
    },
    {
      "id": "5e44414f903586ffb414c950",
      "title": "Build a Probability Calculator Project",
      "challengeType": 23,
      "dashedName": "build-a-probability-calculator-project",
      "description": "Suppose there is a hat containing 5 blue balls, 4 red balls, and 2 green balls. What is the probability that a random draw of 4 balls will contain at least 1 red ball and 2 green balls? While it would be possible to calculate the probability using advanced mathematics, an easier way is to write a program to perform a large number of experiments to estimate an approximate probability.\n\nFor this project, you will write a program to determine the approximate probability of drawing certain balls randomly from a hat.\n\nFirst, create a `Hat` class in `main.py`. The class should take a variable number of arguments that specify the number of balls of each color that are in the hat. For example, a class object could be created in any of these ways:\n\n```py\nhat1 = Hat(yellow=3, blue=2, green=6)\nhat2 = Hat(red=5, orange=4)\nhat3 = Hat(red=5, orange=4, black=1, blue=0, pink=2, striped=9)\n```\n\nA hat will always be created with at least one ball. The arguments passed into the hat object upon creation should be converted to a `contents` instance variable. `contents` should be a list of strings containing one item for each ball in the hat. Each item in the list should be a color name representing a single ball of that color. For example, if your hat is `{'red': 2, 'blue': 1}`, `contents` should be `['red', 'red', 'blue']`.\n\nThe `Hat` class should have a `draw` method that accepts an argument indicating the number of balls to draw from the hat. This method should remove balls at random from `contents` and return those balls as a list of strings. The balls should not go back into the hat during the draw, similar to an urn experiment without replacement. If the number of balls to draw exceeds the available quantity, return all the balls.\n\nNext, create an `experiment` function in `main.py` (not inside the `Hat` class). This function should accept the following arguments:\n\n- `hat`: A hat object containing balls that should be copied inside the function.\n- `expected_balls`: An object indicating the exact group of balls to attempt to draw from the hat for the experiment. For example, to determine the probability of drawing 2 blue balls and 1 red ball from the hat, set `expected_balls` to `{'blue':2, 'red':1}`.\n- `num_balls_drawn`: The number of balls to draw out of the hat in each experiment.\n- `num_experiments`: The number of experiments to perform. (The more experiments performed, the more accurate the approximate probability will be.)\n\nThe `experiment` function should return a probability.\n\nFor example, if you want to determine the probability of getting at least two red balls and one green ball when you draw five balls from a hat containing six black, four red, and three green. To do this, you will perform `N` experiments, count how many times `M` you get at least two red balls and one green ball, and estimate the probability as `M/N`. Each experiment consists of starting with a hat containing the specified balls, drawing several balls, and checking if you got the balls you were attempting to draw.\n\nHere is how you would call the `experiment` function based on the example above with 2000 experiments:\n\n```py\nhat = Hat(black=6, red=4, green=3)\nprobability = experiment(hat=hat,\n                  expected_balls={'red':2,'green':1},\n                  num_balls_drawn=5,\n                  num_experiments=2000)\n```\n\nThe output would be something like this:\n\n```bash\n0.356\n```\n\nSince this is based on random draws, the probability will be slightly different each time the code is run.\n\n_Hint: Consider using the modules that are already imported at the top. Do not initialize random seed within the file._\n\nNote: open the browser console with F12 to see a more verbose output of the tests.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import copy\nimport random\n\nclass Hat:\n    pass\n\ndef experiment(hat, expected_balls, num_balls_drawn, num_experiments):\n    pass"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "import copy\nimport random\n\nclass Hat:\n    def __init__(self, **hat):\n        self.hat = hat\n        contents = []\n        for i in hat:\n            for j in range(hat[i]):\n                contents.append(i)           \n        self.contents = contents\n               \n\n    def draw(self, number): \n        drawn = []\n        if number >= len(self.contents):\n            drawn.extend(self.contents)\n            self.contents = []\n        else:\n            for i in range(number):\n                drawn.append(\n                    self.contents.pop(random.randrange(len(self.contents)))\n                )                \n        return drawn\n\ndef experiment(hat, expected_balls, num_balls_drawn, num_experiments):    \n    expected_balls_list = []\n    drawn_list = []\n    success = 0\n    for i in expected_balls:\n        for j in range(expected_balls[i]):\n            expected_balls_list.append(i)\n    for j in range(num_experiments):\n        hat_copy = copy.deepcopy(hat)\n        drawn_list.append(hat_copy.draw(num_balls_drawn))        \n        exp_ball_list_copy = expected_balls_list[:]\n        for k in range(len(drawn_list[j])):\n            try:\n                ind = exp_ball_list_copy.index(drawn_list[j][k])\n                exp_ball_list_copy.pop(ind)\n            except:\n                continue\n        if len(exp_ball_list_copy) == 0:\n            success += 1        \n    probability = success/num_experiments    \n    return probability"
        }
      ],
      "tests": [
        {
          "text": "Creation of `hat` object should add correct contents.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile(\"/home/pyodide/probability_calculator.py\", code);\n    pyodide.FS.writeFile(\n      \"/home/pyodide/test_module.py\",\n      `\nimport unittest\nimport probability_calculator\nfrom importlib import reload\n\nreload(probability_calculator)\n\nprobability_calculator.random.seed(95)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_hat_class_contents(self):\n        hat = probability_calculator.Hat(red=3,blue=2)\n        actual = hat.contents\n        expected = [\"red\",\"red\",\"red\",\"blue\",\"blue\"]\n        self.assertEqual(actual, expected, 'Expected creation of hat object to add correct contents.')\n        `\n    );\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  },\n});\n```\n\nThe `draw` method in `hat` class should reduce number of items in contents.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile(\"/home/pyodide/probability_calculator.py\", code);\n    pyodide.FS.writeFile(\n      \"/home/pyodide/test_module.py\",\n      `\nimport unittest\nimport probability_calculator\nfrom importlib import reload\n\nreload(probability_calculator)\n\nprobability_calculator.random.seed(95)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_hat_draw(self):\n        hat = probability_calculator.Hat(red=5,blue=2)\n        actual = hat.draw(2)\n        expected = ['blue', 'red']\n        self.assertEqual(actual, expected, 'Expected hat draw to return two random items from hat contents.')\n        actual = len(hat.contents)\n        expected = 5\n        self.assertEqual(actual, expected, 'Expected hat draw to reduce number of items in contents.')\n        `\n    );\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  },\n});\n```\n\nThe `draw` method should behave correctly when the number of balls to extract is bigger than the number of balls in the hat.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile(\"/home/pyodide/probability_calculator.py\", code);\n    pyodide.FS.writeFile(\n      \"/home/pyodide/test_module.py\",\n      `\nimport unittest\nimport probability_calculator\nfrom importlib import reload\n\nreload(probability_calculator)\n\nprobability_calculator.random.seed(95)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_hat_draw_2(self):\n        hat = probability_calculator.Hat(yellow=5,red=1,green=3,blue=9,test=1)\n        actual = sorted(hat.draw(20))\n        expected = sorted(['yellow', 'yellow', 'yellow', 'yellow', 'yellow', 'red', 'green', 'green', 'green', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'blue', 'test'])\n        self.assertEqual(actual, expected, 'Expected hat draw to return all items from hat contents.')\n        actual = len(hat.contents)\n        expected = 0\n        self.assertEqual(actual, expected, 'Expected hat draw to leave no items in contents.')\n        `\n    );\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  },\n});\n```\n\nThe `experiment` method should return a different probability.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile(\"/home/pyodide/probability_calculator.py\", code);\n    pyodide.FS.writeFile(\n      \"/home/pyodide/test_module.py\",\n      `\nimport unittest\nimport probability_calculator\nfrom importlib import reload\n\nreload(probability_calculator)\n\nprobability_calculator.random.seed(95)\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_prob_experiment(self):\n        hat = probability_calculator.Hat(blue=3,red=2,green=6)\n        probability = probability_calculator.experiment(hat=hat, expected_balls={\"blue\":2,\"green\":1}, num_balls_drawn=4, num_experiments=1000)\n        actual = probability\n        expected = 0.272\n        self.assertAlmostEqual(actual, expected, delta = 0.01, msg = 'Expected experiment method to return a different probability.')\n        hat = probability_calculator.Hat(yellow=5,red=1,green=3,blue=9,test=1)\n        probability = probability_calculator.experiment(hat=hat, expected_balls={\"yellow\":2,\"blue\":3,\"test\":1}, num_balls_drawn=20, num_experiments=100)\n        actual = probability\n        expected = 1.0\n        self.assertAlmostEqual(actual, expected, delta = 0.01, msg = 'Expected experiment method to return a different probability.')\n        `\n    );\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  },\n});\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 462364,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\build-a-probability-calculator-project\\probability-calculator.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "build-a-probability-calculator-project",
        "name": "Build A Probability Calculator Project"
      }
    },
    {
      "id": "5e444136903586ffb414c94d",
      "title": "Build a Time Calculator Project",
      "challengeType": 23,
      "dashedName": "build-a-time-calculator-project",
      "description": "Write a function named `add_time` that takes in two required parameters and one optional parameter:\n\n- a start time in the 12-hour clock format (ending in AM or PM)\n- a duration time that indicates the number of hours and minutes\n- (optional) a starting day of the week, case insensitive\n\nThe function should add the duration time to the start time and return the result.\n\nIf the result will be the next day, it should show `(next day)` after the time. If the result will be more than one day later, it should show `(n days later)` after the time, where \"n\" is the number of days later.\n\nIf the function is given the optional starting day of the week parameter, then the output should display the day of the week of the result. The day of the week in the output should appear after the time and before the number of days later.\n\nBelow are some examples of different cases the function should handle. Pay close attention to the spacing and punctuation of the results.\n\n```py\nadd_time('3:00 PM', '3:10')\n# Returns: 6:10 PM\n\nadd_time('11:30 AM', '2:32', 'Monday')\n# Returns: 2:02 PM, Monday\n\nadd_time('11:43 AM', '00:20')\n# Returns: 12:03 PM\n\nadd_time('10:10 PM', '3:30')\n# Returns: 1:40 AM (next day)\n\nadd_time('11:43 PM', '24:20', 'tueSday')\n# Returns: 12:03 AM, Thursday (2 days later)\n\nadd_time('6:30 PM', '205:12')\n# Returns: 7:42 AM (9 days later)\n```\n\nDo not import any Python libraries. Assume that the start times are valid times. The minutes in the duration time will be a whole number less than 60, but the hour can be any whole number.\n\nNote: open the browser console with F12 to see a more verbose output of the tests.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_time(start, duration):\n\n\n\n\n\n    return new_time"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "def add_time(start, duration, day=''):\n    start_arr = start[0:-3].split(':')\n    dur_arr = duration.split(':')\n    tail = ''\n    # converting to 24h format\n    if 'AM' in start:\n        if start_arr[0] == '12':\n            start_arr[0] = '00'\n    elif 'PM' in start:\n        if start_arr[0] == '12':\n            start_arr[0] = '12'\n        else:\n            start_arr[0] = f'{int(start_arr[0]) + 12}'\n\n    # adding minutes\n    sum_m = int(start_arr[1]) + int(dur_arr[1])\n    if sum_m > 59:\n        \n        if (sum_m - 60 * (sum_m//60)) < 10:\n            mins = f'0{(sum_m - 60 * (sum_m//60))}'\n            dur_arr[0] = int(dur_arr[0]) + sum_m//60\n            \n        else:    \n            mins = sum_m - 60 * (sum_m//60)\n            dur_arr[0] = int(dur_arr[0]) + sum_m//60\n    else:\n        if sum_m < 10:\n            mins = f'0{sum_m}'\n        else:\n            mins = sum_m\n    \n    #adding hours\n    sum_h = int(start_arr[0]) + int(dur_arr[0])\n    if sum_h < 24:\n        hours= sum_h\n        #time_24 = f'{hours}:{mins}'\n    else:\n        days_after = sum_h//24\n        if days_after == 1:\n            hours = sum_h - 24\n            tail = ' (next day)'\n        else:\n            hours = sum_h - 24 * days_after\n            tail = f' ({days_after} days later)'\n\n    #converting back to AM/PM\n    if hours == 0:\n        hours = 12\n        time = f'{hours}:{mins} AM'\n        final_time = f'{time}{tail}'\n    elif hours < 12:\n        time = f'{hours}:{mins} AM'\n        final_time = f'{time}{tail}'\n    else:\n        if hours > 12:\n            hours = hours - 12\n        time = f'{hours}:{mins} PM'\n        final_time = f'{time}{tail}'\n\n    #days of the week\n    week = ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday']\n    if day:\n        day = day.capitalize()\n        if not tail:\n            final_time = f'{time}, {day}'\n        elif tail == ' (next day)':\n            index = week.index(day) + 1\n            if index == 7:\n                index = 0\n            week_day = f', {week[index]}'\n            final_time = f'{time}{week_day}{tail}'\n        elif tail:\n            index = (week.index(day) + days_after) % 7\n            week_day = f', {week[index]}'\n            final_time = f'{time}{week_day}{tail}'\n\n    \n    print('\\n')\n    print(final_time)\n    print('\\n')\n    return final_time"
        }
      ],
      "tests": [
        {
          "text": "Calling `add_time('3:30 PM', '2:12')` should return `'5:42 PM'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\nimport time_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_same_period(self):\n        actual = time_calculator.add_time(\"3:30 PM\", \"2:12\")\n        expected = \"5:42 PM\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"3:30 PM\", \"2:12\" to return \"5:42 PM\"')  \n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `add_time('11:55 AM', '3:12')`  should return `'3:07 PM'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_different_period(self):\n        actual = time_calculator.add_time(\"11:55 AM\", \"3:12\")\n        expected = \"3:07 PM\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"11:55 AM\", \"3:12\" to return \"3:07 PM\"')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nExpected time to end with `'(next day)'` when it is the next day.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_next_day(self):\n        actual = time_calculator.add_time(\"9:15 PM\", \"5:30\")\n        expected = \"2:45 AM (next day)\"\n        self.assertEqual(actual, expected, 'Expected time to end with \"(next day)\" when it is the next day.')\n          `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nExpected period to change from `AM` to `PM` at `12:00`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_period_change_at_twelve(self):\n        actual = time_calculator.add_time(\"11:40 AM\", \"0:25\")\n        expected = \"12:05 PM\"\n        self.assertEqual(actual, expected, 'Expected period to change from AM to PM at 12:00')\n          `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `add_time('2:59 AM', '24:00')` should return `'2:59 AM (next day)'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_twenty_four(self):\n        actual = time_calculator.add_time(\"2:59 AM\", \"24:00\")\n        expected = \"2:59 AM (next day)\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"2:59 AM\", \"24:00\" to return \"2:59 AM (next day)\"')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `add_time('11:59 PM', '24:05')` should return `'12:04 AM (2 days later)'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_two_days_later(self):\n        actual = time_calculator.add_time(\"11:59 PM\", \"24:05\")\n        expected = \"12:04 AM (2 days later)\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"11:59 PM\", \"24:05\" to return \"12:04 AM (2 days later)\"')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `add_time('8:16 PM', '466:02')` should return `'6:18 AM (20 days later)'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_high_duration(self):\n        actual = time_calculator.add_time(\"8:16 PM\", \"466:02\")\n        expected = \"6:18 AM (20 days later)\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"8:16 PM\", \"466:02\" to return \"6:18 AM (20 days later)\"')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nExpected adding `0:00` to return the initial time.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_no_change(self):\n        actual = time_calculator.add_time(\"5:01 AM\", \"0:00\")\n        expected = \"5:01 AM\"\n        self.assertEqual(actual, expected, 'Expected adding 0:00 to return initial time.')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `add_time('3:30 PM', '2:12', 'Monday')`should return `'5:42 PM, Monday'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_same_period_with_day(self):\n        actual = time_calculator.add_time(\"3:30 PM\", \"2:12\", \"Monday\")\n        expected = \"5:42 PM, Monday\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"3:30 PM\", \"2:12\", \"Monday\" to return \"5:42 PM, Monday\"')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `add_time('2:59 AM', '24:00', 'saturDay')` should return `'2:59 AM, Sunday (next day)'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_twenty_four_with_day(self):\n        actual = time_calculator.add_time(\"2:59 AM\", \"24:00\", \"saturDay\")\n        expected = \"2:59 AM, Sunday (next day)\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"2:59 AM\", \"24:00\", \"saturDay\" to return \"2:59 AM, Sunday (next day)\"')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `add_time('11:59 PM', '24:05', 'Wednesday')` should return `'12:04 AM, Friday (2 days later)'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_two_days_later_with_day(self):\n        actual = time_calculator.add_time(\"11:59 PM\", \"24:05\", \"Wednesday\")\n        expected = \"12:04 AM, Friday (2 days later)\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"11:59 PM\", \"24:05\", \"Wednesday\" to return \"12:04 AM, Friday (2 days later)\"')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```\n\nCalling `add_time('8:16 PM', '466:02', 'tuesday') `should return `'6:18 AM, Monday (20 days later)'`.\n\n```js\n({\n  test: () => {\n    pyodide.FS.writeFile('/home/pyodide/time_calculator.py', code);\n    pyodide.FS.writeFile('/home/pyodide/test_module.py', `\nimport unittest\ntime_calculator\nfrom importlib import reload\n\nreload(time_calculator)\n\nclass UnitTests(unittest.TestCase):\n    maxDiff = None\n    def test_high_duration_with_day(self):\n        actual = time_calculator.add_time(\"8:16 PM\", \"466:02\", \"tuesday\")\n        expected = \"6:18 AM, Monday (20 days later)\"\n        self.assertEqual(actual, expected, 'Expected calling \"add_time()\" with \"8:16 PM\", \"466:02\", \"tuesday\" to return \"6:18 AM, Monday (20 days later)\"')\n        `);\n    const testCode = `\nfrom unittest import main\nimport test_module\nfrom importlib import reload\n\nreload(test_module)\nt = main(module='test_module', exit=False)\nt.result.wasSuccessful()\n`;\n    const out = runPython(testCode);\n    assert(out);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 462360,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\build-a-time-calculator-project\\time-calculator.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "build-a-time-calculator-project",
        "name": "Build A Time Calculator Project"
      }
    },
    {
      "id": "5e44412c903586ffb414c94c",
      "title": "Build an Arithmetic Formatter Project",
      "challengeType": 23,
      "dashedName": "build-an-arithmetic-formatter-project",
      "description": "Students in primary school often arrange arithmetic problems vertically to make them easier to solve. For example, \"235 + 52\" becomes:\n\n```py\n  235\n+  52\n-----\n```\n\nFinish the `arithmetic_arranger` function that receives a list of strings which are arithmetic problems, and returns the problems arranged vertically and side-by-side. The function should optionally take a second argument. When the second argument is set to `True`, the answers should be displayed.\n\n## Example\n\nFunction Call:\n\n```py\narithmetic_arranger([\"32 + 698\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"])\n```\n\nOutput:\n\n```py\n   32      3801      45      123\n+ 698    -    2    + 43    +  49\n-----    ------    ----    -----\n```\n\nFunction Call:\n\n```py\narithmetic_arranger([\"32 + 8\", \"1 - 3801\", \"9999 + 9999\", \"523 - 49\"], True)\n```\n\nOutput:\n\n```py\n  32         1      9999      523\n+  8    - 3801    + 9999    -  49\n----    ------    ------    -----\n  40     -3800     19998      474\n```\n\n## Rules\n\nThe function will return the correct conversion if the supplied problems are properly formatted, otherwise, it will **return** a **string** that describes an error that is meaningful to the user.\n\n- Situations that will return an error:\n  - If there are **too many problems** supplied to the function. The limit is **five**, anything more will return:\n    `'Error: Too many problems.'`\n  - The appropriate operators the function will accept are **addition** and **subtraction**. Multiplication and division will return an error. Other operators not mentioned in this bullet point will not need to be tested. The error returned will be:\n    `\"Error: Operator must be '+' or '-'.\"`\n  - Each number (operand) should only contain digits. Otherwise, the function will return:\n    `'Error: Numbers must only contain digits.'`\n  - Each operand (aka number on each side of the operator) has a max of four digits in width. Otherwise, the error string returned will be:\n    `'Error: Numbers cannot be more than four digits.'`\n- If the user supplied the correct format of problems, the conversion you return will follow these rules:\n  - There should be a single space between the operator and the longest of the two operands, the operator will be on the same line as the second operand, both operands will be in the same order as provided (the first will be the top one and the second will be the bottom).\n  - Numbers should be right-aligned.\n  - There should be four spaces between each problem.\n  - There should be dashes at the bottom of each problem. The dashes should run along the entire length of each problem individually. (The example above shows what this should look like.)\n\nNote: open the browser console with F12 to see a more verbose output of the tests.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def arithmetic_arranger(problems, show_answers=False):\n\n    return problems\n\nprint(f'\\n{arithmetic_arranger([\"32 + 698\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"])}')"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "def arithmetic_arranger(problems, result=False):\n\n\tlin1 = \"\"\n\tlin2 = \"\"\n\tlin3 = \"\"\n\tlin4 = \"\"\n\n\tif len(problems) > 5:\n\t\treturn 'Error: Too many problems.'\n\tfor problem in problems:\n\t\t[num1, sym, num2] = problem.split()\n\t\tsign = ['+', '-']\n\t\tif sym not in sign:\n\t\t\treturn (\"Error: Operator must be '+' or '-'.\")\n\t\tif len(num1) > 4 or len(num2) > 4:\n\t\t\treturn (\"Error: Numbers cannot be more than four digits.\")\n\t\tif not num1.isnumeric() or not num2.isnumeric():\n\t\t\treturn (\"Error: Numbers must only contain digits.\")\n\n\t\tlin1 += \"  \" + num1 + \"    \" if len(num1) >= len(\n\t\t    num2) else \" \" * (len(num2) + 2 - len(num1)) + num1 + \"    \"\n\t\tlin2 += sym + \" \" + num2 + \"    \" if len(num2) >= len(\n\t\t    num1) else sym + \" \" * (len(num1) - len(num2) + 1) + num2 + \"    \"\n\t\tnmax = (len(num1) + 2) if len(num1) >= len(num2) else (len(num2) + 2)\n\t\tlin3 += \"-\" * nmax + \"    \"\n\t\top = int(num1) + int(num2) if sym == \"+\" else int(num1) - int(num2)\n\t\tlin4 += (\" \" * (nmax - len(str(op)))) + str(op) + \"    \"\n\n\tarranged_problems = lin1.rstrip() + \"\\n\" + lin2.rstrip(\n\t) + \"\\n\" + lin3.rstrip()\n\tif result:\n\t\tarranged_problems += \"\\n\" + lin4.rstrip()\n\n\treturn arranged_problems"
        }
      ],
      "tests": [
        {
          "text": "`arithmetic_arranger([\"3801 - 2\", \"123 + 49\"])` should return `  3801      123\\n-    2    +  49\\n------    -----`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"3801 - 2\", \"123 + 49\"]), '  3801      123\\\\n-    2    +  49\\\\n------    -----')`);\n  }\n})\n```\n\n`arithmetic_arranger([\"1 + 2\", \"1 - 9380\"])` should return `  1         1\\n+ 2    - 9380\\n---    ------`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"1 + 2\", \"1 - 9380\"]), '  1         1\\\\n+ 2    - 9380\\\\n---    ------')`);\n  }\n})\n```\n\n`arithmetic_arranger([\"3 + 855\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"])` should return `    3      3801      45      123\\n+ 855    -    2    + 43    +  49\\n-----    ------    ----    -----`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"3 + 855\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"]), '    3      3801      45      123\\\\n+ 855    -    2    + 43    +  49\\\\n-----    ------    ----    -----')`);\n  }\n})\n```\n\n`arithmetic_arranger([\"11 + 4\", \"3801 - 2999\", \"1 + 2\", \"123 + 49\", \"1 - 9380\"])` should return `  11      3801      1      123         1\\n+  4    - 2999    + 2    +  49    - 9380\\n----    ------    ---    -----    ------`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"11 + 4\", \"3801 - 2999\", \"1 + 2\", \"123 + 49\", \"1 - 9380\"]), '  11      3801      1      123         1\\\\n+  4    - 2999    + 2    +  49    - 9380\\\\n----    ------    ---    -----    ------')`);\n  }\n})\n```\n\n`arithmetic_arranger([\"44 + 815\", \"909 - 2\", \"45 + 43\", \"123 + 49\", \"888 + 40\", \"653 + 87\"])` should return `'Error: Too many problems.'`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"44 + 815\", \"909 - 2\", \"45 + 43\", \"123 + 49\", \"888 + 40\", \"653 + 87\"]), 'Error: Too many problems.')`);\n  }\n})\n```\n\n`arithmetic_arranger([\"3 / 855\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"])` should return `\"Error: Operator must be '+' or '-'.\"`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"3 / 855\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"]), \"Error: Operator must be '+' or '-'.\")`);\n  }\n})\n```\n\n`arithmetic_arranger([\"24 + 85215\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"])` should return `'Error: Numbers cannot be more than four digits.'`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"24 + 85215\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"]), \"Error: Numbers cannot be more than four digits.\")`);\n  }\n})\n```\n\n`arithmetic_arranger([\"98 + 3g5\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"])` should return `'Error: Numbers must only contain digits.'`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"98 + 3g5\", \"3801 - 2\", \"45 + 43\", \"123 + 49\"]), \"Error: Numbers must only contain digits.\")`);\n  }\n})\n```\n\n`arithmetic_arranger([\"3 + 855\", \"988 + 40\"], True)` should return `    3      988\\n+ 855    +  40\\n-----    -----\\n  858     1028`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"3 + 855\", \"988 + 40\"], True), \"    3      988\\\\n+ 855    +  40\\\\n-----    -----\\\\n  858     1028\")`);\n  }\n})\n```\n\n`arithmetic_arranger([\"32 - 698\", \"1 - 3801\", \"45 + 43\", \"123 + 49\", \"988 + 40\"], True)` should return `   32         1      45      123      988\\n- 698    - 3801    + 43    +  49    +  40\\n-----    ------    ----    -----    -----\\n -666     -3800      88      172     1028`.\n\n```js\n({\n  test: () => {\n    runPython(`\nfrom unittest import TestCase\n\nTestCase().assertEqual(arithmetic_arranger([\"32 - 698\", \"1 - 3801\", \"45 + 43\", \"123 + 49\", \"988 + 40\"], True), \"   32         1      45      123      988\\\\n- 698    - 3801    + 43    +  49    +  40\\\\n-----    ------    ----    -----    -----\\\\n -666     -3800      88      172     1028\")`);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 462359,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\build-an-arithmetic-formatter-project\\arithmetic-formatter.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "build-an-arithmetic-formatter-project",
        "name": "Build An Arithmetic Formatter Project"
      }
    },
    {
      "id": "65576ff7888f9e96f52a4be1",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "Dictionaries store data in the form of *key*-*value* pairs. A key is separated from the correspondent value by a colon. And each key-value pair is separated from the following pair by a comma:\n\n```py\nmy_dict = {\n    'name': 'Michael',\n    'occupation': 'Lumberjack'\n}\n```\n\nAdd a new key-value pair to your dictionary. Use the string `'species'` as the key, and the string `'guinea pig'` as the value.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `'species'` key with the value `'guinea pig'` inside your `copper` dictionary.",
          "testCode": "({ test: () => assert(runPython(`\n    copper == {\"species\": \"guinea pig\"}\n  `))\n})"
        },
        {
          "text": "Your `copper` dictionary should have a single key-value pair.",
          "testCode": "({ test: () => assert(runPython(`\n    len(copper) == 1\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65576ff7888f9e96f52a4be1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557709b0aee699a6a00528c",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "For example, a graph can be used to represent two points in the space, `A` and `B`, connected by a path. A graph like this will be made of two nodes connected by an edge.\n\nReplace the existent `'species'` key with the strings `'A'`. Then, replace the correspondent value with the string `'B'` to represent the connection between the `'A'` and `'B'` nodes.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'species': 'guinea pig',\n    'age': 2\n}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your dictionary should have an `'A'` key.",
          "testCode": "({ test: () => assert(runPython(`\n    \"A\" in my_graph\n  `))\n})"
        },
        {
          "text": "Your `'A'` key should have `'B'` as the value.",
          "testCode": "({ test: () => assert(runPython(`\n    my_graph[\"A\"] == \"B\"\n  `))\n})"
        },
        {
          "text": "Your dictionary should have two keys.",
          "testCode": "({ test: () => assert(runPython(`\n    len(my_graph) == 2\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557709b0aee699a6a00528c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557712d77ce2d9bd7e63afd",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "Add another node connected to `B` to your graph and call it `C`.\n\nModify your existing dictionary to represent this arrangement: add another key `'C'` to `my_graph` and give it the value of the string `'B'`.\n\nAlso, change the value of the existing `'B'` key into the list `['A', 'C']` to represent the multiple connections of your `'B'` node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': 'B',\n    'B': 'A'\n}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your dictionary should have 3 keys — `'A'`, `'B'`, and `'C'`.",
          "testCode": "({ test: () => assert(runPython(`\n    key_list = [\"A\", \"B\", \"C\"]\n    len(my_graph) == 3 and all(key in my_graph for key in key_list)\n  `))\n})"
        },
        {
          "text": "The value of `my_graph['A']` should be the string `'B'`.",
          "testCode": "({ test: () => assert(runPython(`\n    my_graph[\"A\"] == \"B\"\n  `))\n})"
        },
        {
          "text": "`my_graph['B']` should be a list.",
          "testCode": "({ test: () => assert(runPython(`\n    type(my_graph[\"B\"]) is list\n  `))\n})"
        },
        {
          "text": "The value of `my_graph['B']` should be a list containing `'A'` and `'C'`.",
          "testCode": "({ test: () => assert(runPython(`\n    len(my_graph[\"B\"]) == 2 and \"A\" in my_graph[\"B\"] and \"C\" in my_graph[\"B\"]\n  `))\n})"
        },
        {
          "text": "The value of `my_graph['C']` should be the string `'B'`.",
          "testCode": "({ test: () => assert(runPython(`\n    my_graph[\"C\"] == \"B\"\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557712d77ce2d9bd7e63afd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557716aadbd2d9c42c0e69a",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "Add one last node, `'D'`, which is connected with `'A'` and `'C'`.\n\nModify your dictionary to represent this structure. Again, use a list to represent multiple connections.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': 'B',\n    'B': ['A', 'C'],\n    'C': 'B'\n}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your dictionary should have 4 keys called `'A'`, `'B'`, `'C'`, and `'D'`.",
          "testCode": "({ test: () => assert(runPython(`\n    key_list = [\"A\", \"B\", \"C\", \"D\"]\n    len(my_graph) == 4 and all(key in my_graph for key in key_list)\n  `))\n})"
        },
        {
          "text": "`my_graph['A']` should be a list.",
          "testCode": "({ test: () => assert(runPython(`\n    type(my_graph[\"A\"]) is list\n  `))\n})"
        },
        {
          "text": "`my_graph['A']` should be a list containing `'B'` and `'D'`.",
          "testCode": "({ test: () => assert(runPython(`\n    len(my_graph[\"A\"]) == 2 and \"B\" in my_graph[\"A\"] and \"D\" in my_graph[\"A\"]\n  `))\n})"
        },
        {
          "text": "`my_graph['B']` should be a list.",
          "testCode": "({ test: () => assert(runPython(`\n    type(my_graph[\"B\"]) is list\n  `))\n})"
        },
        {
          "text": "`my_graph['B']` should be a list containing `'A'` and `'C'`.",
          "testCode": "({ test: () => assert(runPython(`\n    len(my_graph[\"B\"]) == 2 and \"A\" in my_graph[\"B\"] and \"C\" in my_graph[\"B\"]\n  `))\n})"
        },
        {
          "text": "`my_graph['C']` should be a list.",
          "testCode": "({ test: () => assert(runPython(`\n    type(my_graph[\"C\"]) is list\n  `))\n})"
        },
        {
          "text": "`my_graph['C']` should be a list containing `'B'` and `'D'`.",
          "testCode": "({ test: () => assert(runPython(`\n    len(my_graph[\"C\"]) == 2 and \"B\" in my_graph[\"C\"] and \"D\" in my_graph[\"C\"]\n  `))\n})"
        },
        {
          "text": "`my_graph['D']` should be a list.",
          "testCode": "({ test: () => assert(runPython(`\n    type(my_graph[\"D\"]) is list\n  `))\n})"
        },
        {
          "text": "`my_graph['D']` should be a list containing `'A'` and `'C'`.",
          "testCode": "({ test: () => assert(runPython(`\n    len(my_graph[\"D\"]) == 2 and \"A\" in my_graph[\"D\"] and \"C\" in my_graph[\"D\"]\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557716aadbd2d9c42c0e69a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655771d889132f9ccd341060",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "A graph is called a *weighted* graph when its edges are associated with weights, representing a distance, time or other quantitative value.\n\nIn your case, these weights will be the distances between each node, or point in space. To represent a weighted graph you can modify your dictionary, using a list of tuples for each value.\n\nThe first element in the tuple will be the connected node, and the second element will be an integer number indicating the distance.\n\nModify `my_graph['A']` into a list of tuples, considering that the `A-B` distance is `3` and the `A-D` distance is `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': ['B', 'D'],\n--fcc-editable-region--    \n    'B': ['A', 'C'],\n    'C': ['B', 'D'],\n    'D': ['A', 'C']\n}"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "`my_graph[\"A\"]` should be a list containing the tuples `('B', 3)` and `('D', 1)`.",
          "testCode": "({ test: () => assert(runPython(`\n    tuples = [(\"B\", 3), (\"D\", 1)]\n    len(my_graph[\"A\"]) == 2 and all(t in my_graph[\"A\"] for t in tuples)\n  `))\n})"
        },
        {
          "text": "`my_graph` should have 4 keys named `'A'`, `'B'`, `'C'`, and `'D'`.",
          "testCode": "({ test: () => assert(runPython(`\n    key_list = [\"A\", \"B\", \"C\", \"D\"]\n    len(my_graph) == 4 and all(key in my_graph for key in key_list)\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655771d889132f9ccd341060.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65577236b056379d5dbc7000",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "Now you are going to start developing the algorithm to calculate the shortest path between each node in your new graph.\n\nDeclare an empty function called `shortest_path`. Use the `pass` keyword to fill the function body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a function named `shortest_path`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    inspect.isfunction(shortest_path)\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65577236b056379d5dbc7000.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655773b0591c5f9f4045883e",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "The algorithm will start at a specified node. Then it will explore the graph to find the shortest path between the starting node, or *source*, and all the other nodes.\n\nFor that your function needs two parameters: `graph`, and `start`. Add them to your function declaration.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path():\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your function should take `graph` and `start` as the parameters, in this order.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    sig = str(inspect.signature(shortest_path))\n    sig == '(graph, start)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655773b0591c5f9f4045883e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655773f8b8b5db9fc6d0ae76",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "To keep track of the visited nodes, you need a list of all the nodes in the graph. Once a node is visited, it will be removed from that list.\n\nNow, replace the `pass` keyword with a variable named `unvisited` and assign it an empty list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable called `unvisited` inside the `shortest_path` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"shortest_path\").has_variable(\"unvisited\")`)) })"
        },
        {
          "text": "You should assign an empty list to your `unvisited` variable. Remember to delete `pass`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"shortest_path\").find_body().is_equivalent(\"unvisited = []\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655773f8b8b5db9fc6d0ae76.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557743527cb92a06417ea97",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "Create a `for` loop to iterate over your graph, and use the `.append()` method to add each node to the end of the `unvisited` list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = []\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop to iterate over `graph` inside the `shortest_path` function.",
          "testCode": "({ test: () =>  {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {function_body} = __helpers.python.getDef(commentless_code, \"shortest_path\");    \n    assert(function_body.match(/^\\s*for\\s+\\w+\\s+in\\s+graph\\s*:/m));\n  }\n})"
        },
        {
          "text": "You should append each node to `unvisited` inside your `for` loop.",
          "testCode": "({ test: () =>  {\n    const commentless_code = __helpers.python.removeComments(code);\n    const block_regex = /for\\s+(\\w+)\\s+in\\s+graph\\s*/;\n    const {block_body} = __helpers.python.getBlock(commentless_code, block_regex);\n    const loop_condition = commentless_code.match(block_regex);\n    const regex = new RegExp(`^\\\\s+unvisited\\\\.append\\\\s*\\\\(\\\\s*${loop_condition[1]}\\\\s*\\\\)`, \"m\");\n    assert(block_body.match(regex));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557743527cb92a06417ea97.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557746aad2844a0cd864e12",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "While the algorithm explores the graph, it should keep track of the currently known shortest distance between the starting node and the other nodes.\n\nBefore your `for` loop, create a new variable named `distances` and assign it an empty dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = []\n    for node in graph:\n        unvisited.append(node)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable named `distances`.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s*)distances\\s*=.*(?=^\\1for.*:)/ms));\n  }\n})"
        },
        {
          "text": "Your `distances` variable should be an empty dictionary.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s*)distances\\s*=\\s*\\{\\s*\\}.*(?=^\\1for.*:)/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557746aad2844a0cd864e12.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655774955b097ea14897db12",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "The distance from the starting node is zero, because the algorithm begins its assessment right from there.\n\nAfter appending `node` to `unvisited` in your loop, create an `if` statement that triggers if the node is equal to the starting node. Then assign `0` to that node inside the `distances` dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = []\n    distances = {}\n    for node in graph:\n        unvisited.append(node)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that executes when `node` is equal to `start`.",
          "testCode": "({ test: () =>  {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+node\\s+in\\s+graph\\s*/);        \n    assert(block_body.match(/unvisited\\.append\\s*\\(\\s*node\\s*\\)\\s*^\\s+if\\s+(node\\s*==\\s*start|start\\s*==\\s*node)\\s*:/m));\n  }\n})"
        },
        {
          "text": "Inside your new `if` statement you should assign `0` to the node in the `distances` dictionary.",
          "testCode": "({ test: () =>  {\n   const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /if\\s+(node\\s*==\\s*start|start\\s*==\\s*node)\\s*/m);  \n    assert(block_body.match(/^\\s+distances\\s*\\[\\s*node\\s*\\]\\s*=\\s*0/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655774955b097ea14897db12.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655774d01daeeaa1978b99d5",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "At the beginning, all the other nodes in the graph are considered to be at infinite distance from the source node, because the distance has not been determined yet.\n\nCreate an `else` clause and assign an infinite value to the node in the `distances` dictionary. For that, use the `float()` function with the string `'inf'` as argument to generate a floating point number representing the positive infinity.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = []\n    distances = {}\n    for node in graph:\n        unvisited.append(node)\n        if node == start:\n            distances[node] = 0\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `else` clause.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s*)if.*:.*^\\1else\\s*:/ms));\n  }\n})"
        },
        {
          "text": "You should assign `float('inf')` to `distances[node]` inside your new `else` clause.",
          "testCode": "({ test: () =>  {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, \"else\");\n    assert(block_body.match(/^\\s+distances\\s*\\[\\s*node\\s*\\]\\s*=\\s*float\\s*\\(\\s*(\"|')inf\\1\\s*\\)\\s*$/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655774d01daeeaa1978b99d5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655775221059f5a20493d5d7",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "After your `for` loop, add a `print()` call and pass in the following string to see the values of the variables you have created: `f'Unvisited: {unvisited}\\nDistances: {distances}'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = []\n    distances = {}\n    for node in graph:\n        unvisited.append(node)\n        if node == start:\n            distances[node] = 0\n        else:\n            distances[node] = float('inf')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `f'Unvisited: {unvisited}\\nDistances: {distances}'` after your `for` loop.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/(^\\s*)for.*:.*^\\1print\\s*\\(\\s*f(\"|')Unvisited:\\s*\\{\\s*unvisited\\s*\\}\\\\nDistances:\\s\\{\\s*distances\\s*\\}\\2\\s*\\)/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655775221059f5a20493d5d7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655776db1eeae0a620e42a0d",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "Now, call your function passing `my_graph` and `'A'` as the arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = []\n    distances = {}\n    for node in graph:\n        unvisited.append(node)\n        if node == start:\n            distances[node] = 0\n        else:\n            distances[node] = float('inf')\n    print(f'Unvisited: {unvisited}\\nDistances: {distances}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `shortest_path` passing `my_graph` and `'A'` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /^shortest_path\\s*\\(\\s*my_graph\\s*,\\s*(\"|')A\\1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655776db1eeae0a620e42a0d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655777060d8ddea6741be1b1",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "All the distances in `distances` are set to infinite, except for the starting node. The `unvisited` list contains all the nodes in your graph. But actually, you don't need that `for` loop to achieve this result.\n\nRemove your `for` loop with its entire body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = []\n    distances = {}\n    for node in graph:\n        unvisited.append(node)\n        if node == start:\n            distances[node] = 0\n        else:\n            distances[node] = float('inf')\n    print(f'Unvisited: {unvisited}\\nDistances: {distances}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove your `for` loop and all the nested code.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/(^\\s*)distances\\s*=\\s*\\{\\s*\\}\\s*\\1print\\s*\\(\\s*f(\"|')Unvisited:\\s*\\{\\s*unvisited\\s*\\}\\\\nDistances:\\s\\{\\s*distances\\s*\\}\\2\\s*\\)/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655777060d8ddea6741be1b1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65577739f57ecca6c39bb4e9",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "The `list()` type constructor enables you to build a list from an iterable.\n\nModify the assignment of your `unvisited` variable to use `list()`, and pass `graph` as the iterable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = []\n    distances = {}\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use `list()` to generate a list from the `graph` dictionary.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/list\\s*\\(\\s*graph\\s*\\)/));\n  }\n})"
        },
        {
          "text": "You should assign `list(graph)` to `unvisited`.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/unvisited\\s*=\\s*list\\s*\\(\\s*graph\\s*\\)/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65577739f57ecca6c39bb4e9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65577791ad8c26a7705e2919",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "With a dictionary comprehension, you can create a dictionary starting from an existing dictionary:\n\n```py\n{key: val for key in dict}\n```\n\nIn the example above, `val` is the value that `key` will have in the new dictionary, and `dict` is the existing dictionary.\n\nYou want to keep track of the paths between the starting node and each other node.\n\nAfter the `distances` variable, create a `paths` variable and assign it a dictionary with all the keys from `graph`. Assign an empty list to each key and use a dictionary comprehension to build your dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {}\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable named `paths`.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^\\s{4}paths\\s*\\=/m));\n  }\n})"
        },
        {
          "text": "Your `paths` variable should use the dictionary comprehension syntax to assign an empty list to each node in graph.",
          "testCode": "({ test: () =>  {\n    const {function_body} = __helpers.python.getDef(code, \"shortest_path\");       \n    assert(function_body.match(/^\\s{4}paths\\s*\\=\\s*\\{\\s*(\\w+)\\s*:\\s*\\[\\s*\\]\\s+for\\s+\\1\\s+in\\s+graph\\s*\\}/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65577791ad8c26a7705e2919.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65577a17564ce8a8e06c1460",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "Dictionary comprehensions support conditional `if`/`else` syntax too:\n\n```py\n{key: val_1 if condition else val_2 for key in dict}\n```\n\nIn the example above, `dict` is the existing dictionary. When `condition` evaluates to `True`, `key` will have the value `val_1` , otherwise `val_2`.\n\nUse a dictionary comprehension to create a dictionary based on `graph` and assign it to the `distances` variable. Give the key a value of zero if the node is equal to the starting node, and infinite otherwise. Use `float('inf')` to achieve the latter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {}\n    paths = {node: [] for node in graph}\n    print(f'Unvisited: {unvisited}\\nDistances: {distances}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the dictionary comprehension syntax to give a value to your `distances` variable.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;\n    assert(function_body.match(/^\\s{4}distances\\s*=\\s*\\{\\s*(\\w+)\\s*:\\s*0\\s+if\\s+(?:\\1\\s*==\\s*start|start\\s*==\\s*\\1)\\s+else\\s+float\\s*\\(\\s*(\"|')inf\\2\\s*\\)\\s+for\\s+\\1\\s+in\\s+graph\\s*\\}/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65577a17564ce8a8e06c1460.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65578c17d54dfab65cd54b95",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "Since the algorithm begins its assessment from the starting node, after creating the `paths` dictionary, you need to add the starting node to its own list in the `paths` dictionary.\n\nUse the `.append()` method to append `start` to the `paths[start]` list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `.append()` method to append `start` to `paths[start]`.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;\n    assert(function_body.match(/^\\s{4}paths\\s*\\[\\s*start\\s*\\]\\s*\\.append\\s*\\(\\s*start\\s*\\)/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65578c17d54dfab65cd54b95.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65578c74607d40b6d8c4757f",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "Add `\\nPaths: {paths}` at the end of the f-string passed to the `print` call, so that it prints the `paths` variable, too.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your existing `print` call by adding `\\nPaths: {paths}` at the end of the f-string.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^\\s{4}print\\s*\\(\\s*f(\"|')Unvisited:\\s*\\{\\s*unvisited\\s*\\}\\\\nDistances:\\s\\{\\s*distances\\s*\\}\\\\nPaths:\\s\\{\\s*paths\\s*\\}\\1\\s*\\)/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65578c74607d40b6d8c4757f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65578cb031cd93b77a285db2",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "Your function is going to explore all the nodes connected to the starting node. It will calculate the shortest paths for all of them. Then, it will remove the starting node from the unvisited nodes. \n\nNext, the closest neighbor node will be visited and the process will be repeated until all the nodes are visited.\n\nFrom now on, you are going to work on the main loop that explores the nodes in the graph. To avoid issues with running an infinite loop during the algorithm development, turn your function call into a comment.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn your function call into a comment.",
          "testCode": "({ test: () => assert.match(code, /#\\s*shortest_path\\s*\\(\\s*my_graph\\s*,\\s*(\"|')A\\1\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65578cb031cd93b77a285db2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65578cee7f2cb8b80127cce2",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "Before the `print` call, create a `while` loop that runs while `unvisited` is not empty. Use the `pass` keyword to fill the loop body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\n--fcc-editable-region--\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `while` loop that executes while `unvisited` is not empty. Don't forget the `pass` keyword.\n\n```js\n({ test: () =>  {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {function_body} = __helpers.python.getDef(commentless_code, \"shortest_path\");     \n    assert(function_body.match(/^\\s+while\\s+(unvisited|unvisited\\s*!=\\s*\\[\\s*\\]|len\\s*\\(\\s*unvisited\\s*\\)\\s*(>|!=)\\s*0)\\s*:/m));\n    const {block_body} = __helpers.python.getBlock(commentless_code, /while\\s+(unvisited|unvisited\\s*!=\\s*\\[\\s*\\]|len\\s*\\(\\s*unvisited\\s*\\)\\s*(>|!=)\\s*0)\\s*/);\n    assert(block_body.match(/\\s+pass/))\n\n}\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65578cee7f2cb8b80127cce2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65578d0f6c78a0b868a43b9c",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "Inside the `while` loop, the first thing to do is define the current node to visit. For that you can use the `min()` function. It returns the smallest item from the iterable passed as the argument.\n\nRemove `pass`, then create a variable called `current` and assign it `min(unvisited)`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n--fcc-editable-region--\n    while unvisited:\n        pass\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `current` variable in your `while` loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"shortest_path\").find_whiles()[0].has_variable(\"current\")`)) })"
        },
        {
          "text": "You should assign `min(unvisited)` to your `current` variable. Remember to delete `pass`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"shortest_path\").find_whiles()[0].find_bodies()[0].is_equivalent(\"current = min(unvisited)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65578d0f6c78a0b868a43b9c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65578d4fc3afc3b8f554c882",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "`min()` takes also a keyword-only argument. Passing a function as an additional argument to `min()`, you can modify the way the list items are compared.\n\nThe result of the line you've just written in the previous step is the node that comes first in alphabetical order. Instead you want to select the unvisited node having the smallest distance from the starting node. \n\nPass `key=distances.get` as the second argument to your `min()` call. In this way, the comparison will take place depending on the value each `unvisited` list item has inside the `distances` dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n--fcc-editable-region--    \n    while unvisited:\n        current = min(unvisited)\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `key=distances.get` as the second argument to your `min()` call.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s{4})while\\s+unvisited\\s*:\\s*^\\1\\1current\\s*=\\s*min\\s*\\(\\s*unvisited\\s*,\\s*key\\s*=\\s*distances\\.get\\s*\\)/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65578d4fc3afc3b8f554c882.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65578f895f2a65ba7a916804",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "After the `current` variable assignment, create a `for` loop to iterate over the tuples in the `graph[current]` list. You will need two iterating variables for that. Remember to use `pass` to fill the loop body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n--fcc-editable-region--    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop to iterate over the tuples items in the `graph[current]` list. Use two iterating variables and don't forget to add the `pass` keyword.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s*)while\\s+unvisited\\s*:.*^\\1\\1for\\s+\\w+\\s*,\\s*\\w+\\s+in\\s+graph\\s*\\[\\s*current\\s*\\]\\s*:\\s*^\\1\\1\\1pass/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65578f895f2a65ba7a916804.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65578fcf00322dbad5dee05b",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "Create an `if` statement to check if the distance of the neighbor node (the second item in the processed tuple) plus the distance of `current` is less than the currently known distance of the neighbor node (the first item in the processed tuple). \n\nUse the `pass` keyword to temporarily fill the body of the `if`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n--fcc-editable-region--\n        for node, distance in graph[current]:\n            pass\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `if` statement to check if `distance + distances[current]` is less than `distances[node]`.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s*)for\\s+\\w+\\s*,\\s*\\w+\\s+in\\s+graph\\s*\\[\\s*current\\s*\\]\\s*:\\s*^\\1(\\s{4})if\\s+distance\\s*\\+\\s*distances\\s*\\[\\s*current\\s*\\]\\s*<\\s*distances\\s*\\[\\s*node\\s*\\]\\s*:/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65578fcf00322dbad5dee05b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655790d113d14dbb727eaf41",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "Once the distance to a node is set inside the `distances` dictionary, you need to keep track of the path to that node, too. If the distance for the node in the processed tuple has been updated, the last item in its path is the node itself.\n\nInside your conditional, nest another `if` statement that triggers when the last element of `paths[node]` is equal to `node`. Use `pass` to fill the `if` statement body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n--fcc-editable-region--    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a nested `if` statements that checks if `paths[node][-1]` is equal to `node`. Don't forget to use `pass`.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s*)if.*:.*^\\1(\\s{4})if\\s+paths\\s*\\[\\s*node\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*==\\s*node\\s*:\\s*^\\1\\2\\2pass/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655790d113d14dbb727eaf41.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557910b0ebaeebc18209e90",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "Now remove `pass` and assign `paths[current]` to `paths[node]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n--fcc-editable-region--    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node][-1] == node:\n                    pass\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and assign `paths[current]` to `paths[node]`.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s*)if.*:.*^\\1(\\s{4})if\\s+paths\\s*\\[\\s*node\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*==\\s*node\\s*:\\s*^\\1\\2\\2paths\\s*\\[\\s*node\\s*\\]\\s*=\\s*paths\\s*\\[\\s*current\\s*\\]/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557910b0ebaeebc18209e90.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557913b8fe5c0bc834c9f4f",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "The `.extend()` method, allows you to add elements from an iterable to the end of a list:\n\n```py\nmy_list = ['larch', 'birch']\ntree_list = ['fir', 'redwood', 'pine']\nmy_list.extend(tree_list)\nprint(my_list) # Output: ['larch', 'birch', 'fir', 'redwood', 'pine']\n```\n\nCreate an `else` clause and use the `.extend()` method to add the current node path to the neighbor node path.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n--fcc-editable-region--                \n                if paths[node][-1] == node:\n                    paths[node] = paths[current]\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `else` clause after your nested `if` statement.",
          "testCode": "({ test: () =>  {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /if\\s+distance\\s*\\+\\s*distances\\s*\\[\\s*current\\s*\\]\\s*<\\s*distances\\s*\\[\\s*node\\s*\\]\\s*/);\n    assert(block_body.match(/^\\s+else\\s*:/m));\n  }\n})"
        },
        {
          "text": "You should have `paths[node].extend(paths[current])` in your `else` clause.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;\n    assert(function_body.match(/^(\\s*)if\\s+paths\\s*\\[\\s*node\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*==\\s*node\\s*:\\s*^\\1(\\s{4})paths\\s*\\[\\s*node\\s*\\]\\s*=\\s*paths\\s*\\[\\s*current\\s*\\]\\s*^\\1else\\s*:\\s*^\\1\\2paths\\s*\\[\\s*node\\s*\\]\\s*\\.extend\\s*\\(\\s*paths\\s*\\[\\s*current\\s*\\]\\s*\\)/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557913b8fe5c0bc834c9f4f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655791847db8a9bd0b685f40",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "Finally, below the `else` clause, append the neighbor node to its path.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n--fcc-editable-region--    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node][-1] == node:\n                    paths[node] = paths[current]\n                else:\n                    paths[node].extend(paths[current])\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should append `node` to `paths[node]` just after your `else` clause.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;\n    assert(function_body.match(/^(\\s*)else\\s*:\\s*^\\1\\s{4}paths\\s*\\[\\s*node\\s*\\]\\s*\\.extend\\s*\\(\\s*paths\\s*\\[\\s*current\\s*\\]\\s*\\)\\s*^\\1paths\\s*\\[\\s*node\\s*\\]\\s*\\.append\\s*\\(\\s*node\\s*\\)/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655791847db8a9bd0b685f40.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655791ae44c182bd92f31caa",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "The `.remove()` method removes from a list the first matching element that is passed as the argument:\n\n```py\nmy_list = ['larch', 1, True, 1]\nmy_list.remove(1)\nprint(my_list) # Output: ['larch', True, 1]\n```\n\nTerminate the `while` loop by removing the current node from the `unvisited` list. Pay attention to the indentation.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n--fcc-editable-region--    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node][-1] == node:\n                    paths[node] = paths[current]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `.remove()` method to remove the current node from `unvisited` after your `for` loop.",
          "testCode": "({ test: () =>  {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /while\\s+unvisited/);\n    assert(block_body.match(/^\\s+unvisited\\.remove\\s*\\(\\s*current\\s*\\)/m));\n    const {block_body: for_body} = __helpers.python.getBlock(commentless_code, /for\\s+node\\s*,\\s*distance\\s+in\\s+graph\\s*\\[\\s*current\\s*\\]\\s*/);\n    assert.notMatch(for_body, /^\\s+unvisited\\.remove\\s*\\(\\s*current\\s*\\)/m);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655791ae44c182bd92f31caa.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "655791e6cf5e03be3de73451",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "If you try to uncomment your function call, it won't work. You have a couple of bugs to fix. The first one happens because in the nested `if` you are trying to access an element that might not exist in your `paths[node]` list. So, you need to be sure that `paths[node]` is not empty before accessing `paths[node][-1]`.\n\nAdd an additional condition to your nested `if` statement to ensure that `paths[node]` is non-empty before accessing `paths[node][-1]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n--fcc-editable-region--                \n                if paths[node][-1] == node:\n                    paths[node] = paths[current]\n--fcc-editable-region--                   \n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add `paths[node]` as the first condition to your nested `if` statement. Use the `and` operator to combine your conditions.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/if\\s+paths\\s*\\[\\s*node\\s*\\]\\s+and\\s+paths\\s*\\[\\s*node\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*==\\s*node\\s*:/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\655791e6cf5e03be3de73451.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65579228c669fcbebffd01d5",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "The other bug is subtle. When a shorter distance is found for a neighbor node, `paths[current]` gets assigned to the neighbor node path, `paths[node]`. \n\nThis means both variables point to the same list. Since lists are mutable, when you append the neighbor node to its path, both `paths[node]` and `paths[current]` are modified because they are the same list. This results in wrong paths, although the distances are correct.\n\nYou can fix that bug by assigning a copy of `paths[current]` to the neighbor node path. For that you can use the slice syntax:\n\n```py\nmy_list[:]\n```\n\nWhere `my_list` is the list you want to copy. Modify the existing `paths[node] = paths[current]` assignment inside your `if` block by slicing `paths[current]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n--fcc-editable-region--                \n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current]\n--fcc-editable-region--                    \n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \nshortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `paths[current][:]` to the neighbor node path.",
          "testCode": "({ test: () => assert.match(code, /^(\\s*)if\\s+paths\\s*\\[\\s*node\\s*\\]\\s+and\\s+paths\\s*\\[\\s*node\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*==\\s*node\\s*:\\s*^\\1\\s{4}paths\\s*\\[\\s*node\\s*\\]\\s*=\\s*paths\\s*\\[\\s*current\\s*\\]\\s*\\[\\s*::?\\s*\\]/ms) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65579228c669fcbebffd01d5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557924d47c325bf27afbe51",
      "title": "Step 53",
      "challengeType": 20,
      "dashedName": "step-53",
      "description": "The algorithm is complete but you can improve the output. Also, you can provide the function with an additional argument to return only the path between two nodes.\n\nAdd `target` as the third parameter to your function declaration and give it the default value of an empty string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n--fcc-editable-region--\ndef shortest_path(graph, start):\n--fcc-editable-region--\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current][:]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \nshortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your function should take three parameters:`graph`, `start`, and `target`. The order matters.",
          "testCode": "({ test: () => assert.match(code, /^def\\s+shortest_path\\s*\\(\\s*graph\\s*,\\s*start\\s*,\\s*target\\s*=?\\s*.*\\s*\\)\\s*:/m) })"
        },
        {
          "text": "The `target` parameter should have the default value of an empty string.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    sig = str(inspect.signature(shortest_path))\n    sig == \"(graph, start, target='')\"\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557924d47c325bf27afbe51.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6557927ad11e58bf8c794b25",
      "title": "Step 55",
      "challengeType": 20,
      "dashedName": "step-55",
      "description": "Create a `for` loop to iterate over `targets_to_print` and print the following f-string: `f'\\n{start}-{node} distance: {distances[node]}\\nPath: {\" -> \".join(paths[node])}'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start, target = ''):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current][:]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n--fcc-editable-region--    \n    targets_to_print = [target] if target else graph\n\n\nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop to iterate over `targets_to_print`. Use `node` as the loop variable.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s{4})for\\s+node\\s+in\\s+targets_to_print\\s*:/m));\n  }\n})"
        },
        {
          "text": "You should print the provided string inside your new `for` loop.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s{4})for\\s+node\\s+in\\s+targets_to_print\\s*:\\s*^\\1\\1print\\s*\\(\\s*f(\"|')\\\\n\\{\\s*start\\s*\\}-\\{\\s*node\\s*\\}\\sdistance:\\s\\{\\s*distances\\s*\\[\\s*node\\s*\\]\\s*\\}\\\\nPath:\\s\\{\\s*(?=[^\\1])(\"|')\\s->\\s\\3\\.join\\s*\\(\\s*paths\\s*\\[\\s*node\\s*\\]\\s*\\)\\s*\\}\\2\\s*\\)/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6557927ad11e58bf8c794b25.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6559d70c5161b16ff1d6530d",
      "title": "Step 54",
      "challengeType": 20,
      "dashedName": "step-54",
      "description": "Python provides a concise way to write `if`/`else` conditionals by using the ternary syntax:\n\n```py\nval_1 if condition else val_2\n```\n\nThe expression above evaluates to `val_1` if `condition` is true, otherwise to `val_2`.\n\nDelete your `print` call and create a variable called `targets_to_print` after your `while` loop. Use the ternary syntax to assign it `[target]` when `target` is truthy, and `graph` otherwise.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start, target = ''):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current][:]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n--fcc-editable-region--    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete your `print` call.",
          "testCode": "({ test: () => assert.isFalse( /print\\s*\\(\\s*f(\"|')Unvisited:\\s*\\{\\s*unvisited\\s*\\}\\\\nDistances:\\s\\{\\s*distances\\s*\\}\\\\nPaths:\\s\\{\\s*paths\\s*\\}\\1\\s*\\)/.test(code)) })"
        },
        {
          "text": "You should create a variable called `targets_to_print` after your `while` loop.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/unvisited\\.remove\\(\\s*current\\s*\\).*^\\s{4}targets_to_print\\s*=/ms));\n  }\n})"
        },
        {
          "text": "You should use the ternary syntax to assign `[target]` when `target` is truthy, and `graph` otherwise to your `targets_to_print` variable.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/unvisited\\.remove\\(\\s*current\\s*\\).*^\\s{4}targets_to_print\\s*=\\s*\\[\\s*target\\s*\\]\\s+if\\s+target\\s+else\\s+graph/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6559d70c5161b16ff1d6530d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6559d86fe1b8947954b9178d",
      "title": "Step 56",
      "challengeType": 20,
      "dashedName": "step-56",
      "description": "Now it's better but you don't want to print the details about the starting node.\n\nBefore the `print` call, add an `if` statement to execute when `node` is equal to `start` and use the `continue` keyword to go to the next loop iteration.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start, target = ''):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current][:]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n--fcc-editable-region--  \n    targets_to_print = [target] if target else graph\n    for node in targets_to_print:\n        print(f'\\n{start}-{node} distance: {distances[node]}\\nPath: {\" -> \".join(paths[node])}')\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should nest an `if` statement to check that `node` is equal to `start` inside your `for` loop.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s{4})for\\s+node\\s+in\\s+targets_to_print\\s*:\\s*^\\1\\1if\\s+(node\\s*==\\s*start|start\\s*==\\s*node)\\s*:/m));\n  }\n})"
        },
        {
          "text": "You should use the `continue` keyword to go to the next iteration inside your new `if` statement.\n\n```js\n({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^(\\s{4})for\\s+node\\s+in\\s+targets_to_print\\s*:\\s*^\\1\\1if\\s+(node\\s*==\\s*start|start\\s*==\\s*node)\\s*:\\s*^\\1\\1\\1continue/m));\n\n}\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6559d86fe1b8947954b9178d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6559da1b7d75f088f5e6b89f",
      "title": "Step 57",
      "challengeType": 20,
      "dashedName": "step-57",
      "description": "Finally, at the very end of your function, return `distances, paths`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start, target = ''):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current][:]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n--fcc-editable-region--    \n    targets_to_print = [target] if target else graph\n    for node in targets_to_print:\n        if node == start:\n            continue\n        print(f'\\n{start}-{node} distance: {distances[node]}\\nPath: {\" -> \".join(paths[node])}')\n        \n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `distances, paths` at the bottom of your function.",
          "testCode": "({ test: () =>  {\n    const shortest = __helpers.python.getDef(code, \"shortest_path\");\n    const {function_body} = shortest;    \n    assert(function_body.match(/^\\s{4}return\\s+distances\\s*,\\s*paths/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6559da1b7d75f088f5e6b89f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6559da93115de78dbbdc7ba3",
      "title": "Step 59",
      "challengeType": 20,
      "dashedName": "step-59",
      "description": "As a final step, modify your function call passing `'F'` as the third argument to print only the path from `A` to `F`.\n\nWith that, the shortest path algorithm is complete.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': [('B', 5), ('C', 3), ('E', 11)],\n    'B': [('A', 5), ('C', 1), ('F', 2)],\n    'C': [('A', 3), ('B', 1), ('D', 1), ('E', 5)],\n    'D': [('C',1 ), ('E', 9), ('F', 3)],\n    'E': [('A', 11), ('C', 5), ('D', 9)],\n    'F': [('B', 2), ('D', 3)]\n}\n\ndef shortest_path(graph, start, target = ''):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current][:]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n    \n    targets_to_print = [target] if target else graph\n    for node in targets_to_print:\n        if node == start:\n            continue\n        print(f'\\n{start}-{node} distance: {distances[node]}\\nPath: {\" -> \".join(paths[node])}')\n    \n    return distances, paths\n    \nshortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 5), ('C', 3), ('E', 11)],\n    'B': [('A', 5), ('C', 1), ('F', 2)],\n    'C': [('A', 3), ('B', 1), ('D', 1), ('E', 5)],\n    'D': [('C',1 ), ('E', 9), ('F', 3)],\n    'E': [('A', 11), ('C', 5), ('D', 9)],\n    'F': [('B', 2), ('D', 3)]\n}\n\ndef shortest_path(graph, start, target = ''):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current][:]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n    \n    targets_to_print = [target] if target else graph\n    for node in targets_to_print:\n        if node == start:\n            continue\n        print(f'\\n{start}-{node} distance: {distances[node]}\\nPath: {\" -> \".join(paths[node])}')\n    \n    return distances, paths\n    \nshortest_path(my_graph, 'A', 'F')"
        }
      ],
      "tests": [
        {
          "text": "You should call `shortest_path` passing `my_graph`, `'A'` and `'F'` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /^shortest_path\\s*\\(\\s*my_graph\\s*,\\s*(\"|')A\\1\\s*,\\s*(\"|')F\\2\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6559da93115de78dbbdc7ba3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6566195b0a021bb660b2b4b1",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Now modify `my_graph['B']` into a list of tuples, where the first element in the tuple is the connected node, and the second element is the distance. The `B-C` distance is `4`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': ['A', 'C'],\n--fcc-editable-region--    \n    'C': ['B', 'D'],\n    'D': ['A', 'C']\n}"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "`my_graph['B']` should be a list containing the tuples `('A', 3)` and `('C', 4)`.",
          "testCode": "({ test: () => assert(runPython(`\n    tuples = [(\"A\", 3), (\"C\", 4)]\n    len(my_graph[\"B\"]) == 2 and all(t in my_graph[\"B\"] for t in tuples)\n  `))\n})"
        },
        {
          "text": "`my_graph` should have 4 keys named `'A'`, `'B'`, `'C'`, and `'D'`.",
          "testCode": "({ test: () => assert(runPython(`    \n    key_list = [\"A\", \"B\", \"C\", \"D\"]\n    len(my_graph) == 4 and all(key in my_graph for key in key_list)\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6566195b0a021bb660b2b4b1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65661b72d6745ebec6a96923",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "In the same way, modify the remaining two lists considering that the `C-D` distance is `7`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': ['B', 'D'],\n    'D': ['A', 'C']\n}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "`my_graph['C']` should be a list containing the tuples `('B', 4)` and `('D', 7)`.",
          "testCode": "({ test: () => assert(runPython(`\n    tuples = [(\"B\", 4), (\"D\", 7)]\n    len(my_graph[\"C\"]) == 2 and all(t in my_graph[\"C\"] for t in tuples) \n  `))\n})"
        },
        {
          "text": "`my_graph['D']` should be a list containing the tuples `('A', 1)` and `('C', 7)`.",
          "testCode": "({ test: () => assert(runPython(`\n    tuples = [(\"A\", 1), (\"C\", 7)]\n    len(my_graph[\"D\"]) == 2 and all(t in my_graph[\"D\"] for t in tuples)\n  `))\n})"
        },
        {
          "text": "`my_graph` should have 4 keys named `'A'`, `'B'`, `'C'`, and `'D'`.",
          "testCode": "({ test: () => assert(runPython(`\n    key_list = [\"A\", \"B\", \"C\", \"D\"]\n    len(my_graph) == 4 and all(key in my_graph for key in key_list)\n  `))\n})"
        },
        {
          "text": "`my_graph['A']` should be a list containing the tuples `('B', 3)` and `('D', 1)`.",
          "testCode": "({ test: () => assert(runPython(`\n    tuples = [(\"B\", 3), (\"D\", 1)]\n    len(my_graph[\"A\"]) == 2 and all(t in my_graph[\"A\"] for t in tuples)\n  `))\n})"
        },
        {
          "text": "`my_graph['B']` should be a list containing the tuples `('A', 3)` and `('C', 4)`.",
          "testCode": "({ test: () => assert(runPython(`\n    tuples = [(\"A\", 3), (\"C\", 4)]\n    len(my_graph[\"B\"]) == 2 and all(t in my_graph[\"B\"] for t in tuples)\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65661b72d6745ebec6a96923.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6567722f53ad97d7ea6bb082",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "Now uncomment your function call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n--fcc-editable-region--\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current]\n\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n    \n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should restore your `shortest_path(my_graph, 'A')` call.",
          "testCode": "({ test: () => assert.match(code, /^shortest_path\\s*\\(\\s*my_graph\\s*,\\s*(\"|')A\\1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6567722f53ad97d7ea6bb082.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65774ae7c3eee66fe79b9459",
      "title": "Step 58",
      "challengeType": 20,
      "dashedName": "step-58",
      "description": "Now, you are going to test your function with another graph. Change `my_graph` into the following graph:\n\n```py\n{\n    'A': [('B', 5), ('C', 3), ('E', 11)],\n    'B': [('A', 5), ('C', 1), ('F', 2)],\n    'C': [('A', 3), ('B', 1), ('D', 1), ('E', 5)],\n    'D': [('C', 1), ('E', 9), ('F', 3)],\n    'E': [('A', 11), ('C', 5), ('D', 9)],\n    'F': [('B', 2), ('D', 3)]\n}\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n--fcc-editable-region--\ndef shortest_path(graph, start, target = ''):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n    \n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n            if distance + distances[current] < distances[node]:\n                distances[node] = distance + distances[current]\n                if paths[node] and paths[node][-1] == node:\n                    paths[node] = paths[current][:]\n                else:\n                    paths[node].extend(paths[current])\n                paths[node].append(node)\n        unvisited.remove(current)\n\n    targets_to_print = [target] if target else graph\n    for node in targets_to_print:\n        if node == start:\n            continue\n        print(f'\\n{start}-{node} distance: {distances[node]}\\nPath: {\" -> \".join(paths[node])}')\n    \n    return distances, paths\nshortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify `my_graph` into the provided graph.\n\n```js\n({ test: () => assert(runPython(`\n    g = {\n        'A': [('B', 5), ('C', 3), ('E', 11)],\n        'B': [('A', 5), ('C', 1), ('F', 2)],\n        'C': [('A', 3), ('B', 1), ('D', 1), ('E', 5)],\n        'D': [('C',1 ), ('E', 9), ('F', 3)],\n        'E': [('A', 11), ('C', 5), ('D', 9)],\n        'F': [('B', 2), ('D', 3)]\n    }\n    my_graph == g\n\n`))\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65774ae7c3eee66fe79b9459.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "657891ab9c1903f4e55433ba",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "When the condition of your new `if` is true, a shorter path to the neighbor node has been found.\n\nInside your new `if` block, delete `pass` and reassign the neighbor node distance to the sum of the neighbor node distance plus the distance of `current`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "my_graph = {\n    'A': [('B', 3), ('D', 1)],\n    'B': [('A', 3), ('C', 4)],\n    'C': [('B', 4), ('D', 7)],\n    'D': [('A', 1), ('C', 7)]\n}\n\ndef shortest_path(graph, start):\n    unvisited = list(graph)\n    distances = {node: 0 if node == start else float('inf') for node in graph}\n    paths = {node: [] for node in graph}\n    paths[start].append(start)\n\n    while unvisited:\n        current = min(unvisited, key=distances.get)\n        for node, distance in graph[current]:\n--fcc-editable-region--\n            if distance + distances[current] < distances[node]:\n                pass\n--fcc-editable-region--\n    print(f'Unvisited: {unvisited}\\nDistances: {distances}\\nPaths: {paths}')\n    \n#shortest_path(my_graph, 'A')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `distance + distances[current]` to `distances[node]` inside your new `if`.",
          "testCode": "({ test: () =>  {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /if\\s+distance\\s*\\+\\s*distances\\s*\\[\\s*current\\s*\\]\\s*<\\s*distances\\s*\\[\\s*node\\s*\\]\\s*/);\n    assert(block_body.match(/^\\s+distances\\s*\\[\\s*node\\s*\\]\\s*=\\s*distance\\s*\\+\\s*distances\\s*\\[\\s*current\\s*\\]/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\657891ab9c1903f4e55433ba.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65789506b30453080f77470c",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "So far, you have already met different data types:\n\n- Immutable data types, such as integers, strings, tuples, and Booleans.\n- Mutable data types, such as lists, and dictionaries.\n\nA dictionary is identified by a pair of curly braces, `{}`.\n\nStart by creating a variable called `copper` and assign it an empty dictionary using a pair of curly braces, in the same way you would create an empty list with a pair of square brackets.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable called `copper`.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"copper\")) })"
        },
        {
          "text": "Your `copper` variable should have the value of an empty dictionary. Use a pair of curly braces for that.",
          "testCode": "({ test: () => assert(runPython(`\n    copper == {}\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65789506b30453080f77470c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6578b13757611e2825beb8a5",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "Keys must be unique within a dictionary and they can be only immutable data types. This means you cannot use a list or another dictionary as keys.\n\nAdd another key `'age'` to your dictionary and give it the integer number `2` as value.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {'species': 'guinea pig'}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `'age'` key with the value `2` just after `'species': 'guinea pig'`, inside your `copper` dictionary. Don't forget the comma.",
          "testCode": "({ test: () => assert(runPython(`\n    copper == {\"species\": \"guinea pig\", \"age\": 2}\n  `))\n})"
        },
        {
          "text": "You should have two key-value pairs in your `copper` dictionary.",
          "testCode": "({ test: () => assert(runPython(`\n    len(copper) == 2\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6578b13757611e2825beb8a5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6578b57361f2f132a02e2a18",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "You can access the data stored in a dictionary through its keys:\n\n```py\nmy_dict = {\n    'name': 'Michael',\n    'occupation': 'Lumberjack'\n}\n\nmy_dict['name'] # 'Michael'\n```\n\nAfter your dictionary, follow the example above to access the `'species'` key of `copper` and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not modify the assignment of your dictionary.",
          "testCode": "({ test: () => assert(runPython(`\n    copper == {\"species\": \"guinea pig\", \"age\": 2}\n  `))\n})"
        },
        {
          "text": "You should use `copper['species']` to access the value of the `'species'` key.",
          "testCode": "({ test: () => assert.match(code, /copper\\s*\\[\\s*(\"|')species\\1\\s*\\]/) })"
        },
        {
          "text": "You should call `print()` passing `copper['species']` as argument.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*copper\\s*\\[\\s*(\"|')species\\1\\s*\\]\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6578b57361f2f132a02e2a18.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65796fac81f983127558f3f4",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Now, modify your existing `print()` call to print the value of the `age` key.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\nprint(copper['species'])\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use `copper['age']` to access the value of the `age` key.",
          "testCode": "({ test: () => assert.match(code, /copper\\s*\\[\\s*(\"|')age\\1\\s*\\]/) })"
        },
        {
          "text": "You should call `print()` passing `copper['age']` as argument.",
          "testCode": "({ test: () => assert.match(code, /^print\\(\\s*copper\\s*\\[\\s*(\"|')age\\1\\s*\\]\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65796fac81f983127558f3f4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6579717f0920131304286804",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "To add a new key-value pair after declaring a dictionary, you can indicate the key in the same way you would access an existing key, and set the value of the new key by using the assignment operator:\n\n```py\nmy_dict = {\n    'name': 'Michael',\n    'occupation': 'Lumberjack'\n}\n\nmy_dict['country'] = 'Canada'\n```\n\nDelete your `print()` call. Then, after the `copper` declaration, add the key `'food'` to your dictionary and set its value to `'hay'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\nprint(copper['age'])\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(copper['age'])` in your code.",
          "testCode": "({ test: () => assert.notMatch(code, /^print\\(\\s*copper\\s*\\[\\s*(\"|')age\\1\\s*\\]\\s*\\)/m) })"
        },
        {
          "text": "You should add the key `'food'` to `copper` after declaring the dictionary.",
          "testCode": "({ test: () => assert.match(code, /copper\\s*\\[\\s*(\"|')food\\1\\s*\\]/) })"
        },
        {
          "text": "You should set `copper['food']` to `'hay'` after declaring the dictionary.",
          "testCode": "({ test: () => assert.match(code, /^copper\\s*\\[\\s*(\"|')food\\1\\s*\\]\\s*=\\s*(\"|')hay\\2/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6579717f0920131304286804.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65797670e0c0d016f17e7660",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Now, at the bottom of your code, print `copper`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\ncopper['food'] = 'hay'\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `copper` at the bottom of your code.\n\n```js\n({ test: () =>\n  {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.match(commentless_code, /print\\s*\\(\\s*copper\\s*\\)\\s*$/)\n  }\n})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65797670e0c0d016f17e7660.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6579ca0923cfa7162089d2f0",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "The same syntax can be used to change the value of an existing key.\n\nJust before the `print()` call, access the `'species'` key and reassign its value to `'Cavia porcellus'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\ncopper['food'] = 'hay'\n\nprint(copper)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should reassign the `copper['species']` to the string `'Cavia porcellus'` before the `print()` call.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.match(commentless_code, /^copper\\s*\\[\\s*(\"|')species\\1\\s*\\]\\s*=\\s*(\"|')Cavia porcellus\\2\\s+^print\\s*\\(\\s*copper\\s*\\)/m)\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6579ca0923cfa7162089d2f0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6579cbab9825b8170974c69a",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "You can remove a key-value pair from a dictionary by using the `del` keyword:\n\n```py\nmy_dict = {\n    'name': 'Michael',\n    'occupation': 'Lumberjack'\n}\n\ndel my_dict['occupation']\n```\n\nJust before your `for` loop, use the `del` keyword to delete the `'age'` key and its value from `copper`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\ncopper['food'] = 'hay'\ncopper['species'] = 'Cavia porcellus'\n\nfor i, j in copper.items():\n    print(i, j)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `del` keyword to delete `copper['age']` before the `for` loop.",
          "testCode": "({ test: () => assert.match(code, /^del\\s+copper\\s*\\[\\s*(\"|')age\\1\\s*\\].*^for\\s*/ms) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6579cbab9825b8170974c69a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6579cd5f6dd62c189e53ddbb",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "Now that you reviewed the basic aspects of dictionaries, you can proceed to build the shortest path algorithm.\n\nDelete every line of code after the declaration of the `copper` dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "copper = {\n    'species': 'guinea pig',\n    'age': 2\n}\n--fcc-editable-region--\ncopper['food'] = 'hay'\ncopper['species'] = 'Cavia porcellus'\ndel copper['age']\n\nfor i, j in copper.items():\n    print(i, j)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete all the lines of code after the declaration of your dictionary.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.isFalse( /copper\\s*\\[.*?\\]|del|for|print\\s*\\(.*?\\)/ms.test(commentless_code))\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6579cd5f6dd62c189e53ddbb.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "6579dd49fa8a8e1fd06b85a9",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "Graphs are data structures representing relations between pairs of elements.\nThese elements, called *nodes*, can be real-life objects, entities, points in space or others. The connections between the nodes are called the *edges*.\n\nHere's a visual representation of a graph:\n\n<img alt=\"a weighted graph with 6 nodes\" src=\"https://cdn.freecodecamp.org/curriculum/python/graph1-example.png\" style=\"background-color: white; height: 350px; width: auto; padding: 10px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;\">\n\n\nRename the `copper` dictionary into `my_graph`. This will represent the graph to test your algorithm.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should rename your `copper` dictionary into `my_graph`.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"my_graph\")) })"
        },
        {
          "text": "Your `my_graph` variable should be a dictionary.",
          "testCode": "({ test: () => assert(runPython(`\n    type(my_graph) is dict \n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\6579dd49fa8a8e1fd06b85a9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65affe602a2a828b0382a058",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "Replace the `'age'` key with the string `'B'` and set its value to the string `'A'` to represent the connection between the nodes in both directions.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_graph = {\n    'A': 'B',\n    'age': 2\n}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your dictionary should have a `'B'` key.",
          "testCode": "({ test: () => assert(runPython(`\n    \"B\" in my_graph\n  `))\n})"
        },
        {
          "text": "Your `'B'` key should have `'A'` as the value.",
          "testCode": "({ test: () => assert(runPython(`\n    my_graph[\"B\"] == \"A\"\n  `))\n})"
        },
        {
          "text": "Your dictionary should have an `'A'` key.",
          "testCode": "({ test: () => assert(runPython(`\n    \"A\" in my_graph\n  `))\n})"
        },
        {
          "text": "Your `'A'` key should have `'B'` as the value.",
          "testCode": "({ test: () => assert(runPython(`\n    my_graph[\"A\"] == \"B\"\n  `))\n})"
        },
        {
          "text": "Your dictionary should have two keys.",
          "testCode": "({ test: () => assert(runPython(`\n    len(my_graph) == 2\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65affe602a2a828b0382a058.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65b7cd2b7bd9a684ccf1dc16",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "To iterate over the keys of a dictionary, you can simply put the dictionary into a `for` loop. The code below would print each key in the dictionary `dict`:\n\n```py\nfor i in dict:\n   print(i)\n```\n\nReplace the `print()` call with a `for` loop that iterates over `copper` and prints each key.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\ncopper['food'] = 'hay'\ncopper['species'] = 'Cavia porcellus'\n\nprint(copper)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(copper)` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(copper)\")`)) })"
        },
        {
          "text": "You should create a `for` loop to iterate over the `copper` dictionary.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_for_loops()[0].find_for_iter().is_equivalent(\"copper\")`)) })"
        },
        {
          "text": "You should print each key of the `copper` inside your `for` loop.",
          "testCode": "({ test: () => assert(runPython(`\nvar = _Node(_code).find_for_loops()[0].find_for_vars()\n_Node(_code).find_for_loops()[0].find_bodies()[0].is_equivalent(f\"print({var})\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65b7cd2b7bd9a684ccf1dc16.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65b7cf140d34058d7ea8935f",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "If you want to iterate over the values of the dictionary keys, one way is to use the `.values()` method.\n\nModify your `for` loop to iterate over `copper.values()` instead of `copper` and look at the output.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\ncopper['food'] = 'hay'\ncopper['species'] = 'Cavia porcellus'\n\nfor i in copper:\n    print(i)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `for` loop to iterate over `copper.values()` instead of `copper`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_for_loops()[0].find_for_iter().is_equivalent(\"copper.values()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65b7cf140d34058d7ea8935f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65b7d25992879698180e6a71",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "Finally, if you want to be able to go through the key-value pairs, you can use the `.items()` method.\n\nModify your `for` loop to iterate over `copper.items()` instead of `copper.values()`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\ncopper['food'] = 'hay'\ncopper['species'] = 'Cavia porcellus'\n\nfor i in copper.values():\n    print(i)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should mmodify your `for` loop to iterate over `copper.items()` instead of `copper.values()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_for_loops()[0].find_for_iter().is_equivalent(\"copper.items()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65b7d25992879698180e6a71.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "65b7d3319ebec69b983fb91b",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "As you can see from the output, `.items()` creates a data structure that stores each key-value pair in a distinct tuple. To iterate over the elements in those tuples you can add a second loop variable:\n\n```py\nfor i, j in dict.items():\n    print(i, j)\n```\n\nModify your `for` loop to take two loop variables and print both of them inside the loop body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ncopper = {\n    'species': 'guinea pig',\n    'age': 2\n}\ncopper['food'] = 'hay'\ncopper['species'] = 'Cavia porcellus'\n\nfor i in copper.items():\n    print(i)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `for` loop to use two variables.",
          "testCode": "({ test: () => assert(runPython(`\nimport ast\nvar = _Node(_code).find_for_loops()[0].find_for_vars()\nisinstance(var.tree, ast.Tuple)\n`)) })"
        },
        {
          "text": "You should print both loop variables inside your `for` loop.",
          "testCode": "({ test: () => assert(runPython(`\nvar = _Node(_code).find_for_loops()[0].find_for_vars()\n_Node(_code).find_for_loops()[0].find_bodies()[0].is_equivalent(f\"print{var}\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-algorithm-design-by-building-a-shortest-path-algorithm\\65b7d3319ebec69b983fb91b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-algorithm-design-by-building-a-shortest-path-algorithm",
        "name": "Learn Algorithm Design By Building A Shortest Path Algorithm"
      }
    },
    {
      "id": "66068fb0bfddba2b7977eb60",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "In this project, you will learn about classes and objects by building a sudoku puzzle solver.\n\nIn Python, a class is a blueprint for creating objects. Objects created from a class are instances of that class. You can create a class using this syntax:\n\n```py\nclass ClassName:\n    pass\n```\n\nWhere `class` is the keyword required to define the class and `ClassName` is the name of the class, written by convention in *PascalCase*.\n\nBegin by creating a `Board` class.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a class named `Board`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_class(\"Board\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\66068fb0bfddba2b7977eb60.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "66069167b3307b2f4067b22b",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "A new instance of a class is created by using the function notation, which involves appending a pair of parentheses to the class name.\n\nOutside the class definition, create an instance of the `Board` class and assign it to a variable named `gameboard`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `gameboard` outside the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_variable(\"gameboard\")`)) })"
        },
        {
          "text": "Your `gameboard` variable should have the value of `Board()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"gameboard\").is_equivalent(\"gameboard = Board()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\66069167b3307b2f4067b22b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606927d010be4300a4e5330",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "The instantiation creates an empty object. But classes can have methods, which are like local functions for each instance. Within a class, methods are declared as follows:\n\n```py\nclass ClassName:\n    def method_name():\n        pass\n```\n\nInside the `Board` class, replace `pass` with an empty method `spam`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    pass\n    \ngameboard = Board()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method named `spam` inside the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"spam\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606927d010be4300a4e5330.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606933d6813a8308c962dd1",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "In order to be an instance method, a method requires a special parameter, named `self` by convention. This parameter is a reference to the instance of the class and must always be the first parameter.\n\nAdd a `self` parameter to your `spam` method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def spam():\n        pass\n    \ngameboard = Board()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `spam` method should have a `self` parameter.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"spam\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606933d6813a8308c962dd1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660699119472f332798860ad",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Now, replace `pass` with a `print` call and pass it the string `'Spam!'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def spam(self):\n        pass\n    \ngameboard = Board()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and print the string `'Spam!'` within the `spam` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"spam\").find_body().is_equivalent(\"print('Spam!')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660699119472f332798860ad.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660699aabc59c532f2d556e5",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "To call an instance method, you need to use dot notation:\n\n```py\ninstance_name.method_name()\n```\n\nWhere `instance_name` is the instance or object, and `method_name` is the method you want to call.\n\nCall the `spam` method of the `gameboard` object.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def spam(self):\n        print('Spam!')\n    \ngameboard = Board()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `spam` method of the `gameboard` object with `gameboard.spam()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"gameboard.spam()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660699aabc59c532f2d556e5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "66069b0b36053733a2f012fe",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Now, delete your `spam` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def spam(self):\n        print('Spam!')\n    \ngameboard = Board()\ngameboard.spam()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `gameboard.spam()` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"gameboard.spam()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\66069b0b36053733a2f012fe.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "66069b992c1c5e3451f3deb0",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "The instantiation creates an empty object. The `__init__` method is a special method that allows you to instantiate an object to a customized state. When a class implements an `__init__` method, `__init__` is automatically called upon instantiation.\n\nInside your `Board` class, delete the `spam` method and replace it with an `__init__` method that includes a `self` parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def spam(self):\n        print('Spam!')\n    \ngameboard = Board()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have a `spam` method in your `Board` class.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).find_class(\"Board\").has_function(\"spam\")`)) })"
        },
        {
          "text": "You should define an `__init__` method in your `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"__init__\")`)) })"
        },
        {
          "text": "Your `__init__` method should have a `self` parameter.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__init__\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\66069b992c1c5e3451f3deb0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "66069d65162e61357c793e0c",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "The sudoku puzzle to solve will be a list of lists, as the following:\n\n```py\n[\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n```\n\nNote that the empty cells are filled with a zero.\n\nDeclare a `puzzle` variable and assign it the list of lists in the example above.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self):\n        pass\n--fcc-editable-region--\n\n--fcc-editable-region--\ngameboard = Board()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `puzzle` and assign it the provided 2D-list.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"puzzle\").is_equivalent(\"puzzle = [[0, 0, 2, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 3, 7, 6, 2], [4, 3, 0, 0, 0, 0, 8, 0, 0], [0, 5, 0, 0, 3, 0, 0, 9, 0], [0, 4, 0, 0, 0, 0, 0, 2, 6], [0, 0, 0, 4, 6, 7, 0, 0, 0], [0, 8, 6, 7, 0, 4, 0, 0, 0], [0, 0, 0, 5, 1, 9, 0, 0, 8], [1, 7, 0, 0, 0, 6, 0, 0, 5]]\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\66069d65162e61357c793e0c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "66069e5759b800364707988e",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "Going back to the `__init__` method, it requires an additional parameter representing the puzzle to solve.\n\nAdd a second parameter named `board` to the `__init__` method and fix the instantiation of `gameboard` by passing it the `puzzle` list as you would pass an argument to a function call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def __init__(self):\n        pass\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `__init__` method should have two parameters in the order: `self`, and `board`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__init__\").has_args(\"self, board\")`)) })"
        },
        {
          "text": "Your `gameboard` variable should have the value of `Board(puzzle)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"gameboard\").is_equivalent(\"gameboard = Board(puzzle)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\66069e5759b800364707988e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "66069f86f58f85371d47123e",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "An attribute is a variable associated with an object, which is used to store data as regular variables.\n\nInside the `__init__` method, assign the `board` parameter (which is passed when creating an instance of the `Board` class) to an instance attribute `board` using `self.board`.\n\n`self.board` refers to the `board` attribute of the instance of the class. It's a variable that belongs to the object created from the `Board` class.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def __init__(self, board):\n        pass\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and assign the `board` parameter to `self.board` inside the `__init__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__init__\").find_body().is_equivalent(\"self.board = board\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\66069f86f58f85371d47123e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606a219f9efbf38ad496f67",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "You can also use dot notation to access an instance attribute.\n\nOutside the `Board` class, after initializing the `gameboard` object, use `gameboard.board` to access the `board` attribute of your `gameboard` object and print the result to the screen.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def __init__(self, board):\n        self.board = board\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `gameboard.board`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard.board)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606a219f9efbf38ad496f67.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606a2f8a6a36f39518e0439",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "As you can see, the board is printed on the screen. Now, delete your `print` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def __init__(self, board):\n        self.board = board\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\nprint(gameboard.board)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(gameboard.board)` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(gameboard.board)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606a2f8a6a36f39518e0439.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606a3ccb1eea93a23c066bf",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "Now you'll work on a method that finds the empty cells in the sudoku board.\n\nWithin the `Board` class, create an empty method named `find_empty_cell` and give it a `self` parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Board:\n    def __init__(self, board):\n        self.board = board\n    \n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method named `find_empty_cell` inside your `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"find_empty_cell\")`)) })"
        },
        {
          "text": "Your `find_empty_cell` method should have a parameter `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"find_empty_cell\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606a3ccb1eea93a23c066bf.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606a4641ec48b3a9fe8c2fc",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "The `enumerate` built-in function takes an iterable as its argument and returns an enumerate object you can iterate over.\nIt provides the count (which by default starts at zero) and the value from the iterable.\n\n```py\niterable = ['a', 'b', 'c']\nfor i, j in enumerate(iterable):\n    print(i, j)\n```\n\nThe loop from the example above would output the tuples `0, a`, `1, b`, and `2, c`.\n\nInside the `find_empty_cell` method, replace `pass` with a `for` loop that uses the `enumerate()` function to iterate over each row in the sudoku board. Use `row` as the index of the current row and `contents` for the elements of the current row.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def find_empty_cell(self):\n        pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with a `for` loop that iterates over `enumerate(self.board)`. Use `row` and `contents` as the loop variables.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"find_empty_cell\").find_body().is_equivalent(\"for row, contents in enumerate(self.board):\\\\n  pass\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606a4641ec48b3a9fe8c2fc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606b0d602d1e33e81bcef0d",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "You need to locate the empty cell, which is filled with the number zero.\n\nReplace `pass` with a variable `col` and assign it a call to `.index()` on `contents`, passing `0` as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with a variable `col` and assign it `contents.index(0)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"find_empty_cell\").find_for_loops()[0].find_bodies()[0].is_equivalent(\"col = contents.index(0)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606b0d602d1e33e81bcef0d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606b224a69a293f98f8db8f",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "The `.index()` method raises a `ValueError` exception when the value is not found. To prevent the program from halting execution, you'll nest this line of code inside a `try` block. The `try` statement is used to encapsulate code that might raise an exception. The `except` clause, on the other hand, offers alternative code to execute if an exception occurs:\n\n```py\ntry:\n    <code>\nexcept:\n    <code>\n```\n\nPut the assignment of `col` inside a `try` block. Then, create an `except` clause and fill its body with `pass`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            col = contents.index(0)\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should put the assignment of `col` inside a `try` block and create an `except` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"find_empty_cell\").find_for_loops()[0].find_bodies()[0].is_equivalent(\"try:\\\\n  col = contents.index(0)\\\\nexcept:\\\\n  pass\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606b224a69a293f98f8db8f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606b63c0fd55e4314d2ec85",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "If `0` is found, the method should immediately return a tuple containing the row index and column index of the empty cell.\n\nInside the `try` block, after the assignment of `col`, return `row, col`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n            except:\n                pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `row, col` from the `try` block.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"find_empty_cell\").find_for_loops()[0].find_bodies()[0].is_equivalent(\"try:\\\\n  col = contents.index(0)\\\\n  return row, col\\\\nexcept:\\\\n  pass\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606b63c0fd55e4314d2ec85.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606b6b7760d0643c3b4eb29",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "If the code inside the `try` block raises an exception, you want the program to continue running, and the `pass` statement accomplishes this.\n\nAlthough this code works, specifying the exception type after the `except` keyword is considered good practice.\n\nSince you know that a `ValueError` might be raised, leave a space after the `except` keyword and add `ValueError` after that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except:\n                pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `except ValueError:` in your code.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"find_empty_cell\").find_for_loops()[0].find_bodies()[0].is_equivalent(\"try:\\\\n  col = contents.index(0)\\\\n  return row, col\\\\nexcept ValueError:\\\\n  pass\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606b6b7760d0643c3b4eb29.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606b8d31356fe4563f0e99c",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "Outside the `for` loop, return `None`. This handles the case in which no empty cell is found, indicating that the sudoku board is completely filled.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `None` after the `for` loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"find_empty_cell\").has_return(\"None\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606b8d31356fe4563f0e99c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606b961ebcf04460f8af76e",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Test that the `find_empty_cell` method works properly by calling it on `gameboard` and printing the result.\n\nNote that, although `find_empty_cell` is defined with one parameter, you must not give it a value by passing an argument to the function call, since `self` is automatically passed in as the object you are calling the method on.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `gameboard.find_empty_cell()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard.find_empty_cell())\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606b961ebcf04460f8af76e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606baaf1828ff46ebcc008c",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "`find_empty_cell` is returning `(0, 0)`, which is the position of the first empty cell in the sudoku board.\n\nTurn the first `0` inside `puzzle` into a `1`. You will see in the output that the next empty cell will be found.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n--fcc-editable-region--\ngameboard = Board(puzzle)\nprint(gameboard.find_empty_cell())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the first item of the first list in `puzzle` into a `1`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"puzzle\").is_equivalent(\"puzzle = [[1, 0, 2, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 3, 7, 6, 2], [4, 3, 0, 0, 0, 0, 8, 0, 0], [0, 5, 0, 0, 3, 0, 0, 9, 0], [0, 4, 0, 0, 0, 0, 0, 2, 6], [0, 0, 0, 4, 6, 7, 0, 0, 0], [0, 8, 6, 7, 0, 4, 0, 0, 0], [0, 0, 0, 5, 1, 9, 0, 0, 8], [1, 7, 0, 0, 0, 6, 0, 0, 5]]\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606baaf1828ff46ebcc008c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606bbd52233b247cf0a56e4",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "Now, turn the `1` you modified earlier back into a `0` to restore the original board configuration. Then, delete your `print` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n--fcc-editable-region--\npuzzle = [\n  [1, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\nprint(gameboard.find_empty_cell())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn the first item of the first list of `puzzle` back into a zero.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"puzzle\").is_equivalent(\"puzzle = [[0, 0, 2, 0, 0, 8, 0, 0, 0], [0, 0, 0, 0, 0, 3, 7, 6, 2], [4, 3, 0, 0, 0, 0, 8, 0, 0], [0, 5, 0, 0, 3, 0, 0, 9, 0], [0, 4, 0, 0, 0, 0, 0, 2, 6], [0, 0, 0, 4, 6, 7, 0, 0, 0], [0, 8, 6, 7, 0, 4, 0, 0, 0], [0, 0, 0, 5, 1, 9, 0, 0, 8], [1, 7, 0, 0, 0, 6, 0, 0, 5]]\")`)) })"
        },
        {
          "text": "You should not have `print(gameboard.find_empty_cell())` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(gameboard.find_empty_cell())\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606bbd52233b247cf0a56e4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606bc4e5535c0484990ccd5",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "Next, you're going to work on a method that checks if a given number can be inserted into a specified row of the sudoku board.\n\nWithin the `Board` class, create a method named `valid_in_row` and give it three parameters: `self`, `row`, and `num`. Where `self` represents the instance of the class, and `row` and `num` are the row index and the number to be checked, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n--fcc-editable-region--\n    \n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new method named `valid_in_row` within the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"valid_in_row\")`)) })"
        },
        {
          "text": "Your `valid_in_row` method should have three parameters: `self`, `row`, and `num`, in this order.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_row\").has_args(\"self, row, num\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606bc4e5535c0484990ccd5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606bd3d02e86548d3ce1a0a",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "Replace `pass` with an expression that checks if the number `num` is not already present in that row.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n--fcc-editable-region--\n    def valid_in_row(self, row, num):\n        pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with the expression `num not in self.board[row]`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_row\").find_body().is_equivalent(\"num not in self.board[row]\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606bd3d02e86548d3ce1a0a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606beade9200b49aaeecd94",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "If `num` is not in the row, the expression evaluates to `True` and it means the number is valid for insertion.\n\nIf `num` is in the row, the expression evaluates to `False` and insertion would violate the rules.\n\nPrepend a `return` keyword to the expression inside the `valid_in_row` method body, so that the validity of the number can be checked.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n--fcc-editable-region--\n    def valid_in_row(self, row, num):\n        num not in self.board[row]\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `num not in self.board[row]`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_row\").find_body().is_equivalent(\"return num not in self.board[row]\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606beade9200b49aaeecd94.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606bf4561f8794a0d345919",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "It's time to test the `valid_in_row` method. Call `valid_in_row` on `gameboard`. Pass it `0` and `8` as the arguments and print the result.\n\nAgain, note how the method is defined with three parameters, yet it is called with only two arguments because `self` is automatically passed as the object on which the method is called.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the result of calling `valid_in_row(0, 8)` on `gameboard`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_row(0, 8))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606bf4561f8794a0d345919.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606c05b5624a54ab85808fa",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "As you can see, the output is `False` because `8` is already present in the first row of the board. Now change the `8` into a `7`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\nprint(gameboard.valid_in_row(0, 8))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You modify your `print` call to print the result of calling `valid_in_row(0, 7)` on `gameboard`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_row(0, 7))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606c05b5624a54ab85808fa.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606c0dd3293064b30d17a72",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "Great! `7` is not present in the first row of the sudoku board and the method is telling that `7` is a valid choice for that row.\n\nNow delete the `print` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\nprint(gameboard.valid_in_row(0, 7))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(gameboard.valid_in_row(0, 7))` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_row(0, 7))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606c0dd3293064b30d17a72.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606c14182435d4bab0de2ee",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "Next, you're going to create a method that checks if a number can be inserted in a specified column of the sudoku board by checking if the number is not already present in that column.\n\nWithin the `Board` class, create a method named `valid_in_col` and give it three parameters: `self`, `col` and `num`.\nWhere `col` and `num` are the column index and the number to be checked, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n--fcc-editable-region--\n    \n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new method named `valid_in_col` within the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"valid_in_col\")`)) })"
        },
        {
          "text": "Your `valid_in_col` method should have three parameters: `self`, `col`, and `num`, in this order.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_col\").has_args(\"self, col, num\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606c14182435d4bab0de2ee.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606c2d203a8124c83b2234b",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "You need to check if a given number is not equal to the number in the specified column of the current row.\n\nFor this, replace `pass` with a generator expression that iterates over the range from `0` to `8` (inclusive), and for each `row`, evaluates whether the number at the specified `row` and column `col` on the board is different from `num`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n--fcc-editable-region--\n    def valid_in_col(self, col, num):\n        pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and create a generator expression `(self.board[row][col] != num for row in range(9))`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_col\").find_body().is_equivalent(\"(self.board[row][col] != num for row in range(9))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606c2d203a8124c83b2234b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606c3fd5634684d48a7887b",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "The generator expression you just wrote in the previous step generates a list of boolean values representing whether the condition `self.board[row][col] != num` is `True` or `False` for each element in the specified column across all rows.\n\nPass that generator expression to the `all()` function to check if all the elements in the column are different from `num` and return the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n--fcc-editable-region--\n    def valid_in_col(self, col, num):\n        (self.board[row][col] != num for row in range(9))\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass the generator expression as the argument to an `all()` call and return the result.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_col\").find_body().is_equivalent(\"return all(self.board[row][col] != num for row in range(9))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606c3fd5634684d48a7887b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606cb019db4f74f224856f4",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "Call `valid_in_col` on `gameboard`. Pass it `0` and `7` as the arguments to see if the number `7` is allowed in the first column of the board and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the result of calling `valid_in_col(0, 7)` on `gameboard`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_col(0, 7))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606cb019db4f74f224856f4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606cc088fd3574fa9010a4f",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "Now change the `7` into a `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\nprint(gameboard.valid_in_col(0, 7))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `print` call to print the result of calling `valid_in_col(0, 1)` on `gameboard`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_col(0, 1))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606cc088fd3574fa9010a4f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606cc473675e85017b0c53d",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "The `1` is already present in the first column. So, everything seems to work fine. Now delete your `print` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\nprint(gameboard.valid_in_col(0, 1))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(gameboard.valid_in_col(0, 1))` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_col(0, 1))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606cc473675e85017b0c53d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606cc754a8834509cd0afb6",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "Another thing to check is if a number can be inserted in a 3x3 square.\n\nInside the `Board` class, create a method named `valid_in_square` with four parameters: `self`, `row`, `col`, and `num`. Where `row`, `col`, and `num` represent the row index, the column index, and the number to be checked, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n--fcc-editable-region--\n    \n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new method named `valid_in_square` within the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"valid_in_square\")`)) })"
        },
        {
          "text": "Your `valid_in_square` method should have four parameters: `self`, `row`, `col`, and `num`, in this order.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").has_args(\"self, row, col, num\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606cc754a8834509cd0afb6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606cd69f56e27516583b0cc",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "Now you need to calculate the starting row index for the 3x3 square within the board grid and ensure that the starting row index for each 3x3 square is a multiple of 3.\n\nThis can be achieved by taking the result of the integer division `row // 3` multiplied by `3`. Replace `pass` with a variable `row_start` and assign it `(row // 3) * 3`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n--fcc-editable-region--\n    def valid_in_square(self, row, col, num):\n        pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and declare a variable `row_start` with the value of `(row // 3) * 3`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").find_body().is_equivalent(\"row_start = (row//3)*3\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606cd69f56e27516583b0cc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606cf1b2b9f65529c161098",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "Similarly to the previous step, you need to ensure that the starting column index for each 3x3 square is a multiple of 3.\n\nDeclare a variable `col_start` and assign it `(col // 3) * 3`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n--fcc-editable-region--\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `col_start` with the value of `(col // 3) * 3`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").find_variable(\"col_start\").is_equivalent(\"col_start = (col//3)*3\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606cf1b2b9f65529c161098.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d03ff198245383e61d90",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "Now, iterate only over the rows inside the 3x3 square by creating a `for` loop. Use the `range()` function to generate a sequence starting at `row_start`, and use `row_no` as the loop variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n--fcc-editable-region--\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop that iterates over `range(row_start, row_start + 3)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").find_for_loops()[0].find_for_iter().is_equivalent(\"range(row_start, row_start + 3)\")`)) })"
        },
        {
          "text": "Your `for` loop should use `row_no` as the loop variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").find_for_loops()[0].find_for_vars().is_equivalent(\"row_no\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d03ff198245383e61d90.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d32096165654b8e73f21",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "Inside the loop created in the previous step, nest another `for` loop to iterate over a sequence of three elements starting at `col_start`. Use the `range()` function to generate this sequence and `col_no` as the loop variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n--fcc-editable-region--\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop that iterates over `range(col_start, col_start + 3)` inside the existing loop body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").find_for_loops()[0].find_for_loops()[0].find_for_iter().is_equivalent(\"range(col_start, col_start + 3)\")`)) })"
        },
        {
          "text": "Your `for` loop should use `col_no` as the loop variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").find_for_loops()[0].find_for_loops()[0].find_for_vars().is_equivalent(\"col_no\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d32096165654b8e73f21.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d378de78d55523f08298",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "Now, check if the given number `num` is already present in the current cell of the 3x3 square.\n\nReplace `pass` with an `if` statement that checks if the number in the current cell of the sudoku board is equal to `num`. If so, return `False` from the `if` body, indicating that the number is not a valid choice.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n--fcc-editable-region--\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and create an `if` statement that checks if the current cell of the sudoku board is equal to `num`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").find_for_loops()[0].find_for_loops()[0].find_ifs()[0].find_conditions()[0].is_equivalent(\"self.board[row_no][col_no] == num\")`)) })"
        },
        {
          "text": "You should return `False` from your new `if` statement body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").find_for_loops()[0].find_for_loops()[0].find_ifs()[0].find_bodies()[0].is_equivalent(\"return False\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d378de78d55523f08298.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d589750ad655fa0df168",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "If the number is not present, it can be inserted into the square without violating the rules of sudoku.\n\nAfter the outer `for` loop, return `True`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n--fcc-editable-region--\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `True` after the outer `for` loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"valid_in_square\").has_return(\"True\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d589750ad655fa0df168.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d6138c49e456920fa818",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "Test the method to ensure it works properly by calling `valid_in_square` on `gameboard`. Pass it `1`, `0`, and `3` as the arguments and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the result of calling `valid_in_square(1, 0, 3)` on `gameboard`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_square(1, 0, 3))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d6138c49e456920fa818.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d7bb9e4c6b574235159a",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "The method returns `False` because `3` is already present in that square. Try another square by changing the column index to `6`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\nprint(gameboard.valid_in_square(1, 0, 3))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the result of calling `valid_in_square(1, 6, 3)` on `gameboard`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_square(1, 6, 3))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d7bb9e4c6b574235159a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d8795bd533582425a363",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "Everything works fine. Now delete your `print` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)\n--fcc-editable-region--\nprint(gameboard.valid_in_square(1, 6, 3))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(gameboard.valid_in_square(1, 6, 3))` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(gameboard.valid_in_square(1, 6, 3))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d8795bd533582425a363.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d8c323d6205890fbbd54",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "Within the `Board` class, create another method `is_valid` and give it three parameters: `self`, `empty`, and `num`. Where `empty` is a tuple representing the row and column indices of an empty cell and `num` is the number to be checked.\n\nThis method will check if a given number is a valid choice for an empty cell in the sudoku board by validating its compatibility with the row, column, and 3x3 square of the specified empty cell.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n--fcc-editable-region--\n    \n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new method named `is_valid` within the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"is_valid\")`)) })"
        },
        {
          "text": "Your `is_valid` method should have three parameters: `self`, `empty`, and `num`, in this order.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"is_valid\").has_args(\"self, empty, num\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d8c323d6205890fbbd54.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606d9d92fcf78598b3b5184",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "A tuple can be unpacked, meaning that the elements contained in the tuple can be assigned to variables, like this:\n\n```py\nspam = ('lemon', 'curry')\nitem1, item2 = spam\n```\n\nIn the example above, `item1` would have the value `'lemon'` and `item2` would have the value `'curry'`.\n\nInside the method, delete `pass` and unpack the `empty` tuple into `row` and `col`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n--fcc-editable-region--\n    def is_valid(self, empty, num):\n        pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and unpack the `empty` tuple into `row` and `col`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"is_valid\").find_body().is_equivalent(\"row, col = empty\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606d9d92fcf78598b3b5184.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606db6a23a1455a402f91ae",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "Within the `is_valid` method, check if the number is valid for insertion in the specified row by calling the `valid_in_row()` method with `row` and `num` as arguments, and assign the result to a variable `valid_in_row`. Remember to use `self` to reference the methods of the current instance.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n--fcc-editable-region--\n    def is_valid(self, empty, num):\n        row, col = empty\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `valid_in_row` and assign it `self.valid_in_row(row, num)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"is_valid\").find_variable(\"valid_in_row\").is_equivalent(\"valid_in_row = self.valid_in_row(row, num)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606db6a23a1455a402f91ae.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606dcf5a31e4e5b43737417",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "Check if the number is valid for insertion in the specified column by calling the `valid_in_col()` method with `col` and `num` as the arguments and assign the result to a variable `valid_in_col`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n--fcc-editable-region--\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `valid_in_col` and assign it `self.valid_in_col(col, num)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"is_valid\").find_variable(\"valid_in_col\").is_equivalent(\"valid_in_col = self.valid_in_col(col, num)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606dcf5a31e4e5b43737417.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606dd63109f9f5c2195e30c",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "Check if the number is valid for insertion in the specified 3x3 square by calling the `valid_in_square()` method with `row`, `col` and `num` as the arguments and assign the result to a variable `valid_in_square`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n--fcc-editable-region--\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `valid_in_square` and assign it `self.valid_in_square(row, col, num)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"is_valid\").find_variable(\"valid_in_square\").is_equivalent(\"valid_in_square = self.valid_in_square(row, col, num)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606dd63109f9f5c2195e30c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606de006a82e05c9a65cebe",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "To verify that the number is valid after all those checks, call the `all()` function and pass it a list containing `valid_in_row`, `valid_in_col`, and `valid_in_square`. Also, return the result of the `all()` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n--fcc-editable-region--\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return a call to the `all()` function passing it a list containing `valid_in_row`, `valid_in_col`, and `valid_in_square`.",
          "testCode": "({ test: () => assert(runPython(`\nimport itertools\np = list(itertools.permutations([\"valid_in_row\", \"valid_in_col\", \"valid_in_square\"]))\nl = [\", \".join(i) for i in p]\nnode = _Node(_code).find_class(\"Board\").find_function(\"is_valid\")\nany([node.has_return(f\"all([{i}])\") for i in l])\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606de006a82e05c9a65cebe.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606e2f27f19ca5f398c6aed",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "Next, you'll work on a method that attempts to solve the sudoku in-place, meaning it will modify the existing sudoku board rather than creating a new one.\n\nWithin the `Board` class, create a method named `solver` and give it a single parameter, `self`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    \n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new method named `solver` within the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"solver\")`)) })"
        },
        {
          "text": "Your `solver` method should have a single parameter `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606e2f27f19ca5f398c6aed.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "6606e3e6231702600bd5860c",
      "title": "Step 53",
      "challengeType": 20,
      "dashedName": "step-53",
      "description": "Delete `pass` and create an `if` statement that checks if the value returned by `find_empty_cell` is `None`. In that case, the puzzle is solved. Therefore, return `True` from the `if` body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and create an `if` statement that checks if the value returned by `self.find_empty_cell` is `None`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_ifs()[0].find_conditions()[0].is_equivalent(\"self.find_empty_cell() is None\")`)) })"
        },
        {
          "text": "You should return `True` from your new `if` statement body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_ifs()[0].find_bodies()[0].is_equivalent(\"return True\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\6606e3e6231702600bd5860c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a737f0f72b51de361051c",
      "title": "Step 54",
      "challengeType": 20,
      "dashedName": "step-54",
      "description": "The `:=` operator gives you the ability to assign variables in the middle of an expression. The syntax is: `name := val`, where `name` is the variable name and `val` is the variable value.\n\nThis construct is formally named *assignment expressions*, while the `:=` operator is commonly referred to as the *walrus* operator.\n\nSince you are going to need the `self.find_empty_cell()` call more than once, assign it to a variable `next_empty` by using the walrus operator. Then, enclose the assignment between a pair of parentheses.\n\nIn this way, you'll combine the assignment and the conditional check into a single line, making the code more concise.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        if self.find_empty_cell() is None:\n            return True\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the `if` condition into `(next_empty := self.find_empty_cell()) is None`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_ifs()[0].find_conditions()[0].is_equivalent(\"(next_empty := self.find_empty_cell()) is None\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a737f0f72b51de361051c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a7a1cac69b7217cbae22d",
      "title": "Step 55",
      "challengeType": 20,
      "dashedName": "step-55",
      "description": "After the `if` statement, create a `for` loop to iterate over the range from `1` to `9` inclusive. Use `guess` as the loop variable.\n\nThis loop will enable you to systematically check if any cipher from `1` to `9` is suitable to fill an empty cell.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop that iterates over `range(1, 10)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_for_loops()[0].find_for_iter().is_equivalent(\"range(1, 10)\")`)) })"
        },
        {
          "text": "Your `for` loop should have `guess` as the loop variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_for_loops()[0].find_for_vars().is_equivalent(\"guess\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a7a1cac69b7217cbae22d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a7cb75dce3d22ab562c0d",
      "title": "Step 56",
      "challengeType": 20,
      "dashedName": "step-56",
      "description": "Inside the loop body, replace `pass` with an `if` statement that checks if the number is a valid choice for the current cell.\n\nBuild the `if` condition with an `is_valid` call, passing `next_empty` and `guess` as the arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and create an `if` statement that checks if `self.is_valid(next_empty, guess)` is `True`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_for_loops()[0].find_bodies()[0].is_equivalent(\"if self.is_valid(next_empty, guess):\\\\n  pass\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a7cb75dce3d22ab562c0d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a7ea6e3a21a243d6aa288",
      "title": "Step 57",
      "challengeType": 20,
      "dashedName": "step-57",
      "description": "Inside the `if` body, delete `pass` and unpack the tuple `next_empty` into `row, col`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete `pass` and unpack the tuple `next_empty` into `row, col`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_for_loops()[0].find_ifs()[0].find_bodies()[0].is_equivalent(\"row, col = next_empty\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a7ea6e3a21a243d6aa288.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a7f28d5ce6a24ef856a50",
      "title": "Step 58",
      "challengeType": 20,
      "dashedName": "step-58",
      "description": "Now, modify the board in place by accessing the cell at the given row and column and assigning it the value of `guess`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `guess` to `self.board[row][col]`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_for_loops()[0].find_ifs()[0].find_bodies()[0].is_equivalent(\"row, col = next_empty\\\\nself.board[row][col] = guess\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a7f28d5ce6a24ef856a50.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a8b6cd8de406ae82ce910",
      "title": "Step 59",
      "challengeType": 20,
      "dashedName": "step-59",
      "description": "Nest an `if` statement inside the current `if`. For the `if` condition, use a recursive call to `solver()` and return `True` from the new `if` body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should nest an `if` statement inside the current `if` statement and use `self.solver()` as the condition.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_for_loops()[0].find_ifs()[0].find_ifs()[0].find_conditions()[0].is_equivalent(\"self.solver()\")`)) })"
        },
        {
          "text": "You should return `True` from your new `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_for_loops()[0].find_ifs()[0].find_ifs()[0].find_bodies()[0].is_equivalent(\"return True\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a8b6cd8de406ae82ce910.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a8c3b21100c6b83e57cb0",
      "title": "Step 60",
      "challengeType": 20,
      "dashedName": "step-60",
      "description": "If the recursive call returns `False`, it means the guess led to an unsolvable sudoku. So you'll need to restore the cell to be empty and explore another guess.\n\nAfter the innermost `if` statement, set the current cell value back to `0`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should set the current cell value back to `0` after the innermost `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").find_for_loops()[0].find_ifs()[0].find_bodies()[0].is_equivalent(\"row, col = next_empty\\\\nself.board[row][col] = guess\\\\nif self.solver():\\\\n  return True\\\\nself.board[row][col] = 0\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a8c3b21100c6b83e57cb0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a8d7c5f33c16c67e58b37",
      "title": "Step 61",
      "challengeType": 20,
      "dashedName": "step-61",
      "description": "Finally, make the `solver` method return `False` if none of the guesses leads to a solution. Pay attention to the indentation.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n--fcc-editable-region--\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `False` after the `for` loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"solver\").has_return(\"False\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a8d7c5f33c16c67e58b37.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a8ef6b7571f6dddc3553b",
      "title": "Step 62",
      "challengeType": 20,
      "dashedName": "step-62",
      "description": "Outside the class definition, create a function `solve_sudoku` to print and solve the sudoku board.\n\nGive it a single parameter `board` that will be your 2D list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n--fcc-editable-region--\n\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a new function named `solve_sudoku` outside the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_function(\"solve_sudoku\")`)) })"
        },
        {
          "text": "Your `solve_sudoku` function should have a single parameter `board`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solve_sudoku\").has_args(\"board\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a8ef6b7571f6dddc3553b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a92e93854486efa68fe6f",
      "title": "Step 63",
      "challengeType": 20,
      "dashedName": "step-63",
      "description": "Inside the `solve_sudoku` function, delete `pass` and create a `gameboard` variable and assign it an instance of the `Board` class, passing `board` as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n--fcc-editable-region--\ndef solve_sudoku(board):\n    pass\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with a variable `gameboard` and assign it `Board(board)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solve_sudoku\").find_body().is_equivalent(\"gameboard = Board(board)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a92e93854486efa68fe6f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a937220bf966fd844f1ee",
      "title": "Step 64",
      "challengeType": 20,
      "dashedName": "step-64",
      "description": "Now, add a `print()` call to print the following f-string: `f'Puzzle to solve:\\n{gameboard}'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n--fcc-editable-region--\ndef solve_sudoku(board):\n    gameboard = Board(board)\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the provided string inside the `solve_sudoku` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solve_sudoku\").has_call(\"print(f'Puzzle to solve:\\\\\\\\n{gameboard}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a937220bf966fd844f1ee.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a940b3379fb708a83593a",
      "title": "Step 65",
      "challengeType": 20,
      "dashedName": "step-65",
      "description": "Create an `if` statement that checks if the `solver()` method call from the `gameboard` object returns `True`.\n\nThen, add a `print()` call inside the `if` body passing the following f-string: `f'Solved puzzle:\\n{gameboard}'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n--fcc-editable-region--\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if the `solver()` method call from the `gameboard` object returns `True`.",
          "testCode": "({ test: () => assert(runPython(`\nconditions = [\"gameboard.solver()\", \"gameboard.solver() == True\", \"True == gameboard.solver()\"]\nnode = _Node(_code).find_function(\"solve_sudoku\").find_ifs()[0].find_conditions()[0]\nany(node.is_equivalent(condition) for condition in conditions)`)) })"
        },
        {
          "text": "You should print `f'Solved puzzle:\\n{gameboard}'` inside the new `if` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solve_sudoku\").find_ifs()[0].find_bodies()[0].has_call(\"print(f'Solved puzzle:\\\\\\\\n{gameboard}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a940b3379fb708a83593a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a94f55c3c9b71a37e1c8b",
      "title": "Step 66",
      "challengeType": 20,
      "dashedName": "step-66",
      "description": "Create an `else` clause for when the sudoku puzzle is not solvable and print the following string inside the new `else` block: `'The provided puzzle is unsolvable.'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n--fcc-editable-region--\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `else` clause and print `'The provided puzzle is unsolvable.'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solve_sudoku\").find_ifs()[0].find_bodies()[1].has_call(\"print('The provided puzzle is unsolvable.')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a94f55c3c9b71a37e1c8b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a957f44c096728ba9c41f",
      "title": "Step 67",
      "challengeType": 20,
      "dashedName": "step-67",
      "description": "After the conditional statements, return your instance of the `Board` class, which represents the final state of the sudoku board after attempting to solve it.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n--fcc-editable-region--\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n--fcc-editable-region--\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\ngameboard = Board(puzzle)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `gameboard` after the `else` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solve_sudoku\").has_return(\"gameboard\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a957f44c096728ba9c41f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a95c3da857673124ed698",
      "title": "Step 68",
      "challengeType": 20,
      "dashedName": "step-68",
      "description": "There's still something to fix. Try to print your `gameboard` object.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n--fcc-editable-region--\ngameboard = Board(puzzle)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `gameboard`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(gameboard)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a95c3da857673124ed698.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a968ca0838773c9bbfc85",
      "title": "Step 69",
      "challengeType": 20,
      "dashedName": "step-69",
      "description": "When you print your `gameboard` object, you get something like `<__main__.Board object at 0xf3c1c8>`, which is the default representation of an object. This means that the `solve_sudoku` function will also give you an output different from what you expect.\n\nDelete both the `print()` call and the `gameboard` object.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n--fcc-editable-region--\ngameboard = Board(puzzle)\nprint(gameboard)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(gameboard)` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(gameboard)\")`)) })"
        },
        {
          "text": "You should not have `gameboard = Board(puzzle)` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_variable(\"gameboard\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a968ca0838773c9bbfc85.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660a9819ad113774d65a1e7c",
      "title": "Step 70",
      "challengeType": 20,
      "dashedName": "step-70",
      "description": "The `__str__` method is a special method that is called under the hood when the object is printed using the `print()` function, or converted into a string using the `str()` function.\n\nDefine an empty `__str__` method within the `Board` class and give it a `self` parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    \n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new method named `__str__` within the `Board` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").has_function(\"__str__\")`)) })"
        },
        {
          "text": "Your `__str__` method should have a single parameter `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660a9819ad113774d65a1e7c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660ac1d158923e805d3c3099",
      "title": "Step 71",
      "challengeType": 20,
      "dashedName": "step-71",
      "description": "Replace `pass` with a variable `board_str` and assign it an empty string. You'll use this variable to build the custom string representation to return.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def __str__(self):\n        pass\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with a variable `board_str` and assign it an empty string.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_body().is_equivalent(\"board_str = ''\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660ac1d158923e805d3c3099.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660ac2873b090d80d6aa6ce2",
      "title": "Step 72",
      "challengeType": 20,
      "dashedName": "step-72",
      "description": "Now, create a `for` loop to iterate over the rows in the board. Use `row` as the loop variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def __str__(self):\n        board_str = ''\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop that iterates over `self.board`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_for_iter().is_equivalent(\"self.board\")`)) })"
        },
        {
          "text": "You should use `row` as the loop variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_for_vars().is_equivalent(\"row\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660ac2873b090d80d6aa6ce2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660ac35d55a15d81afdedd76",
      "title": "Step 73",
      "challengeType": 20,
      "dashedName": "step-73",
      "description": "Inside the `for` loop, declare a variable `row_str` and assign it a list comprehension that iterates over `row` and turns each item `i` in `row` into a string. Use the `str()` function for that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def __str__(self):\n        board_str = ''\n        for row in self.board:\n            pass\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `row_str`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_bodies()[0].has_variable(\"row_str\")`)) })"
        },
        {
          "text": "You should assign a list comprehension that iterates over `row` to the `row_str` variable.",
          "testCode": "({ test: () => (runPython(`\nimport ast\nvar = _Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_bodies()[0].find_variable(\"row_str\")\nassert var.find_comp_iters()[0].is_equivalent(\"row\"), \"You should iterate over row\"\nassert isinstance(var.tree.value, ast.ListComp), \"It's not a list comprehension\"\n`)) })"
        },
        {
          "text": "The list comprehension assigned to the `row_str` variable should use `i` as iteration variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_bodies()[0].find_variable(\"row_str\").find_comp_targets()[0].is_equivalent(\"i\")`)) })"
        },
        {
          "text": "The list comprehension assigned to the `row_str` variable should call `str()` on each item `i` in `row`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_bodies()[0].find_variable(\"row_str\").find_comp_expr().is_equivalent(\"str(i)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660ac35d55a15d81afdedd76.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660ac44c7eec868220318297",
      "title": "Step 74",
      "challengeType": 20,
      "dashedName": "step-74",
      "description": "Modify the `row_str` comprehension to give a string only when the item is not zero, and an asterisk character otherwise.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def __str__(self):\n        board_str = ''\n        for row in self.board:\n            row_str = [str(i) for i in row]\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The list comprehension assigned to the `row_str` variable should call `str()` on each item `i` in `row` if `i` is truthy, and it should evaluate to `'*'` otherwise.",
          "testCode": "({ test: () => assert(runPython(`\nexpressions = [\"str(i) if i else '*'\",\"'*' if i == 0 else str(i)\",\"str(i) if i != 0 else '*'\"]\nnode =_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_bodies()[0].find_variable(\"row_str\").find_comp_expr()\nany(node.is_equivalent(expr) for expr in expressions)`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660ac44c7eec868220318297.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660ac4f4f784b9829e89632a",
      "title": "Step 75",
      "challengeType": 20,
      "dashedName": "step-75",
      "description": "Next, join the items in `row_str` with a space and add the result to the current value of `board_str`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def __str__(self):\n        board_str = ''\n        for row in self.board:\n            row_str = [str(i) if i else '*' for i in row]\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use `.join()` to join the items in `row_str` with a space and add the result to the current value of `board_str`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_bodies()[0].find_aug_variable(\"board_str\").is_equivalent(\"board_str += ' '.join(row_str)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660ac4f4f784b9829e89632a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660ac56326c2eb831583c0de",
      "title": "Step 76",
      "challengeType": 20,
      "dashedName": "step-76",
      "description": "Add a new line character to the current value of `board_str`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def __str__(self):\n        board_str = ''\n        for row in self.board:\n            row_str = [str(i) if i else '*' for i in row]\n            board_str += ' '.join(row_str)\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a `'\\n'` character to the current value of `board_str`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").find_for_loops()[0].find_bodies()[0].has_stmt(\"board_str += '\\\\\\\\n'\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660ac56326c2eb831583c0de.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660ac59d7ea60083900b83df",
      "title": "Step 77",
      "challengeType": 20,
      "dashedName": "step-77",
      "description": "Finally, return `board_str` after the `for` loop.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n--fcc-editable-region--\n    def __str__(self):\n        board_str = ''\n        for row in self.board:\n            row_str = [str(i) if i else '*' for i in row]\n            board_str += ' '.join(row_str)\n            board_str += '\\n'\n--fcc-editable-region--\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `board_str` after the `for` loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Board\").find_function(\"__str__\").has_return(\"board_str\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660ac59d7ea60083900b83df.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "660ac60e22aa218400acb4b6",
      "title": "Step 78",
      "challengeType": 20,
      "dashedName": "step-78",
      "description": "And now call the `solve_sudoku` method passing `puzzle` as the argument. You should see the partially empty puzzle to solve, and the solved puzzle as the output.\n\nWith this, you completed the sudoku solver project!",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def __str__(self):\n        board_str = ''\n        for row in self.board:\n            row_str = [str(i) if i else '*' for i in row]\n            board_str += ' '.join(row_str)\n            board_str += '\\n'\n        return board_str\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "class Board:\n    def __init__(self, board):\n        self.board = board\n\n    def __str__(self):\n        board_str = ''\n        for row in self.board:\n            row_str = [str(i) if i else '*' for i in row]\n            board_str += ' '.join(row_str)\n            board_str += '\\n'\n        return board_str\n\n    def find_empty_cell(self):\n        for row, contents in enumerate(self.board):\n            try:\n                col = contents.index(0)\n                return row, col\n            except ValueError:\n                pass\n        return None\n\n    def valid_in_row(self, row, num):\n        return num not in self.board[row]\n\n    def valid_in_col(self, col, num):\n        return all(self.board[row][col] != num for row in range(9))\n\n    def valid_in_square(self, row, col, num):\n        row_start = (row // 3) * 3\n        col_start = (col // 3) * 3\n        for row_no in range(row_start, row_start + 3):\n            for col_no in range(col_start, col_start + 3):\n                if self.board[row_no][col_no] == num:\n                    return False\n        return True\n\n    def is_valid(self, empty, num):\n        row, col = empty\n        valid_in_row = self.valid_in_row(row, num)\n        valid_in_col = self.valid_in_col(col, num)\n        valid_in_square = self.valid_in_square(row, col, num)\n        return all([valid_in_row, valid_in_col, valid_in_square])\n\n    def solver(self):\n        if (next_empty := self.find_empty_cell()) is None:\n            return True\n        for guess in range(1, 10):\n            if self.is_valid(next_empty, guess):\n                row, col = next_empty\n                self.board[row][col] = guess\n                if self.solver():\n                    return True\n                self.board[row][col] = 0\n        return False\n\ndef solve_sudoku(board):\n    gameboard = Board(board)\n    print(f'Puzzle to solve:\\n{gameboard}')\n    if gameboard.solver():\n        print(f'Solved puzzle:\\n{gameboard}')\n    else:\n        print('The provided puzzle is unsolvable.')\n    return gameboard\n\npuzzle = [\n  [0, 0, 2, 0, 0, 8, 0, 0, 0],\n  [0, 0, 0, 0, 0, 3, 7, 6, 2],\n  [4, 3, 0, 0, 0, 0, 8, 0, 0],\n  [0, 5, 0, 0, 3, 0, 0, 9, 0],\n  [0, 4, 0, 0, 0, 0, 0, 2, 6],\n  [0, 0, 0, 4, 6, 7, 0, 0, 0],\n  [0, 8, 6, 7, 0, 4, 0, 0, 0],\n  [0, 0, 0, 5, 1, 9, 0, 0, 8],\n  [1, 7, 0, 0, 0, 6, 0, 0, 5]\n]\n\nsolve_sudoku(puzzle)"
        }
      ],
      "tests": [
        {
          "text": "You should call `solve_sudoku()` and pass it `puzzle` as the argument.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"solve_sudoku(puzzle)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-classes-and-objects-by-building-a-sudoku-solver\\660ac60e22aa218400acb4b6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-classes-and-objects-by-building-a-sudoku-solver",
        "name": "Learn Classes And Objects By Building A Sudoku Solver"
      }
    },
    {
      "id": "655cd899f8de09431eabb40c",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "In this project, you'll learn data structures by building the merge sort algorithm. \n\nThis is a sorting algorithm that uses the divide-and-conquer principle to sort collections of data. That is, it 'divides' a collection into smaller sub-parts, and 'conquers' the sub-parts by sorting them independently, then merges the sorted sub-parts.\n\nCreate a function called `merge_sort`. This function will handle the task of sorting a list of numbers. \n\nUse the `pass` keyword in the function body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a function named `merge_sort`. Don't forget use the `pass` keyword in the function body.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    inspect.isfunction(merge_sort)\n`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\655cd899f8de09431eabb40c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6564a9fe51964c229d5b7f4c",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "You'll need a parameter that denotes the data collection to be sorted. Create a parameter called `array` in the `merge_sort` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort():\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `merge_sort` function should take a single parameter: `array`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    str(inspect.signature(merge_sort)) == '(array)'    \n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6564a9fe51964c229d5b7f4c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6564aee9c077774ea49c3faf",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "The merge sort algorithm mainly performs three actions:\n\n- Divide an unsorted sequence of items into sub-parts\n- Sort the items in the sub-parts\n- Merge the sorted sub-parts\n\nThe above happens recursively until the sub-parts are merged into the complete sorted sequence. Let's start by dividing the sequence.\n\nFirst, replace the `pass` keyword with a variable `middle_point`. Use the integer division operator (`//`) to divide the length of the `array` list by 2 and assign the result to your new `middle_point` variable. Remember to indent your code.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort(array):\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `pass` in the body of the function.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.notMatch(function_body, /^\\s{4}pass/m);\n  }\n})\n```\n\nYou should declare a `middle_point` variable and assign `len(array) // 2` to it.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /^\\s{4}middle_point\\s*=\\s*len\\(\\s*array\\s*\\)\\s*\\/\\/\\s*2/m);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6564aee9c077774ea49c3faf.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "656627b47bd2d2a4afbc945d",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "In the previous step, you got the mid point. You can use it to divide `array` into two and assign each part to new variables. \n\nUse the slice syntax to extract the left half of `array` and assign it to a variable named `left_part`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort(array):\n    middle_point = len(array) // 2\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable named `left_part` in your `merge_sort` function.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /left_part\\s*(?!=)/m);\n  }\n})\n```\n\nYou should assign `array[:middle_point]` to the `left_part` variable.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /left_part\\s*=\\s*array\\s*\\[\\s*:\\s*middle_point\\s*\\]/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\656627b47bd2d2a4afbc945d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "656639771fed09b5c0e8fe71",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "Now that you've divided the `array` list into two separate lists, you'll keep dividing each list until every element stands alone in its own list. A list with a single number is always sorted.\n\nTo do that, recursively call `merge_sort` inside your function. Do not pass in any argument for now.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n--fcc-editable-region--\n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `merge_sort` at the bottom of your function body.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /merge_sort\\s*\\(\\s*\\)/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\656639771fed09b5c0e8fe71.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "656680b0fc79f2c38a34d90e",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "Now it's time to sort and merge the lists (`left_part` and `right_part`) into the original `array`. \n\nYou can do this by comparing elements on both lists, and merging the smaller element to the main list. You are going to do this comparison for all the indexes in `left_part` and `right_part`.\n\nCreate three variables: `left_array_index`, `right_array_index`, and `sorted_index` and set their values to `0`. These variables will help you keep track of each index during the sorting process.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable named `left_array_index` inside your `merge_sort` function\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /left_array_index/);\n  }\n})\n```\n\nThe value of `left_array_index` should be 0\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /left_array_index\\s*=\\s*0/);\n  }\n})\n```\n\nYou should have a variable named `right_array_index` inside your `merge_sort` function\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /right_array_index/);\n  }\n})\n```\n\nThe value of `right_array_index` should be 0\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /right_array_index\\s*=\\s*0/);\n  }\n})\n\n```\n\nYou should have a variable named `sorted_index` inside your `merge_sort` function\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /sorted_index/);\n  }\n})\n```\n\nThe value of `sorted_index` should be 0\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /sorted_index\\s*=\\s*0/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\656680b0fc79f2c38a34d90e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "656702f8b4cbd8cbf0a433c6",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "Inside your function, create a `while` loop that compares an element in `left_part` to an element in `right_part`, and merges the smaller element to the main `array` list. \n\nCreate two conditions for the loop: one that checks whether the `left_array_index` is less than the length of `left_part` and another condition that checks whether `right_array_index` is less than the length of `right_part`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `while` loop should have these conditions: `left_array_index < len(left_part) and right_array_index < len(right_part)`. Don't forget to use the `pass` keyword in the body of the loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\)\\s+and\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):/);\n  }\n})\n```\n\nUse the `pass` keyword in the body of the loop\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\)\\s+and\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):\\s*pass/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\656702f8b4cbd8cbf0a433c6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "656706afd65547d22bee0b68",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "Within the `while` loop, replace `pass` with an `if` statement that checks if the index of `left_part` is less than the index of `right_part`.\n\nUse the `pass` keyword in the body of the `if` statement.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n--fcc-editable-region--\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` keyword with an `if` statement with this condition: `left_part[left_array_index] < right_part[right_array_index]`. Add the `pass` keyword to the body of the `if` statement.",
          "testCode": "({\n test: () => assert(runPython(`\n  _Node(_code).find_function(\"merge_sort\").find_whiles()[0].find_body().is_equivalent(\"if left_part[left_array_index] < right_part[right_array_index]:\\\\n  pass\")`))\n })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\656706afd65547d22bee0b68.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "656707e11e671ed54c96f7ec",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "When the `if` condition evaluates to `True`, it means that the element in the `left_part` list is smaller than the element it is being compared to in the `right_part` list.\n\nIn that case, you can assign the `left_part` index to the sorted array. \n\nInside the `if` block, remove `pass` and assign `left_part[left_array_index]` to `array[sorted_index]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n--fcc-editable-region--\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with `array[sorted_index] = left_part[left_array_index]` in the body of the `if` statement.",
          "testCode": "({\n  test: () => assert(runPython(`\n  _Node(_code).find_function(\"merge_sort\").find_whiles()[0].find_ifs()[0].find_body().is_equivalent(\"array[sorted_index] = left_part[left_array_index]\")`))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\656707e11e671ed54c96f7ec.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "656709e50ed928da35260276",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "In a previous step, you assigned the element in the `left_part` to the `array` list because it was smaller. But this will not always be the case. In some comparison cases, the element on the right could be smaller. \n\nCreate an `else` clause to execute when the `left_part` index is not less than the `right_part` index.\n\nInside the `else` block, assign `right_part[right_array_index]` to `array[sorted_index]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n--fcc-editable-region--\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `array[sorted_index] = right_part[right_array_index]` in the body of your `else` clause.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /else:\\s*[^}]*array\\s*\\[\\s*sorted_index\\s*\\]\\s*=\\s*right_part\\s*\\[\\s*right_array_index\\s*\\]/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\656709e50ed928da35260276.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "65670d1ef177e7e2b76d9528",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "The `if` and `else` statements you created in the previous steps will assign elements to the sorted array. \n\nEach element assigned to the sorted array takes up an index in the list. So you have to move to the next index without an element.\n\nBelow the `if`/`else` block, but still within the `while` loop increment `sorted_index` by 1. This should not be in the body of the `if` or `else` statement",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n--fcc-editable-region--\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should increment the current value of `sorted_index` by 1.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /^\\s{8}sorted_index\\s*(\\+=\\s*1|=\\s*sorted_index\\s*\\+\\s*1)/m);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\65670d1ef177e7e2b76d9528.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "656710d1e0ec62253426db24",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "The `while` loop you created compares one element from `left_part` with another in `right_part`, then adds the smaller element to the main `array` list.\n\nIt will continue this operation until there are no elements left to be compared. But `left_part` may still have elements left while `right_part` has none, and vice versa.\n\nCreate another `while` loop to copy the remaining elements in `left_part` into the `array` list. Use `left_array_index < len(left_part)` for the `while` condition.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `while` loop should have this condition: `left_array_index < len(left_part)`. Don't forget to use the `pass` keyword in the body of the loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /^\\s{4}while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\):/m);\n  }\n})\n```\n\nYou should have the `pass` keyword in the body of your `while` loop\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\):[^}]*\\bpass\\b/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\656710d1e0ec62253426db24.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569b0a63423f65dd30888df",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "Remove the `pass` keyword. For the `while` loop's code block, assign `left_part[left_array_index]` to `array[sorted_index]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n        \n--fcc-editable-region--\n    while left_array_index < len(left_part):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `array[sorted_index] = left_part[left_array_index]` in the body of the loop. Don't forget to remove the `pass` keyword in the body of the loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\):[^}]*\\barray\\s*\\[\\s*sorted_index\\s*\\]\\s*=\\s*left_part\\s*\\[\\s*left_array_index\\s*\\]/);\n  }\n})\n```\n\nYou should not have `pass` in the `while` loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\):(?:(?!\\bpass\\b)[^}])*\\barray\\s*\\[\\s*sorted_index\\s*\\]\\s*=\\s*left_part\\s*\\[\\s*left_array_index\\s*\\]/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569b0a63423f65dd30888df.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569b19d31a09b65b4bc390a",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "Still within the `while` loop, increment the value of `left_array_index` by 1.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n        \n--fcc-editable-region--\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `+=` operator to increment the current value of `left_array_index` by one within the `while` loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\):[^}]*\\bleft_array_index\\s*\\+=\\s*1\\b/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569b19d31a09b65b4bc390a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569b20f829b7e69d43c232a",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "The last thing to do for the `while` loop is to move to the next index in the sorted array.\n\nUsing the augmented assignment addition operator, add `1` to the value of `sorted_index`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n        \n--fcc-editable-region--\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `+=` operator to increment the current value of `sorted_index` by one within the `while` loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\):[^}]*\\bsorted_index\\s*\\+=\\s*1\\b/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569b20f829b7e69d43c232a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569b4e0bd29d17d4b53b16c",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "Now, you are going to replicate the same `while` loop logic for `right_part`.\n\nCreate a `while` loop that runs when `right_array_index` is less than `len(right_part)`, and use the `pass` keyword in the body of the loop.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `while` loop should have this condition: `right_array_index < len(right_part)`. Don't forget to use the `pass` keyword in the body of the loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /^\\s{4}while\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):/m);\n  }\n})\n```\n\nYou should have the `pass` keyword in the body of your `while` loop\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):[^}]*\\bpass\\b/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569b4e0bd29d17d4b53b16c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569b5c820a6a1859786e774",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "Within the `while` loop, assign `right_part[right_array_index]` to `array[sorted_index]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n--fcc-editable-region--\n    while right_array_index < len(right_part):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `array[sorted_index] = right_part[right_array_index]` in the body of the loop. Don't forget to remove the `pass` keyword in the body of the loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):[^}]*\\barray\\s*\\[\\s*sorted_index\\s*\\]\\s*=\\s*right_part\\s*\\[\\s*right_array_index\\s*\\]/);\n  }\n})\n```\n\nThere should be no `pass` keyword in the `while` loop\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):(?:(?!\\bpass\\b)[^}])*\\barray\\s*\\[\\s*sorted_index\\s*\\]\\s*=\\s*right_part\\s*\\[\\s*right_array_index\\s*\\]/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569b5c820a6a1859786e774.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569b68fac723e8c20223ed3",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "Now, use the `+=` operator to increment `right_array_index` by `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n--fcc-editable-region--\n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `right_array_index += 1` within the `while` loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):[^}]*\\bright_array_index\\s*\\+=\\s*1\\b/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569b68fac723e8c20223ed3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569b6be44940a8e2a469c31",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "For the last step in the `while` loop, increment `sorted_index` by `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n--fcc-editable-region--\n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `+=` operator to increment the current value of `sorted_index` by one within the `while` loop.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /while\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):[^}]*\\bsorted_index\\s*\\+=\\s*1\\b/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569b6be44940a8e2a469c31.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569b743630ee592a65a7e2f",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "Before testing the `merge_sort()` function, you need to create a base case that stops the function execution when the length of `array` is less than or equal to `1`.\n\nThis base case will stop the recursion call. Without it, the merge sort operation would continue to run even when the list has been sorted or has no element in it.\n\nRight after the function declaration, create an `if` statement with this condition: `len(array) <= 1`. Use the `pass` keyword in the function's body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort(array):\n\n--fcc-editable-region--\n   \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n   \n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement to check if `len(array) <= 1`. Don't forget to use the `pass` keyword in the body of the `if` statement.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_function(\"merge_sort\").find_ifs()[0].find_conditions()[0].is_equivalent(\"len(array) <= 1\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569b743630ee592a65a7e2f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569bca4dd9feab7b295a5e1",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "Replace the `pass` keyword within the `if` statement with a `return` statement. This will stop the execution of the `merge_sort` function when the given condition is true.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort(array):\n    if len(array) <= 1:\n        pass\n--fcc-editable-region--\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with a `return` statement in the body of the `if` statement.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /if\\s+len\\(\\s*array\\s*\\)\\s*<=\\s*1:\\s*return/);\n  }\n})\n```\n\nThere should be no `pass` keyword in the body of the `if` statement\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /if\\s+len\\(\\s*array\\s*\\)\\s*<=\\s*1:\\s*(?!.*\\bpass\\b).*return/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569bca4dd9feab7b295a5e1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569beee367427c90c74899e",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "It's time to test the `merge_sort` function!\n\nReplace `pass` with a list called `numbers`, and assign this list to it: `[4, 10, 6, 14, 2, 1, 8, 5]`",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    if len(array) <= 1:\n        return\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1\n\n--fcc-editable-region--\nif __name__ == '__main__':\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with a `numbers` list with these values: `[4, 10, 6, 14, 2, 1, 8, 5]`",
          "testCode": "({ test: () =>  assert.equal(__userGlobals.get(\"numbers\"), \"[4, 10, 6, 14, 2, 1, 8, 5]\") })"
        },
        {
          "text": "You should not have the `pass` keyword in the body of your `if` statement",
          "testCode": "({ test: () =>  assert(runPython(`\n    _Node(_code).find_ifs()[0].find_body().is_equivalent(\"numbers = [4, 10, 6, 14, 2, 1, 8, 5]\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569beee367427c90c74899e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569c05b9166f9d5bb36c09e",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "Use the `print()` function to print the string `'Unsorted array:'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    if len(array) <= 1:\n        return\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1\n\n--fcc-editable-region--\nif __name__ == '__main__':\n    numbers = [4, 10, 6, 14, 2, 1, 8, 5]\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print('Unsorted array:')`",
          "testCode": "({ test: () => assert.match(code, /^\\s{4}print\\s*\\(\\s*('|\")Unsorted array:\\1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569c05b9166f9d5bb36c09e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569c166d708dcdf7c8fd34c",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "Call the `print()` function again to print the `numbers` list. This will print the unsorted list in the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    if len(array) <= 1:\n        return\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1\n\n--fcc-editable-region--\nif __name__ == '__main__':\n    numbers = [4, 10, 6, 14, 2, 1, 8, 5]\n    print('Unsorted array:')\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print(numbers)` in your code.",
          "testCode": "assert.match(code, /^\\s{4}print\\s*\\(\\s*numbers\\s*\\)/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569c166d708dcdf7c8fd34c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569c1aeecaf95e25a3e2573",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "After your `print()` calls, call the `merge_sort` function and pass in the `numbers` list as an argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    if len(array) <= 1:\n        return\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1\n\n\n--fcc-editable-region--\nif __name__ == '__main__':\n    numbers = [4, 10, 6, 14, 2, 1, 8, 5]\n    print('Unsorted array: ')\n    print(numbers)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `merge_sort` function passing `numbers` as the argument.",
          "testCode": "({ test: () => assert.match(code, /merge_sort\\s*\\(\\s*numbers\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569c1aeecaf95e25a3e2573.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6569c2cbf6c993ea8cd85682",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "At this point, the `numbers` list has been sorted. Call the `print` function to print string `'Sorted array: '` and the sorted list.\n\nTo do that, concatenate `'Sorted array: '` and `str(numbers)` in the `print()` call.\n\nWith that, the merge sort algorithm is complete.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    if len(array) <= 1:\n        return\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n    \n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1\n\n\n--fcc-editable-region--\nif __name__ == '__main__':\n    numbers = [4, 10, 6, 14, 2, 1, 8, 5]\n    print('Unsorted array: ')\n    print(numbers)\n    merge_sort(numbers)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    if len(array) <= 1:\n        return\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n\n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1\n\n\nif __name__ == '__main__':\n    numbers = [4, 10, 6, 14, 2, 1, 8, 5]\n    print('Unsorted array: ')\n    print(numbers)\n    merge_sort(numbers)\n    print('Sorted array: ' + str(numbers))"
        }
      ],
      "tests": [
        {
          "text": "You should have `print('Sorted array: ' + str(numbers))` in your code. Remember to add the space after the colon.",
          "testCode": "({ test: () => assert.match(code, /^\\s{4}print\\s*\\(\\s*(\"|')Sorted array: \\1\\s*\\+\\s*str\\s*\\(\\s*numbers\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6569c2cbf6c993ea8cd85682.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6577254891048c8f2c19e961",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "Call the `merge_sort()` function again. Do not pass in any argument for now.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort(array):\n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n    \n    merge_sort(left_part)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `merge_sort()` again after the previous function call.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /merge_sort\\s*\\(\\s*\\)/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6577254891048c8f2c19e961.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "65772ef923f922cd720e5008",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Pass `left_part` as the argument to the `merge_sort()` call you added in the last step.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n    \n    merge_sort()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `left_part` as the argument to your `merge_sort()` call.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /merge_sort\\s*\\(\\s*left_part\\s*\\)/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\65772ef923f922cd720e5008.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6577320da0d4c2e594d418e2",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "Pass `right_part` as the argument to the `merge_sort()` call you added in the last step.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `right_part` as the argument to your last `merge_sort()` call.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /merge_sort\\s*\\(\\s*right_part\\s*\\)/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6577320da0d4c2e594d418e2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "6577562501feabdf0984a184",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "After assigning the `left_part` index to the sorted array, increment `left_array_index` by `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n--fcc-editable-region--\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add `1` to the current value of `left_array_index`.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nconst allowedMatches = [\n      /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\)\\s+and\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):\\s*[^}]*if\\s+left_part\\s*\\[\\s*left_array_index\\s*\\]\\s*<\\s*right_part\\s*\\[\\s*right_array_index\\s*\\]\\s*:\\s*[^}]*left_array_index\\s*\\+=\\s*1\\s*(?!.*\\bpass\\b)/,\n      /while\\s+left_array_index\\s*<\\s*len\\(\\s*left_part\\s*\\)\\s+and\\s+right_array_index\\s*<\\s*len\\(\\s*right_part\\s*\\):\\s*[^}]*if\\s+left_part\\s*\\[\\s*left_array_index\\s*\\]\\s*<\\s*right_part\\s*\\[\\s*right_array_index\\s*\\]\\s*:\\s*[^}]*left_array_index\\s*=\\s*left_array_index\\s*\\+\\s*1\\s*(?!.*\\bpass\\b)/\n    ]\n\nconst anyMatch = allowedMatches.some((match) => match.test(function_body));\n    assert.isTrue(anyMatch);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\6577562501feabdf0984a184.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "657823a9f4f372518614c8b7",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "Still within the `else` block, increment `right_array_index` by `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        \n--fcc-editable-region--\n        else:\n            array[sorted_index] = right_part[right_array_index]\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add `1` to the current value of `right_array_index`.\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nconst allowedMatches = [\n      /else:\\s*[^}]*right_array_index\\s*\\+=\\s*1/,\n      /else:\\s*[^}]*right_array_index\\s*=\\s*right_array_index\\s*\\+\\s*1/\n    ]\n\nconst anyMatch = allowedMatches.some((match) => match.test(function_body))\n    assert.isTrue(anyMatch);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\657823a9f4f372518614c8b7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "657f3a661730891aa64f3568",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Use the slice syntax to extract the right half of `array` and assign it to a variable named `right_part`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef merge_sort(array):\n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable named `right_part`\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /right_part\\s*(?!=)/m);\n  }\n})\n```\n\nYou should assign `array[middle_point:]` to the `right_part` variable\n\n```js\n({\n  test: () => {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const merge_sort = __helpers.python.getDef(\"\\n\" + transformedCode, \"merge_sort\");\n    const { function_body } = merge_sort;\n\nassert.match(function_body, /right_part\\s*=\\s*array\\s*\\[\\s*middle_point\\s*:\\s*\\]/);\n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\657f3a661730891aa64f3568.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "657f59751d5a5c9b069ae0f3",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "You can use the `__name__` variable to determine if a Python script is being run as the main program or if it is being imported as a module (code written in another Python file).\n\nIf the value of `__name__` is set to `'__main__'`, it implies that the current script is the main program, and not a module.\n\nIn this project, you'll use the current script as the main program.\n\nCreate an `if` statement that checks whether the value of `__name__` is `'__main__'`.\n\nUse the `pass` keyword in the body of the `if` statement.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def merge_sort(array):\n    if len(array) <= 1:\n        return\n   \n    middle_point = len(array) // 2\n    left_part = array[:middle_point]\n    right_part = array[middle_point:]\n\n    merge_sort(left_part)\n    merge_sort(right_part)\n\n    left_array_index = 0\n    right_array_index = 0\n    sorted_index = 0\n\n    while left_array_index < len(left_part) and right_array_index < len(right_part):\n        if left_part[left_array_index] < right_part[right_array_index]:\n            array[sorted_index] = left_part[left_array_index]\n            left_array_index += 1\n        else:\n            array[sorted_index] = right_part[right_array_index]\n            right_array_index += 1\n        sorted_index += 1\n\n    while left_array_index < len(left_part):\n        array[sorted_index] = left_part[left_array_index]\n        left_array_index += 1\n        sorted_index += 1\n   \n    while right_array_index < len(right_part):\n        array[sorted_index] = right_part[right_array_index]\n        right_array_index += 1\n        sorted_index += 1\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `if` statement should check if `__name__` has a value of `'__main__'`",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_ifs()[0].find_conditions()[0].is_equivalent(\"__name__ == '__main__'\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-data-structures-by-building-the-merge-sort-algorithm\\657f59751d5a5c9b069ae0f3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-data-structures-by-building-the-merge-sort-algorithm",
        "name": "Learn Data Structures By Building The Merge Sort Algorithm"
      }
    },
    {
      "id": "65f569725359e10d345bc52a",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "You are going to build a program that calculates and draws the trajectory of a projectile given the angle, speed and height of the throw.\n\nStart by importing `math`, you will use it a lot in this project as it has useful methods like `math.radians`, `math.cos`, `math.sin` and others.\n\nAlso create these variables to have the value of the gravitational acceleration and some special symbols that will be useful later (use copy and paste for these).\n\n```py\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Use `import math` to import the `math` module.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).has_import('import math')`))})"
        },
        {
          "text": "You should have a `GRAVITATIONAL_ACCELERATION` variable with value of `9.81`.",
          "testCode": "({test: () => runPython(`\nassert _Node(_code).has_variable(\"GRAVITATIONAL_ACCELERATION\"), \"missing variable\"\nassert _Node(_code).find_variable(\"GRAVITATIONAL_ACCELERATION\").is_equivalent('GRAVITATIONAL_ACCELERATION = 9.81'), \"variable has wrong value\"\n`)})"
        },
        {
          "text": "You should have a `PROJECTILE` variable with value of `\"∙\"`.",
          "testCode": "({test: () => runPython(`\nassert _Node(_code).has_variable(\"PROJECTILE\"), \"missing variable\"\nassert _Node(_code).find_variable(\"PROJECTILE\").is_equivalent('PROJECTILE = \"∙\"'), \"variable has wrong value\"\n`)})"
        },
        {
          "text": "You should have a `x_axis_tick` variable with value of `\"T\"`.",
          "testCode": "({test: () => runPython(`\nassert _Node(_code).has_variable(\"x_axis_tick\"), \"missing variable\"\nassert _Node(_code).find_variable(\"x_axis_tick\").is_equivalent('x_axis_tick = \"T\"'), \"variable has wrong value\"\n`)})"
        },
        {
          "text": "You should have a `y_axis_tick` variable with value of `\"⊣\"`.",
          "testCode": "({test: () => runPython(`\nassert _Node(_code).has_variable(\"y_axis_tick\"), \"missing variable\"\nassert _Node(_code).find_variable(\"y_axis_tick\").is_equivalent('y_axis_tick = \"⊣\"'), \"variable has wrong value\"\n`)})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\65f569725359e10d345bc52a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "65fd4b3bedee044b4b957d33",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "Create a `Projectile` class with an `__init__` method that initializes the class using three arguments: the starting speed, the starting height, and the starting angle of the throw of the projectile, in this order. \n\nInside the `__init__` method, assign these arguments to three private attributes: `__speed`, `__height`, and `__angle`. The angle provided will be in degrees; however, it should be stored internally in radians. To achieve this, use the `math.radians()` function to convert the angle from degrees to radians when assigning it to `__angle`. \n\nThe use of two underscores before an attribute name triggers name mangling in Python. This means the attributes are not directly accessible from outside the class using their given names, and must be accessed with the mangled names like `ball._Projectile__height` if needed externally, indicating these are intended for internal use only.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use `class Projectile:` to create the class.\n\n```js\n({test: () => assert(runPython(`_Node(_code).has_class(\"Projectile\")`))})\n\n```\n\nYou should have an `__init__` method inside the `Projectile` class.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_body().has_function(\"__init__\")`))})"
        },
        {
          "text": "A new `Projectile` class instance should have the values of the three attributes properly initialized.\n\n```js\n({test: () => assert(runPython(`\nimport math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\np = Projectile(20, 21, 22)\np._Projectile__height == 21 and p._Projectile__speed == 20 and p._Projectile__angle == math.radians(22)\n`))})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\65fd4b3bedee044b4b957d33.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "65fd4bd84561a14d3e720061",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "The class variable `__slots__` has a special usage in Python classes. Declaring `__slots__` and assigning it a sequence of strings restricts the creation of attributes to those included in that sequence. Also, it prevents the creation of the `__dict__` special attribute and it allows for more efficient attribute access.\n\nYou should use the `__slots__` variable inside the class to define which attributes the class has: assign to `__slots__` a tuple containing 3 strings, each equal to one of the attribute names defined in the `__init__`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\n--fcc-editable-region--\nclass Projectile:\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign to `__slots__` a tuple that contains `'__height'`, `'__speed'`, and `'__angle'`.\n\n```js\n({test: () => assert(runPython(`\nfrom itertools import permutations\nslots = _Node(_code).find_class(\"Projectile\").find_body().find_variable(\"__slots__\")\nperms = permutations((\"__height\", \"__speed\", \"__angle\"))\nany(slots.is_equivalent(f'__slots__ = {perm}') for perm in perms)\n`))})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\65fd4bd84561a14d3e720061.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "660400f02cf3a76795b82d4e",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "The first thing to set up is a method that calculates the displacement of the projectile, which is the horizontal space traveled from the throw to when the projectile touches the ground.\n\nCreate a method `__calculate_displacement`, which has only `self` as a parameter, and return the displacement of the projectile.\n\nUse the following formula to compute the projectile displacement:\n\\\\[ d = \\frac{v \\cdot \\cos\\theta \\cdot \\left(v\\cdot\\sin\\theta + \\sqrt{v^2 \\cdot \\sin^2\\theta + 2 \\cdot g \\cdot h}\\right)}{g} \\\\]\n\nIn which $d$ is the displacement, $v$ is the starting speed, $\\theta$ is the angle and $h$ is the starting height of the projectile.\nFor $g$ you can use the `GRAVITATIONAL_ACCELERATION` variable.\n\nYou should use the methods `math.cos()` and `math.sin()` for the trigonometric functions and `math.sqrt()` to calculate the square root. Also you should know that $x^y$ is written as `x ** y` in python. Also $\\sin^2\\theta$ means that the value resulting from the sine is then squared.\n\nRemember that with name mangling you need to call the method as `_Projectile__calculate_displacement` if you want to test, or use it from outside of the class:\n\n```py\nball = Projectile(10, 3, 45)\ndisplacement_of_ball = ball._Projectile__calculate_displacement() # 12.6173996009878\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n--fcc-editable-region--\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a method called `__calculate_displacement` with `def __calculate_displacement(self):`.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").has_function(\"__calculate_displacement\")`))})"
        },
        {
          "text": "The `__calculate_displacement` method should have only the `self` argument.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).find_class(\"Projectile\").find_function(\"__calculate_displacement\").has_args('self')`))})"
        },
        {
          "text": "The `__calculate_displacement` method should return the correct value.",
          "testCode": "({test: () => assert(runPython(`\np = Projectile(20, 21, 22)\ndisp = p._Projectile__calculate_displacement()\nround(disp, 2) == 55.06 and round(disp, 2) != disp\n`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\660400f02cf3a76795b82d4e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "660fcf3e1b9bb056b2edb567",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "At this point you are ready to create the string representation.\nStart by creating an instance of the `Projectile` class. Below the class definition, create a `ball` variable and assign it a call to `Projectile` using `10, 3, 45` as arguments.\n\nDefine a `__str__` method within the class, to give your instance a proper string representation, and make it return a string with the following format:\n\n```py\n\nProjectile details:\nspeed: 10 m/s\nheight: 3 m\nangle: 45°\ndisplacement: 12.6 m\n\n```\n\nIt should start and end with a new line character, the angle has to be written as an integer in degrees and the displacement should be printed with one decimal digit.\n\nYou will find useful `math.degrees` to convert the angle from radians to degrees.\n\nWhen you are ready you can `print(ball)` to test your function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `ball` variable.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).has_variable('ball')`))})"
        },
        {
          "text": "The `ball` variable should have a value of `Projectile(10, 3, 45)`.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).find_variable('ball').is_equivalent('ball = Projectile(10, 3, 45)')`))})"
        },
        {
          "text": "The string representation for `Projectile(45, 45, 45)` should be correct.",
          "testCode": "({test: () => assert(runPython(\n`\nball = Projectile(45, 45, 45)\nstr(ball) == \"\"\"\nProjectile details:\nspeed: 45 m/s\nheight: 45 m\nangle: 45°\ndisplacement: 244.4 m\n\"\"\"`\n))})"
        },
        {
          "text": "The string representation should also be correct for other instances.",
          "testCode": "({test: () => assert(runPython(`p = Projectile(10, 10, 10)\nstr(\n    p\n) == \"\"\"\nProjectile details:\nspeed: 10 m/s\nheight: 10 m\nangle: 10°\ndisplacement: 15.9 m\n\"\"\"`))})"
        },
        {
          "text": "You should have a `print(ball)` call.",
          "testCode": "({\n    test: () => runPython(`\n    calls = _Node(_code).find_calls('print')\n    assert any(c.is_equivalent('print(ball)') for c in calls)\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\660fcf3e1b9bb056b2edb567.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "6616ec0bf9ee8548ce6b0f08",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "Now it's time to work on calculating the coordinates of the trajectory! Create a method of the `Projectile` class named `__calculate_y_coordinate`, it should have, other than `self`, an `x` parameter.\n\n\\\\[ y = y_0 + x \\tan\\theta - \\frac{g x^2}{2 v_0^2 \\cos^2\\theta} \\\\]\n\nThe above is the formula to calculate the vertical position $y$ for any given horizontal position $x$, having the starting angle $\\theta$, speed $v_0$ and height $y_0$.\n\nYou will need to use `math.tan()` and `math.cos()` and remember that `x ** y` is the way to write $x^y$, and that the value of $g$ is in the variable `GRAVITATIONAL_ACCELERATION`.\n\nImplement the method so that it returns the $y$ coordinate.\n\nIf you want to test the method, from outside of class, you can call `ball._Projectile__calculate_y_coordinate()` with a number as an argument after `ball` is declared.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.__speed} m/s\nheight: {self.__height} m\nangle: {round(math.degrees(self.__angle))}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    --fcc-editable-region--\n    \n    --fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `Projectile` class should have a method named `__calculate_y_coordinate`.",
          "testCode": "({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').has_function('__calculate_y_coordinate')`))}})"
        },
        {
          "text": "The `__calculate_y_coordinate` method should have `self, x` as arguments.",
          "testCode": "({test: () => {assert(runPython(`_Node(_code).find_class('Projectile').find_function('__calculate_y_coordinate').has_args('self, x')`))}})"
        },
        {
          "text": "The method should return the correct value. For `Projectile(12, 12, 12)`, given the 4 $x$ coordinates of 0, 1, 2 and 3, the y coordinate should be approximately 12, 12.18, 12.28, 12.32.",
          "testCode": "({test: () => {\n    assert(runPython(`\n    a = Projectile(12, 12, 12)\n    all([round(a._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(0, 12.0), (1, 12.18), (2, 12.28), (3, 12.32)]])\n    `))\n}})"
        },
        {
          "text": "The method should return the correct value. For `Projectile(45, 12, 22)`, given the $x$ coordinates of 6, 9, 10 and 12 the y coordinate should be approximately 14.32, 15.41, 15.76, 16.44.",
          "testCode": "({test: () => {\n    assert(runPython(`\n    b = Projectile(45, 12, 22)\n    all([round(b._Projectile__calculate_y_coordinate(x), 2) == y for x,y in [(6, 14.32), (9, 15.41), (10, 15.76), (12, 16.44)]])\n    `))\n}})"
        },
        {
          "text": "The `__calculate_y_coordinate` method should not round the result.",
          "testCode": "({test: () => assert.isFalse(runPython(`Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5) == round(Projectile(12, 13, 14)._Projectile__calculate_y_coordinate(5), 2)`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\6616ec0bf9ee8548ce6b0f08.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "662f9f65c50bd21d05ffdee9",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Define a method named `calculate_all_coordinates`, which calculates the coordinates for all \\\\(x\\\\) values from `0` up to the displacement rounded up (not inclusive), and then returns them as a list of tuples `(x, y)`.\n\nThen, call the `calculate_all_coordinates` method on the `ball` instance and assign the output to a new variable named `coordinates`.\n\nYou can use `math.ceil()` to round up a number to the smallest integer greater than or equal to that number.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.__speed} m/s\nheight: {self.__height} m\nangle: {round(math.degrees(self.__angle))}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x**2 / (\n                2 * self.__speed**2 * math.cos(self.__angle)**2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n\n    --fcc-editable-region--\n    \n        \n        \nball = Projectile(10, 3, 45)\nprint(ball)\n   --fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `calculate_all_coordinates` method with a single argument, `self` .",
          "testCode": "({test: () => assert(runPython(`\nc = _Node(_code).find_class('Projectile')\nc.has_function('calculate_all_coordinates') and c.find_function('calculate_all_coordinates').has_args('self')\n`))})"
        },
        {
          "text": "You should call the `calculate_all_coordinates` method on `ball` and assign the result to a variable named `coordinates`.\n\n```js\n({\n    test: () => runPython(`\n        assert _Node(_code).has_variable('coordinates'), \"coordinates variable is missing\"\n\nassert _Node(_code).find_variable('coordinates').is_equivalent('coordinates = ball.calculate_all_coordinates()'), \"wrong value assigned to coordinates variable\"\n    `)\n})\n```\n\nThe `calculate_all_coordinates` method should return a list containing all the `(x, y)` coordinates.\n\n```js\n({test: () => assert(runPython(`\nimport math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\nball = Projectile(12, 13, 14)\nexpected = [(x, ball._Projectile__calculate_y_coordinate(x)) for x in range(math.ceil(ball._Projectile__calculate_displacement()))]\nactual = ball.calculate_all_coordinates()\nexpected == actual\n`))})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\662f9f65c50bd21d05ffdee9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "662fa453ec8033322b3ab2e3",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "It's time to talk about encapsulation and getters. You have written the three instance attributes to be private using a leading double underscore. Note that these attributes are called private by convention: although they can still be accessed from outside, it is agreed upon to not do that.\n\nGetters are what can be used to get the values from outside. To define a getter, you define a method that returns the value of the desired attribute and give it a `@property` decorator:\n\n```py\nclass Nest:\n    ...\n    @property\n    def number_of_eggs(self):\n        return self.__number_of_eggs\n```\n\n The decorator changes the method into a property, meaning that the method is not called like a regular method, but it's used like an attribute:\n\n```py\nn = Nest()\nprint(n.number_of_eggs)\n```\n\nIn the example above, the private attribute `__number of eggs` is accessed through the `number_of_eggs` property of `n`.\n\nCreate a getter named `speed` and make it return the value of the private attribute `__speed`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.__speed} m/s\nheight: {self.__height} m\nangle: {round(math.degrees(self.__angle))}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n--fcc-editable-region--\n    \n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `speed` method.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').has_function('speed')\n`))})"
        },
        {
          "text": "Your `speed` method should have a single parameter, `self`.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_function('speed').has_args('self')\n`))})"
        },
        {
          "text": "Your `speed` method should have a `@property` decorator.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_function('speed').has_decorators('property')\n`))})"
        },
        {
          "text": "Your `speed` method should return the value of the private attribute `__speed`.",
          "testCode": "({test: () => assert(runPython(`\na = Projectile(22, 23, 24)\na.speed == 22\n`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\662fa453ec8033322b3ab2e3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "662fc35902038376c7a00b3c",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "Once you have the getters, you can write the setters, which allow you to set the value of an attribute in an indirect manner.\nFollowing the example of the last step, a setter would be written as:\n\n```py\nclass Nest:\n    ...\n    @number_of_eggs.setter\n    def number_of_eggs(self, new_value):\n        self.__number_of_eggs = new_value\n```\n\nSame as the getter, a setter is not called like a method but used like an attribute:\n\n```py\nnest = Nest()\nnest.number_of_eggs = 12\n```\n\nThis way of writing calls the setter and set the new value.\n\nFor this step you will have to write the setters for the three private attributes. Remember that for the angle the value is received in degrees but saved internally in radians.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.__speed} m/s\nheight: {self.__height} m\nangle: {round(math.degrees(self.__angle))}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n\n        \n--fcc-editable-region--\n    \n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a new `speed` method.",
          "testCode": "({test: () => assert(runPython(`\nlen(_Node(_code).find_class('Projectile').find_functions('speed')) == 2\n`))})"
        },
        {
          "text": "Your new `speed` method should have a `@speed.setter` decorator.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_functions('speed')[1].has_decorators('speed.setter')\n`))})"
        },
        {
          "text": "Your new `speed` method should set the value of the private `__speed` property.",
          "testCode": "({test: () => assert(runPython(`\na = Projectile(22, 23, 24)\na.speed = 33\na.speed == 33\n`))})"
        },
        {
          "text": "You should define a new `height` method.",
          "testCode": "({test: () => assert(runPython(`\nlen(_Node(_code).find_class('Projectile').find_functions('height')) == 2\n`))})"
        },
        {
          "text": "Your new `height` method should have a `@height.setter` decorator.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_functions('height')[1].has_decorators('height.setter')\n`))})"
        },
        {
          "text": "Your new `height` method should set the value of the private `__height` property.",
          "testCode": "({test: () => assert(runPython(`\na = Projectile(22, 23, 24)\na.height = 44\na.height == 44\n`))})"
        },
        {
          "text": "You should define a new `angle` method.",
          "testCode": "({test: () => assert(runPython(`\nlen(_Node(_code).find_class('Projectile').find_functions('angle')) == 2\n`))})"
        },
        {
          "text": "Your new `angle` method should have a `@angle.setter` decorator.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_functions('angle')[1].has_decorators('angle.setter')\n`))})"
        },
        {
          "text": "Your `angle` method should set the value of the private `__angle` property.",
          "testCode": "({test: () => assert(runPython(`\na = Projectile(22, 23, 24)\na.angle = 12\na.angle == 12\n`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\662fc35902038376c7a00b3c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "66335223f3e2a31d62d84367",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "Going back to the projectile trajectory calculator, now you'll create a new class that accepts a list of coordinates and creates the trajectory drawing.\n\nCreate a new class `Graph`, which should be instantiated with a private attribute `__coordinates` where the list of coordinates is stored. Declare the `__slots__` class variable and define the  `__init__` and `__repr__` special methods.\n\nAlso, create a `Graph` instance passing the `coordinates` variable and assign it to a new `graph` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}({self.speed}, {self.height}, {self.angle})\"\n\n--fcc-editable-region--\n\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new `Graph` class.",
          "testCode": "({\n    test: () => assert(runPython(\n        `_Node(_code).has_class('Graph')`\n    ))\n})"
        },
        {
          "text": "You should have the `__slots__` variable inside the class.",
          "testCode": "({\n    test: () => assert(runPython(\n        `_Node(_code).find_class('Graph').has_variable('__slots__')`\n    ))\n})"
        },
        {
          "text": "The `__slots__` variable should have a value of `('__coordinates')` or `['__coordinates']`.\n\n```js\n({\n    test: () => (runPython(\n        `\n        slots = _Node(_code).find_class('Graph').find_variable('__slots__')\n\nassert any(slots.is_equivalent(str) for str in ['__slots__ = (\"__coordinates\")', '__slots__ = [\"__coordinates\"]'])`\n    ))\n})\n```\n\nYou should have an `__init__` method.",
          "testCode": "({\n    test: () => assert(runPython(\n        `_Node(_code).find_class('Graph').has_function('__init__')`\n    ))\n})"
        },
        {
          "text": "The `__init__` method should instantiate the `__coordinates` private property with the passed in value.",
          "testCode": "({\n    test: () => assert(runPython(\n        `\n        l = [(3, 4), (4, 1), (3, 9)]\n        g = Graph(l)\n        g._Graph__coordinates == l\n        `\n    ))\n})"
        },
        {
          "text": "You should have a `__repr__` method.",
          "testCode": "({\n    test: () => assert(runPython(\n        `_Node(_code).find_class('Graph').has_function('__repr__')`\n    ))\n})"
        },
        {
          "text": "The `__repr__` method should return the correct string.",
          "testCode": "({\n    test: () => assert(runPython(\n        `\n        ball = Projectile(10, 3, 45)\n        coords = ball.calculate_all_coordinates()\n        repr(Graph(coords)) == f'Graph({coords})'\n        `\n    ))\n})"
        },
        {
          "text": "You should create a `Graph` instance passing in the `coordinates` variable and assign it to `graph` variable.\n\n```js\n({\n    test: () => {\n        runPython(`\n\nassert _Node(_code).has_variable('graph'), \"variable graph is missing\"\n\nassert _Node(_code).find_variable('graph').is_equivalent('graph = Graph(coordinates)'), \"assignment to graph is wrong\"\n        `)\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\66335223f3e2a31d62d84367.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "663353465bfb14259717da93",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "Create a method `create_coordinates_table`, then at the end of the code print `graph.create_coordinates_table())`.\n\nThe method should use the `__coordinates` property and return a string containing all the coordinates, where x and y have always the same position, the values for x are always integers, and the values for y are always rounded to two decimal places:\n\n```py\n  x      y\n  0   3.00\n  1   3.90\n  2   4.61\n  3   5.12\n  4   5.43\n  5   5.55\n  6   5.47\n  7   5.19\n  8   4.72\n  9   4.05\n 10   3.19\n 11   2.13\n 12   0.87  \n```\n\nThe table should start with a newline character and end with a newline character.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n    \n    def __repr__(self):\n        return f'Graph({self.__coordinates})'\n\n--fcc-editable-region--\n    \n\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\n\ngraph = Graph(coordinates)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `create_coordinates_table()` method.",
          "testCode": "({\n    test: () => assert(runPython(\n        `_Node(_code).find_class('Graph').has_function('create_coordinates_table')`\n    ))\n})"
        },
        {
          "text": "The `create_coordiantes_table` method for `Projectile(10, 3, 45)` should return `'\\n  x      y\\n  0   3.00\\n  1   3.90\\n  2   4.61\\n  3   5.12\\n  4   5.43\\n  5   5.55\\n  6   5.47\\n  7   5.19\\n  8   4.72\\n  9   4.05\\n 10   3.19\\n 11   2.13\\n 12   0.87\\n'`.",
          "testCode": "({\n    test: () => assert(runPython(\n        `a = \"\"\"\n  x      y\n  0   3.00\n  1   3.90\n  2   4.61\n  3   5.12\n  4   5.43\n  5   5.55\n  6   5.47\n  7   5.19\n  8   4.72\n  9   4.05\n 10   3.19\n 11   2.13\n 12   0.87\n\"\"\"\nball = Projectile(10, 3, 45)\ng = Graph(ball.calculate_all_coordinates())\ng.create_coordinates_table() == a`\n    ))\n})"
        },
        {
          "text": "You should print `graph.create_coordiantes_table()`.",
          "testCode": "({\n    test: () => {\n        runPython(`\n        prints = _Node(_code).find_calls('print')\n        assert any(p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordiantes_table()) is missing\"\n        `)\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\663353465bfb14259717da93.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "6633b26c4f2d603072ef0818",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "It's good practice to give a representation to the class by using the `__repr__` special method. While the `__str__` method returns a readable string representation that's intended to be user friendly, `__repr__` is intended for programmers. Often `__repr__` provides a string that can be used to recreate the object.\n\nWrite the `__repr__` method, which will return the string needed to instantiate the object.\n\nYou can test this by calling the `repr` function and passing it an instance of the class.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n    \n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n\n--fcc-editable-region--\n    \n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `Projectile` class should have a `__repr__` method.",
          "testCode": "({\n    test: () => assert(runPython(\n        `_Node(_code).find_class('Projectile').has_function('__repr__')`\n    ))\n})"
        },
        {
          "text": "The instance `Projectile(12, 12, 12)` should have representation equal to `'Projectile(12, 12, 12)'`.",
          "testCode": "({\n    test: () => assert(runPython(\n        `repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12)' or \\\\\n        repr(Projectile(12, 12, 12)) == 'Projectile(12, 12, 12.0)'`\n    ))\n})"
        },
        {
          "text": "The instance `Projectile(21, 22, 45)` should have representation equal to `'Projectile(21, 22, 45)'`.",
          "testCode": "({\n    test: () => assert(runPython(\n        `repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45)' or \\\\\n        repr(Projectile(21, 22, 45)) == 'Projectile(21, 22, 45.0)'`\n    ))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\6633b26c4f2d603072ef0818.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "6633b4d3271d5b3aea1c1195",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "Now it's time for the graph. Create a method `create_trajectory` and replace the last `print` call at the bottom of your code with `print(graph.create_trajectory())`.\n\nAs the first step of this new method, make a local copy of the coordinates but where all the values are rounded to integers. Save this new version of the coordinates in a variable named `rounded_coords`, and return this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n--fcc-editable-region--\n    \n        \n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nprint(graph.create_coordinates_table())\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method named `create_trajectory`.",
          "testCode": "({\n    test: () => assert(runPython(\n        `_Node(_code).find_class('Graph').has_function('create_trajectory')`\n    ))\n})"
        },
        {
          "text": "You should replace `print(graph.create_coordinates_table())` with `print(graph.create_trajectory())`.\n\n```js\n({\n    test: () => runPython(`\n    prints = _Node(_code).find_calls('print')\n\nassert all(not p.is_equivalent('print(graph.create_coordinates_table())') for p in prints), \"print(graph.create_coordinates_table()) should not be present\"\n\nassert any(p.is_equivalent('print(graph.create_trajectory())') for p in prints), \"print(graph.create_trajectory()) not found\"\n    `)\n})\n```\n\nThe function should return `rounded_coords`.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('rounded_coords'), \"return rounded_coords missing\"\n    `)\n})"
        },
        {
          "text": "The `rounded_coords` variable should contain the rounded coordinates.",
          "testCode": "({\n    test: () => {\n        runPython(`\n            ball = Projectile(10, 3, 45)\n            coordinates = ball.calculate_all_coordinates()\n            graph = Graph(coordinates)\n            assert [(round(x), round(y)) for x,y in coordinates] == graph.create_trajectory(), \"coordinates are not rounded correctly\"\n        `)\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\6633b4d3271d5b3aea1c1195.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "6633bdc3ca38c068c3735984",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Add the x and y axes to the graph to obtain the following output:\n\n```py\n[\n    \"⊣     ∙       \",\n    \"⊣  ∙∙∙ ∙∙∙    \",\n    \"⊣ ∙       ∙   \",\n    \"⊣∙         ∙  \",\n    \"⊣           ∙ \",\n    \"⊣            ∙\",\n    \"⊣             \",\n    \" TTTTTTTTTTTTT\",\n]\n```\n\nThe symbols are available as `x_axis_tick` and `y_axis_tick`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n--fcc-editable-region--\n    def create_trajectory(self):\n\n        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n\n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n\n        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n\n        for x, y in rounded_coords:\n            matrix_list[-1 - y][x] = PROJECTILE\n\n        matrix = [\"\".join(line) for line in matrix_list]\n\n        return matrix\n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nfor row in graph.create_trajectory():\n    print(row)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The method should return the correct output.",
          "testCode": "({\n    test: () => assert(runPython(\n        `\ngr = [\n    \"⊣     ∙       \",\n    \"⊣  ∙∙∙ ∙∙∙    \",\n    \"⊣ ∙       ∙   \",\n    \"⊣∙         ∙  \",\n    \"⊣           ∙ \",\n    \"⊣            ∙\",\n    \"⊣             \",\n    \" TTTTTTTTTTTTT\",\n]\nball = Projectile(10, 3, 45)\ncoords = ball.calculate_all_coordinates()\ng = Graph(coords)\ng.create_trajectory() == gr`\n    ))\n})"
        },
        {
          "text": "The method should return the correct output for different instances.",
          "testCode": "({\n    test: () => assert(runPython(\n        `\ngr = [\n    \"⊣     ∙∙             \",\n    \"⊣ ∙∙∙∙  ∙∙∙          \",\n    \"⊣∙         ∙∙        \",\n    \"⊣            ∙       \",\n    \"⊣             ∙      \",\n    \"⊣              ∙     \",\n    \"⊣               ∙    \",\n    \"⊣                ∙   \",\n    \"⊣                 ∙  \",\n    \"⊣                  ∙ \",\n    \"⊣                    \",\n    \"⊣                   ∙\",\n    \" TTTTTTTTTTTTTTTTTTTT\",\n]\nball = Projectile(11, 9, 30)\ncoords = ball.calculate_all_coordinates()\ng = Graph(coords)\ng.create_trajectory() == gr`\n    ))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\6633bdc3ca38c068c3735984.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "6633bfcef57e1d70cc3142c6",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "Finally, make the final output a multiline string. It should start with a newline character and end with a newline character.\n\n```py\n\n⊣     ∙       \n⊣  ∙∙∙ ∙∙∙    \n⊣ ∙       ∙   \n⊣∙         ∙  \n⊣           ∙ \n⊣            ∙\n⊣             \n TTTTTTTTTTTTT\n\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n--fcc-editable-region--\n    def create_trajectory(self):\n\n        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n\n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n\n        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n\n        for x, y in rounded_coords:\n            matrix_list[-1 - y][x] = PROJECTILE\n\n        matrix = [\"\".join(line) for line in matrix_list]\n\n        matrix_axes = [y_axis_tick + row for row in matrix]\n        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n\n        return matrix_axes\n\n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nprint(graph.create_trajectory())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The method should return the correct string.",
          "testCode": "({\n    test: () => (runPython(\n        `gr = '\\\\n⊣     ∙       \\\\n⊣  ∙∙∙ ∙∙∙    \\\\n⊣ ∙       ∙   \\\\n⊣∙         ∙  \\\\n⊣           ∙ \\\\n⊣            ∙\\\\n⊣             \\\\n TTTTTTTTTTTTT\\\\n'\nball = Projectile(10, 3, 45)\ncoords = ball.calculate_all_coordinates()\ng = Graph(coords)\nactual = g.create_trajectory()\nexpected = gr\nassert actual == expected, f'expected {repr(expected)} but found {repr(actual)}'`\n    ))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\6633bfcef57e1d70cc3142c6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "6633c06601c081735063b528",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "You have built a projectile trajectory calculator.\n\nNow to conclude, modify the code you wrote outside the classes, and incorporate it into a little utility function called `projectile_helper` that takes in the desired values for speed, height and angle and prints to the terminal in sequence, the details of the projectile, the table of coordinates and the graph of the trajectory.\n\nCall `projectile_helper` once with values of your choice.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n    def create_trajectory(self):\n\n        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n\n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n\n        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n\n        for x, y in rounded_coords:\n            matrix_list[-1 - y][x] = PROJECTILE\n\n        matrix = [\"\".join(line) for line in matrix_list]\n\n        matrix_axes = [y_axis_tick + row for row in matrix]\n        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n\n        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n\n        return graph\n\n--fcc-editable-region--\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nprint(graph.create_trajectory())\n\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n        \n    def __str__(self):\n    \treturn self.create_trajectory()\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n    def create_trajectory(self):\n\n        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n\n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n\n        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n\n        for x, y in rounded_coords:\n            matrix_list[-1 - y][x] = PROJECTILE\n\n        matrix = [\"\".join(line) for line in matrix_list]\n\n        matrix_axes = [y_axis_tick + row for row in matrix]\n        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n\n        graph = \"\\n\" + \"\\n\".join(matrix_axes) + \"\\n\"\n\n        return graph\n\ndef projectile_helper(speed, height, angle):\n    p = Projectile(speed, height, angle)\n    print(p)\n    coord = p.calculate_all_coordinates()\n    g = Graph(coord)\n    print(g.create_coordinates_table())\n    print(g.create_trajectory())\n    \nprojectile_helper(12, 43, 1)"
        }
      ],
      "tests": [
        {
          "text": "You should create `projectile_helper` in the global scope.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).has_function('projectile_helper')    \n    `)\n})"
        },
        {
          "text": "You should print the requested strings in order. Do not print other values.\n\n```js\n({\n    test: () => {\n        let code_ = code.replaceAll('print(', '__result.append(')\n\nrunPython(`\n__result = []\n${code_}\n__result = [] # code_ includes a call, so let's reset it here\nprojectile_helper(12, 13, 14)\nbullet = Projectile(12, 13, 14)\nassert str(__result[0]) == str(bullet)\nc = bullet.calculate_all_coordinates()\ng = Graph(c)\nassert __result[1] == g.create_coordinates_table()\nassert __result[2] == g.create_trajectory()\n        `)\n    }\n})\n```\n\nYou should call the `projectile_helper` function at least once.",
          "testCode": "({\n    test: () => runPython(`\n    assert len(_Node(_code).find_calls('projectile_helper')) > 0\n    `)\n})"
        },
        {
          "text": "You should not have variables or print calls in the global scope.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).find_calls('print') == [], \"found print\"\n    assert not _Node(_code).has_variable('graph'), \"found graph\"\n    assert not _Node(_code).has_variable('ball'), \"found ball\"\n    assert not _Node(_code).has_variable('coordinates'), \"found coordinates\"\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\6633c06601c081735063b528.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "6634fa2417d7194b0c9425f9",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "Now create the two getters for `__height` and `__angle`. Remember that for the angle, the value is given to the class in degrees, but is saved internally in radians, so have the getter return the degrees value. You can use `math.degrees`, and the `round` function for this.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.__speed} m/s\nheight: {self.__height} m\nangle: {round(math.degrees(self.__angle))}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n--fcc-editable-region--\n    @property\n    def speed(self):\n        return self.__speed\n\n    \n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `height` method.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').has_function('height')\n`))})"
        },
        {
          "text": "Your `height` method should have a single parameter, `self`.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_function('height').has_args('self')\n`))})"
        },
        {
          "text": "Your `height` method should have a `@property` decorator.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_function('height').has_decorators('property')\n`))})"
        },
        {
          "text": "Your `height` method should return the value of the private attribute `__height`.",
          "testCode": "({test: () => assert(runPython(`\na = Projectile(22, 23, 24)\na.height == 23\n`))})"
        },
        {
          "text": "You should define an `angle` method.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').has_function('angle')\n`))})"
        },
        {
          "text": "Your `angle` method should have a `@property` decorator.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_function('angle').has_decorators('property')\n`))})"
        },
        {
          "text": "Your `angle` method should have a single parameter, `self`.",
          "testCode": "({test: () => assert(runPython(`\n_Node(_code).find_class('Projectile').find_function('angle').has_args('self')\n`))})"
        },
        {
          "text": "Your `angle` method should return the value of the private attribute `__angle` converted to degrees.",
          "testCode": "({test: () => assert(runPython(`\na = Projectile(22, 23, 24)\na.angle == 24\n`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\6634fa2417d7194b0c9425f9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "66475bab40e5125c84b03337",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "Now that you have the rounded coordinates, find the maximum value between all the x coordinates and the maximum value between all the y coordinates.\n\nThese max values will be the number of rows and columns in the graph. Save the first in a new variable named `x_max` and the second in a variable named `y_max`.\n\nReturn `x_max, y_max`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        displacement = horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        return displacement\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n--fcc-editable-region--\n    def create_trajectory(self):\n\n        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n\n        return rounded_coords\n        \n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nprint(graph.create_trajectory())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The method should return `x_max, y_max`.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).find_class('Graph').find_function('create_trajectory').has_return('x_max, y_max'), \"return x_max, y_max missing\"\n    `)\n})"
        },
        {
          "text": "The variable `x_max` should contain the highest x value.\n\n```js\n({\n    test: () => {\n        runPython(`\n            ball = Projectile(10, 3, 45)\n            coordinates = ball.calculate_all_coordinates()\n            graph = Graph(coordinates)\n            assert graph.create_trajectory()[0] == round(max(coordinates, key=lambda i: round(i[0]))[0])\n\n`)\n    }\n})\n```\n\nThe variable `y_max` should contain the highest y value.\n\n```js\n({\n    test: () => {\n        runPython(`\n            ball = Projectile(10, 3, 45)\n            coordinates = ball.calculate_all_coordinates()\n            graph = Graph(coordinates)\n            assert graph.create_trajectory()[1] == round(max(coordinates, key=lambda i: round(i[1]))[1])\n\n`)\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\66475bab40e5125c84b03337.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "66475d40dd42fb614f14fd03",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "Now that you have `x_max` and `y_max` you can use these as number of rows and columns to start building the graph structure: create a list of lists where the external list contains `y_max` +1 lists, each with inside `x_max` +1 elements, where each element is a string containing a single space.\n\nSave this list of lists in a variable named `matrix_list` and return this value.\n\n`matrix_list` should look like this:\n\n```py\n[\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n]\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n--fcc-editable-region--\n    def create_trajectory(self):\n        \n        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n        \n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n\n        return x_max, y_max\n        \n        \n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nprint(graph.create_trajectory())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The method should return the correct value.",
          "testCode": "({\n    test: () => {\n        runPython(`\nexpected = [\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n]\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nactual = graph.create_trajectory()\nassert actual == expected, \"matrix_list has wrong value\"\n        `)\n    }\n})"
        },
        {
          "text": "The `create_trajectory` method should return the right value for any instance.",
          "testCode": "({\n    test: () => {\n        runPython(`\nexpected = [\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n]\nball = Projectile(9, 9, 30)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nactual = graph.create_trajectory()\nassert actual == expected, \"matrix_list has wrong value\"\n        `)\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\66475d40dd42fb614f14fd03.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "66475e40f3891c645d50135e",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "`matrix_list` is a list of lists, each element has an `(x, y)` coordinate. Use the list of coordinates in `rounded_coords` to change the elements in `matrix_list` at the coordinates in the list to the symbol in the `PROJECTILE` variable. Remember that a coordinates graph has the `(0, 0)` in the bottom left corner.\n\n```py\n[\n    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n]\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n--fcc-editable-region--\n    def create_trajectory(self):\n        \n        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n        \n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n        \n        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n\n        return matrix_list\n        \n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nfor row in graph.create_trajectory():\n    print(row)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The method should return the correct value.",
          "testCode": "({\n    test: () => {\n        runPython(`\nexpected = [\n    [\" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \"∙\", \"∙\", \"∙\", \" \", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \"],\n    [\" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n    [\"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n]\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nactual = graph.create_trajectory()\nassert actual == expected, \"matrix_list has wrong value\"\n        `)\n    }\n})"
        },
        {
          "text": "The method should return the correct value for different instances.",
          "testCode": "({\n    test: () => {\n        runPython(`\nexpected = [\n    [\" \", \" \", \"∙\", \"∙\", \"∙\", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \"∙\", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \"∙\"],\n    [\" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \", \" \"],\n]\nball = Projectile(9, 9, 30)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nactual = graph.create_trajectory()\nassert actual == expected, \"matrix_list has wrong value\"\n        `)\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\66475e40f3891c645d50135e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "66475f7b91d7c6681987739d",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "You have a list of lists of strings. Join the inner lists to have a list of strings.\n\nIt should look like this:\n\n```py\n[\n    \"     ∙       \",\n    \"  ∙∙∙ ∙∙∙    \",\n    \" ∙       ∙   \",\n    \"∙         ∙  \",\n    \"           ∙ \",\n    \"            ∙\",\n    \"             \",\n]\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n--fcc-editable-region--\n    def create_trajectory(self):\n        \n        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n        \n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n        \n        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n        \n        for (x, y) in rounded_coords:\n            matrix_list[-y-1][x] = PROJECTILE\n\n        return matrix_list\n\n--fcc-editable-region--\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nfor row in graph.create_trajectory():\n    print(row)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The method should return the correct value.",
          "testCode": "({\n    test: () => {\n        runPython(`\nexpected = [\n    \"     ∙       \",\n    \"  ∙∙∙ ∙∙∙    \",\n    \" ∙       ∙   \",\n    \"∙         ∙  \",\n    \"           ∙ \",\n    \"            ∙\",\n    \"             \",\n]\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nactual = graph.create_trajectory()\nassert actual == expected, \"matrix has wrong value\"\n        `)\n    }\n})"
        },
        {
          "text": "`create_trajectory()` should calculate the correct output for different instances.",
          "testCode": "({\n    test: () => {\n        runPython(`\nexpected = [\n    \"  ∙∙∙∙∙        \",\n    \"∙∙     ∙       \",\n    \"        ∙∙     \",\n    \"          ∙    \",\n    \"           ∙   \",\n    \"               \",\n    \"            ∙  \",\n    \"             ∙ \",\n    \"               \",\n    \"              ∙\",\n    \"               \",\n]\nball = Projectile(9, 9, 30)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\nactual = graph.create_trajectory()\nassert actual == expected, \"matrix has wrong value\"\n        `)\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\66475f7b91d7c6681987739d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "665d949e628d9f3fe305b6e8",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "The output is becoming quite difficult to read, so you should replace the `print(graph.create_trajectory())` with a loop that prints each row separately.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n    def create_trajectory(self):\n        \n        rounded_coords = [(round(x), round(y)) for x,y in self.__coordinates]\n        \n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n        \n        matrix_list = [[' ' for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n\n        return matrix_list\n        \nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\n--fcc-editable-region--\nprint(graph.create_trajectory())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Remove the `print(graph.create_trajectory())` call.",
          "testCode": "({\n    test: () => {\n        runPython(`\nprnt = _Node(_code).find_calls('print')\nassert not any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print still present\"\n        `)\n    }\n})"
        },
        {
          "text": "You should have a loop that iterates over `graph.create_trajectory()`.",
          "testCode": "({\n    test: () => {\n        runPython(`\niter = _Node(_code).find_for_loops()[0].find_for_iter()\nassert iter.is_equivalent('graph.create_trajectory()'), \"loop is missing\"\n        `)\n    }\n})"
        },
        {
          "text": "You should print each row in `graph.create_trajectory()`.",
          "testCode": "({ test: () => runPython(`\nloop = _Node(_code).find_for_loops()[0]\nvar = str(loop.find_for_vars())\nassert loop.find_bodies()[0].has_call(f\"print({var})\")\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\665d949e628d9f3fe305b6e8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "66601c3c460ee12fbd669d6a",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "Now you can remove the loop to print each row of the output, and replace it with `print(graph.create_trajectory())`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n        \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.speed} m/s\nheight: {self.height} m\nangle: {self.angle}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n\n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n    \n    def __repr__(self):\n        return f'{self.__class__}({self.speed}, {self.height}, {self.angle})'\n\nclass Graph:\n    __slots__ = ('__coordinates')\n\n    def __init__(self, coord):\n        self.__coordinates = coord\n\n    def __repr__(self):\n        return f\"Graph({self.__coordinates})\"\n\n    def create_coordinates_table(self):\n        table = '\\n  x      y\\n'\n        for x, y in self.__coordinates:\n            table += f'{x:>3}{y:>7.2f}\\n'\n\n        return table\n\n    def create_trajectory(self):\n\n        rounded_coords = [(round(x), round(y)) for x, y in self.__coordinates]\n\n        x_max = max(rounded_coords, key=lambda i: i[0])[0]\n        y_max = max(rounded_coords, key=lambda j: j[1])[1]\n\n        matrix_list = [[\" \" for _ in range(x_max + 1)] for _ in range(y_max + 1)]\n\n        for x, y in rounded_coords:\n            matrix_list[-1 - y][x] = PROJECTILE\n\n        matrix = [\"\".join(line) for line in matrix_list]\n\n        matrix_axes = [y_axis_tick + row for row in matrix]\n        matrix_axes.append(\" \" + x_axis_tick * (len(matrix[0])))\n\n        return matrix_axes\n\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()\ngraph = Graph(coordinates)\n--fcc-editable-region--\nfor row in graph.create_trajectory():\n    print(row)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have a loop in the global scope.",
          "testCode": "({\n    test: () => {\n        runPython(`\nassert not _Node(_code).find_for_loops(), \"loop still present\"\n        `)\n    }\n})"
        },
        {
          "text": "You should have `print(graph.create_trajectory())`.",
          "testCode": "({\n    test: () => {\n        runPython(`\nprnt = _Node(_code).find_calls('print')\nassert any(p.is_equivalent('print(graph.create_trajectory())') for p in prnt), \"print not present\"\n        `)\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\66601c3c460ee12fbd669d6a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "66671a41b55e531d08ab82b5",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "The `__str__` method refers to the attributes of the class directly, but now that you have created the getters it is better to use those to obtain those values.\n\nEdit the `__str__` method to not reference the attributes anymore, but to use the getters.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import math\n\nGRAVITATIONAL_ACCELERATION = 9.81\nPROJECTILE = \"∙\"\nx_axis_tick = \"T\"\ny_axis_tick = \"⊣\"\n\nclass Projectile:\n    __slots__ = ('__speed', '__height', '__angle')\n\n    def __init__(self, speed, height, angle):\n        self.__speed = speed\n        self.__height = height\n        self.__angle = math.radians(angle)\n--fcc-editable-region--    \n    def __str__(self):\n        return f'''\nProjectile details:\nspeed: {self.__speed} m/s\nheight: {self.__height} m\nangle: {round(math.degrees(self.__angle))}°\ndisplacement: {round(self.__calculate_displacement(), 1)} m\n'''\n--fcc-editable-region--\n\n    def __calculate_displacement(self):\n        horizontal_component = self.__speed * math.cos(self.__angle)\n        vertical_component = self.__speed * math.sin(self.__angle)\n        squared_component = vertical_component**2\n        gh_component = 2 * GRAVITATIONAL_ACCELERATION * self.__height\n        sqrt_component = math.sqrt(squared_component + gh_component)\n        \n        return horizontal_component * (vertical_component + sqrt_component) / GRAVITATIONAL_ACCELERATION\n        \n    def __calculate_y_coordinate(self, x):\n        height_component = self.__height\n        angle_component = math.tan(self.__angle) * x\n        acceleration_component = GRAVITATIONAL_ACCELERATION * x ** 2 / (\n                2 * self.__speed ** 2 * math.cos(self.__angle) ** 2)\n        y_coordinate = height_component + angle_component - acceleration_component\n\n        return y_coordinate\n    \n    def calculate_all_coordinates(self):\n        return [\n            (x, self.__calculate_y_coordinate(x))\n            for x in range(math.ceil(self.__calculate_displacement()))\n        ]\n\n    @property\n    def height(self):\n        return self.__height\n\n    @property\n    def angle(self):\n        return round(math.degrees(self.__angle))\n\n    @property\n    def speed(self):\n        return self.__speed\n    \n    @height.setter\n    def height(self, n):\n        self.__height = n\n\n    @angle.setter\n    def angle(self, n):\n        self.__angle = math.radians(n)\n\n    @speed.setter\n    def speed(self, s):\n       self.__speed = s\n\nball = Projectile(10, 3, 45)\nprint(ball)\ncoordinates = ball.calculate_all_coordinates()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The string representation for `Projectile(45, 45, 45)` should be correct.",
          "testCode": "({test: () => assert(runPython(\n`\nball = Projectile(45, 45, 45)\nstr(ball) == \"\"\"\nProjectile details:\nspeed: 45 m/s\nheight: 45 m\nangle: 45°\ndisplacement: 244.4 m\n\"\"\"`\n))})"
        },
        {
          "text": "The string representation should also be correct for other instances.",
          "testCode": "({test: () => assert(runPython(`p = Projectile(10, 10, 10)\nstr(\n    p\n) == \"\"\"\nProjectile details:\nspeed: 10 m/s\nheight: 10 m\nangle: 10°\ndisplacement: 15.9 m\n\"\"\"`))})"
        },
        {
          "text": "You should not be referencing the private properties directly.",
          "testCode": "({\n    test: () => runPython(`\n    rtrn = str(_Node(_code).find_class('Projectile').find_function('__str__').find_return())\n    assert not 'self.__angle' in rtrn\n    assert not 'self.__speed' in rtrn\n    assert not 'self.__height' in rtrn\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-encapsulation-by-building-a-projectile-trajectory-calculator\\66671a41b55e531d08ab82b5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-encapsulation-by-building-a-projectile-trajectory-calculator",
        "name": "Learn Encapsulation By Building A Projectile Trajectory Calculator"
      }
    },
    {
      "id": "6565a536ba1f9f25bd30e88b",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "In this project, you will implement the Luhn Algorithm. This algorithm is a formula to validate a variety of identification numbers.\n\nStart by declaring a function called `main`, this will serve as the entry point of the program. Use the `pass` keyword to avoid an error.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "python",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `def main():` in your code.",
          "testCode": "({\n    test: () => {\n        assert(runPython(`\n        import inspect\n        inspect.isfunction(main)\n        `))\n    }\n})"
        },
        {
          "text": "You should have `pass` in your code.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const pass = __helpers.python.getDef(\"\\n\"+transformedCode, \"main\");\n        assert.include(pass?.function_body, \"pass\");\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\6565a536ba1f9f25bd30e88b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656877c202f44995ed952608",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "Replace the `pass` statement with a variable named `card_number` and a value of `'4111-1111-4555-1142'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef main():\n    pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `card_number = '4111-1111-4555-1142'` within the `main` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.match(function_body, / +card_number\\s*=\\s*('|\")4111-1111-4555-1142\\1/);\n    }\n})\n```\n\nYou should not have a `pass` in your code.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const no_comments = __helpers.python.removeComments(transformedCode);\n        assert.notInclude(no_comments, \"pass\");\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656877c202f44995ed952608.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656877f71bba2b97acedf9af",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "Python comes with built-in classes that can help us with string manipulation. One of them is the `str` class. It has a method called `maketrans` that can help us create a translation table. This table can be used to replace characters in a string:\n\n```python\nstr.maketrans({'t': 'c', 'l': 'b'})\n```\n\nThe above, when called on a string, will replace all `t` characters with `c` and all `l` characters with `b`.\n\nCreate a variable called `card_translation` and assign it a translation table to replace all `-` and ` ` characters with an empty string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `card_translation` variable within `main`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.match(function_body, / +card_translation\\s*=/);\n    }\n})\n```\n\nYou should assign `card_translation` a value of `str.maketrans({'-': '', ' ': ''})`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nconst allowedMatches = [\n            / +card_translation\\s*=\\s*str\\.maketrans\\(\\s*\\{\\s*('|\")-\\1\\s*:\\s*('|\")\\2\\s*,\\s*('|\") \\3\\s*:\\s*('|\")\\4\\s*\\}\\s*\\)/,\n            / +card_translation\\s*=\\s*str\\.maketrans\\(\\s*\\{\\s*('|\") \\1\\s*:\\s*('|\")\\2\\s*,\\s*('|\")-\\3\\s*:\\s*('|\")\\4\\s*\\}\\s*\\)/,\n        ];\n        const anyMatch = allowedMatches.some((match) => match.test(function_body));\n        assert.isTrue(anyMatch);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656877f71bba2b97acedf9af.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656878585631369a6b2d2191",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "Defining the translation does not in itself translate the string. The `translate` method must be called on the string to be translated with the translation table as an argument:\n\n```py\nmy_string = \"tamperlot\"\ntranslation_table = str.maketrans({'t': 'c', 'l': 'b'})\ntranslated_string = my_string.translate(translation_table)\n```\n\nCreate a variable called `translated_card_number` and assign it the result of calling the `translate` method on `card_number` with `card_translation` as an argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `translated_card_number` variable within `main`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.match(function_body, / +translated_card_number\\s*=/);\n    }\n})\n```\n\nYou should assign `translated_card_number` a value of `card_number.translate(card_translation)`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.match(function_body, / +translated_card_number\\s*=\\s*card_number\\.translate\\(\\s*card_translation\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656878585631369a6b2d2191.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "6568789edf2ed39c81983cc4",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Print the translated card number to the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `translated_card_number` to the console.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.match(function_body, / +print\\(\\s*translated_card_number\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\6568789edf2ed39c81983cc4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687946130b0ea10aa19b75",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "Call the `main` function at the end of your script.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `main()` outside of the `main` function.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        assert.match(transformedCode, /\\nmain\\(\\s*\\)/);\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687946130b0ea10aa19b75.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656879613a96aba21cbe80b9",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "Within your `main` function, call the `verify_card_number` function and pass in the `translated_card_number` variable as an argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    pass\n\n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n--fcc-editable-region--\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `verify_card_number(translated_card_number)` within the `main` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.match(function_body, / +verify_card_number\\(\\s*translated_card_number\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656879613a96aba21cbe80b9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656879a66338b2a461d5d307",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "<!-- TODO: Find better places to split explanation up. -->\n\nThe Luhn algorithm is as follows:\n\n1. From the right to left, double the value of every second digit; if the product is greater than 9, sum the digits of the products.\n2. Take the sum of all the digits.\n3. If the sum of all the digits is a multiple of 10, then the number is valid; else it is not valid.\n\nAssume an example of an account number \"7992739871\" that will have a check digit added, making it of the form 7992739871x:\n\n```markdown\nAccount number      7   9  9  2  7  3  9   8  7  1  x\nDouble every other  7  18  9  4  7  6  9  16  7  2  x\nSum 2-char digits   7   9  9  4  7  6  9   7  7  2  x\n```\n\nReplace the `pass` statement with a variable `sum_of_odd_digits` and a value of `0`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    pass\n\n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `sum_of_odd_digits = 0` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /sum_of_odd_digits\\s*=\\s*0/);\n    }\n})\n```\n\nYou should not have `pass` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.notMatch(function_body, /pass/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656879a66338b2a461d5d307.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656879c6f35a85a59c06b3a7",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "You have accessed elements (characters) of a string before, using the index operator `[]`. You can also use the index operator to access a range of characters in a string with `string[start:stop:step]`:\n\n```python\nmy_string = 'camperbot'\nmy_string[0:6] == 'camper' # True\nmy_string[0:6:3] == 'cp' # True\n```\n\nWhere `start` is the starting index (inclusive), `stop` is the ending index (exclusive), and `step` is the amount of characters to skip over. If not specified, `step` is default to 1.\n\nCreate a variable named `card_number_reversed` and assign it the value of the first 4 characters of `card_number`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `card_number_reversed = card_number[0:4]` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /card_number_reversed\\s*=\\s*card_number\\s*\\[\\s*0\\s*:\\s*4\\s*\\]/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656879c6f35a85a59c06b3a7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656879e1c749d7a6c5eba2d2",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "Remove the `print` call from the `verify_card_number` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    print(card_number_reversed)\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have a `print` call within the `verify_card_number` function.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n        const no_comments = __helpers.python.removeComments(function_body);\n        assert.notMatch(no_comments, /print\\(/);\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656879e1c749d7a6c5eba2d2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687a005aba3ea815b84e68",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "Remove the `print` call from the `main` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n\n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n    verify_card_number(translated_card_number)\n--fcc-editable-region--\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have a `print` call within the `main` function.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n        const no_comments = __helpers.python.removeComments(function_body);\n        assert.notMatch(no_comments, /print\\(/);\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687a005aba3ea815b84e68.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687a8253766cac4c99c57f",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "Within the `verify_card_number` function, create a variable `odd_digits` that contains every other digit of the `card_number_reversed` string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `odd_digits = card_number_reversed[::2]` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /odd_digits\\s*=\\s*card_number_reversed\\s*\\[\\s*:\\s*:\\s*2\\s*\\]/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687a8253766cac4c99c57f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687a923dd792ad339f9c09",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "Print the value of the `odd_digits` variable to the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print(odd_digits)` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /print\\(\\s*odd_digits\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687a923dd792ad339f9c09.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687ad86596e0af38640a84",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "Use a `for` loop to iterate over each digit in the `odd_digits` list. Move your `print` call from the previous step into the `for` loop, and change it to print each digit.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    print(odd_digits)\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use a `for` loop over `odd_digits`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /for\\s+\\w+\\s+in\\s+odd_digits/);\n    }\n})\n```\n\nYou should have `--fcc-expected--` within the `for` loop.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\n// Get variable name used in for loop\n        const for_loop_variable = function_body.match(/for\\s+(\\w+)\\s+in\\s+odd_digits/)?.[1];\n        assert.exists(for_loop_variable);\n\nassert.equal(function_body.match(new RegExp(`print\\\\(\\\\s*${for_loop_variable}\\\\s*\\\\)`))?.[0], `print(${for_loop_variable})`);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687ad86596e0af38640a84.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687b182c2a8fb1470e0b97",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "Within the `for` loop, use the `+=` operator to add the `digit` to the `sum_of_odd_digits` variable.\n\nDoing this your script throws a `TypeError` because you are trying to add a string to an integer, but don't worry, you will learn more about how to make it work in the next step.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        print(digit)\n        \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `sum_of_odd_digits += digit` within the `for` loop.\n\n```js\nconst transformedCode = code.replace(/\\r/g, \"\");\nconst verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\nconst { function_body } = verify_card_number;\n\nassert.match(function_body, /sum_of_odd_digits\\s*\\+=\\s*digit/);\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687b182c2a8fb1470e0b97.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687b48f2201ab32e06c37c",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Currently, your script throws a `TypeError` because you are trying to add a string to an integer. You can fix this by converting the `digit` variable to an integer before adding it to `sum_of_odd_digits`, using the built-in `int` function:\n\n```python\nmy_string = '123'\nmy_int = int(my_string)\n```\n\nConvert the `digit` variable to an integer before adding it to `sum_of_odd_digits`. Then, move the `print` call to the end of the `verify_card_number` function to print the value of `sum_of_odd_digits`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n--fcc-editable-region--\n    for digit in odd_digits:\n        print(digit)\n        sum_of_odd_digits += digit\n        \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `sum_of_odd_digits += int(digit)` within the `for` loop.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /sum_of_odd_digits\\s*\\+=\\s*int\\(\\s*digit\\s*\\)/);\n    }\n})\n```\n\nYou should have `print(sum_of_odd_digits)` at the end of the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /print\\(\\s*sum_of_odd_digits\\s*\\)/);\n    }\n})\n```\n\nYou should not have `print(digit)` anymore.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nconst no_comments = __helpers.python.removeComments(function_body);\n\nassert.notMatch(no_comments, /print\\(\\s*digit\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687b48f2201ab32e06c37c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687b68003a61b46fe691f0",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "Below your `print` call, create a variable named `sum_of_even_digits` and assign it a value of `0`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n    print(sum_of_odd_digits)\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `sum_of_even_digits = 0` below your `print` call.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /sum_of_even_digits\\s*=\\s*0/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687b68003a61b46fe691f0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687b8eb0bbf7b5d41b610b",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "Create a variable `even_digits` and assign it the even digits of the reversed card number.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n    print(sum_of_odd_digits)\n\n--fcc-editable-region--\n    sum_of_even_digits = 0\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `even_digits = card_number_reversed[1::2]` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /even_digits\\s*=\\s*card_number_reversed\\s*\\[\\s*1\\s*:\\s*:\\s*2\\s*\\]/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687b8eb0bbf7b5d41b610b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687bbfd9a7d6b78cd5b5cf",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "Loop over the even digits and print each to the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n    print(sum_of_odd_digits)\n\n--fcc-editable-region--\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `for` loop over `even_digits` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /for +(\\w+) +in +even_digits:/);\n    }\n})\n```\n\nYou should have `--fcc-expected--` within the `for` loop.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\n// Get the name of the variable used in the for loop\n        const for_loop_variable = function_body.match(/for +(\\w+) +in +even_digits:/)?.[1];\n        assert.exists(for_loop_variable);\n\nconst [_,lower_function_body] = function_body.split(\"sum_of_even_digits\");\n\nassert.equal(lower_function_body.match(new RegExp(`print\\\\(\\\\s*${for_loop_variable}\\\\s*\\\\)`))?.[0], `print(${for_loop_variable})`);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687bbfd9a7d6b78cd5b5cf.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687c2fd0fec7ba9fb8af30",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "Remove the `print` call for the sum of the odd digits.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n    print(sum_of_odd_digits)\n\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        print(digit)\n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(sum_of_odd_digits)` in your code.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n        const no_comments = __helpers.python.removeComments(function_body);\n        assert.notMatch(no_comments, /print\\(\\s*sum_of_odd_digits\\s*\\)/);\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687c2fd0fec7ba9fb8af30.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687c8d86e18cbd775a53c9",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "The next part of the Luhn Algorithm is to multiply all the even digits by `2`.\n\nWithin the even digit `for` loop, replace the `print` call with a variable named `number` and assign it the value of `digit` multiplied by `2`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n--fcc-editable-region--\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        print(digit)\n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `number = int(digit) * 2` within the `for` loop.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /number\\s*=\\s*int\\(\\s*digit\\s*\\)\\s*\\*\\s*2/);\n    }\n})\n```\n\nYou should not have `print(digit)` within the `for` loop.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nconst no_comments = __helpers.python.removeComments(function_body);\n\nassert.notMatch(no_comments, /print\\s*\\(\\s*digit\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687c8d86e18cbd775a53c9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687da2e60409c45595bbe1",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "To prevent the multiplication of one digit from being greater than `9`, within the even digit loop, add an `if` statement that checks if `number` is greater than or equal to `10`. If it is, print `number`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n--fcc-editable-region--\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `if number >= 10:` within the `for` loop.",
          "testCode": "({\n    test: () => \n    {\n      assert(runPython(`_Node(_code).find_function(\"verify_card_number\").find_for_loops()[1].find_ifs()[0].find_conditions()[0].is_equivalent(\"number >= 10\")`));\n    }\n})"
        },
        {
          "text": "You should have `print(number)` within the `if` statement.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nconst [_,lower_function_body] = function_body.split(\"sum_of_even_digits\");\n\nassert.match(lower_function_body, /print\\s*\\(\\s*number\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687da2e60409c45595bbe1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687db6a9fcf3c548a6c1b7",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "Part of the algorithm is to double every second digit, starting from the right. If the result of doubling the number is greater than or equal to `10`, add the two digits together. For example, if the digit is `6`, double it to get `12`. Add `1` and `2` together to get `3`. You can do this by using _integer division_ to get the first digit and the modulus operator (`%`) to get the second digit:\n\n```python\nmy_number = 12\nfirst_digit = my_number // 10\nsecond_digit = my_number % 10\n```\n\nInteger division results in the quotient of the division, rounded down to the nearest integer.\n\nWithin the `if` statement, assign `number` the result of `number // 10` (integer division) plus the modulus of `number` and `10`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n--fcc-editable-region--\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            print(number)\n            \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `number = number // 10 + number % 10` within the `if` statement.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getBlock(\"\\n\" + transformedCode, \"if number >= 10\");\n        const { block_body } = verify_card_number;\n        const allowedMatches = [\n            /number *= *\\(?\\s*number *\\/\\/ *10\\s*\\)? *\\+ *\\(?\\s*number *% *10/,\n            /number *= *\\(?\\s*number *% *10\\s*\\)? *\\+ *\\(?\\s*number *\\/\\/ *10/\n        ];\n\nconst someMatch = allowedMatches.some(allowedMatch => allowedMatch.test(block_body));\n        assert.isTrue(someMatch);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687db6a9fcf3c548a6c1b7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687dd4b641fdc67d7de487",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "Move the `print` call below the `number` reassignment.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n--fcc-editable-region--\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            print(number)\n            number = (number // 10) + (number % 10)\n            \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should move `print(number)` below `number = (number // 10) + (number % 10)`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const if_statement = __helpers.python.getBlock(\"\\n\" + transformedCode, \"if number >= 10\");\n\nconst { block_body } = if_statement;\n        const [number_assignment, print_pos] = block_body.split('\\n').filter(line => line.trim().length > 0);\n        assert.match(number_assignment, /number *=/);\n        assert.match(print_pos, /print\\s*\\(\\s*number\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687dd4b641fdc67d7de487.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687e069cf4e0c85b0a06b1",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "Outside of the `if` statement, add `number` to `sum_of_even_digits`. Also, remove the `print` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n--fcc-editable-region--\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            number = (number // 10) + (number % 10)\n            print(number)\n        \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `sum_of_even_digits += number` within the `for` loop.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const for_loop = __helpers.python.getBlock(\"\\n\" + transformedCode, \"for digit in even_digits\");\n        const {block_body} = for_loop;\n\nassert.match(block_body, /sum_of_even_digits\\s*\\+=\\s*number/);\n    }\n})\n```\n\nYou should not have `print(number)` within the `for` loop.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nconst no_comments = __helpers.python.removeComments(function_body);\n\nassert.notMatch(no_comments, /print\\s*\\(\\s*number\\s*\\)/);\n    }\n})\n```\n\nYou should not have `sum_of_even_digits += number` within the `if` statement.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const if_statement = __helpers.python.getBlock(\"\\n\" + transformedCode, \"if number >= 10\");\n        const {block_body} = if_statement;\n\nassert.notMatch(block_body, /sum_of_even_digits *\\+= *number/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687e069cf4e0c85b0a06b1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687e0ed12e20c91811a48d",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "Below the second `for` loop of the `verify_card_number` function, create a variable named `total`, and assign it the value of the sum of the odd and even digits. Print `total` to the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n--fcc-editable-region--\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            number = (number // 10) + (number % 10)\n        sum_of_even_digits += number\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `total = sum_of_odd_digits + sum_of_even_digits` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nconst function_body_indentation = function_body.match(/^\\s*/)[0];\n\nconst total_re = new RegExp(`^${function_body_indentation}total\\\\s*=\\\\s*(sum_of_odd_digits\\\\s*\\\\+\\\\s*sum_of_even_digits|sum_of_even_digits\\\\s*\\\\+\\\\s*sum_of_odd_digits)`, \"m\");\n\nassert.match(function_body, total_re);\n    }\n})\n```\n\nYou should have `print(total)` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /print\\(\\s*total\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687e0ed12e20c91811a48d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687e294ef2bdca637fb213",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "Return the result of comparing `0` to `total` modulo `10`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            number = (number // 10) + (number % 10)\n        sum_of_even_digits += number\n--fcc-editable-region--\n    total = sum_of_odd_digits + sum_of_even_digits\n    print(total)\n\n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `return 0 == total % 10` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nconst acceptableMatches = [\n            /return +0 *== *total *% *10/,\n            /return +total *% *10 *== *0/\n        ];\n\nconst someMatch = acceptableMatches.some((match) => {\n            return match.test(function_body);\n        });\n\nassert.isTrue(someMatch);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687e294ef2bdca637fb213.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687e457ab1c4cb8c3fe7c8",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "Adjust the `verify_card_number` call such that if it returns `True`, print `'VALID!'` to the console. Otherwise, print `'INVALID!'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            number = (number // 10) + (number % 10)\n        sum_of_even_digits += number\n    total = sum_of_odd_digits + sum_of_even_digits\n    print(total)\n    return total % 10 == 0\n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    verify_card_number(translated_card_number)\n--fcc-editable-region--\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `if verify_card_number(translated_card_number):` within the `main` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nconst if_statement = __helpers.python.getBlock(\"\\n\" + function_body, \"if verify_card_number(translated_card_number)\");\n        assert.exists(if_statement);\n    }\n})\n```\n\nYou should have `print('VALID!')` within the `if` statement.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const if_statement = __helpers.python.getBlock(\"\\n\" + transformedCode, \"if verify_card_number(translated_card_number)\");\n        const {block_body} = if_statement;\n\nassert.match(block_body, /print\\(\\s*('|\")VALID!\\1\\s*\\)/);\n    }\n})\n```\n\nYou should have `print('INVALID!')` within the `else` clause.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const else_statement = __helpers.python.getBlock(\"\\n\" + transformedCode, \"else\");\n        const {block_body} = else_statement;\n\nassert.match(block_body, /print\\(\\s*('|\")INVALID!\\1\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687e457ab1c4cb8c3fe7c8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "65687f47f9001dd35bdcd5ab",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "Change the value of `card_number` such that `'INVALID!'` is printed to the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            number = (number // 10) + (number % 10)\n        sum_of_even_digits += number\n    total = sum_of_odd_digits + sum_of_even_digits\n    print(total)\n    return total % 10 == 0\n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n--fcc-editable-region--\n\n    if verify_card_number(translated_card_number):\n        print('VALID!')\n    else:\n        print('INVALID!')\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `card_number = '4111-1111-4555-1141'` within the main function.",
          "testCode": "({\n  test: () => {\n    const spyCode = \"a = ''\\ndef printSpy(*x):\\n    global a\\n    a += str(x)\\n\" + code.replaceAll(\"print(\", \"printSpy(\") + \"\\na\";\n    const out = runPython(spyCode);\n    assert.include(out, \"INVALID!\");\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\65687f47f9001dd35bdcd5ab.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656880227dab4bd8fbc02d41",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "Well done on completing this project.\n\nAs a final step, remove the `print` call from the `verify_card_number` function, and change the `card_number` back to something valid.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            number = (number // 10) + (number % 10)\n        sum_of_even_digits += number\n    total = sum_of_odd_digits + sum_of_even_digits\n    print(total)\n    return total % 10 == 0\n\ndef main():\n    card_number = '4111-1111-4555-1141'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    if verify_card_number(translated_card_number):\n        print('VALID!')\n    else:\n        print('INVALID!')\n\nmain()\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "def verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[::-1]\n    odd_digits = card_number_reversed[::2]\n\n    for digit in odd_digits:\n        sum_of_odd_digits += int(digit)\n\n    sum_of_even_digits = 0\n    even_digits = card_number_reversed[1::2]\n    for digit in even_digits:\n        number = int(digit) * 2\n        if number >= 10:\n            number = (number // 10) + (number % 10)\n        sum_of_even_digits += number\n\n    total = sum_of_odd_digits + sum_of_even_digits\n    return total % 10 == 0\n\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    if verify_card_number(translated_card_number):\n        print('VALID!')\n    else:\n        print('INVALID!')\n\nmain()"
        }
      ],
      "tests": [
        {
          "text": "You should not have a `print` call within the `verify_card_number` function.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n        const no_comments = __helpers.python.removeComments(function_body);\n        assert.notMatch(no_comments, /print\\(/);\n    }\n})"
        },
        {
          "text": "You should change `card_number` back to something valid.",
          "testCode": "({\n    test: () => {\n        const spyCode = \"a = ''\\ndef printSpy(*x):\\n    global a\\n    a = str(x)\\n\" + code.replaceAll(\"print(\", \"printSpy(\") + \"\\na\";\n        const out = runPython(spyCode);\n        assert.notInclude(out, \"INVALID!\");\n        assert.include(out, \"VALID!\");\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656880227dab4bd8fbc02d41.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "6569b831a07d7154c793301b",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Define a function `verify_card_number` with a parameter `card_number`, and use the `pass` keyword to make the function do nothing.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--\n\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a function called `verify_card_number` with a parameter called `card_number`.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        assert.exists(verify_card_number);\n        const { function_parameters } = verify_card_number;\n        assert.equal(function_parameters.trim(), \"card_number\");\n    }\n})"
        },
        {
          "text": "You should use the `pass` keyword in the body of the `verify_card_number` function.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        assert.exists(verify_card_number);\n        const { function_body } = verify_card_number;\n        assert.match(function_body, / +pass/);\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\6569b831a07d7154c793301b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656b4638cb8bcf2729afe9a9",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "Print the value of the `card_number_reversed` variable to the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[0:4]\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print(card_number_reversed)` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /print\\(\\s*card_number_reversed\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656b4638cb8bcf2729afe9a9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656b475b394390334828eb12",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "Change `card_number_reversed` to be every second digit of the first four digits of `card_number`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[0:4]\n    print(card_number_reversed)\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `card_number_reversed = card_number[0:4:2]` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /card_number_reversed\\s*=\\s*card_number\\s*\\[\\s*0\\s*:\\s*4\\s*:\\s*2\\s*\\]/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656b475b394390334828eb12.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656b47dc2cf39e37025dc033",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "Reverse the order of the digits in the last four digits of `card_number`, by using a slice with a step of `-1`. You can use either negative or positive indices for the start and end indices.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[0:4:2]\n    print(card_number_reversed)\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `card_number_reversed = card_number[-1:-5:-1]` within the `verify_card_number` function. Expected `--fcc-actual--` to equal `--fcc-expected--`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body, def } = verify_card_number;\n\nconst pyCode = `\ncard_number = \"4111111145551142\"\n${def}\n${function_body.match(/ +/)[0]}return card_number_reversed\n\nverify_card_number(card_number)\n`;\n        const out = runPython(pyCode, {});\n        assert.equal(out, \"2411\");\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656b47dc2cf39e37025dc033.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "656b481ec4976439565a78b2",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "Just as the step is optional, a start at `0` and an end at the end of the slice are optional:\n\n```python\nmy_string = 'camperbot'\ncamperbot = my_string[::]\n```\n\nAssign the reverse of the full `card_number` string to the `card_number_reversed` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef verify_card_number(card_number):\n    sum_of_odd_digits = 0\n    card_number_reversed = card_number[-1:-5:-1]\n    print(card_number_reversed)\n    \n--fcc-editable-region--\ndef main():\n    card_number = '4111-1111-4555-1142'\n    card_translation = str.maketrans({'-': '', ' ': ''})\n    translated_card_number = card_number.translate(card_translation)\n\n    print(translated_card_number)\n\n    verify_card_number(translated_card_number)\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `card_number_reversed = card_number[::-1]` within the `verify_card_number` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const verify_card_number = __helpers.python.getDef(\"\\n\" + transformedCode, \"verify_card_number\");\n        const { function_body } = verify_card_number;\n\nassert.match(function_body, /card_number_reversed\\s*=\\s*card_number\\s*\\[\\s*:\\s*:\\s*-1\\s*\\]/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm\\656b481ec4976439565a78b2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-how-to-work-with-numbers-and-strings-by-implementing-the-luhn-algorithm",
        "name": "Learn How To Work With Numbers And Strings By Implementing The Luhn Algorithm"
      }
    },
    {
      "id": "662a6bc12cde72c32fb526f0",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "An <dfn>interface</dfn> is like a blueprint for a class. An interface contains a set of methods and properties that a class should implement.  \n\nStart this project by declaring an empty class named `Equation`. You will use this class to define an interface, a blueprint for a generic equation.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a new class named `Equation`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_class(\"Equation\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662a6bc12cde72c32fb526f0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662bd456896f16d9bd03f1a6",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "Within the `Equation` class, define two new instance methods named `solve` and `analyze`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Equation:\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method named `solve` within the `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_function(\"solve\")`)) })"
        },
        {
          "text": "Your `solve` method should take one parameter, `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"solve\").has_args(\"self\")`)) })"
        },
        {
          "text": "You should define a method named `analyze` within the `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_function(\"analyze\")`)) })"
        },
        {
          "text": "Your `analyze` method should take one parameter, `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"analyze\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662bd456896f16d9bd03f1a6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662bd552e1c1d2db1b88ba47",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "Now, define another class named `LinearEquation` and make it inherit from `Equation`. You'll use this class to represent linear equations.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Equation:\n    def solve(self):\n        pass\n        \n    def analyze(self):\n        pass\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a class named `LinearEquation`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_class(\"LinearEquation\")`)) })"
        },
        {
          "text": "Your `LinearEquation` class should inherit from the `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").inherits_from(\"Equation\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662bd552e1c1d2db1b88ba47.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662bd8260da84bdd5feae419",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "You want the `LinearEquation` class to implement and not simply inherit all the methods defined inside the `Equation` class, which should act as an interface.\n\nCurrently, the `Equation` class is simply the parent class of `LinearEquation`. In the next steps you will learn how to turn it into a formal interface.\n\nFor now, create an instance of `Equation` and assign it to a variable `eq`, and an instance of `LinearEquation` and assign it to a variable `lin_eq`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class Equation:\n    def solve(self):\n        pass\n        \n    def analyze(self):\n        pass\n        \n\nclass LinearEquation(Equation):\n    pass\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `eq` and assign it an instance of `Equation`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_stmt(\"eq = Equation()\")`)) })"
        },
        {
          "text": "You should declare a variable `lin_eq` and assign it an instance of `LinearEquation`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_stmt(\"lin_eq = LinearEquation()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662bd8260da84bdd5feae419.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662bdd364bf2cde1487922a9",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Unlike other programming languages, Python does not implement interfaces in its core language, but the Python standard library allows you to define interfaces in a simple way.\n\nFor this project, you'll use utilities from the `abc` module. Therefore, import this module in your code.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--\nclass Equation:\n    def solve(self):\n        pass\n        \n    def analyze(self):\n        pass\n        \n\nclass LinearEquation(Equation):\n    pass\n    \n\neq = Equation()\nlin_eq = LinearEquation()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should import the `abc` module.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_import(\"import abc\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662bdd364bf2cde1487922a9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662bde88dc84f1e249801b1a",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "`ABC` stands for *Abstract Base Classes*. The `ABC` class enables you to turn a regular class into an abstract class, which is a class that acts as a blueprint for concrete classes.\n\nModify your `import` statement to import just the `ABC` class from the `abc` module. You can import a specific object `x` from a module `y` following the import construct `from y import x`.\n\nThen, turn your `Equation` class into an abstract class by making it inherit from `ABC`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nimport abc\n\n\nclass Equation:\n    def solve(self):\n        pass\n        \n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    pass\n    \neq = Equation()\nlin_eq = LinearEquation()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should import `ABC` from the `abc` module.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_import(\"from abc import ABC\")`)) })"
        },
        {
          "text": "Your `Equation` class should inherit from `ABC`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").inherits_from(\"ABC\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662bde88dc84f1e249801b1a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662f6d7c92381a3049e4c987",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "An interface doesn't have to define only abstract methods, but it can also implement methods to be inherited by the concrete classes.\n\nBefore taking care of the actual implementation of `solve` and `analyze`, within the `Equation` class, define an `__init__` method. Do not use any decorator on it.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nfrom abc import ABC, abstractmethod\n\n\nclass Equation(ABC):\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    def solve(self):\n        pass\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `__init__` method in your `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_function(\"__init__\")`)) })"
        },
        {
          "text": "Your `__init__` method should take one parameter, `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662f6d7c92381a3049e4c987.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662f96576ef178927de87975",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "In order to be recognized as an abstract method, a method should be decorated with the `@abstractmethod` decorator.\n\nA <dfn>decorator</dfn> is used in Python to modify the behavior of a function. Here's an example of how to use a decorator named `spam`:\n\n```py\n@spam\ndef foo():\n    pass\n```\n\nModify your import statement to import the `abstractmethod` decorator and decorate both the `solve` and `analyze` methods of the `Equation` class. This will raise two exceptions.\n\nOnce a class inheriting from `ABC` has an abstract method, the class cannot be instantiated anymore. Therefore, delete the `Equation` instance to get rid of the error.\n\nThe other error occurs because the `LinearEquation` class must implement all the abstract methods defined in the interface. Make sure to define them inside the `LinearEquation` class, too. You must not use the `abstractmethod` decorator in the concrete class.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nfrom abc import ABC\n\n\nclass Equation(ABC):\n    def solve(self):\n        pass\n        \n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    pass\n\neq = Equation()\nlin_eq = LinearEquation()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should import `abstractmethod` from the `abc` module.",
          "testCode": "({ test: () => assert(runPython(`\n_Node(_code).has_import(\"from abc import ABC, abstractmethod\") or \\\\\n_Node(_code).has_import(\"from abc import abstractmethod, ABC\") or \\\\\n(_Node(_code).has_import(\"from abc import abstractmethod\") and _Node(_code).has_import(\"from abc import ABC\"))\n`)) })"
        },
        {
          "text": "You should decorate with `@abstractmethod` the `solve` method within the `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"solve\").has_decorators(\"abstractmethod\")`)) })"
        },
        {
          "text": "You should decorate with `@abstractmethod` the `analyze` method within the `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"analyze\").has_decorators(\"abstractmethod\")`)) })"
        },
        {
          "text": "You should define a method named `solve` within the `LinearEquation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").has_function(\"solve\")`)) })"
        },
        {
          "text": "Your `solve` method should take one parameter, `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_args(\"self\")`)) })"
        },
        {
          "text": "You should define a method named `analyze` within the `LinearEquation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").has_function(\"analyze\")`)) })"
        },
        {
          "text": "Your `solve` method should take one parameter, `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"analyze\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662f96576ef178927de87975.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662fa2e2cf27c09f21f4f5d0",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "In Python, data types are recognized during runtime (when the code is executed). Therefore, you don't have to specify the data type of a variable when you declare it. Nonetheless, you can annotate a variable to clarify that it will hold a specific data type with `variable: <data type> = value` or just `variable: <data type>`. Note that the Python interpreter does not enforce the types used to annotate variables, and normally you'd need external tools to do it.\n\nInside the `Equation` class, define a class attribute `degree`. Do not assign it a value. Instead use a type annotation of `int` to show that it will store an integer number inside the concrete classes.\n\nLater on, you'll use this class attribute as a part of the validation process of the arguments passed to instantiate the equation objects.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n--fcc-editable-region--\nclass Equation(ABC):\n    def __init__(self):\n        pass\n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    def solve(self):\n        pass\n\n    def analyze(self):\n        pass\n--fcc-editable-region--\nlin_eq = LinearEquation()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define class attribute named `degree` and annotate it with `int` within the `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_variable(\"degree\").is_equivalent(\"degree: int\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662fa2e2cf27c09f21f4f5d0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662fbcef5f05e1b84f541a0c",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "Each equation object will be instantiated passing as many arguments as the coefficients of the equation, starting from n-th degree of \\\\( x \\\\) down to the zero-th degree, including the possible coefficient with the value of `0`.\n\nFor example, `LinearEquation(4, 5)` would represent the equation \\\\( 4x + 5 = 0 \\\\), with `4` being the coefficient of the first (highest here) degree and `5` the coefficient of the zero-th degree.\n\nYou need to check that the right number of arguments is passed to instantiate the equation object.\n\nInside the `__init__` method, create an `if` statement to check if the length of `args` is different from the number of coefficients the equation should have (`degree + 1`). If it is, raise a `TypeError` and use the following string to provide a custom message: `f\"'{self.__class__.__name__}' object takes {self.degree + 1} positional arguments but {len(args)} were given\"`.\n\nThen, fix the error by passing the `2` and `3` to instantiate `lin_eq`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n--fcc-editable-region--\n    def __init__(self, *args):\n        pass        \n    \n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if the number of coefficients used to instantiate the equation is different from `degree + 1`.",
          "testCode": "({ test: () => assert(runPython(`\ncond = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[0].find_conditions()[0]\ncond.is_equivalent(\"(self.degree + 1) != len(args)\") or cond.is_equivalent(\"len(args) != (self.degree + 1)\")\n`)) })"
        },
        {
          "text": "You should raise a `TypeError` within the new `if` statement and use the provided string to return a custom error message.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[0].find_bodies()[0].has_stmt('raise TypeError(f\"\\\\'{self.__class__.__name__}\\\\' object takes {self.degree + 1} positional arguments but {len(args)} were given\")')\n`)) })"
        },
        {
          "text": "You should pass `2` and `3` to instantiate `lin_eq`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_stmt(\"lin_eq = LinearEquation(2, 3)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662fbcef5f05e1b84f541a0c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "662fc3eba556a6bf800d48c1",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "The `isinstance()` built-in function takes two arguments and returns a Boolean indicating if the object passed as the first argument is an instance of the class passed as the second argument.\n\n```py\nisinstance(7, int) # True\n```\n\nAnother thing you want to check is that every argument is a number. After your first `if`, create a `for` loop that iterates over `args` and checks if the argument at the current iteration is not an instance of `int` or `float`. Use the `isinstance()` function and pass it a tuple containing `int` and `float` as the second argument.\n\nIf the argument is not a number, raise a `TypeError` saying `\"Coefficients must be of type 'int' or 'float'\"`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n--fcc-editable-region--\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'{self.__class__.__name__}' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n--fcc-editable-region--\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation(2, 3)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop that iterates over `args` after your `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_for_loops()[0].find_for_iter().is_equivalent(\"args\")`)) })"
        },
        {
          "text": "You should create an `if` statement that checks if the current coefficient is not an instance of either `int` or `float` within the `for` loop.",
          "testCode": "({ test: () => assert(runPython(`\nvar = str(_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_for_loops()[0].find_for_vars())\ncond1 = f'not isinstance({var}, (int, float))'\ncond2 = f'not isinstance({var}, (float, int))'\nif_stmt = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_for_loops()[0].find_ifs()[0].find_conditions()[0]\nif_stmt.is_equivalent(cond1) or if_stmt.is_equivalent(cond2)\n`)) })"
        },
        {
          "text": "You should use the provided string to raise a `TypeError` within the `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_for_loops()[0].find_ifs()[0].find_bodies()[0].has_stmt(\"raise TypeError(\\\\\"Coefficients must be of type 'int' or 'float'\\\\\")\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\662fc3eba556a6bf800d48c1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6639f947d3a1818c9322c64a",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "The last step of validating the coefficients is checking that the highest degree coefficient is different from zero. Remember that the highest degree coefficient should be passed as the first argument when instantiating the object.\n\nAdd an `if` statement for that and raise a `ValueError` using the following string to provide a custom message: `'Highest degree coefficient must be different from zero'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n--fcc-editable-region--\n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n--fcc-editable-region--\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation(2, 3)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if the first coefficient passed to instantiate the equation is equal to zero.",
          "testCode": "({ test: () => assert(runPython(`\ncond = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[2].find_conditions()[0]\ncond.is_equivalent(\"args[0] == 0\") or cond.is_equivalent(\"0 == args[0]\") or cond.is_equivalent(\"not args[0]\")\n`)) })"
        },
        {
          "text": "You should raise a `ValueError` within the new `if` statement and use the provided string to return a custom error message.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[2].find_bodies()[0].has_stmt(\"raise ValueError('Highest degree coefficient must be different from zero')\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6639f947d3a1818c9322c64a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6639fdcc701833a54c364211",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "After validating the coefficients, you need to store them in an instance attribute. Use a dictionary comprehension to create a dictionary in which the key is the degree of the coefficient and the corresponding value is the coefficient, and assign it to an attribute named `coefficients`.\n\nFor example, a `LinearEquation` object instantiated with `2` and `4` should have the following `coefficients` attribute: `{1: 2, 0: 4}`, because `2` corresponds to the first degree of `x` and `4` corresponds to zero-th degree of `x`.\n\nCreate the key-value pairs in your new dictionary following the same order as in `args`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n--fcc-editable-region--\n        \n--fcc-editable-region--\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\n    \nlin_eq = LinearEquation(2, 3)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare an attribute named `coefficients` within your `__init__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").has_variable(\"self.coefficients\")`)) })"
        },
        {
          "text": "You should use a dictionary comprehension to store your coefficients.",
          "testCode": "({ test: () => runPython(`\nimport ast\nnode = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_variable(\"self.coefficients\")\nassert isinstance(node.tree.value, ast.DictComp)\n`) })"
        },
        {
          "text": "Your `coefficients` attribute should be a dictionary containing key-value pairs in the form degree-coefficient. Remember to follow the same order in which coefficients are stored inside `args`.",
          "testCode": "({ test: () => runPython(`\nactual1 = list(LinearEquation(1, 6).coefficients.items())\nexpected1 = list({1: 1, 0: 6}.items())\nactual2 = list(LinearEquation(-3.5, 0).coefficients.items())\nexpected2 = list({1: -3.5, 0: 0}.items())\nassert actual1 == expected1\nassert actual2 == expected2\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6639fdcc701833a54c364211.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663a22ba7420c4d2f7fd2aec",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "It's time to implement the `solve` method. Given a linear equation in the form \\\\( ax + b = 0 \\\\), the solution is \\\\(x = -\\frac{b}{a}\\\\).\n\nUnpack the coefficients stored in the `coefficients` attribute into the variables `a` and `b`. Note that you'll need to use the `.values()` method.\n\nThen, declare a variable `x`, assign it the solution of the equation and return it from the `solve` method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')                \n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n--fcc-editable-region--\n    def solve(self):\n        pass\n--fcc-editable-region--\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should unpack the values stored inside the `coefficients` attribute into the variables `a` and `b`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_stmt(\"a, b = self.coefficients.values()\")`)) })"
        },
        {
          "text": "You should declare a variable named `x` and assign it the solution of the linear equation.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_stmt(\"x = -b/a\")`)) })"
        },
        {
          "text": "You should return `x` from your `solve` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_return(\"x\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663a22ba7420c4d2f7fd2aec.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663a2dd1901cbeecc28748bd",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "It's time to test the `solve` method. Call it on `lin_eq` and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')                \n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n    \n    def analyze(self):\n        pass\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `solve` method of your `lin_eq` object and print the result.",
          "testCode": "({ test: () => assert(runPython(`\n_Node(_code).has_call(\"print(lin_eq.solve())\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663a2dd1901cbeecc28748bd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663a32735b317af9812eb0d7",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "In linear equations in the form \\\\( ax + b = 0 \\\\), the slope is simply the coefficient \\\\( a \\\\), and the y-intercept is the coefficient \\\\( b \\\\).\n\n<img alt=\"a plot of a linear function\" src=\"https://cdn.freecodecamp.org/curriculum/python/linear-equation.png\" style=\"background-color: white; height: 350px; width: auto; padding: 15px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;\">\n\nYou are going to use the `analyze` method to provide additional information about the equation. Inside the `analyze` method, unpack the coefficients into the variables `slope` and `intercept`.\n\nThen, return a dictionary with the keys `'slope'` and `'intercept'` and the values of the slope and the y-intercept, respectively. After that, call `analyze` on `lin_eq` and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')                \n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n--fcc-editable-region--\n    def analyze(self):\n        pass\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nprint(lin_eq.solve())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should unpack the values stored in the `coefficients` attribute into the variables `slope` and `intercept` inside the `analyze` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"analyze\").has_stmt(\"slope, intercept = self.coefficients.values()\")`)) })"
        },
        {
          "text": "The `analyze` method should return a dictionary with the keys `'slope'` and `'intercept'` and the values of the slope and the y-intercept, respectively.",
          "testCode": "({ test: () => runPython(`\neq = LinearEquation(2.2, 1.5)\na = eq.analyze()\nassert a['slope'] == 2.2, \"Expected different slope\"\nassert a['intercept'] == 1.5, \"Expected different intercept\"\n`) })"
        },
        {
          "text": "You should call the `analyze` method of your `lin_eq` object.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(lin_eq.analyze())\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663a32735b317af9812eb0d7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663b7fefd437bd984e091cbf",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "Next, create a new class named `QuadraticEquation` and make it inherit from `Equation`. You'll use this new class to represent quadratic equations, which are second-degree equations having the form $ax^2 + bx + c = 0$. \n\nInside your new class, define a `degree` class attribute with the value `2`, which is the degree of a quadratic equation. Also, define the `solve` and `analyze` methods. You will take care of the implementation in the following steps.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')                \n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n--fcc-editable-region--\n\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new class named `QuadraticEquation` and make it inherit from the `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").inherits_from(\"Equation\")`)) })"
        },
        {
          "text": "You should define a `solve` method within the `QuadraticEquation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").has_function(\"solve\")`)) })"
        },
        {
          "text": "Your `solve` method should take a single parameter, `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"solve\").has_args(\"self\")`)) })"
        },
        {
          "text": "You should define an `analyze` method within the `QuadraticEquation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").has_function(\"analyze\")`)) })"
        },
        {
          "text": "Your `analyze` method should take a single parameter, `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"analyze\").has_args(\"self\")`)) })"
        },
        {
          "text": "You should define a `degree` class attribute within the `QuadraticEquation` class and assign it the value `2`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_variable(\"degree\").is_equivalent(\"degree = 2\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663b7fefd437bd984e091cbf.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663b83a28943e6aa6275a514",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "Still within the `Equation` class, define a `__str__` method to give a proper string representation to the equation objects you are going to create.\n\nFor now, within the `__str__` method, declare a variable `terms` and assign it an empty list. You'll use this variable to store each term (coefficient times \\\\( x^n \\\\)) of your equation.\n\nThen, declare a variable `equation_string`, assign it the result of joining the elements in the `terms` list with a space. Finally, return `equation_string`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n--fcc-editable-region--\n    \n--fcc-editable-region--    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__str__` method within the `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_function(\"__str__\")`)) })"
        },
        {
          "text": "Your `__str__` method should take one parameter, `self`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_args(\"self\")`)) })"
        },
        {
          "text": "You should declare a variable `terms` and assign it an empty list within the `__str__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_stmt(\"terms = []\")`)) })"
        },
        {
          "text": "You should declare a variable `equation_string` and assign it the result of joining the elements in `terms` with a space within the `__str__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_stmt(\"equation_string = ' '.join(terms)\")`)) })"
        },
        {
          "text": "You should return `equation_string` from your `__str__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_return(\"equation_string\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663b83a28943e6aa6275a514.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663b93aee129b3c4cc07d0db",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "Just after the `terms` list, create a `for` loop and use the `.items()` method to iterate over the keys and values stored in the `coefficients` attribute. Use `n` and `coefficient` as the loop variables. \n\nInside the loop, create an `if` statement that checks if the coefficient at the current iteration has a falsy value and skip the iteration in that case. This is because you don't want to represent coefficients with the value of zero.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n--fcc-editable-region--\n    def __str__(self):\n        terms = []\n        \n--fcc-editable-region--\n        equation_string = ' '.join(terms)\n        return equation_string        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop that iterates over `coefficients.items()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_for_iter().is_equivalent(\"self.coefficients.items()\")`)) })"
        },
        {
          "text": "Your `for` loop should use `n` and `coefficient` to iterate over `coefficients.items()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_for_vars().is_equivalent(\"n, coefficient\")`)) })"
        },
        {
          "text": "You should create an `if` statement to check if `coefficient` has a falsy value inside your `for` loop.",
          "testCode": "({ test: () => assert(runPython(`\nif_cond = _Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[0].find_conditions()[0]\nconditions = [\"not coefficient\", \"coefficient == 0\", \"0 == coefficient\"]\nany(if_cond.is_equivalent(condition) for condition in conditions)\n`)) })"
        },
        {
          "text": "You should use the `continue` keyword inside your new `if` statement.",
          "testCode": "({ test: () => assert(runPython(`\n_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[0].find_bodies()[0].has_stmt(\"continue\")\n`)) })"
        },
        {
          "text": "Your `for` loop should be placed just after the declaration of `terms`.",
          "testCode": "({ test: () => assert(runPython(`\nloop = str(_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0])\n_Node(_code).find_class(\"Equation\").find_function(\"__str__\").is_ordered(\"terms = []\", loop, \"equation_string = ' '.join(terms)\", \"return equation_string\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663b93aee129b3c4cc07d0db.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663b95d65caeb3ca04c5fef4",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "If the coefficient has a non-zero value, you can have different cases. If `n == 0`, the term is made by the coefficient itself.\n\nAfter your `if` statement, create another `if` statement for this case and append a string containing the coefficient to the `terms` list. Use an f-string for that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n--fcc-editable-region--\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n        equation_string = ' '.join(terms)\n        return equation_string\n--fcc-editable-region--    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement to check if `n` is equal to `0` after your existing `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_conditions()[0].is_equivalent(\"n==0\")`)) })"
        },
        {
          "text": "You should append `f'{coefficient}'` to the `terms` list within your new `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[0].is_equivalent(\"terms.append(f'{coefficient}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663b95d65caeb3ca04c5fef4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663c981b9b06922e13a97fe9",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "Create an `elif` clause for the case `n == 1`. Within the `elif` clause, create an f-string containing the coefficient directly followed by a lowercase `x` and append it to the `terms` list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n--fcc-editable-region--\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient}')\n        equation_string = ' '.join(terms)\n        return equation_string\n--fcc-editable-region--\n        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `elif` clause to check if `n` is equal to `1`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_conditions()[1].is_equivalent(\"n==1\")`)) })"
        },
        {
          "text": "You should append `f'{coefficient}x'` to the `terms` list within your new `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[1].is_equivalent(\"terms.append(f'{coefficient}x')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663c981b9b06922e13a97fe9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "663c9f31306353460da54542",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "As you can see, the `+` sign is missing from the output. The number sign is displayed by default only if negative. To change this behavior, you can write a colon after the expression to be evaluated within the curly braces of your f-string, and specify the option `+`. This will allow you to display the sign both for positive and negative numbers.\n\nModify the string in your two conditional clauses by adding `:+` inside the curly braces after `coefficient`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n--fcc-editable-region--\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient}')\n            elif n == 1:\n                terms.append(f'{coefficient}x')                \n        equation_string = ' '.join(terms)        \n        return equation_string\n--fcc-editable-region--    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the string to append to the `terms` list within your `if` statement into `f'{coefficient:+}'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[0].is_equivalent(\"terms.append(f'{coefficient:+}')\")`)) })"
        },
        {
          "text": "You should modify the string to insert into the `terms` list within your `elif` clause into `f'{coefficient:+}x'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[1].is_equivalent(\"terms.append(f'{coefficient:+}x')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\663c9f31306353460da54542.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664c670069bae45fd060c25d",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "Next, print your `lin_eq` instance.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}        \n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `lin_eq`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(lin_eq)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664c670069bae45fd060c25d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664cb04a16fe6938708967ef",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "After joining the terms, concatenate the string `' = 0'` to `equation_string` to display the complete equation.\n\nAlso, to refine the output, remove any leading `+` sign from `equation_string`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n        \n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n--fcc-editable-region--\n        equation_string = ' '.join(terms)\n        \n        return equation_string\n--fcc-editable-region--\n        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `__str__` method should return a different string representation.",
          "testCode": "({ test: () => assert(runPython(`\neq1 = LinearEquation(4, 2)\nstr(eq1) == '4x +2 = 0'\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664cb04a16fe6938708967ef.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664e4a590b52ba8d2adff19f",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "The discriminant of a quadratic equation in the form \\\\( ax^2 + bx + c = 0 \\\\), usually indicated by the capital Greek letter delta, is equal to \\\\( Δ = b^2 - 4ac \\\\).\n\nWithin the `QuadraticEquation` class, define an `__init__` method. Use `super()` to call the `__init__` method from the parent class. Then, define a new attribute named `delta`, which stores the value of the discriminant of the equation.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')                \n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n--fcc-editable-region--\n    \n--fcc-editable-region--    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `__init__` method within the `QuadraticEquation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").has_function(\"__init__\")`)) })"
        },
        {
          "text": "Your `__init__` method should take two parameters, `self` and `*args`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"__init__\").has_args(\"self, *args\")`)) })"
        },
        {
          "text": "You should call `super().__init__(*args)` within your `__init__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"__init__\").has_call(\"super().__init__(*args)\")`)) })"
        },
        {
          "text": "You should declare a `delta` attribute within your `__init__` method and assign it the value of the discriminant of the equation.",
          "testCode": "({ test: () => runPython(`\neq = QuadraticEquation(2, -3, -4)\nassert eq.delta == 41\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664e4a590b52ba8d2adff19f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664e4e1b6c35a99cbba49e84",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "Now, create an instance of the `QuadraticEquation` class to represent the equation \\\\( 11x^2 - x + 1 = 0 \\\\).\n\nAssign the new instance to a variable `quadr_eq`, then print your new variable. Note that, at this point, the second degree term would be missing from the string representation of the equation.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')                \n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n   \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n--fcc-editable-region-- \nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `quadr_eq` and assign it an instance of `QuadraticEquation` passing it `11`, `-1`, and `1` as the arguments.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_stmt(\"quadr_eq = QuadraticEquation(11, -1, 1)\")`)) })"
        },
        {
          "text": "You should print your `quadr_eq` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(quadr_eq)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664e4e1b6c35a99cbba49e84.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664ee8037f4bbe3c0944c35e",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "As you can see, the second-degree term is missing from the string representation. Within the `__str__` method, create an `else` clause to handle the case in which the exponent of \\\\( x \\\\) is greater than `1`.\n\nAppend a string to the `terms` list so that the term is represented as `<coefficient>x**<exponent>`. Display the number sign both for positive and negative coefficients and make sure that the inserted string is suitable to represent equations of degree > 2, too.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n--fcc-editable-region--\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            \n--fcc-editable-region--\n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n   \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `else` clause after your existing `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_conditions()[2].is_empty()`)) })"
        },
        {
          "text": "You should append `f'{coefficient:+}x**{n}'` to the `terms` list within your new `else` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").find_for_loops()[0].find_ifs()[1].find_bodies()[2].is_equivalent(\"terms.append(f'{coefficient:+}x**{n}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664ee8037f4bbe3c0944c35e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664eec7f38234443b42c206f",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "Your equation is currently represented as `11x**2 -1x +1 = 0`, but it would be nice not to display the coefficient multiplying \\\\( x \\\\) when it's equal to one. So that equation is represented as `11x**2 -x +1 = 0`.\n\nImport the `re` module. You are going to use a regular expression to substitute the coefficients for this case during the next steps.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n--fcc-editable-region--\n\n--fcc-editable-region--\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n   \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should import the `re` module.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_import(\"import re\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664eec7f38234443b42c206f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664eef158d792a509e8d708a",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "The `sub` function from the `re` module enables you to replace text inside a string based on a regex pattern.\n\n```py\nverse = 'Always look on the bright side of life'\nspam = re.sub('bright', 'spam', verse)\nspam == 'Always look on the spam side of life' # True\n```\n\nIt takes three arguments: the regex pattern to match, the replacement, and the string on which you want to perform the replacement.\n\nFrom your `__str__` method, return a `sub()` call passing the string `'1'`, an empty string, and your existing `equation_string.strip('+')` call as the arguments. This will replace each `1` with an empty string. The result is not refined yet and you'll continue to work on the regex pattern in the next steps.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n--fcc-editable-region--\n        return equation_string.strip('+')        \n--fcc-editable-region--\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n   \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return a `re.sub()` call from your `__str__` method. Pass the string `'1'`, an empty string, and your existing `equation_string.strip('+')` call as the arguments to `re.sub()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_return(\"re.sub('1', '', equation_string.strip('+'))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664eef158d792a509e8d708a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664ef4623946e65e18d59764",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "In a regex pattern, a *lookaround* is an assertion that matches a certain pattern without consuming characters in the string. One kind of lookaround is the lookbehind, which can be either positive or negative. They are denoted by `(?<=...)` and `(?<!...)`, respectively.\n\n```py\nspam = 'black back bat'\nre.sub('(?<=l)a', 'o', spam) == 'block back bat' # True\nre.sub('(?<!l)a', 'o', spam) == 'black bock bot' # True\n```\n\nIn the example above, the pattern `(?<=l)a` contains a positive lookbehind, which is used to match the `a` character only when preceded by an `l`. In the last line of the example, the pattern `(?<!l)a` contains a negative lookbehind, which is used to match the `a` character only if it is **not** preceded by an `l`. Note how, in both cases, the character contained in the lookbehind is not consumed.\n\nModify your regex pattern to use a negative lookbehind so that the character `1` is substituted only if not preceded by a digit.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n--fcc-editable-region--\n        return re.sub('1', '', equation_string.strip('+'))        \n--fcc-editable-region--\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n   \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the pattern passed as the first argument to the `re.sub()` call using a negative lookbehind.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"Equation\").find_function(\"__str__\")\nvalues = [\n  \"re.sub('(?<!\\\\d)1', '', equation_string.strip('+'))\",\n  \"re.sub(r'(?<!\\\\d)1', '', equation_string.strip('+'))\",\n  \"re.sub('(?<![0-9])1', '', equation_string.strip('+'))\"\n]\nany(node.has_return(value) for value in values)\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664ef4623946e65e18d59764.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664f0389424a6f7aa15fd3e5",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "Another kind of lookaround assertion is the lookahead. Positive and negative lookahead are denoted by `(?=...)` and `(?!...)`, respectively. They are used to match a pattern if followed by a certain sequence of characters, which is not consumed:\n\n```py\nspam = 'black back bat'\nre.sub('a(?=t)', 'o', spam) == 'black back bot' # True\nre.sub('a(?!t)', 'o', spam) == 'block bock bat' # True\n```\n\nIn the example above, the pattern `a(?=t)` contains a positive lookahead, which is used to match the `a` character only when followed by a `t`. In the last line of the example, the pattern `a(?!t)` contains a negative lookahead, which is used to match the `a` character only if **not** followed by a `t`. Again, in both cases, the character contained in the lookahead is not consumed.\n\nAdd a positive lookahead to your regex pattern so that the character `1` is substituted only if followed by the character `x`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n--fcc-editable-region--\n        return re.sub(r'(?<!\\d)1', '', equation_string.strip('+'))        \n--fcc-editable-region--\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n   \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your regex pattern using a positive lookahead to substitute the character `1` only if followed by an `x`. Do not remove the negative lookbehind from your pattern.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__str__\").has_return(\"re.sub(r'(?<!\\\\d)1(?=x)', '', equation_string.strip('+'))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664f0389424a6f7aa15fd3e5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "664f4559c17d2138ae680566",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "It's time to implement the `solve` method. When the discriminant of the quadratic equation is negative, the equation does not have real solutions, or roots.\n\nWithin the `solve` method, create an `if` statement to check if the discriminant is negative. If it is, return an empty list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n--fcc-editable-region--\n    def solve(self):\n        pass\n--fcc-editable-region--\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement to check if `self.delta` is lower than `0`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"solve\").find_ifs()[0].find_conditions()[0].is_equivalent(\"self.delta < 0\")`)) })"
        },
        {
          "text": "You should return an empty list from your new `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").find_function(\"solve\").find_ifs()[0].find_bodies()[0].has_return(\"[]\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\664f4559c17d2138ae680566.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6650583d9d9a194714da47f0",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "The roots of quadratic equations can be found by applying the formula:\n\n\\\\[ x = \\frac{-b \\pm \\sqrt{b^2 - 4ac}}{2a} = \\frac{-b \\pm \\sqrt{\\Delta}}{2a} \\\\]\n\nAfter the `if` statement, create two variables: assign them the root obtained by taking the plus sign between \\\\( b \\\\) and the square root of the discriminant in the formula above, and the root obtained by taking the minus sign. Then, return a list containing your two new variables.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n--fcc-editable-region--\n    def solve(self):\n        if self.delta < 0:\n            return []\n--fcc-editable-region--\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `solve` method should return a list containing the correct solutions.",
          "testCode": "({ test: () => runPython(`\neq = QuadraticEquation(-1, 2, 3)\nassert eq.solve() == [-1, 3] or eq.solve() == [3, -1]\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6650583d9d9a194714da47f0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6650633eaeccf266fee14ba6",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "It's time to test the `solve` method. Call it on your `quadr_eq` instance and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        return [x1, x2]\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\n--fcc-editable-region--\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `quadr_eq.solve()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(quadr_eq.solve())\") or _Node(_code).has_call(\"print(quadr_eq.solve(), quadr_eq.results)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6650633eaeccf266fee14ba6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6650e11fa60e222e691bb283",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "Modify the first argument used to instantiate `quadr_eq` into `-11`. In this way, the discriminant of the equation will be positive.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        return [x1, x2]\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\n--fcc-editable-region--\nquadr_eq = QuadraticEquation(11, -1, 1)\nprint(quadr_eq)\nprint(quadr_eq.solve())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the first argument used to instantiate `quadr_eq` into `-11`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_stmt(\"quadr_eq = QuadraticEquation(-11, -1, 1)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6650e11fa60e222e691bb283.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6650e27cf34f2335a9bbbd08",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "One last check: modify your `quadr_eq` instance to represent the equation \\\\( x^2 + 2x + 1 = 0 \\\\).",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        return [x1, x2]\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\n--fcc-editable-region--\nquadr_eq = QuadraticEquation(-11, -1, 1)\nprint(quadr_eq)\nprint(quadr_eq.solve())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the first two arguments used to instantiate `quadr_eq` into `1` and `2`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_stmt(\"quadr_eq = QuadraticEquation(1, 2, 1)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6650e27cf34f2335a9bbbd08.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6650e88cc500673ec881c9ca",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "In this case, the discriminant is zero and the two roots are coincidents.\n\nCreate an `if` statement to check if the discriminant is zero and return a list containing the root.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n--fcc-editable-region--\n        \n--fcc-editable-region--\n        return [x1, x2]\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(quadr_eq)\nprint(quadr_eq.solve())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement to check if the `delta` attribute is equal to zero.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"QuadraticEquation\").find_function(\"solve\").find_ifs()[1].find_conditions()[0]\nnode.is_equivalent(\"self.delta == 0\") or node.is_equivalent(\"not self.delta\")\n`)) })"
        },
        {
          "text": "You should return a list containing the root within your new `if` statement.",
          "testCode": "({ test: () => runPython(`\neq = QuadraticEquation(4, 4, 1)\nassert eq.solve() == [-0.5]\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6650e88cc500673ec881c9ca.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6650eb84e248684c2f57555c",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "In general, it is good practice to make the same methods from different classes return the same type of data. The `solve` method from the `QuadraticEquation` class returns a list, because quadratic equations can have two roots.\n\nAlthough linear equations have a single real solution, modify the `solve` method within the `LinearEquation` class to return a list containing the root, so that the `solve` methods from different classes return the same type of data.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n--fcc-editable-region--\n        return x\n--fcc-editable-region--\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(quadr_eq)\nprint(quadr_eq.solve())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return a list containing the single root from the `solve` method of your `LinearEquation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").find_function(\"solve\").has_return(\"[x]\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6650eb84e248684c2f57555c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6650f037c017aa6855a608e3",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "The graph of any quadratic equation has a parabolic shape. The \\\\( x \\\\) coordinate of the vertex of the parabola can be found at \\\\( x = - \\frac{b}{2a} \\\\).\n\nFrom the `analyze` method, return the dictionary containing two keys, `'x'`, and `'y'`, and the corresponding values of the vertex \\\\( x \\\\) and \\\\( y \\\\) coordinates, respectively.\n\nUse the relation above to find the \\\\( x \\\\) coordinate. Then, use the \\\\( x \\\\) coordinate to calculate the \\\\( y \\\\) coordinate.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n--fcc-editable-region--\n    def analyze(self):\n        pass\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(quadr_eq)\nprint(quadr_eq.solve())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return a dictionary containing two keys, `'x'`, and `'y'`, and the corresponding values of vertex `x` and `y` coordinates, respectively.",
          "testCode": "({ test: () => runPython(`\neq = QuadraticEquation(16, 2, 1)\nassert eq.analyze() == {'x': -0.0625, 'y': 0.9375}\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6650f037c017aa6855a608e3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "665460392acb7e91db2afad1",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "When the second-degree coefficient is positive, the parabola has a minimum point and opens upward, or it is called concave upwards. Instead, when the second-degree coefficient is negative, the parabola has a maximum point and opens downward, or it is called concave downwards.\n\n<img alt=\"two parabolas with different concavities\" src=\"https://cdn.freecodecamp.org/curriculum/python/parabola.png\" style=\"background-color: white; height: 350px; width: auto; padding: 15px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;\">\n\nDeclare a `concavity` variable and assign it either the string `'upwards'` or `'downwards'`, depending on the concavity of the parabola. Also, declare a variable named `min_max` and assign it either the string `'min'` or `'max'`, depending on if the vertex is a minimum or a maximum, respectively.\n\nFinally, add the dictionary to return two keys `'min_max'` and `'concavity'` with the values of `min_max'` and `concavity`, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n--fcc-editable-region--\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        \n        return {'x': x, 'y': y}\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(quadr_eq)\nprint(quadr_eq.solve())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `analyze` method should return a dictionary with four keys, `'x'`, `'y'`, `'min_max'`, and `'concavity'` and the values of `x`, `y`, `min_max`, and `concavity`, respectively.",
          "testCode": "({ test: () => runPython(`\neq1 = QuadraticEquation(16, 2, 1)\neq2 = QuadraticEquation(-16, 2, 1)\nassert eq1.analyze() == {'x': -0.0625, 'y': 0.9375, 'min_max': 'min', 'concavity': 'upwards'}\nassert eq2.analyze() == {'x': 0.0625, 'y': 1.0625, 'min_max': 'max', 'concavity': 'downwards'}\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\665460392acb7e91db2afad1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "665467883dded0a1dad983b2",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "Now, get rid of all your `print` calls.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(quadr_eq)\nprint(quadr_eq.solve())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete all your `print` calls.",
          "testCode": "({ test: () => assert(runPython(`\n_Node(_code).find_calls(\"print\") == []`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\665467883dded0a1dad983b2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66558720bbe6e038315b7f81",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "Next, you are going to create a function that will trigger the instance methods you wrote to solve the equation. Also, it will display the results in a formatted output.\n\nOutside the classes, create a new function named `solver` that takes a single parameter, `equation`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n--fcc-editable-region--\n\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a function named `solver` that takes a single parameter, `equation`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_args(\"equation\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66558720bbe6e038315b7f81.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "665621ef85db565d26632761",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "Within your new function, create an `if` statement that checks if `equation` is not an instance of the `Equation` class and raise a `TypeError` using the string `'Argument must be an Equation object'` to provide a custom message.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n--fcc-editable-region--\ndef solver(equation):\n    pass\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement to check if `equation` is not an instance of the `Equation` class within your `solver` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_ifs()[0].find_conditions()[0].is_equivalent(\"not isinstance(equation, Equation)\")`)) })"
        },
        {
          "text": "You should raise a `TypeError` with the provided string within your new `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_ifs()[0].find_bodies()[0].has_stmt(\"raise TypeError('Argument must be an Equation object')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\665621ef85db565d26632761.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66562f71937f877c66123bbe",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "The first thing to display at the top of the output will be the equation type. Add a class attribute named `type` to the `Equation` class and annotate it with `str`.\n\nThen, add another `if` statement to the `__init_subclass__` method to check if the classes inheriting from `Equation` have the `type` attribute. Use the same format of the existing `if` statement with the appropriate modifications.\n\nFinally, add the new class attribute to the `LinearEquation` class and to the `QuadraticEquation` class. Assign it the string `'Linear Equation'` and the string `'Quadratic Equation'`, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n--fcc-editable-region--\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\nclass QuadraticEquation(Equation):\n    degree = 2\n--fcc-editable-region--\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a class variable named `type` within the `Equation` class and annotate it with `str`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").has_stmt(\"type: str\")`)) })"
        },
        {
          "text": "You should create an `if` statement that checks if `cls` does not have the attribute `type` inside the `__init_subclass__` method and raise an `AttributeError` using the provided string.",
          "testCode": "({ test: () => assert(runPython(`\nif_str = \"\"\"\nif not hasattr(cls, 'type'):\n  raise AttributeError(\n    f\\\\\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\\\\\"\n  )\n\"\"\"\n_Node(_code).find_class(\"Equation\").find_function(\"__init_subclass__\").has_stmt(if_str)\n`)) })"
        },
        {
          "text": "The `type` attribute of the `LinearEquation` class shouls have the value `'Linear Equation'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"LinearEquation\").has_stmt(\"type = 'Linear Equation'\")`)) })"
        },
        {
          "text": "The `type` attribute of the `QuadraticEquation` class should have the value `'Quadratic Equation'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"QuadraticEquation\").has_stmt(\"type = 'Quadratic Equation'\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66562f71937f877c66123bbe.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "665ee783d35cb68875c626d4",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "Now, remove both the `print(lin_eq.solve())` and `print(lin_eq.analyze())` calls from your code.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\nclass Equation(ABC):\n    degree: int\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')                \n        equation_string = ' '.join(terms) + ' = 0'\n        return equation_string.strip('+')        \n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return x\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nlin_eq = LinearEquation(2, 3)\nprint(lin_eq)\n--fcc-editable-region--\nprint(lin_eq.solve())\nprint(lin_eq.analyze())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove both your `print(lin_eq.solve())` and `print(lin_eq.analyze())` calls.",
          "testCode": "({ test: () => runPython(`\nassert not _Node(_code).has_call(\"print(lin_eq.analyze())\")\nassert not _Node(_code).has_call(\"print(lin_eq.solve())\")\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\665ee783d35cb68875c626d4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66759e32b88fb5459b1e0234",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "The `__init_subclass__` method is called whenever the class that defines it is subclassed and it enables to customize the child classes. The method takes a parameter named by convention `cls` (standing for \"class\"), which represents the new child class.\n\nDefine an `__init_subclass__` method in your `Equation` class and give it a `cls` parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\n\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self):\n        pass\n--fcc-editable-region--\n    \n--fcc-editable-region--\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    def solve(self):\n        pass\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `__init_subclass__` method with a `cls` parameter in your `Equation` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init_subclass__\").has_args(\"cls\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66759e32b88fb5459b1e0234.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6675a38a8b535e4ff3274520",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "The `hasattr` built-in function takes an object as its first argument and a string representing an attribute name as its second argument. It returns a boolean indicating if the object has the specified attribute.\n\nNow you are going to use the `__init_subclass__` method to check if the child class has the `degree` attribute at the moment of the instantiation.\n\nCreate an `if` statement to check if `cls` does not have a `degree` attribute. If so, raise an `AttributeError` and use the string `f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"` to provide a custom message.\n\nAfter that, fix the error that has appeared in the terminal by declaring a `degree` class attribute inside the `LinearEquation` class. This attribute should represent the degree of the equation, which is the exponent of the highest \\\\( x \\\\) term. Therefore, assign the integer `1` to the `degree` attribute.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\n\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self):\n        pass\n--fcc-editable-region--\n    def __init_subclass__(cls):\n        pass\n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    \n--fcc-editable-region--\n    def solve(self):\n        pass\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if `cls` does not have the attribute `degree` inside the `__init_subclass__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init_subclass__\").find_ifs()[0].find_conditions()[0].is_equivalent(\"not hasattr(cls, 'degree')\")`)) })"
        },
        {
          "text": "You should raise an `AttributeError` using the provided string inside your `if` statement.",
          "testCode": "({ test: () => runPython(`\nraise_stmt = 'raise AttributeError(f\"Cannot create \\\\'{cls.__name__}\\\\' class: missing required attribute \\\\'degree\\\\'\")'\nnode = _Node(_code).find_class(\"Equation\").find_function(\"__init_subclass__\").find_ifs()[0].find_bodies()[0]\nassert node.has_stmt(raise_stmt) \n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6675a38a8b535e4ff3274520.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6675aaf418b41157f6ccd692",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "It's time to go back to the `__init__` method. Depending on the equation type, you'll need to pass a variable number of arguments during the instantiation.\n\nAdd a second parameter `args` to the method and use the `*` operator to make it accept a variable number of arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\n\nclass Equation(ABC):\n    degree: int\n--fcc-editable-region--\n    def __init__(self):\n        pass\n--fcc-editable-region--\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n\n    def solve(self):\n        pass\n\n    def analyze(self):\n        pass\n\n\nlin_eq = LinearEquation()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `__init__` method should take two parameters, `self`, and `*args`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").has_args(\"self, *args\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6675aaf418b41157f6ccd692.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667938f754145d165c25725d",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "An interesting feature of f-strings is the capability of forcing the output to be right/left-aligned, or centered. After the expression to be evaluated is inside the curly braces, you need to write a colon followed by an alignment option (`<` to left-align, `>` to right-align, `^` to center) and a number representing the width, that is the number of characters in which you want to arrange the text. For example:\n\n```py\nf'{\"Hello World\":>20}'\n```\n\nPrinting the string from the example above would result in right-aligned text arranged in a space of 20 characters.\n\nBack to the `solver` function, after your `if` statement, create a variable named `output_string` and assign it an f-string containing the equation type centered in a width of `24` characters. Make the string begin with a new line character, and return `output_string` from your function.\n\nThen, call the `solver` function passing `lin_eq` as the argument, and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n            \n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n--fcc-editable-region--\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a variable named `output_string` and assign it `f'\\n{equation.type:^24}'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_stmt(\"output_string = f'\\\\\\\\n{equation.type:^24}'\")`)) })"
        },
        {
          "text": "Your `solver` function should return `output_string`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_return(\"output_string\")`)) })"
        },
        {
          "text": "You should print `solver(lin_eq)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(solver(lin_eq))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667938f754145d165c25725d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66793a552f357b17006a8726",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "Between the colon and the alignment option, you can specify a fill character, which will be used to fill the space around the text within the specified width.\n\nAdd a `-` between the colon and the `^` in your f-string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n            \n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n--fcc-editable-region--\n    output_string = f'\\n{equation.type:^24}'\n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a `-` character between the colon and the `^` in your f-string.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_stmt(\"output_string = f'\\\\\\\\n{equation.type:-^24}'\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66793a552f357b17006a8726.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66793c5b4bdacc17c40ff8e7",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "Another feature of f-strings enables you to convert the content of the replacement field (the curly braces) into a string by using a `!` followed by the conversion type `s`. For example, `f'{obj!s}'` converts `obj` into a string and it is equivalent to `f'{str(obj)}'`.\n\nFrom now on, you'll keep building the output by concatenating strings to `output_string`.\n\nCreate a string containing the string representation of your equation centered in a width of `24` characters. Make the string begin and end with two newline characters, and add your new string to the current value of `output_string`.\n\nThe output of the `solver` function should look like this:\n\n```md\n\n----Linear Equation-----\n\n       2x +3 = 0        \n\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n            \n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n--fcc-editable-region--\n    output_string = f'\\n{equation.type:-^24}'\n    \n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `solver` function should return a different string.\n\n```js\n({ test: () => runPython(`\neq = LinearEquation(4, 3)\nexpected = \"\"\"\n----Linear Equation-----\n\n4x +3 = 0\n\n\"\"\"\nassert solver(eq) == expected\n`) })\n```\n\nYou should use the conversion flag `!s` to convert `equation` into a string.",
          "testCode": "({ test: () => (runPython(`\nfunction = str(_Node(_code).find_function(\"solver\"))\nassert \"equation!s\" in function\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66793c5b4bdacc17c40ff8e7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66793d1e1581681871635ac6",
      "title": "Step 53",
      "challengeType": 20,
      "dashedName": "step-53",
      "description": "Add a new piece to your `output_string` formed by the string `'Solutions'` centered in a width of 24 characters. Use a `-` as a fill character, and make the string end with two new line characters.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n--fcc-editable-region--\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    \n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `solver` function should return a different string.\n\n```js\n({ test: () => runPython(`\neq = LinearEquation(4, 3)\nexpected = \"\"\"\n----Linear Equation-----\n\n4x +3 = 0\n\n-------Solutions--------\n\n\"\"\"\nassert solver(eq) == expected\n`) })\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66793d1e1581681871635ac6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66794346ddfa141cbe70093a",
      "title": "Step 54",
      "challengeType": 20,
      "dashedName": "step-54",
      "description": "Now, call the `solve()` method of `equation` and assign the result a variable named `results`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n--fcc-editable-region--\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    \n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `results` and assign it the result of calling `equation.solve()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_stmt(\"results = equation.solve()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66794346ddfa141cbe70093a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667944fed1f6b61da3406bd8",
      "title": "Step 55",
      "challengeType": 20,
      "dashedName": "step-55",
      "description": "Structural pattern matching is a Python construct that enables matching a pattern with a subject value, which is specified after the `match` keyword:\n\n```py\nmatch value:\n    case x:\n        <code>\n    case y:\n        <code>\n```\n\nEach pattern is specified after the `case` statement. If the match is positive, the code inside the `case` block is run.\n\nUse the `match`/`case` syntax to check the length of `results`. In case the length is `0`, assign a list containing the string `'No real roots'` to a variable named `result_list`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n--fcc-editable-region--\n    results = equation.solve()\n    \n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `match`/`case` construct using `len(results)` as the subject value.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_subject().is_equivalent(\"len(results)\")`)) })"
        },
        {
          "text": "You should create a new `case` with the pattern `0`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0].find_case_pattern().is_equivalent(\"0\")`)) })"
        },
        {
          "text": "You should assign a list containing `'No real roots'` to `result_list` inside the `case` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0].find_body().is_equivalent(\"result_list = ['No real roots']\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667944fed1f6b61da3406bd8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66799278873fd2570217bffa",
      "title": "Step 56",
      "challengeType": 20,
      "dashedName": "step-56",
      "description": "Add another `case` for when the length of `results` is `1`. In this case, assign to `result_list` a list containing a string with the format `x = <root>`, where `<root>` is the solution of the equation. Format the string so that both positive and negative sign are displayed for the solution.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n--fcc-editable-region--\n    match len(results):\n        case 0:\n            result_list = ['No real roots']\n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not modify the subject value of your `match` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_subject().is_equivalent(\"len(results)\")`)) })"
        },
        {
          "text": "You should not modify your existing `case` block.",
          "testCode": "({ test: () => runPython(`\ncase = _Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0]\nassert case.find_case_pattern().is_equivalent(\"0\")\nassert case.find_body().is_equivalent(\"result_list = ['No real roots']\")\n`) })"
        },
        {
          "text": "You should create a new `case` with the pattern `1` after the existing `case` block.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_case_pattern().is_equivalent(\"1\")`)) })"
        },
        {
          "text": "You should assign a list containing `f'x = {results[0]:+}'` to `result_list` inside your new `case` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_body().is_equivalent(\"result_list = [f'x = {results[0]:+}']\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66799278873fd2570217bffa.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6679934707d5fe577f898efd",
      "title": "Step 57",
      "challengeType": 20,
      "dashedName": "step-57",
      "description": "Add another case for when the length of `results` is `2`. This time, assign `result_list` a list containing two strings with the format `x1 = <root1>` and `x2 = <root2>`. Again, make the solution display both positive and negative signs.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n--fcc-editable-region--\n    match len(results):\n        case 0:\n            result_list = ['No real roots']\n        case 1:\n            result_list = [f'x = {results[0]:+}']\n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not modify the subject value of your `match` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_subject().is_equivalent(\"len(results)\")`)) })"
        },
        {
          "text": "You should not modify your existing `case` blocks.",
          "testCode": "({ test: () => runPython(`\ncase0 = _Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0]\nassert case0.find_case_pattern().is_equivalent(\"0\")\nassert case0.find_body().is_equivalent(\"result_list = ['No real roots']\")\ncase1 = _Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1]\nassert case1.find_case_pattern().is_equivalent(\"1\")\nassert case1.find_body().is_equivalent(\"result_list = [f'x = {results[0]:+}']\")\n`) })"
        },
        {
          "text": "You should create a new `case` with the pattern `2` after the existing `case` block.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_case_pattern().is_equivalent(\"2\")`)) })"
        },
        {
          "text": "You should assign a list containing two strings with the format `x1 = <root1>` and `x2 = <root2>` to `result_list` inside your new `case` body. Display both positive and negative signs for the results.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_body().is_equivalent(\"result_list = [f'x1 = {results[0]:+}', f'x2 = {results[1]:+}']\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6679934707d5fe577f898efd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66799ba07c5fd58a61a604d3",
      "title": "Step 58",
      "challengeType": 20,
      "dashedName": "step-58",
      "description": "After your `match`/`case` block, iterate through `result_list` and concatenate each element to `output_string`. Keep aligning the text to the center and make each result string end with a new line character.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n--fcc-editable-region--\n    match len(results):\n        case 0:\n            result_list = ['No real roots']\n        case 1:\n            result_list = [f'x = {results[0]:+}']\n        case 2:\n            result_list = [f'x1 = {results[0]:+}', f'x2 = {results[1]:+}']\n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `solver` function should return a different string.\n\n```js\n({ test: () => runPython(`\neq = LinearEquation(4, 3)\nexpected = \"\"\"\n----Linear Equation-----\n\n4x +3 = 0\n\n-------Solutions--------\n\nx = -0.75        \n\"\"\"\nassert solver(eq) == expected\n`) })\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66799ba07c5fd58a61a604d3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "66799c1a0204668cef35555d",
      "title": "Step 59",
      "challengeType": 20,
      "dashedName": "step-59",
      "description": "f-strings also enable you to set a specific precision to your numerical data by using the `.nf` format specifier, where `n` is the number of decimal digits to display.\n\nWithin the curly braces of the f-strings contained inside `result_list`, write the format specifier needed to display `3` decimal digits just after the `:+`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n--fcc-editable-region--\n    match len(results):\n        case 0:\n            result_list = ['No real roots']\n        case 1:\n            result_list = [f'x = {results[0]:+}']\n        case 2:\n            result_list = [f'x1 = {results[0]:+}', f'x2 = {results[1]:+}']\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the string contained in `result_list` in your `case 1` block into `f'x = {results[0]:+.3f}'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_body().is_equivalent(\"result_list = [f'x = {results[0]:+.3f}']\")`)) })"
        },
        {
          "text": "You should modify the strings contained in `result_list` in your `case 2` block so that the results are displayed with `3` decimal digits.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_body().is_equivalent(\"result_list = [f'x1 = {results[0]:+.3f}', f'x2 = {results[1]:+.3f}']\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\66799c1a0204668cef35555d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6679bf00da92e5c0db0ffdc3",
      "title": "Step 61",
      "challengeType": 20,
      "dashedName": "step-61",
      "description": "Right after your `for` loop, add another piece to your output. Create a string having the text `Details` centered. Use a `-` as a fill character and make your string begin with a single newline character and end with two newline characters.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n    match results:\n        case []:\n            result_list = ['No real roots']\n        case [x]:\n            result_list = [f'x = {x:+.3f}']\n        case [x1, x2]:\n            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n--fcc-editable-region--\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `solver` function should return a different string.\n\n```js\n({ test: () => runPython(`\neq = LinearEquation(4, 3)\nexpected = \"\"\"\n----Linear Equation-----\n\n4x +3 = 0\n\n-------Solutions--------\n\nx = -0.750\n\n--------Details---------\n\n\"\"\"\nassert solver(eq) == expected\n`) })\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6679bf00da92e5c0db0ffdc3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "6679bfe40a6d77c6a3c17e06",
      "title": "Step 62",
      "challengeType": 20,
      "dashedName": "step-62",
      "description": "Now, call the `analyze` method of `equation` and assign the result to a new variable named `details`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n    match results:\n        case []:\n            result_list = ['No real roots']\n        case [x]:\n            result_list = [f'x = {x:+.3f}']\n        case [x1, x2]:\n            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n--fcc-editable-region--\n    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `details` and assign it the result of calling `equation.analyze()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").has_stmt(\"details = equation.analyze()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\6679bfe40a6d77c6a3c17e06.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667a7ce2a9925416e7b4781b",
      "title": "Step 60",
      "challengeType": 20,
      "dashedName": "step-60",
      "description": "The structural pattern matching enables you to verify that the subject has a specific structure. In addition to that, it binds names in the pattern to elements of the subject. For example:\n\n```py\nmatch my_list:\n    case [a]:\n        print(a)\n    case [a, b]:\n        print(a, b)\n```\n\nModify your `match`/`case` construct to match `results` instead of `len(results)`. Then, modify each `case` to use a list with the appropriate number of elements. Use `x` for the case the list contains a single element, and `x1` and `x2` for the case the list contains two elements.\n\nFinally, modify the f-strings to use the variable names used in each `case`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n--fcc-editable-region--\n    match len(results):\n        case 0:\n            result_list = ['No real roots']\n        case 1:\n            result_list = [f'x = {results[0]:+.3f}']\n        case 2:\n            result_list = [f'x1 = {results[0]:+.3f}', f'x2 = {results[1]:+.3f}']\n--fcc-editable-region--\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `match` statement to use `results` as the subject value.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_subject().is_equivalent(\"results\")`)) })"
        },
        {
          "text": "You should modify your first `case` to use the pattern `[]`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0].find_case_pattern().is_equivalent(\"[]\")`)) })"
        },
        {
          "text": "You should not modify your first `case` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[0].find_body().is_equivalent(\"result_list = ['No real roots']\")`)) })"
        },
        {
          "text": "You should modify your second `case` to use the pattern `[x]`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_case_pattern().is_equivalent(\"[x]\")`)) })"
        },
        {
          "text": "You should modify the f-string contained inside `result_list` to use `x` in place of `result[0]`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[1].find_body().is_equivalent(\"result_list = [f'x = {x:+.3f}']\")`)) })"
        },
        {
          "text": "You should modify your third `case` to use a list containing `x1` and `x2` as the pattern.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_case_pattern().is_equivalent(\"[x1, x2]\")`)) })"
        },
        {
          "text": "You should modify the f-strings contained inside `result_list` to use the bound variables from your pattern.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[0].find_match_cases()[2].find_body().is_equivalent(\"result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667a7ce2a9925416e7b4781b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667a860c3b61f61b7a18930c",
      "title": "Step 63",
      "challengeType": 20,
      "dashedName": "step-63",
      "description": "Create another `match`/`case` construct to match the value of the `details` variable.\n\nWhen the equation is linear, `details` is a dictionary having the form `{'slope': slope, 'intercept': intercept}`. Use it as the pattern for your first `case`.\n\nThen, inside the `case` block, declare a variable named `details_list` and assign it a list containing two strings having the form `slope = <slope>` and `y-intercept = <intercept>`, respectively. Format the strings to display `3` decimal digits.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n    match results:\n        case []:\n            result_list = ['No real roots']\n        case [x]:\n            result_list = [f'x = {x:+.3f}']\n        case [x1, x2]:\n            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n--fcc-editable-region--\n    details = equation.analyze()\n    \n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a new `match` statement that uses `details` as the subject value.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[1].find_match_subject().is_equivalent(\"details\")`)) })"
        },
        {
          "text": "You should create a new `case` with the pattern `{'slope': slope, 'intercept': intercept}`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[1].find_match_cases()[0].find_case_pattern().is_equivalent(\"{'slope': slope, 'intercept': intercept}\")`)) })"
        },
        {
          "text": "You should assign a list containing two f-strings having the form `slope = <slope>` and `y-intercept = <intercept>` to `details_list` inside the `case` body. Remember to format the numerical values to display `3` decimal digits.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[1].find_match_cases()[0].find_body().is_equivalent(\"details_list = [f'slope = {slope:.3f}', f'y-intercept = {intercept:.3f}']\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667a860c3b61f61b7a18930c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667a8d7a735cf221729570ff",
      "title": "Step 64",
      "challengeType": 20,
      "dashedName": "step-64",
      "description": "Add another `case` for when the equation is quadratic. Use a dictionary with the same format returned by the `analyze` method of `QuadraticEquation`.\n\nThen, assign `details_list` a list containing two strings with the format `concavity = <concavity>` and `<min_max> = (<x>, <y>)`, respectively. Format `<x>` and `<y>` to display `3` decimal digits.\n\nFinally, after the `match`/`case` block, iterate through `details_list` and add each item to the current value of `output_string`. Make sure that each string item ends with a newline character. Do not use any additional format option here.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n    match results:\n        case []:\n            result_list = ['No real roots']\n        case [x]:\n            result_list = [f'x = {x:+.3f}']\n        case [x1, x2]:\n            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n--fcc-editable-region--\n    details = equation.analyze()\n    match details:\n        case {'slope': slope, 'intercept': intercept}:\n            details_list = [f'slope = {slope:.3f}', f'y-intercept = {intercept:.3f}']\n    \n--fcc-editable-region--\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not modify the subject value of your `match` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_matches()[1].find_match_subject().is_equivalent(\"details\")`)) })"
        },
        {
          "text": "You should not modify your existing `case` block.",
          "testCode": "({ test: () => runPython(`\ncase = _Node(_code).find_function(\"solver\").find_matches()[1].find_match_cases()[0]\nassert case.find_case_pattern().is_equivalent(\"{'slope': slope, 'intercept': intercept}\")\nassert case.find_body().is_equivalent(\"details_list = [f'slope = {slope:.3f}', f'y-intercept = {intercept:.3f}']\")\n`) })"
        },
        {
          "text": "You should create a new `case` block for when `equation` is a quadratic equation.",
          "testCode": "({ test: () => assert(runPython(`len(_Node(_code).find_function(\"solver\").find_matches()[1].find_match_cases()) == 2`)) })"
        },
        {
          "text": "You should create a `for` loop to iterate over `details_list`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"solver\").find_for_loops()[1].find_for_iter().is_equivalent(\"details_list\")`)) })"
        },
        {
          "text": "Your `solver` function should return a different string.\n\n```js\n({ test: () => runPython(`\nexpected1 = \"\"\"\n----Linear Equation-----\n\n4x +3 = 0\n\n-------Solutions--------\n\nx = -0.750\n\n--------Details---------\n\nslope = 4.000\ny-intercept = 3.000\n\"\"\"\neq1 = LinearEquation(4, 3)\nactual1 = solver(eq1)\nassert expected1 == actual1\n\nexpected2 = \"\"\"\n---Quadratic Equation---\n\nx**2 -3x +1 = 0\n\n-------Solutions--------\n\nx1 = +2.618       \n      x2 = +0.382\n\n--------Details---------\n\nconcavity = upwards\nmin = (1.500, -1.250)\n\"\"\"\neq2 = QuadraticEquation(1, -3, 1)\nactual2 = solver(eq2)\nassert expected2 == actual2\n`) })\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667a8d7a735cf221729570ff.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667a965d5a4b5825ffb2e1d8",
      "title": "Step 65",
      "challengeType": 20,
      "dashedName": "step-65",
      "description": "Modify the strings contained inside `details_list` to right-align the numerical values of the slope and the intercept. The final output should look like this:\n\n```py\n\n----Linear Equation-----\n\n       2x +3 = 0        \n\n-------Solutions--------\n\n       x = -1.500       \n\n--------Details---------\n\nslope =            2.000\ny-intercept =      3.000\n\n```\n\nNote that the align option and the width should be placed between the colon and the precision format specifier.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n    match results:\n        case []:\n            result_list = ['No real roots']\n        case [x]:\n            result_list = [f'x = {x:+.3f}']\n        case [x1, x2]:\n            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n    details = equation.analyze()\n    match details:\n        case {'slope': slope, 'intercept': intercept}:\n--fcc-editable-region--\n            details_list = [f'slope = {slope:.3f}', f'y-intercept = {intercept:.3f}']\n--fcc-editable-region--\n        case {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}:\n            coord = f'({x:.3f}, {y:.3f})'\n            details_list = [f'concavity = {concavity}', f'{min_max} = {coord}']\n    for detail in details_list:\n        output_string += f'{detail}\\n'    \n\n    return output_string\n\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `solver` function should return a different string.\n\n```js\n({ test: () => runPython(`\neq = LinearEquation(44, 3)\nexpected = \"\"\"\n----Linear Equation-----\n\n44x +3 = 0\n\n-------Solutions--------\n\nx = -0.068\n\n--------Details---------\n\nslope =           44.000\ny-intercept =      3.000\n\"\"\"\nassert solver(eq) == expected, f'{solver(eq)}'\n`) })\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667a965d5a4b5825ffb2e1d8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667a9c91a87bb453a355b63d",
      "title": "Step 66",
      "challengeType": 20,
      "dashedName": "step-66",
      "description": "Feel free to change the coefficients of your `lin_eq` to see how the output changes.\n\nThen, delete your `print(solver(lin_eq))` call, and print the result of calling `solver()` with `quadr_eq` as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n    match results:\n        case []:\n            result_list = ['No real roots']\n        case [x]:\n            result_list = [f'x = {x:+.3f}']\n        case [x1, x2]:\n            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n    details = equation.analyze()\n    match details:\n        case {'slope': slope, 'intercept': intercept}:\n            details_list = [f'slope = {slope:>16.3f}', f'y-intercept = {intercept:>10.3f}']\n        case {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}:\n            coord = f'({x:.3f}, {y:.3f})'\n            details_list = [f'concavity = {concavity}', f'{min_max} = {coord}']\n    for detail in details_list:\n        output_string += f'{detail}\\n'\n    return output_string\n--fcc-editable-region--\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(lin_eq))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(solver(lin_eq))` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(solver(lin_eq))\")`)) })"
        },
        {
          "text": "You should print `solver(quadr_eq)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(solver(quadr_eq))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667a9c91a87bb453a355b63d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667aa056f1240f58fb9a2c17",
      "title": "Step 67",
      "challengeType": 20,
      "dashedName": "step-67",
      "description": "As a last step, modify the strings contained in `details_list` so that the text placed after the equal sign is right-aligned for each line. Your final output should look like this:\n\n```py\n\n---Quadratic Equation---\n\n    x**2 +2x +1 = 0     \n\n-------Solutions--------\n\n       x = -1.000       \n\n--------Details---------\n\nconcavity =      upwards\nmin =    (-1.000, 0.000)\n\n```\n\nWith that, the project is complete!",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n    match results:\n        case []:\n            result_list = ['No real roots']\n        case [x]:\n            result_list = [f'x = {x:+.3f}']\n        case [x1, x2]:\n            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n    details = equation.analyze()\n    match details:\n        case {'slope': slope, 'intercept': intercept}:\n            details_list = [f'slope = {slope:>16.3f}', f'y-intercept = {intercept:>10.3f}']\n        case {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}:\n            coord = f'({x:.3f}, {y:.3f})'\n--fcc-editable-region--\n            details_list = [f'concavity = {concavity}', f'{min_max} = {coord}']\n--fcc-editable-region--\n    for detail in details_list:\n        output_string += f'{detail}\\n'\n    return output_string\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(quadr_eq))"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\nimport re\n\n\nclass Equation(ABC):\n    degree: int\n    type: str\n  \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'Equation' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n        if any(not isinstance(arg, (int, float)) for arg in args):\n            raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n        if args[0] == 0:\n            raise ValueError(\"Highest degree coefficient must be different from zero\")\n        self.coefficients = {(len(args) - n - 1): arg for n, arg in enumerate(args)}\n\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n        if not hasattr(cls, \"type\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'type'\"\n            )\n\n    def __str__(self):\n        terms = []\n        for n, coefficient in self.coefficients.items():\n            if not coefficient:\n                continue\n            if n == 0:\n                terms.append(f'{coefficient:+}')\n            elif n == 1:\n                terms.append(f'{coefficient:+}x')\n            else:\n                terms.append(f\"{coefficient:+}x**{n}\")\n        equation_string = ' '.join(terms) + ' = 0'\n        return re.sub(r\"(?<!\\d)1(?=x)\", \"\", equation_string.strip(\"+\"))        \n\n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n\n\nclass LinearEquation(Equation):\n    degree = 1\n    type = 'Linear Equation'\n    \n    def solve(self):\n        a, b = self.coefficients.values()\n        x = -b / a\n        return [x]\n\n    def analyze(self):\n        slope, intercept = self.coefficients.values()\n        return {'slope': slope, 'intercept': intercept}\n\n\nclass QuadraticEquation(Equation):\n    degree = 2\n    type = 'Quadratic Equation'\n\n    def __init__(self, *args):\n        super().__init__(*args)\n        a, b, c = self.coefficients.values()\n        self.delta = b**2 - 4 * a * c\n\n    def solve(self):\n        if self.delta < 0:\n            return []\n        a, b, _ = self.coefficients.values()\n        x1 = (-b + (self.delta) ** 0.5) / (2 * a)\n        x2 = (-b - (self.delta) ** 0.5) / (2 * a)\n        if self.delta == 0:\n            return [x1]\n\n        return [x1, x2]\n\n    def analyze(self):\n        a, b, c = self.coefficients.values()\n        x = -b / (2 * a)\n        y = a * x**2 + b * x + c\n        if a > 0:\n            concavity = 'upwards'\n            min_max = 'min'\n        else:\n            concavity = 'downwards'\n            min_max = 'max'\n        return {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}\n\n\ndef solver(equation):\n    if not isinstance(equation, Equation):\n        raise TypeError(\"Argument must be an Equation object\")\n\n    output_string = f'\\n{equation.type:-^24}'\n    output_string += f'\\n\\n{equation!s:^24}\\n\\n'\n    output_string += f'{\"Solutions\":-^24}\\n\\n'\n    results = equation.solve()\n    match results:\n        case []:\n            result_list = ['No real roots']\n        case [x]:\n            result_list = [f'x = {x:+.3f}']\n        case [x1, x2]:\n            result_list = [f'x1 = {x1:+.3f}', f'x2 = {x2:+.3f}']\n    for result in result_list:\n        output_string += f'{result:^24}\\n'\n    output_string += f'\\n{\"Details\":-^24}\\n\\n'\n    details = equation.analyze()\n    match details:\n        case {'slope': slope, 'intercept': intercept}:\n            details_list = [f'slope = {slope:>16.3f}', f'y-intercept = {intercept>10:.3f}']\n        case {'x': x, 'y': y, 'min_max': min_max, 'concavity': concavity}:\n            coord = f'({x:.3f}, {y:.3f})'\n            details_list = [f'concavity = {concavity:>12}', f'{min_max} = {coord:>18}']\n    for detail in details_list:\n        output_string += f'{detail}\\n'\n    return output_string\nlin_eq = LinearEquation(2, 3)\nquadr_eq = QuadraticEquation(1, 2, 1)\nprint(solver(quadr_eq))"
        }
      ],
      "tests": [
        {
          "text": "The `solver` function should return a different string.\n\n```js\n({ test: () => runPython(`\neq = QuadraticEquation(-4, 3, 2)\nexpected = \"\"\"\n---Quadratic Equation---\n\n-4x**2 +3x +2 = 0\n\n-------Solutions--------\n\nx1 = -0.425       \n      x2 = +1.175\n\n--------Details---------\n\nconcavity =    downwards\nmax =     (0.375, 2.562)\n\"\"\"\nassert solver(eq) == expected\n`) })\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667aa056f1240f58fb9a2c17.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "667e623208053643ca9d3c6e",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "Now, replace the `for` loop and `if` statement you added in the previous step with an `if` statement that uses the `any()` built-in function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "from abc import ABC, abstractmethod\n\n\nclass Equation(ABC):\n    degree: int\n    \n    def __init__(self, *args):\n        if (self.degree + 1) != len(args):\n            raise TypeError(\n                f\"'{self.__class__.__name__}' object takes {self.degree + 1} positional arguments but {len(args)} were given\"\n            )\n--fcc-editable-region--\n        for arg in args:\n            if not isinstance(arg, (int, float)):\n                raise TypeError(\"Coefficients must be of type 'int' or 'float'\")\n--fcc-editable-region--\n    def __init_subclass__(cls):\n        if not hasattr(cls, \"degree\"):\n            raise AttributeError(\n                f\"Cannot create '{cls.__name__}' class: missing required attribute 'degree'\"\n            )\n    \n    @abstractmethod\n    def solve(self):\n        pass\n        \n    @abstractmethod\n    def analyze(self):\n        pass\n        \nclass LinearEquation(Equation):\n    degree = 1\n    \n    def solve(self):\n        pass\n    \n    def analyze(self):\n        pass\n    \nlin_eq = LinearEquation(2, 3)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The condition of your new `if` statement should be a call to `any()`.",
          "testCode": "({ test: () => runPython(`\ncond = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_conditions()[0]\ncalls = _Node(str(cond)).find_calls(\"any\")\nassert len(calls) == 1\n`) })"
        },
        {
          "text": "You should pass a generator expression as the argument to your `any()` call.",
          "testCode": "({ test: () => runPython(`\nimport ast\nargument = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_conditions()[0].find_call_args()[0]\nassert isinstance(argument.tree, ast.GeneratorExp)\n`) })"
        },
        {
          "text": "The generator expression passed to `any()` should iterate over `args`.",
          "testCode": "({ test: () => runPython(`\nimport ast\nargument = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_conditions()[0].find_call_args()[0]\niters = argument.find_comp_iters()\nassert len(iters) == 1\nassert iters[0].is_equivalent(\"args\")\n`) })"
        },
        {
          "text": "Your `if` statement should check if any of the arguments in `args` is not an instance of either `int` or `float`.",
          "testCode": "({ test: () => runPython(`\nimport ast\nargument = _Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_conditions()[0].find_call_args()[0]\ntarget = argument.find_comp_targets()[0]\nexpr = argument.find_comp_expr()\nsolutions = [\n  f\"not isinstance({target}, (int, float))\",\n  f\"not isinstance({target}, (float, int))\",\n  f\"not isinstance({target}, float) and not isinstance({target}, int)\",\n  f\"not isinstance({target}, int) and not isinstance({target}, float)\",\n]\nassert any(expr.is_equivalent(sol) for sol in solutions)\n`) })"
        },
        {
          "text": "You should use the provided string to raise a `TypeError` within your new `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Equation\").find_function(\"__init__\").find_ifs()[1].find_bodies()[0].has_stmt(\"raise TypeError(\\\\\"Coefficients must be of type 'int' or 'float'\\\\\")\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-interfaces-by-building-an-equation-solver\\667e623208053643ca9d3c6e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-interfaces-by-building-an-equation-solver",
        "name": "Learn Interfaces By Building An Equation Solver"
      }
    },
    {
      "id": "658212ba98182f3e855e85f9",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "In this project, you're going to build a simple, yet functional expense tracker in Python.\n\nStart by defining a function named `add_expense` that takes three parameters: `expenses`, `amount` and `category`. Use the `pass` keyword to fill the function body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `def` keyword to declare a function named `add_expense`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    inspect.isfunction(add_expense)\n  `))\n})"
        },
        {
          "text": "Your `add_expense` function should take three parameters: `expenses`, `amount` and `category`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    sig = str(inspect.signature(add_expense))\n    sig == '(expenses, amount, category)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658212ba98182f3e855e85f9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65821c1c40ccac44adf38e6b",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "Create an empty list named `expenses`. You will use it to store each of your expenses.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    pass\n    \n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a new variable named `expenses`.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"expenses\")) })"
        },
        {
          "text": "You should assign an empty list to the `expenses` variable.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"expenses\").length, 0) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65821c1c40ccac44adf38e6b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65821fcc010c3245718f2a06",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "The `expenses` parameter of your `add_expense` function will be a list of expenses. You want to be able to add items at the end of your list. For that you'll use the `.append()` list method.\n\nAdd a call to the `.append()` method on the `expenses` list. Don't pass any arguments to `.append()` for now.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef add_expense(expenses, amount, category):\n    pass\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `expenses.append()` in your function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"add_expense\").has_stmt(\"expenses.append()\")`)) })"
        },
        {
          "text": "You should not have `pass` in your function.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).find_function(\"add_expense\").has_pass()`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65821fcc010c3245718f2a06.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65822308ded1ba4632f66aa3",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "A dictionary is another built-in data type in Python. A dictionary is a collection of data in the form of *key*-*value* pairs. Dictionaries are defined with curly braces (`{}`) and they contain key-value pairs separated by commas. Each key is followed by a colon (`:`) and the value:\n\n```py\n{'amount': 50.0, 'category': 'Food'}\n```\n\nIn the example above, `'amount'` and `'category'` are keys, and `50.0` and `'Food'` are their corresponding values.\n\nCreate a dictionary with a key `'amount'` and value of the `amount` parameter and pass your new dictionary to the `.append()` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef add_expense(expenses, amount, category):\n    expenses.append()\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass a dictionary as the argument to the `.append()` method.",
          "testCode": "({ test: () => assert(runPython(`\nimport ast\nnode = _Node(_code).find_function(\"add_expense\").find_calls(\"append\")[0].find_call_args()\nlen(node) == 1 and isinstance(node[0].tree, ast.Dict)\n`)) })"
        },
        {
          "text": "You should pass `{'amount': amount}` as the argument to the `.append()` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"add_expense\").has_stmt(\"expenses.append({'amount': amount})\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65822308ded1ba4632f66aa3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "658225d560369446ece5518b",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "Add another key-value pair to the dictionary you are appending to the `expense` list. Use the string `'category'` as the key, and the `category` parameter as the value.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef add_expense(expenses, amount, category):\n    expenses.append({'amount': amount})\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a second key-value pair to the dictionary you are passing as the argument to the `.append()` method.",
          "testCode": "({ test: () => assert(runPython(`\nimport ast\nnode = _Node(_code).find_function(\"add_expense\").find_calls(\"append\")[0].find_call_args()\nlen(node) == 1 and isinstance(node[0].tree, ast.Dict) and len(node[0].tree.keys) == 2\n`)) })"
        },
        {
          "text": "You should pass `{'amount': amount, 'category': category}` as the argument to the `.append()` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"add_expense\").has_stmt(\"expenses.append({'amount': amount, 'category': category})\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658225d560369446ece5518b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6582267ef39f5047411c1743",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "Next, define a function named `print_expenses` that takes one parameter `expenses`. This function will later be used to display each expense in your list.\n\nFill the body of your new function with a `pass` statement.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \n--fcc-editable-region--\n\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a new function named `print_expenses`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    inspect.isfunction(print_expenses)\n  `))\n})"
        },
        {
          "text": "Your `print_expenses` function should take a single parameter `expenses`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    sig = str(inspect.signature(print_expenses))\n    sig == '(expenses)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6582267ef39f5047411c1743.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65822773f4c60a479ec89f66",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "Inside the `print_expenses` function, create a `for` loop that iterates over each item in the `expenses` list. Use `expense` as the loop variable and move `pass` inside the loop body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \n--fcc-editable-region--\ndef print_expenses(expenses):\n    pass\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop that iterates over `expenses` in your `print_expenses` function. Remember to use `pass` within the loop body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"print_expenses\").find_for_loops()[0].find_for_iter().is_equivalent(\"expenses\")`)) })"
        },
        {
          "text": "You should use `expense` as the loop variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"print_expenses\").find_for_loops()[0].find_for_vars().is_equivalent(\"expense\")`)) })"
        },
        {
          "text": "You should have `pass` only inside your loop body.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).find_function(\"print_expenses\").has_pass()`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65822773f4c60a479ec89f66.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65822934c8a0454803e3ef12",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "Next, you are going to display the details for each expense.\n\nInside the `for` loop, replace `pass` with a `print()` call and pass it the following f-string: `f'Amount: {expense}, Category: {expense}'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \n--fcc-editable-region--\ndef print_expenses(expenses):\n    for expense in expenses:\n        pass\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `f'Amount: {expense}, Category: {expense}'` in your `for` loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"print_expenses\").find_for_loops()[0].has_call(\"print(f'Amount: {expense}, Category: {expense}')\")`)) })"
        },
        {
          "text": "You should not have `pass` inside your loop body.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).find_function(\"print_expenses\").find_for_loops()[0].find_bodies()[0].has_pass()`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65822934c8a0454803e3ef12.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65822bd82d708c4895080c35",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "In Python, an important thing to know is that the same type of quote used to define a string cannot be used inside it. For example, the string `'I'm a string!'` is not valid. To use the single quote inside that string you should either:\n\n- Escape the quote by prepending a backlash to it: `'I\\'m a string!'`\n- Or use double quotes to define the string: `\"I'm a string!\"` (preferred).\n\nYou can access values in a dictionary through its keys. You need to use bracket notation and include the key between the square brackets:\n\n```py\nmy_dict = {'amount': 50.0, 'category': 'Food'}\nmy_dict['amount'] # 50.0\n```\n\nYou are currently interpolating the `expense` dictionary in your f-string. Modify the f-string expression to access the value of the `'amount'` key and the `'category'` key in the `expense` dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \n--fcc-editable-region--\ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense}, Category: {expense}')\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}'` to your `print()` call. Remember to use double quotes within your single-quoted f-string and vice versa.",
          "testCode": "({ test: () => assert.match(code, /^\\s+print\\s*\\(\\s*f(\"|')Amount: \\{\\s*expense\\s*\\[\\s*(?=[^\\1])(\"|')amount\\2\\s*\\]\\s*\\}, Category: \\{\\s*expense\\s*\\[\\s*(?=[^\\1])(\"|')category\\3\\s*\\]\\s*\\}\\1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65822bd82d708c4895080c35.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65823040bdb32949d4c1a96f",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "You will need a function to calculate the total amount of expenses.\n\nDefine a function named `total_expenses` that takes one parameter `expenses`. Fill the function body with a `pass` statement for now.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a function named `total_expenses`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    inspect.isfunction(total_expenses)\n  `))\n})"
        },
        {
          "text": "Your `total_expenses` function should take a single `expenses` parameter.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    sig = str(inspect.signature(total_expenses))\n    sig == '(expenses)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65823040bdb32949d4c1a96f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6582324b5d37fe4b622bc3c0",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "Lambda functions are brief, anonymous functions in Python, ideal for simple, one-time tasks. They are defined by the `lambda` keyword, and they use the following syntax:\n\n```py\nlambda x: expr\n```\n\nIn the example above, `x` represents a parameter to be used in the expression `expr`, and it acts just like any parameter in a traditional function. `expr` is the expression that gets evaluated and returned when the lambda function is called.\n\nCreate a variable named `test` and assign it a lambda function that takes an `x` parameter and returns `x * 2`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n\ndef total_expenses(expenses):\n    pass\n    \n--fcc-editable-region--\n\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `test`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_variable(\"test\")`))})"
        },
        {
          "text": "You should assign `lambda x: x * 2` to your `test` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"test\").is_equivalent(\"test = lambda x: x * 2\")`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6582324b5d37fe4b622bc3c0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6582352cbdbcde4d0c4f7b0b",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "To call a lambda function you can use the usual function syntax with a pair of parentheses after the variable name.\n\nCall your `test` lambda function and pass `3` as the argument. Then, print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n\ndef total_expenses(expenses):\n    pass\n    \n--fcc-editable-region--\ntest = lambda x: x * 2\n\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print(test(3))` in your code.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*test\\s*\\(\\s*3\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6582352cbdbcde4d0c4f7b0b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65823634a308cb4d6bcc5fa6",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Lambda functions can be valuably combined with the `map()` function, which executes a specified function for each element in a collection of objects, such as a list:\n\n```py\nmap(lambda x: x * 2, [1, 2, 3])\n```\n\nThe function to execute is passed as the first argument, and the iterable is passed as the second argument.\n\nThe result of the example above would be `[2, 4, 6]`, where each item in the list passed to `map()` has been doubled by the action of the lambda function.\n\nModify your `print()` call to print the result of calling `map()` with `test` as the first argument, and `[2, 3, 5, 8]` as the second argument. You won't be able to see a readable output yet.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n\ndef total_expenses(expenses):\n    pass\n    \n--fcc-editable-region--\ntest = lambda x: x * 2\nprint(test(3))\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print(map(test, [2, 3, 5, 8]))` in your code.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*map\\s*\\(\\s*test\\s*,\\s*\\[\\s*2\\s*,\\s*3\\s*,\\s*5\\s*,\\s*8\\s*\\]\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65823634a308cb4d6bcc5fa6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "658238f7604f154ea9a23e1e",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "The `sum()` function returns the sum of the items in the iterable which is passed as its argument. You are going to use `sum()` together with `map()` and `lambda` functions to get the total amount of expenses.\n\nFor now, make a little test and modify your current `print()` call replacing the `list()` call with a call to the `sum()` function passing it the current `map()` call as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n\ndef total_expenses(expenses):\n    pass\n    \n--fcc-editable-region--\ntest = lambda x: x * 2\nprint(list(map(test, [2,3,5,8])))\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `sum(map(test, [2, 3, 5, 8]))`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*sum\\s*\\(\\s*map\\s*\\(\\s*test\\s*,\\s*\\[\\s*2\\s*,\\s*3\\s*,\\s*5\\s*,\\s*8\\s*\\]\\s*\\)\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658238f7604f154ea9a23e1e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65823b0167fd894f4a7ea60a",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "Next, you are going to implement the same logic within the `total_expenses` function.\n\nFor now, delete both the `test` function and the `print()` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n\ndef total_expenses(expenses):\n    pass\n    \n--fcc-editable-region--\ntest = lambda x: x * 2\nprint(sum(map(test, [2, 3, 5, 8])))\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete your `test` variable and the related `print()` call.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_variable(\"test\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65823b0167fd894f4a7ea60a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65823bbbdb4eaa4f9d20a0fb",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "In the `total_expenses` function, you'll now integrate a lambda function. Replace `pass` with a lambda function that has `expense` as its parameter.\n\n`expense` is expected to be a dictionary, and your lambda function should return the value of the `'amount'` key in the `expense` dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \n--fcc-editable-region--\ndef total_expenses(expenses):\n    pass\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `lambda` function that uses the parameter `expense` and returns `expense['amount']` in your `total_expenses` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"total_expenses\").has_stmt(\"lambda expense: expense['amount']\")`)) })"
        },
        {
          "text": "You should not have `pass` in your `total_expenses` function.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).find_function(\"total_expenses\").has_pass()`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65823bbbdb4eaa4f9d20a0fb.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65823cfc74aa564ffc460489",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "Now, call `map()` passing your `lambda` function as the first argument and the `expenses` list as the second argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \n--fcc-editable-region--\ndef total_expenses(expenses):\n    lambda expense: expense['amount']\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `map()` function inside the `total_expenses` function.",
          "testCode": "({ test: () => assert(runPython(`len(_Node(_code).find_function(\"total_expenses\").find_calls(\"map\")) == 1`)) })"
        },
        {
          "text": "You should pass your `lambda` function as the first argument to the `map()` call.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"total_expenses\").find_calls(\"map\")[0].find_call_args()[0].is_equivalent(\"lambda expense: expense['amount']\")`)) })"
        },
        {
          "text": "You should pass the `expenses` list as the second argument to the `map()` call.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"total_expenses\").find_calls(\"map\")[0].find_call_args()[1].is_equivalent(\"expenses\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65823cfc74aa564ffc460489.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65823dde36392f505a39f7c7",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "Finally, pass your `map()` call to the `sum()` function to obtain the total expenses and return the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \n--fcc-editable-region--\ndef total_expenses(expenses):\n    map(lambda expense: expense['amount'], expenses)\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `sum()` function passing it your current `map()` call as the argument and return the result from your `total_expenses` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"total_expenses\").has_return(\"sum(map(lambda expense: expense['amount'], expenses))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65823dde36392f505a39f7c7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65823e87c9741750a22085a7",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "Next, define a function named `filter_expenses_by_category` that takes two parameters: `expenses` and `category`. Use `pass` to fill the function body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \n--fcc-editable-region--\n\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a function named `filter_expenses_by_category`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    inspect.isfunction(filter_expenses_by_category)\n  `))\n})"
        },
        {
          "text": "Your `filter_expenses_by_category` function should take `expenses` and `category` as the parameters.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    sig = str(inspect.signature(filter_expenses_by_category))\n    sig == '(expenses, category)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65823e87c9741750a22085a7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65823ff0d4b991510fade1a8",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "Within the `filter_expenses_by_category` function, replace `pass` with a `lambda` function. Use `expense` as the parameter and evaluate the comparison between the value of the `'category'` key of the `expense` dictionary and `category` using the equality operator.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \n--fcc-editable-region--\ndef filter_expenses_by_category(expenses, category):\n    pass\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `lambda` function that uses a parameter named `expense` and evaluates the expression `expense['category'] == category` inside the `filter_expenses_by_category` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"filter_expenses_by_category\").has_stmt(\"lambda expense: expense['category'] == category\")`)) })"
        },
        {
          "text": "You should not have `pass` inside the `filter_expenses_by_category` function.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).find_function(\"filter_expenses_by_category\").has_pass()`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65823ff0d4b991510fade1a8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65824111a09164518320088d",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "The `filter()` function allows you to select items from an iterable, such as a list, based on the output of a function: \n\n```py\nfilter(my_function, my_list)\n```\n\n`filter()` takes a function as its first argument and an iterable as its second argument. It returns an iterator, which is a special object that enables you to iterate over the elements of a collection, like a list.\n\nThe result of the example above is an iterator containing the elements of `my_list` for which `my_function` returns `True`. \n\nWithin the `filter_expenses_by_category` function, call `filter()` passing the `lambda` function you wrote in the previous step as the first argument and the `expenses` list as the second argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \n--fcc-editable-region--\ndef filter_expenses_by_category(expenses, category):\n    lambda expense: expense['category'] == category\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `filter()` inside the `filter_expenses_by_category` function.",
          "testCode": "({ test: () => assert(runPython(`len(_Node(_code).find_function(\"filter_expenses_by_category\").find_calls(\"filter\")) == 1`)) })"
        },
        {
          "text": "You should pass `lambda expense: expense['category'] == category` as the first argument to the `filter()` call.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"filter_expenses_by_category\").find_calls(\"filter\")[0].find_call_args()[0].is_equivalent(\"lambda expense: expense['category'] == category\")`)) })"
        },
        {
          "text": "You should pass `expenses` as the second argument to the `filter()` call.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"filter_expenses_by_category\").find_calls(\"filter\")[0].find_call_args()[1].is_equivalent(\"expenses\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65824111a09164518320088d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "658244fdf4b0265334711664",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "Finally, return the result of the `filter()` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \n--fcc-editable-region--\ndef filter_expenses_by_category(expenses, category):\n    filter(lambda expense: expense['category'] == category, expenses)\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return the result of the `filter()` call from your `filter_expenses_by_category` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"filter_expenses_by_category\").has_return(\"filter(lambda expense: expense['category'] == category, expenses)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658244fdf4b0265334711664.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65824561f3478e5371a33ae5",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "The next step is to define the main function, which will be the entry point of the interactive expense tracker program.\n\nDefine a function named `main` without parameters. Fill the function body with the `expenses` list you created at the beginning of this project. You will use this list to store the expense records.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n--fcc-editable-region--\n\nexpenses = []\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a function named `main()` without parameters.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    inspect.isfunction(main)\n    sig = str(inspect.signature(main))\n    sig == '()'\n  `))\n})"
        },
        {
          "text": "You should move the `expenses` list inside the `main()` function body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_body().is_equivalent(\"expenses = []\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65824561f3478e5371a33ae5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "658246c28575d653d1f89b59",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "A `while` loop is another kind of loop that runs a portion of code as long as a specified condition is `True`. The loop terminates when the condition becomes `False`:\n\n```py\nwhile condition:\n    <code>\n```\n\nBelow the `expenses` list, create a `while` loop. Use `True` for the condition, and print the string `'\\nExpense Tracker'` inside the loop body to show the title of the program.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n--fcc-editable-region--\ndef main():\n    expenses = []\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `while` loop using `True` as the condition within your `main()` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_conditions()[0].is_equivalent(\"True\")`)) })"
        },
        {
          "text": "You should print `'\\nExpense Tracker'` in your `while` loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_calls(\"print\")[0].is_equivalent(\"print('\\\\\\\\nExpense Tracker')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658246c28575d653d1f89b59.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65824872894f59546e3084e2",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "The `while` loop you created in the previous step is an infinite loop that will allow the program to continuously present menu options until the user decides to exit. \n\nAfter the `print()` call, add another `print()` call to print the string `'1. Add an expense'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n\ndef main():\n    expenses = []\n--fcc-editable-region--\n    while True:\n        print('\\nExpense Tracker')\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `'1. Add an expense'` within your `while` loop after the existing `print()` call.",
          "testCode": "({ test: () => assert(runPython(`\ncall_lst = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_calls(\"print\")\ntest_lst = [\"print('\\\\\\\\nExpense Tracker')\", \"print('1. Add an expense')\"]\nall(call_lst[n].is_equivalent(i) for n, i in enumerate(test_lst))\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65824872894f59546e3084e2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65824a1b16631c54fa524154",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "Next, add another `print()` call and pass the string `'2. List all expenses'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n\ndef main():\n    expenses = []\n--fcc-editable-region--\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `'2. List all expenses'` in your `while` loop after the existing `print()` calls.",
          "testCode": "({ test: () => assert(runPython(`\ncall_lst = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_calls(\"print\")\ntest_lst = [\"print('\\\\\\\\nExpense Tracker')\", \"print('1. Add an expense')\", \"print('2. List all expenses')\"]\nall(call_lst[n].is_equivalent(i) for n, i in enumerate(test_lst))\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65824a1b16631c54fa524154.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65824c7b4e2da85597693dcf",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "Provide the other menu options by printing the following three strings in your `while` loop: `'3. Show total expenses'`, `'4. Filter expenses by category'`, and `'5. Exit'`. Keep adding the `print()` calls in order.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n\ndef main():\n    expenses = []\n--fcc-editable-region--\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print('3. Show total expenses')` in your `while` loop.",
          "testCode": "({ test: () => assert(runPython(`\ncall_lst = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_calls(\"print\")\ntest_lst = [\"print('\\\\\\\\nExpense Tracker')\", \"print('1. Add an expense')\", \"print('2. List all expenses')\", \"print('3. Show total expenses')\"]\nall(call_lst[n].is_equivalent(i) for n, i in enumerate(test_lst))\n`)) })"
        },
        {
          "text": "You should have `print('4. Filter expenses by category')` in your `while` loop.",
          "testCode": "({ test: () => assert(runPython(`\ncall_lst = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_calls(\"print\")\ntest_lst = [\"print('\\\\\\\\nExpense Tracker')\", \"print('1. Add an expense')\", \"print('2. List all expenses')\", \"print('3. Show total expenses')\", \"print('4. Filter expenses by category')\"]\nall(call_lst[n].is_equivalent(i) for n, i in enumerate(test_lst))\n`)) })"
        },
        {
          "text": "You should have `print('5. Exit')` in your `while` loop.",
          "testCode": "({ test: () => assert(runPython(`\ncall_lst = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_calls(\"print\")\ntest_lst = [\"print('\\\\\\\\nExpense Tracker')\", \"print('1. Add an expense')\", \"print('2. List all expenses')\", \"print('3. Show total expenses')\", \"print('4. Filter expenses by category')\", \"print('5. Exit')\"]\nall(call_lst[n].is_equivalent(i) for n, i in enumerate(test_lst))\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65824c7b4e2da85597693dcf.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65824dfdb6815d563b2d3256",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "The `input()` function takes a user input and it returns the user input in the form of a string.\n\nInside your `while` loop, call the `input()` function passing the string `'Enter your choice: '` as the argument, and assign the result to a variable named `choice`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n--fcc-editable-region--\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `choice` within your `while` loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].has_variable(\"choice\")\n`)) })"
        },
        {
          "text": "You should assign the result of the `input()` function, with the string `'Enter your choice: '` as its argument, to your `choice` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_variable(\"choice\").is_equivalent(\"choice = input('Enter your choice: ')\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65824dfdb6815d563b2d3256.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6582507654b3ed5712341382",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "You are going to use conditional statements to check the user's choice. If the choice is `'1'`, it means the user wants to add an expense.\n\nStill in the `while` loop, under the `choice` variable, write an `if` statement to check if `choice` equals the string `'1'`. If it's true, it will be the starting point for adding a new expense.\n\nInside the `if` statement body, declare a variable `amount` and assign it an empty `input()` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n--fcc-editable-region--\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if `choice` is equal to `'1'` in your `while` loop.",
          "testCode": "({ test: () => assert(runPython(`\ncond = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_conditions()[0]\ncond.is_equivalent(\"choice == '1'\") or cond.is_equivalent(\"'1' == choice\")\n`)) })"
        },
        {
          "text": "You should declare a variable named `amount` in your `if` statement body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].has_variable(\"amount\")\n`)) })"
        },
        {
          "text": "You should assign an empty `input()` call to your `amount` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].find_variable(\"amount\").is_equivalent(\"amount = input()\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6582507654b3ed5712341382.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "658252f6b1526d57b103d48a",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "Inside the `if` statement, you should ask the user to enter the amount for the expense and store it in a variable.\n\nPass the string `'Enter amount: '` to your empty `input()` call, so you can store the expense.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n--fcc-editable-region--\n        if choice == '1':\n            amount = input()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `'Enter amount: '` to the `input()` call assigned to the `amount` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].find_variable(\"amount\").is_equivalent(\"amount = input('Enter amount: ')\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658252f6b1526d57b103d48a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "658254db6e12485a48130f57",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "The amount of the expense needs to be converted before performing any calculation. The `float()` function takes a string or an integer number as argument and returns a floating point number.\n\nPass `input('Enter amount: ')` to the `float()` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n--fcc-editable-region--\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n        \n        if choice == '1':\n            amount = input('Enter amount: ')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `input('Enter amount: ')` to the `float()` function in the assignment of `amount`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].find_variable(\"amount\").is_equivalent(\"amount = float(input('Enter amount: '))\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658254db6e12485a48130f57.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "658255d5f955175b270f251d",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "Inside your `if` statement, create a variable named `category` to store the expense category. Assign it a call to `input()` and use the `'Enter category: '` as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n--fcc-editable-region--       \n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `category` in your `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].has_variable(\"category\")`)) })"
        },
        {
          "text": "You should assign `input('Enter category: ')` to your `category` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].find_variable(\"category\").is_equivalent(\"category = input('Enter category: ')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658255d5f955175b270f251d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6582575b8089f85b8b92d7c8",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "Once you have the expense details, you need to call the `add_expense` function to add the new expense to the `expenses` list.\n\nAfter getting the `amount` and `category` using `input()`, call the `add_expense` function, passing three arguments: `expenses`, `amount` and `category`. \n\n- `expenses` is the empty list created in the main function earlier in this project.\n- `amount` is the amount of the expense.\n- `category` is the category of the expense.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n--fcc-editable-region--\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `add_expense()` function within your `if` statement.",
          "testCode": "({ test: () => assert(runPython(`len(_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].find_calls(\"add_expense\")) == 1`)) })"
        },
        {
          "text": "You should pass three arguments to your `add_expense()` call: `expenses`, `amount`, and `category`. The order matters.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].has_call(\"add_expense(expenses, amount, category)\")`)) })"
        },
        {
          "text": "Your `add_expense()` call should come after the assignment of `amount` and `category`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[0].is_equivalent(\"amount = float(input('Enter amount: '))\\\\ncategory = input('Enter category: ')\\\\nadd_expense(expenses, amount, category)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6582575b8089f85b8b92d7c8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "658258c0e5fbe85c14c060cf",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "To list all expenses, you can use an `elif` clause after an `if` statement. The `elif` checks additional conditions and only works following an `if` statement.\n\nCreate an `elif` clause to check if the user's choice equals the string `'2'`. Inside the `elif` clause, print the string `'\\nAll Expenses:'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n--fcc-editable-region--\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `elif` clause that checks that `choice` is equal to `'2'` after your `if` statement.",
          "testCode": "({ test: () => assert(runPython(`\ncond = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_conditions()[1]\ncond.is_equivalent(\"choice == '2'\") or cond.is_equivalent(\"'2' == choice\")\n`)) })"
        },
        {
          "text": "You should print `'\\nAll Expenses:'` inside your `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[1].has_call(\"print('\\\\\\\\nAll Expenses:')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\658258c0e5fbe85c14c060cf.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65825a9520a0795c8afbef50",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "After the `print()` call, call the `print_expenses` function to display all the expenses that have been added so far. Pass the `expenses` list as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n--fcc-editable-region--\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `print_expenses()` function within your `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`len(_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[1].find_calls(\"print_expenses\")) == 1`)) })"
        },
        {
          "text": "You should pass the `expenses` list as the argument to your `print_expenses()` call.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[1].has_call(\"print_expenses(expenses)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65825a9520a0795c8afbef50.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65825b758fe85a5cebabc8c5",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "To show the total expenses, create an `elif` statement that checks if `choice == '3'`. \n\nIf it's true, it means the user wants to see the total expenses. So call `print()` and pass the string `'\\nTotal Expenses: '` as the first argument and `total_expenses(expenses)` as the second argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n       \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n--fcc-editable-region--\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `elif` clause that checks if `choice == '3'`.",
          "testCode": "({ test: () => assert(runPython(`\ncond = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_conditions()[2]\ncond.is_equivalent(\"choice == '3'\") or cond.is_equivalent(\"'3' == choice\")\n`)) })"
        },
        {
          "text": "You should print `'\\nTotal Expenses: ', total_expenses(expenses)` in your new `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[2].has_call(\"print('\\\\\\\\nTotal Expenses: ', total_expenses(expenses))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65825b758fe85a5cebabc8c5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65825cda2668995d5168e37c",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "Create another `elif` clause that checks if `choice == '4'`. Inside the new `elif`, create a variable `category` and assign it `input('Enter category to filter: ')` to filter the expense category.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n       \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n--fcc-editable-region--           \n        elif choice == '3':\n            print('\\nTotal Expenses: ', total_expenses(expenses))\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `elif` clause that checks if `choice == '4'`.",
          "testCode": "({ test: () => assert(runPython(`\ncond = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_conditions()[3]\ncond.is_equivalent(\"choice == '4'\") or cond.is_equivalent(\"'4' == choice\")\n`)) })"
        },
        {
          "text": "You should declared a variable named `category` in your new `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[3].has_variable(\"category\")`)) })"
        },
        {
          "text": "You should assign `input('Enter category to filter: ')` to your `category` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[3].find_variable(\"category\").is_equivalent(\"category = input('Enter category to filter: ')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65825cda2668995d5168e37c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65825e96b5db5f5dee6bf57c",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "After getting the category, print the following f-string `f'\\nExpenses for {category}:'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n       \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n\n        elif choice == '3':\n            print('\\nTotal Expenses: ', total_expenses(expenses))\n--fcc-editable-region--\n        elif choice == '4':\n            category = input('Enter category to filter: ')\n            \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `f'\\nExpenses for {category}:'` after the assignment of `category`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[3].is_equivalent(\"category = input('Enter category to filter: ')\\\\nprint(f'\\\\\\\\nExpenses for {category}:')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65825e96b5db5f5dee6bf57c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6582601b2987045e8e7da994",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "After your `print()` call, you need to filter the expenses and print the filtered list. Declare a variable `expenses_from_category` and assign it a call to `filter_expenses_by_category` passing `expenses` and `category` as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n\n        elif choice == '3':\n            print('\\nTotal Expenses: ', total_expenses(expenses))\n--fcc-editable-region--\n        elif choice == '4':\n            category = input('Enter category to filter: ')\n            print(f'\\nExpenses for {category}:')\n            \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `expenses_from_category` in your `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[3].has_variable(\"expenses_from_category\")`)) })"
        },
        {
          "text": "You should call `filter_expenses_by_category()` passing `expenses` and `category` as the arguments and assign it to your `expenses_from_category` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[3].find_variable(\"expenses_from_category\").is_equivalent(\"expenses_from_category = filter_expenses_by_category(expenses, category)\")`)) })"
        },
        {
          "text": "Your `expenses_from_category` variable should come after the `print()` call.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[3].is_equivalent(\"category = input('Enter category to filter: ')\\\\nprint(f'\\\\\\\\nExpenses for {category}:')\\\\nexpenses_from_category = filter_expenses_by_category(expenses, category)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6582601b2987045e8e7da994.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6582622cb6c11a5f4c5d79b4",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "Still within the `elif` clause, pass the `expenses_from_category` iterator to a `print_expenses` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n\n        elif choice == '3':\n            print('\\nTotal Expenses: ', total_expenses(expenses))\n--fcc-editable-region--\n        elif choice == '4':\n            category = input('Enter category to filter: ')\n            print(f'\\nExpenses for {category}:')\n            expenses_from_category = filter_expenses_by_category(expenses, category)\n            \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `print_expenses()` passing `expenses_from_category` as the argument in your `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[3].has_call(\"print_expenses(expenses_from_category)\")`)) })"
        },
        {
          "text": "Your `print_expenses()` call should come after the `expenses_from_category` variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[3].is_equivalent(\"category = input('Enter category to filter: ')\\\\nprint(f'\\\\\\\\nExpenses for {category}:')\\\\nexpenses_from_category = filter_expenses_by_category(expenses, category)\\\\nprint_expenses(expenses_from_category)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6582622cb6c11a5f4c5d79b4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6582687859366a618424d84b",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "To provide a way to exit the program, use another `elif` clause to check if `choice` equals the string `'5'`.\n\nInside the new `elif` clause, print the string `'Exiting the program.'` to show that the program is terminating its execution.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n\n        elif choice == '3':\n            print('\\nTotal Expenses: ', total_expenses(expenses))\n--fcc-editable-region--\n        elif choice == '4':\n            category = input('Enter category to filter: ')\n            print(f'\\nExpenses for {category}:')\n            expenses_from_category = filter_expenses_by_category(expenses, category)\n            print_expenses(expenses_from_category)\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `elif` clause that checks if `choice == '5'`.",
          "testCode": "({ test: () => assert(runPython(`\ncond = _Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_conditions()[4]\ncond.is_equivalent(\"choice == '5'\") or cond.is_equivalent(\"'5' == choice\")\n`)) })"
        },
        {
          "text": "You should print `'Exiting the program.'` in your new `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[4].has_call(\"print('Exiting the program.')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6582687859366a618424d84b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65826a6e9d189a623141c726",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "Finally, to stop the execution of the `while` loop, add the `break` statement inside your last `elif` clause.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n       \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n\n        elif choice == '3':\n            print('\\nTotal Expenses: ', total_expenses(expenses))\n\n        elif choice == '4':\n            category = input('Enter category to filter: ')\n            print(f'\\nExpenses for {category}:')\n            expenses_from_category = filter_expenses_by_category(expenses, category)\n            print_expenses(expenses_from_category)\n--fcc-editable-region--\n        elif choice == '5':\n            print('Exiting the program.')\n            \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `break` statement after the `print()` call inside your last `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"main\").find_whiles()[0].find_bodies()[0].find_ifs()[0].find_bodies()[4].is_equivalent(\"print('Exiting the program.')\\\\nbreak\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65826a6e9d189a623141c726.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "65826af5b226a5628aa154b1",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "Finally, call your `main()` function, and try the expense tracker program in the console.\n\nWith that, the expense tracker project is complete!",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n       \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n    \n        elif choice == '3':\n            print('\\nTotal Expenses: ', total_expenses(expenses))\n    \n        elif choice == '4':\n            category = input('Enter category to filter: ')\n            print(f'\\nExpenses for {category}:')\n            expenses_from_category = filter_expenses_by_category(expenses, category)\n            print_expenses(expenses_from_category)\n    \n        elif choice == '5':\n            print('Exiting the program.')\n            break\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n    \ndef total_expenses(expenses):\n    return sum(map(lambda expense: expense['amount'], expenses))\n    \ndef filter_expenses_by_category(expenses, category):\n    return filter(lambda expense: expense['category'] == category, expenses)\n    \n\ndef main():\n    expenses = []\n    while True:\n        print('\\nExpense Tracker')\n        print('1. Add an expense')\n        print('2. List all expenses')\n        print('3. Show total expenses')\n        print('4. Filter expenses by category')\n        print('5. Exit')\n        \n        choice = input('Enter your choice: ')\n\n        if choice == '1':\n            amount = float(input('Enter amount: '))\n            category = input('Enter category: ')\n            add_expense(expenses, amount, category)\n\n        elif choice == '2':\n            print('\\nAll Expenses:')\n            print_expenses(expenses)\n\n        elif choice == '3':\n            print('\\nTotal Expenses: ', total_expenses(expenses))\n\n        elif choice == '4':\n            category = input('Enter category to filter: ')\n            print(f'\\nExpenses for {category}:')\n            expenses_from_category = filter_expenses_by_category(expenses, category)\n            print_expenses(expenses_from_category)\n\n        elif choice == '5':\n            print('Exiting the program.')\n            break\n\nmain()"
        }
      ],
      "tests": [
        {
          "text": "You should call your `main()` function.",
          "testCode": "assert.match(code, /^main\\s*\\(\\s*\\)/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\65826af5b226a5628aa154b1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "66314f2add0a8b57da5d6d91",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "You should see something like `<map object at 0xd273a8>` printed on the console, which is the string representation of the map object returned by `map()`.\n\nTo obtain a readable output you need to turn the map object into a list. Do it by passing the `map()` call as the argument to the `list()` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def add_expense(expenses, amount, category):\n    expenses.append({'amount': amount, 'category': category})\n    \ndef print_expenses(expenses):\n    for expense in expenses:\n        print(f'Amount: {expense[\"amount\"]}, Category: {expense[\"category\"]}')\n\ndef total_expenses(expenses):\n    pass\n    \n--fcc-editable-region--\ntest = lambda x: x * 2\nprint(map(test, [2, 3, 5, 8]))\n--fcc-editable-region--\n\nexpenses = []"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass the `map()` call as the argument to the `list()` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(list(map(test, [2,3,5,8])))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\66314f2add0a8b57da5d6d91.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "66694bfa435cef241f6f9a68",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "Before starting with the project, you are going to learn about lists.\n\nUnlike numbers and strings, a <dfn>list</dfn> is a data type that works as a container for other values:\n\n```py\nexample_list = [1, 2, 3, 4]\nempty_list = []\n```\n\nThe list is characterized by the square brackets around all the values, and a comma between the values, like: `[\"A\", \"happy\", \"list\"]`. If the list does not contain any values, then it is an empty list: `[]`.\n\nA list can contain different data types: `[1, \"Up\", [\"Down\", \"Twice\"]]`. That includes all possible data types. It can also contain another list!\n\nCreate a variable called `my_list` and assign to it an empty list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable called `my_list`.",
          "testCode": "({\n    test: () => runPython(`\n        assert _Node(_code).has_variable('my_list'), \"variable my_list not found\"\n    `)\n})"
        },
        {
          "text": "The variable `my_list` should have value of an empty list.",
          "testCode": "({\n    test: () => runPython(`\n        assert _Node(_code).find_variable('my_list').is_equivalent('my_list = []'), \"variable my_list is not an empty list\"\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\66694bfa435cef241f6f9a68.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "66694eaaeb7d253049fa7883",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "To add items to a list, you can write them between the square brackets, separating the values with commas.\n\nAdd the numbers `1` and `2` inside the list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_list = []\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The first element of `my_list` should be `1`.",
          "testCode": "({\n    test: () => runPython(`\n        assert my_list[0] == 1, \"my_list[0] is not 1\"\n    `)\n})"
        },
        {
          "text": "The second element of `my_list` should be `2`.",
          "testCode": "({\n    test: () => runPython(`\n        assert my_list[1] == 2, \"my_list[1] is not 2\"\n    `)\n})"
        },
        {
          "text": "`my_list` should have two elements inside.",
          "testCode": "({\n    test: () => runPython(`\n        assert len(my_list) == 2, \"my_list doesn't have two elements\"\n    `)\n})"
        },
        {
          "text": "You should assign `[1, 2]` to `my_list` directly.",
          "testCode": "({\n    test: () => runPython(`\n        assert _Node(_code).find_variable('my_list').is_equivalent(\"my_list = [1, 2]\")\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\66694eaaeb7d253049fa7883.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "66694fc4bba24f33ca01fa5b",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "Python has a handful of list methods. Such as methods for adding or removing list items.\n\nYou can add an item to the end of a list using the `append()` method. For example:\n\n```py\nexample_list = [4, 5, 6]\n\nexample_list.append(7)\n```\n\n`example_list` now is `[4, 5, 6, 7]`.\n\nTry to use the `append()` method to add `3` to `my_list`. Then print the list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_list = [1, 2]\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The last element of `my_list` should be `3`.",
          "testCode": "({\n    test: () => runPython(`\n        assert my_list[2] == 3, \"my_list[2] is not 3\"\n    `)\n})"
        },
        {
          "text": "`my_list` should have a length of 3.",
          "testCode": "({\n    test: () => runPython(`\n        assert len(my_list) == 3, \"my_list doesn't have three elements\"\n    `)\n})"
        },
        {
          "text": "You should not change the list declaration.",
          "testCode": "({\n    test: () => runPython(`\n        assert _Node(_code).find_variable('my_list').is_equivalent(\"my_list = [1, 2]\")\n    `)\n})"
        },
        {
          "text": "You should print the list.",
          "testCode": "({\n    test: () => runPython(`\n    calls = _Node(_code).find_calls(\"print\")\n    assert any(call.is_equivalent('print(my_list)') for call in calls)\n    `)\n})"
        },
        {
          "text": "You should print the list after using `append()`.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).is_ordered('my_list.append(3)', 'print(my_list)')\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\66694fc4bba24f33ca01fa5b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "666951d2e4b27e3a3c72ca5f",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "You can also access a single element to get its value.\n\nLists are zero-indexed like strings are. That means that the first element is at index `0`, the second element is at index `1` and so on.\n\nTo access an element you use bracket notation. For example, `example_list[1]` is accessing the element at index `1`, the second element, of `example_list`.\n\nPrint the first element of `my_list`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_list = [1, 2]\n\nmy_list.append(3)\nprint(my_list)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the first element of the list with `print(my_list[0])`.",
          "testCode": "({\n    test: () => runPython(`\ncalls =  _Node(_code).find_calls(\"print\")\nassert any(call.is_equivalent('print(my_list[0])') for call in calls), \"print of my_list[0] not found\"\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\666951d2e4b27e3a3c72ca5f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "6669539c1379793f9cb8917c",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Python lists are mutable which means that the value of the list items can be changed. You can change the value of an element using the bracket notation.\n\n```py\nexample_list = [4, 5, 6, 7]\nexample_list[1] = 'oh'\n```\n\nThis will make `example_list` have value of `[4, 'oh', 6, 7]`.\n\nChange the first element of `my_list` to `0`, then print the list to check the value.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_list = [1, 2]\n\nmy_list.append(3)\nprint(my_list)\n\nprint(my_list[0])\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Do not change the list declaration.",
          "testCode": "({\n    test: () => runPython(`\n        assert _Node(_code).find_variable('my_list').is_equivalent(\"my_list = [1, 2]\")\n    `)\n})"
        },
        {
          "text": "The first element of `my_list` should be 0.",
          "testCode": "({\n    test: () => runPython(`\n        assert my_list[0] == 0\n    `)\n})"
        },
        {
          "text": "You should change the first element using `my_list[0] = 0`.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).has_stmt(\"my_list[0] = 0\")\n    `)\n})"
        },
        {
          "text": "You should print the list.",
          "testCode": "({\n    test: () => runPython(`\n        calls = _Node(_code).find_calls('print')\n        assert any(call.is_equivalent(\"print(my_list)\") for call in calls)\n    `)\n})"
        },
        {
          "text": "You should print the list after changing the first element.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).is_ordered(\"my_list[0] = 0\", \"print(my_list)\")\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\6669539c1379793f9cb8917c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "666aae6a5d30a71f1fd7749f",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "The `insert` method can add an element at any position in a list. The first argument is the position at which the element has to be added, and the second argument is the element to add. For example, here's how to add a new element in the third position of `example_list`:\n\n```py\nexample_list = [4, 5, 6, 7]\n\nexample_list.insert(2, 5.5)\n\nprint(example_list) # [4, 5, 5.5, 6, 7]\n```\n\nUsing `insert()`, add `1` to `my_list` in the proper position so that it is counting upward, then print the list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_list = [1, 2]\n\nmy_list.append(3)\nprint(my_list)\n\nprint(my_list[0])\n\nmy_list[0] = 0\nprint(my_list)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add `1` to `my_list` at index `1` using `insert()`.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).has_call('my_list.insert(1, 1)')\n    `)\n})"
        },
        {
          "text": "`my_list` should have 4 elements.",
          "testCode": "({\n    test: () => runPython(`\n    assert len(my_list) == 4\n    `)\n})"
        },
        {
          "text": "`my_list` should equal `[0, 1, 2, 3]`.",
          "testCode": "({\n    test: () => runPython(`\n    assert my_list == [0, 1, 2, 3]\n    `)\n})"
        },
        {
          "text": "You should print the list after adding the new element.",
          "testCode": "({\n    test: () => runPython(`\n    assert _Node(_code).is_ordered('my_list.insert(1, 1)', \"print(my_list)\")\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\666aae6a5d30a71f1fd7749f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "666ab82c874add3c95145213",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "The `pop()` method can be used to remove an element from a list. By default, it removes the last element of the list. You can pass an index as the argument to the method, and it will remove the element at the given index.\n\n```py\nfruits_list = [\"cherry\", \"lemon\", \"tomato\", \"apple\", \"orange\"]\n\nfruits_list.pop(2)\n\nprint(fruits_list) # [\"cherry\", \"lemon\", \"apple\", \"orange\"]\n```\n\nIn this case, `fruits_list.pop(2)` removes the element at index `2` of the list.\n\nUse `pop()` to remove the last element from `my_list`, then print `my_list`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_list = [1, 2]\n\nmy_list.append(3)\nprint(my_list)\n\nprint(my_list[0])\n\nmy_list[0] = 0\nprint(my_list)\n\nmy_list.insert(1, 1)\nprint(my_list)\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use `pop()`.",
          "testCode": "({\n    test: () => runPython(`\n    assert len(_Node(_code).find_calls('pop')) > 0\n    `)\n})"
        },
        {
          "text": "`my_list` should be `[0, 1, 2]`.",
          "testCode": "({\n    test: () => runPython(`\n    assert my_list == [0, 1, 2]\n    `)\n})"
        },
        {
          "text": "You should print `my_list` after using `pop()`.",
          "testCode": "({\n    test: () => runPython(`\n    code = _Node(_code)\n    assert(\n        any(\n            code.is_ordered(pop, 'print(my_list)') for pop in ['my_list.pop()', 'my_list.pop(3)']\n        )\n    )\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\666ab82c874add3c95145213.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "666ab9013cd5563f2b39947a",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "Now that you have explored lists, remove all of the code you wrote for your review so you can begin the project.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nmy_list = [1, 2]\n\nmy_list.append(3)\nprint(my_list)\n\nprint(my_list[0])\n\nmy_list[0] = 0\nprint(my_list)\n\nmy_list.insert(1, 1)\nprint(my_list)\n\nmy_list.pop()\nprint(my_list)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete everything.",
          "testCode": "({\n    test: () => runPython(`\n    assert not _Node(_code)\n    `)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-lambda-functions-by-building-an-expense-tracker\\666ab9013cd5563f2b39947a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-lambda-functions-by-building-an-expense-tracker",
        "name": "Learn Lambda Functions By Building An Expense Tracker"
      }
    },
    {
      "id": "657e928716b77b2277980276",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "In this project, you are going to build a program that takes a `camelCase` or `PascalCase` formatted string as input and converts that to a `snake_case` formatted string using two approaches. First, you'll use a for loop and then list comprehension to achieve the same results. You'll see how list comprehension can make your code more concise.\n\nStart defining a new function named `convert_to_snake_case()` that accepts a string named `pascal_or_camel_cased_string` as input. For now, add a `pass` statement inside the function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a new function named `convert_to_snake_case()`. Don't forget the colon at the end and use `pass` to fill the function body.",
          "testCode": "({\n  test: () => {\n    assert(runPython(`\n      import inspect\n      inspect.isfunction(convert_to_snake_case)\n    `));\n  }\n})"
        },
        {
          "text": "Your function should take a parameter named `pascal_or_camel_cased_string`.",
          "testCode": "({\n  test: () => {\n    assert(runPython(`\n      import inspect\n      'pascal_or_camel_cased_string' in inspect.signature(convert_to_snake_case).parameters\n    `));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657e928716b77b2277980276.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657ed53c19461d4b95c4757a",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "You need to add an empty list that will hold the characters of the string after you have converted them to snake case. \n\nInside the function, replace the `pass` statement by creating an empty list named `snake_cased_char_list`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef convert_to_snake_case(pascal_or_camel_cased_string):\n    pass    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `pass` with an empty list named `snake_cased_char_list` within `convert_to_snake_case`.",
          "testCode": "({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const commentless_code = __helpers.python.removeComments(transformedCode)\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + commentless_code, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n        assert.notMatch(function_body, /\\bpass\\b/);\n        assert.match(function_body, / +snake_cased_char_list\\s*=\\s*\\[\\s*\\]\\s*/);\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657ed53c19461d4b95c4757a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657ee28cefc4945568287673",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "With the empty list in place, now you can start iterating through the input string and convert it into snake case.\n\nInside the function, below the list you just created, add a `for` loop to iterate through the `pascal_or_camel_cased_string`. Make sure to name the target variable `char`. For now, add a `pass` statement as a placeholder in the loop body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write a new `for` loop with the target variable named `char`. Don't forget the colon at the end and to use `pass` to fill the loop body.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.match(function_body, / +for\\s+char\\s+in\\s+pascal_or_camel_cased_string\\s*:\\s*pass[\\s]*$/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657ee28cefc4945568287673.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657ef2a86d4e545cec9a85fb",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "In both camel case and pascal case, uppercase characters mark the beginning of new words. To convert the input string to snake case, you will need to check if the characters in the input string are uppercase. \n\nYou can use the `.isupper()` string method to check if a character is uppercase. This method returns `True` if the character is uppercase and `False` if it is not.\n\nInside the `for` loop, add an `if` statement to check if the current character is uppercase. Move the `pass` statement inside the new `if` statement.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write a new if statement with char.isupper() as the condition. Remember to add the colon at the end and use the pass keyword to fill the if statement body.",
          "testCode": "({\n    test: () => {        \n        const commentless_code = __helpers.python.removeComments(code)\n        const transformedCode = commentless_code.replace(/\\r/g, \"\");\n        const {function_body} = __helpers.python.getDef(\"\\n\" + commentless_code, \"convert_to_snake_case\");\n        assert.match(function_body, /\\s+if\\s+char\\.isupper\\s*\\(\\s*\\)\\s*:\\s+pass/);\n    }\n})"
        },
        {
          "text": "You should replace the `pass` statement in the loop body with the `if` statement.\n\n```js\n({\n   test: () => {\n        const commentless_code = __helpers.python.removeComments(code)\n        const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+pascal_or_camel_cased_string\\s*/);\n        assert.notMatch(block_body, /^\\s+pass/);\n\n}\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657ef2a86d4e545cec9a85fb.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657efa642593c5746acc5c81",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Inside the `if` statement body, you need to convert any uppercase character to lowercase and prepend an underscore to this lowercase character.\n\nUse the `.lower()` string method to convert uppercase characters to lowercase characters. Then, prepend an underscore to the character. Assign the results to a variable named `converted_character`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n--fcc-editable-region--\n        if char.isupper():\n            pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign the modified character to a variable named `converted_character`.\n\n```js\n({\n    test: () => {\n   assert(runPython(`\n      converted_character_variable = (\n          _Node(_code)\n          .find_function(\"convert_to_snake_case\")\n          .find_for_loops()[0]\n          .find_ifs()[0]\n          .find_variable(\"converted_character\")\n      )\n\nconverted_character_variable.is_equivalent(\n          \"converted_character = '_' + char.lower()\"\n      ) or converted_character_variable.is_equivalent(\n          \"converted_character = f'_{char.lower()}'\"\n      )\n    `)); \n    }\n})\n```\n\nYou should not have `pass` in your `if` statement.",
          "testCode": "({\n    test: () => {\n        assert(runPython(`not _Node(_code).find_function(\"convert_to_snake_case\").find_for_loops()[0].find_ifs()[0].has_stmt(\"pass\")`)); \n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657efa642593c5746acc5c81.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657efce98e958b75df86b305",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "Within the `if` statement body, you are going to add the converted character to the list you created earlier.\n\nFor this, the `.append()` method will be used. This method adds a given object to the end of the list it is invoked on.\n\nUse the `.append()` method on the `snake_cased_char_list` to add the `converted_character` to the list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n--fcc-editable-region--\n        if char.isupper():\n            converted_character = '_' + char.lower()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `.append()` method to add the converted character to the `snake_cased_char_list`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.match(function_body, / +snake_cased_char_list\\.append\\s*\\(\\s*converted_character\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657efce98e958b75df86b305.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657efdcf7fe23b76c0cff9ec",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "You need to handle the characters that are already in lowercase by adding them to the list of converted characters.\n\nRight after the `if` statement within the `for` loop, add an `else` clause and use the `.append()` method to add `char` to the `snake_cased_char_list` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n--fcc-editable-region--\n        if char.isupper():\n            converted_character = '_' + char.lower()\n            snake_cased_char_list.append(converted_character)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add an `else` clause inside the `for` loop. Don't forget the colon at the end.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.match(function_body, / +else:/);\n    }\n})\n```\n\nYou should use the `.append()` method to add `char` to the `snake_cased_char_list` variable.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.match(function_body, / +snake_cased_char_list.append\\(\\s*char\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657efdcf7fe23b76c0cff9ec.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657effaa2a5e0277d71f9cbe",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "By this point, the variable `snake_cased_char_list` holds the list of converted characters. To combine these characters into a single string, you can utilize the `.join()` method.\n\nThe `join` method works by concatenating each element of a list into a string, separated by a designated string, known as the separator.\n\n```py\nresult_string = ''.join(characters)\n```\n\nThe example above joins together the elements of the `characters` list into a single string where each element is concatenated together using an empty string as the separator.\n\nNow, right after the `for` loop, use the `.join()` method to join the elements in `snake_cased_char_list` using an empty string as the separator. Assign the result to a new variable named `snake_cased_string`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n        if char.isupper():\n            converted_character = '_' + char.lower()\n            snake_cased_char_list.append(converted_character)\n        else:\n            snake_cased_char_list.append(char)\n--fcc-editable-region--\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should join the characters in the `snake_cased_char_list` list into a string using the `.join()` method and assign the string to a variable named `snake_cased_string` after your `for` loop.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.match(function_body, / +snake_cased_string\\s*=\\s*('|\")\\1\\.join\\s*\\(\\s*snake_cased_char_list\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657effaa2a5e0277d71f9cbe.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f0044be09db790b1eb1c5",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "In pascal case, strings begin with a capital letter. After converting all the characters to lowercase and adding an underscore to them, there's a chance of having an extra underscore at the start of your string.\n\nThe easiest way to fix this is by using the `.strip()` string method, which removes from a string any leading or trailing characters among a set of characters passed as its argument. For example:\n\n```py\noriginal_string = \"_example_string_\"\n\nclean_string = original_string.strip('_')\n```\n\nThe `strip()` method is applied to `original_string`. This removes any leading and trailing underscore. The result of the example above would be the string `'example_string'`.\n\nDeclare a new variable named `clean_snake_cased_string` and assign it the result of the `.strip()` method applied to `snake_cased_string` , passing `'_'` as the argument to the method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n        if char.isupper():\n            converted_character = '_' + char.lower()\n            snake_cased_char_list.append(converted_character)\n        else:\n            snake_cased_char_list.append(char)\n--fcc-editable-region--\n    snake_cased_string = ''.join(snake_cased_char_list)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign the resulting string from `snake_cased_string.strip('_')` to a variable named `clean_snake_cased_string`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.match(function_body, / +clean_snake_cased_string\\s*=\\s*snake_cased_string.strip\\(\\s*(\"|')_\\1\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f0044be09db790b1eb1c5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f01ae9aea647b27402d3e",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "To wrap up the function, return the `clean_snake_cased_string`. This will complete the function and allow you to use it to convert strings from pascal or camel case to snake case.\n\nAdd a `return` statement at the end of the function to return the `clean_snake_cased_string`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n        if char.isupper():\n            converted_character = '_' + char.lower()\n            snake_cased_char_list.append(converted_character)\n        else:\n            snake_cased_char_list.append(char)\n    snake_cased_string = ''.join(snake_cased_char_list)\n    clean_snake_cased_string = snake_cased_string.strip('_')\n--fcc-editable-region--\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add `return clean_snake_cased_string` at the end of the `convert_to_snake_case` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.match(function_body, / +return\\s+clean_snake_cased_string/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f01ae9aea647b27402d3e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f025ec86c3d7c4177b6be",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "With the function complete, you can now use it inside another function. \n\nCreate a new function called `main()` with `pass` as the body of the function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n        if char.isupper():\n            converted_character = '_' + char.lower()\n            snake_cased_char_list.append(converted_character)\n        else:\n            snake_cased_char_list.append(char)\n    snake_cased_string = ''.join(snake_cased_char_list)\n    clean_snake_cased_string = snake_cased_string.strip('_')\n\n    return clean_snake_cased_string\n--fcc-editable-region--\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a new function named `main()`. Don't forget the colon at the end and use `pass` to fill the function body.",
          "testCode": "({\n  test: () => {\n    assert(runPython(`\n      import inspect\n      inspect.isfunction(main)\n    `));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f025ec86c3d7c4177b6be.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f0353c9523d7d896873ea",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "Inside the `main()` function, replace the `pass` statement, with a call to the `convert_to_snake_case()` function, passing the string `'aLongAndComplexString'` as input.\n\nTo display the output, pass the function call as the argument to the `print()` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n        if char.isupper():\n            converted_character = '_' + char.lower()\n            snake_cased_char_list.append(converted_character)\n        else:\n            snake_cased_char_list.append(char)\n    snake_cased_string = ''.join(snake_cased_char_list)\n    clean_snake_cased_string = snake_cased_string.strip('_')\n\n    return clean_snake_cased_string\n\n--fcc-editable-region--\ndef main():\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `convert_to_snake_case()` inside the `main()` function and pass `'aLongAndComplexString'` as input to the function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.match(function_body, / +print\\s*\\(\\s*convert_to_snake_case\\s*\\(\\s*(\"|')aLongAndComplexString\\1\\s*\\)\\s*\\)/);\n    }\n})\n```\n\nYou should not have `pass` in your `main` function.\n\n```js\n({\n    test: () => {\n        const commentless_code = __helpers.python.removeComments(code);\n        const transformedCode = commentless_code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.notMatch(function_body, /pass/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f0353c9523d7d896873ea.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f04ed0035f47ed04d0f1f",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "In order to display the output of the `convert_to_snake_case()` function, you need to call the `main()` function. \n\nAt the same level as the two existing functions, add a call to the `main()` function. You should see the given camel or pascal cased string converted to snake case upon execution.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n        if char.isupper():\n            converted_character = '_' + char.lower()\n            snake_cased_char_list.append(converted_character)\n        else:\n            snake_cased_char_list.append(char)\n    snake_cased_string = ''.join(snake_cased_char_list)\n    clean_snake_cased_string = snake_cased_string.strip('_')\n\n    return clean_snake_cased_string\n\n--fcc-editable-region--\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a call to the `main()` function.",
          "testCode": "({\n  test: () => {\n    const pythonCode = `_Node(_code.replace('\\\\\\\\r', '')).has_call(\"main()\")`;\n    const result = runPython(pythonCode);\n    assert(result);\n  }\n});"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f04ed0035f47ed04d0f1f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f425dbab54e11993c80f0",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "So far, in this project you have used a `for` loop to iterate over your input string and convert it into the desired output. Now you'll begin the transition from a `for` loop to a list comprehension.\n\nBegin by commenting out all the lines of code inside the `convert_to_snake_case()` function. Don't delete them as they'll be helpful when you implement the logic using a list comprehension.\n\nRemember to add the `pass` keyword to the function body to prevent the code from failing during the tests.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef convert_to_snake_case(pascal_or_camel_cased_string):\n    snake_cased_char_list = []\n    for char in pascal_or_camel_cased_string:\n        if char.isupper():\n            converted_character = '_' + char.lower()\n            snake_cased_char_list.append(converted_character)\n        else:\n            snake_cased_char_list.append(char)\n    snake_cased_string = ''.join(snake_cased_char_list)\n    clean_snake_cased_string = snake_cased_string.strip('_')\n\n    return clean_snake_cased_string\n--fcc-editable-region--\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should comment out all the 10 lines of code inside the `convert_to_snake_case()` function and nothing else. Add `pass` to fill temporarily the function body and avoid an error.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\").replace(/\\n#/g, \"\\n #\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.equal(function_body.split(\"#\").length - 1, 10);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f425dbab54e11993c80f0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f4345abe7f2161f99f1ad",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "Replace the `pass` keyword with the variable `snake_cased_char_list` and assign it an empty list. Use the square brace notation to create the list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    # snake_cased_char_list = []\n    # for char in pascal_or_camel_cased_string:\n    #     if char.isupper():\n    #       converted_character = '_' + char.lower()\n    #       snake_cased_char_list.append(converted_character)\n    #     else:\n    #         snake_cased_char_list.append(char)\n    # snake_cased_string = ''.join(snake_cased_char_list)\n    # clean_snake_cased_string = snake_cased_string.strip('_')\n\n    # return clean_snake_cased_string\n--fcc-editable-region--\n    pass\n\n\n--fcc-editable-region--\n\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare an empty list named `snake_cased_char_list` within `convert_to_snake_case`.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.match(function_body, /clean_snake_cased_string\\s+    snake_cased_char_list\\s*=\\s*\\[\\n*\\s*\\n*\\]/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f4345abe7f2161f99f1ad.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f43d341a0dd17120cdb08",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "You will need to convert uppercase characters to lowercase and add an underscore before them. \n\nBefore proceeding to work on the list comprehension, you're going to give your function a return value. In this way you'll be able to check the output.\n\nUse the `return` statement to return the list `snake_cased_char_list` from your function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    # snake_cased_char_list = []\n    # for char in pascal_or_camel_cased_string:\n    #     if char.isupper():\n    #       converted_character = '_' + char.lower()\n    #       snake_cased_char_list.append(converted_character)\n    #     else:\n    #         snake_cased_char_list.append(char)\n    # snake_cased_string = ''.join(snake_cased_char_list)\n    # clean_snake_cased_string = snake_cased_string.strip('_')\n\n    # return clean_snake_cased_string\n\n    snake_cased_char_list = []\n--fcc-editable-region--\n\n--fcc-editable-region--\n\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return the `snake_cased_char_list` list. Ensure the indentation is set correctly.\n\n```js\nconst transformedCode = code.replace(/\\r/g, \"\");\nconst convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\nconst { function_body } = convert_to_snake_case;\n\nassert.match(function_body, /return\\s*snake_cased_char_list/);\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f43d341a0dd17120cdb08.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f456223b8c1187b461987",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "In Python, a <dfn>list comprehension</dfn> is a construct that allows you to generate a new list by applying an expression to each item in an existing iterable and optionally filtering items with a condition. Apart from being briefer, list comprehensions often run faster.\n\nA basic list comprehension consists of an expression followed by a `for` clause:\n\n```py\nspam = [i * 2 for i in iterable]\n```\n\nThe above uses the variable `i` to iterate over `iterable`. Each elements of the resulting list is obtained by evaluating the expression `i * 2` at the current iteration.\n\nIn this step, you need to fill the empty list `snake_cased_char_list` using the list comprehension syntax.\n\nTurn your empty list into a list comprehension that converts each character in `pascal_or_camel_cased_string` into a lowercase character and prepends an underscore to it (the code you commented out before may help you write the expression). Use `char` to iterate over `pascal_or_camel_cased_string`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    # snake_cased_char_list = []\n    # for char in pascal_or_camel_cased_string:\n    #     if char.isupper():\n    #       converted_character = '_' + char.lower()\n    #       snake_cased_char_list.append(converted_character)\n    #     else:\n    #         snake_cased_char_list.append(char)\n    # snake_cased_string = ''.join(snake_cased_char_list)\n    # clean_snake_cased_string = snake_cased_string.strip('_')\n\n    # return clean_snake_cased_string\n\n--fcc-editable-region--\n    snake_cased_char_list = []\n--fcc-editable-region--\n    return ''.join(snake_cased_char_list).strip('_')\n\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn `snake_cased_char_list` into a list comprehension that iterates over `pascal_or_camel_cased_string`.",
          "testCode": "({ \n    test: () => assert(runPython(`\n    iters = _Node(_code).find_function(\"convert_to_snake_case\").find_variable(\"snake_cased_char_list\").find_comp_iters()\n    len(iters) == 1 and iters[0].is_equivalent(\"pascal_or_camel_cased_string\")\n    `)) \n})"
        },
        {
          "text": "Your list comprehension should use `char` to iterate over `pascal_or_camel_cased_string`.",
          "testCode": "({ \n    test: () => assert(runPython(`\n    targets = _Node(_code).find_function(\"convert_to_snake_case\").find_variable(\"snake_cased_char_list\").find_comp_targets()\n    len(targets) == 1 and targets[0].is_equivalent(\"char\")\n    `)) \n})"
        },
        {
          "text": "Your list comprehension should evaluate `'_' + char.lower()` for each `char` in `pascal_or_camel_cased_string`.",
          "testCode": "({ \n    test: () => assert(runPython(`\n    target_var = _Node(_code).find_function(\"convert_to_snake_case\").find_variable(\"snake_cased_char_list\")\n    target_var.find_comp_expr().is_equivalent(\"'_' + char.lower()\") and len(target_var.find_comp_ifs()) == 0\n    `)) \n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f456223b8c1187b461987.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f465f8e718b19c5105ae5",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "List comprehensions accept conditional statements, to evaluate the provided expression only if certain conditions are met:\n\n```py\nspam = [i * 2 for i in iterable if i > 0]\n```\n\nAs you can see from the output, the list of characters generated from `pascal_or_camel_cased_string` has been joined. Since the expression inside the list comprehension is evaluated for each character, the result is a lowercase string with all the characters separated by an underscore.\n\nFollow the example above to add an `if` clause to your list comprehension so that the expression is executed only if the character is uppercase.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    # snake_cased_char_list = []\n    # for char in pascal_or_camel_cased_string:\n    #     if char.isupper():\n    #       converted_character = '_' + char.lower()\n    #       snake_cased_char_list.append(converted_character)\n    #     else:\n    #         snake_cased_char_list.append(char)\n    # snake_cased_string = ''.join(snake_cased_char_list)\n    # clean_snake_cased_string = snake_cased_string.strip('_')\n\n    # return clean_snake_cased_string\n\n--fcc-editable-region--\n    snake_cased_char_list = ['_' + char.lower() for char in pascal_or_camel_cased_string]\n--fcc-editable-region--\n    return ''.join(snake_cased_char_list).strip('_')\n\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add an `if` clause with the condition `char.isupper()` to your list comprehension.",
          "testCode": "({ \n    test: () => assert(runPython(`\n    ifs = _Node(_code).find_function(\"convert_to_snake_case\").find_variable(\"snake_cased_char_list\").find_comp_ifs()\n    len(ifs) == 1 and ifs[0].is_equivalent(\"char.isupper()\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f465f8e718b19c5105ae5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f47b12c51e41b3149e584",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Still, the final result is not exactly what you want to achieve. You need to execute a different expression for the characters filtered out by the `if` clause. You'll use an `else` clause for that:\n\n```py\nspam = [i * 2 if i > 0 else -1 for i in iterable]\n```\n\nNote that, differently from the `if` clause, the `if`/`else` construct must be placed between the expression and the `for` keyword.\n\nModify your list comprehension so that when a character is not uppercase it remains unchanged.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    # snake_cased_char_list = []\n    # for char in pascal_or_camel_cased_string:\n    #     if char.isupper():\n    #       converted_character = '_' + char.lower()\n    #       snake_cased_char_list.append(converted_character)\n    #     else:\n    #         snake_cased_char_list.append(char)\n    # snake_cased_string = ''.join(snake_cased_char_list)\n    # clean_snake_cased_string = snake_cased_string.strip('_')\n\n    # return clean_snake_cased_string\n\n--fcc-editable-region--\n    snake_cased_char_list = ['_' + char.lower() for char in pascal_or_camel_cased_string if char.isupper()]\n--fcc-editable-region--\n    return ''.join(snake_cased_char_list).strip('_')\n\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your list comprehension to evaluate the expression `'_' + char.lower()` if `char.isupper()` and char otherwise.",
          "testCode": "({ \n    test: () => assert(runPython(`\n    _Node(_code).find_function(\"convert_to_snake_case\").find_variable(\"snake_cased_char_list\").find_comp_expr().is_equivalent(\"'_' + char.lower() if char.isupper() else char\")\n    `)) \n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f47b12c51e41b3149e584.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f4a4a5828a01de04b652f",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "Get rid of the commented lines of code inside the `convert_to_snake_case()` function to clean up the function definition.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n--fcc-editable-region--\n    # snake_cased_char_list = []\n    # for char in pascal_or_camel_cased_string:\n    #     if char.isupper():\n    #         converted_character = '_' + char.lower()\n    #         snake_cased_char_list.append(converted_character)\n    #     else:\n    #         snake_cased_char_list.append(char)\n    # snake_cased_string = ''.join(snake_cased_char_list)\n    # clean_snake_cased_string = snake_cased_string.strip('_')\n\n    # return clean_snake_cased_string\n--fcc-editable-region--\n\n    snake_cased_char_list = [\n        '_' + char.lower() if char.isupper()\n        else char\n        for char in pascal_or_camel_cased_string\n    ]\n\n    return ''.join(snake_cased_char_list).strip('_')\n\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have any commented line of code in the `convert_to_snake_case()` function at all.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\n        const { function_body } = convert_to_snake_case;\n\nassert.equal(function_body.split(\"#\").length - 1, 0);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f4a4a5828a01de04b652f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "657f4add33ea4b1f61ba3dc8",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "Finally try out this new implementation by executing the program. Change the input string to `'IAmAPascalCasedString'` and see if it comes out as `'i_am_a_pascal_cased_string'`, even though that's a lie.\n\nIf you've done everything correctly, you should see the input string converted into snake case, like before.\n\nCongratulations! Now your `convert_to_snake_case()` function is ready.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n\n    snake_cased_char_list = [\n        '_' + char.lower() if char.isupper()\n        else char\n        for char in pascal_or_camel_cased_string\n    ]\n\n    return ''.join(snake_cased_char_list).strip('_')\n\n--fcc-editable-region--\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\n    \n--fcc-editable-region--\n\nmain()"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n\n    snake_cased_char_list = [\n        '_' + char.lower() if char.isupper()\n        else char\n        for char in pascal_or_camel_cased_string\n    ]\n\n    return ''.join(snake_cased_char_list).strip('_')\n\ndef main():\n    print(convert_to_snake_case('IAmAPascalCasedString'))\n\nmain()"
        }
      ],
      "tests": [
        {
          "text": "You should change the input string from `'aLongAndComplexString'` to `'IAmAPascalCasedString'` inside the `main()` function.\n\n```js\n({\n    test: () => {\n        const transformedCode = code.replace(/\\r/g, \"\");\n        const main = __helpers.python.getDef(\"\\n\" + transformedCode, \"main\");\n        const { function_body } = main;\n\nassert.match(function_body, / +print\\(\\s*convert_to_snake_case\\(\\s*'IAmAPascalCasedString'\\s*\\)\\s*\\)/);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\657f4add33ea4b1f61ba3dc8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "663b10c10a4c0a0e095137ee",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "Instead of returning the list `snake_cased_char_list`, you will need to join its elements into a single string using an empty string `''` as the separator.\n\nModify the `return` statement to return the result of joining `snake_cased_char_list` with an empty string as a separator.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    # snake_cased_char_list = []\n    # for char in pascal_or_camel_cased_string:\n    #     if char.isupper():\n    #       converted_character = '_' + char.lower()\n    #       snake_cased_char_list.append(converted_character)\n    #     else:\n    #         snake_cased_char_list.append(char)\n    # snake_cased_string = ''.join(snake_cased_char_list)\n    # clean_snake_cased_string = snake_cased_string.strip('_')\n\n    # return clean_snake_cased_string\n\n    snake_cased_char_list = []\n--fcc-editable-region--\n    return snake_cased_char_list\n--fcc-editable-region--\n\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the `return` statement to return the result of joining `snake_cased_char_list` with an empty string `''` as the separator using the `join()` method.",
          "testCode": "({\n    test: () => assert(runPython(`\n    _Node(_code).find_function('convert_to_snake_case').find_return().is_equivalent('return \"\".join(snake_cased_char_list)')\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\663b10c10a4c0a0e095137ee.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "663b16e62fee463b4caf46e9",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "After joining the elements of the list `snake_cased_char_list`, you will need to remove any leading or trailing underscores from the resulting string. For this, use the `strip` method with the underscore character `_` as an argument.\n\nMethod calls can be chained together, which means that the result of one method call can be used as the object for another method call.\n\n```py\nwords_list = ['hello', 'world', 'this', 'is', 'chained', 'methods']\nresult = ' '.join(words_list).upper()\n```\n\nIn the example above, the `.upper()` method is chained to `' '.join(words_list)`, therefore `.upper()` is called on the result of the `.join()` call.\n\nModify the `return` statement by chaining to `''.join(snake_cased_char_list)` a call to the `.strip()` method to remove any leading or trailing underscores.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def convert_to_snake_case(pascal_or_camel_cased_string):\n    # snake_cased_char_list = []\n    # for char in pascal_or_camel_cased_string:\n    #     if char.isupper():\n    #       converted_character = '_' + char.lower()\n    #       snake_cased_char_list.append(converted_character)\n    #     else:\n    #         snake_cased_char_list.append(char)\n    # snake_cased_string = ''.join(snake_cased_char_list)\n    # clean_snake_cased_string = snake_cased_string.strip('_')\n\n    # return clean_snake_cased_string\n\n    snake_cased_char_list = []\n--fcc-editable-region--\n    return ''.join(snake_cased_char_list)\n--fcc-editable-region--\n\ndef main():\n    print(convert_to_snake_case('aLongAndComplexString'))\n\nmain()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the return statement to include the `strip` method with the underscore character `_` as an argument.\n\n```js\nconst transformedCode = code.replace(/\\r/g, \"\");\nconst convert_to_snake_case = __helpers.python.getDef(\"\\n\" + transformedCode, \"convert_to_snake_case\");\nconst { function_body } = convert_to_snake_case;\n\nassert.match(function_body, /return\\s*''.join\\(snake_cased_char_list\\).strip\\('_'\\)/);\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-list-comprehension-by-building-a-case-converter-program\\663b16e62fee463b4caf46e9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-list-comprehension-by-building-a-case-converter-program",
        "name": "Learn List Comprehension By Building A Case Converter Program"
      }
    },
    {
      "id": "64dc8b1faf9c60304ca8a9b6",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "In this project, you will solve the mathematical puzzle known as the Tower of Hanoi. The puzzle consists of three rods and a number of disks of different diameters.\n\nThe goal of this puzzle is moving the disks from the first rod to the third rod, following specific rules that restrict placing a larger disk on top of a smaller one.\n\nStart by creating an empty dictionary named `rods` to represent the rods.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a variable named `rods`.",
          "testCode": "({ test: () => assert(__userGlobals.has('rods')) })"
        },
        {
          "text": "Your `rods` variable should be an empty dictionary.",
          "testCode": "({ test: () => assert(runPython(`\n    rods == {}\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc8b1faf9c60304ca8a9b6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc8ea01436383a88256d7f",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "The puzzle starts with the disks piled up on the first rod, in decreasing size, with the smallest disk on top and the largest disk on the bottom. You need to populate your first list with numbers representing the various disk sizes.\n\nInstead of adding the items manually to the first list, generate a sequence of numbers counting down from `3` to `1` by using the `range()` function and assign it to `rods['A']`. Here, `3` represents the largest disk at the bottom of the pile and `1` represents the smallest disk at the top of the pile.\n\nThe syntax is `range(x, y, h)`, where `x` is the starting integer (inclusive), `y` is the last integer (not inclusive), and `h` is the difference between a number and the next one in the sequence.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nrods = {\n    'A': [],\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `range()` function to assign a sequence of numbers to `rods['A']`. The syntax for calling the `range()` function is `range(x, y, h)`.",
          "testCode": "({ test: () => assert(runPython(`\n  type(rods['A']) is range\n  `))\n})"
        },
        {
          "text": "You should use the `range()` function to assign the sequence of numbers from `3` to `1` to `rods['A']`.",
          "testCode": "({ test: () => assert(runPython(`\n rods['A'] == range(3, 0, -1)\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc8ea01436383a88256d7f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc9004f658183afa85f4f1",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "Now check the data type of your `'A'` key by passing it to the `type()` function and print the result on the terminal.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nrods = {\n    'A': range(3, 0, -1),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass your `'A'` key to the `type()` function.",
          "testCode": "({ test: () => assert.match(code, /type\\s*\\(\\s*rods\\s*\\[\\s*('|\")\\s*A\\s*\\1\\s*\\]\\s*\\)/) })"
        },
        {
          "text": "You should print the type of `rods['A']` using the `print()` function.",
          "testCode": "({ test: () => assert.match(code, /print\\s*\\(\\s*type\\s*\\(\\s*rods\\s*\\[\\s*('|\")\\s*A\\s*\\1\\s*\\]\\s*\\)\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc9004f658183afa85f4f1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc90949ff85e3b37be40d0",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "The `range()` function returns an immutable sequence of numbers. As you can see, the data type of `rods['A']` is `range`, but you want it to be a list.\n\nPass your `range()` call to the `list()` function to do that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nrods = {\n    'A': range(3, 0, -1),\n    'B': [],\n    'C': []\n}\nprint(type(rods['A']))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass your `range()` call to the `list()` function.",
          "testCode": "({ test: () => assert(runPython(`\n  rods['A'] == list(range(3, 0, -1))\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc90949ff85e3b37be40d0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc90e837670a3ba26a1e61",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "Now that the type is `list` as required, you can remove the `print()` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nrods = {\n    'A': list(range(3, 0, -1)),\n    'B': [],\n    'C': []\n}\nprint(type(rods['A']))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove `print(type(rods['A']))` from your code.",
          "testCode": "({ test: () => assert.match(code, /\\}(?!\\s+print\\s*\\(\\s*type\\s*\\(\\s*rods\\s*\\[\\s*('|\")A\\1\\s*\\]\\s*\\)\\s*\\))/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc90e837670a3ba26a1e61.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc916138dbe03bdfe6cec6",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "The goal of the Tower of Hanoi is moving all the disks to the last rod. To do that, you must follow three simple rules:\n\n1. You can move only top-most disks\n2. You can move only one disk at a time\n3. You cannot place larger disks on top of smaller ones\n\nBelow your existing code, declare an empty function named `move`. Later on, you will use that function to move the disks between the rods. For now, to avoid errors, use the `pass` keyword inside the function body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "rods = {\n    'A': list(range(3, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare an empty function named `move`. Remember to use the `pass` keyword inside the function body with the correct indentation.",
          "testCode": "({ test: () => {\n\t\tassert(runPython(`\n        import inspect\n        inspect.isfunction(move)\n    `))\n\t} \n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc916138dbe03bdfe6cec6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc922df2919e3c38cead61",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "At the top of your code, declare a variable named `NUMBER_OF_DISKS` to store the number of disks and give it the value of `3`. Then, replace the first argument passed in to the `range()` function with your new variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\nrods = {\n    'A': list(range(3, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\n\ndef move():\n    pass"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `NUMBER_OF_DISKS`.",
          "testCode": "({test: () => assert(__userGlobals.has('NUMBER_OF_DISKS')) })"
        },
        {
          "text": "The `NUMBER_OF_DISKS` variable should have the value `3`.",
          "testCode": "({test: () => assert.equal(__userGlobals.get('NUMBER_OF_DISKS'), 3) })"
        },
        {
          "text": "You should change the value of the `range()` function's first argument into the `NUMBER_OF_DISKS` variable.",
          "testCode": "({test: () => assert.match(code, /('|\")A\\1\\s*:\\s*list\\s*\\(\\s*range\\s*\\(\\s*NUMBER_OF_DISKS\\s*,\\s*0\\s*,\\s*-\\s*1\\s*\\)\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc922df2919e3c38cead61.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc92a9718fb53ca3d1bad7",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "The Tower of Hanoi puzzle can be solved in 2<sup>n</sup> - 1 moves, where n is the number of disks. Declare a variable named `number_of_moves` and assign the total number of moves to this variable.\n\nThe power operator in Python is `**`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nNUMBER_OF_DISKS = 3\n\n--fcc-editable-region--\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\ndef move():\n    pass"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `number_of_moves`.",
          "testCode": "({ test: () => assert(__userGlobals.has('number_of_moves')) })"
        },
        {
          "text": "The value of `number_of_moves` should be the expression to calculate the number of moves.",
          "testCode": "({ test: () => {\n    assert(runPython(`  \n    number_of_moves == 2**NUMBER_OF_DISKS -1      \n    `))\n} })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc92a9718fb53ca3d1bad7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc963d866fff3dd0329993",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "Print the variable you declared in the previous step and feel free to change the number of disks to see how fast the required minimum number of moves increases.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nNUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\n\n--fcc-editable-region--\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move():\n    pass"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the `number_of_moves` variable.\n\n```js\n({ test: () => assert.match(code, /print\\s*\\(\\s*number_of_moves\\s*\\)/) })\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc963d866fff3dd0329993.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc97005bc7943e2978df0a",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "Now you can remove your `print()` call. Then, inside the `move()` function, remove the `pass` keyword and print the content of your `rods` dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nNUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nprint(number_of_moves)\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\ndef move():\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(number_of_moves)` in your code.",
          "testCode": "({ test: () => assert.isFalse(/print\\s*\\(\\s*number_of_moves\\s*\\)/.test(code)) })"
        },
        {
          "text": "You should remove the `pass` keyword and print the `rods` dictionary.",
          "testCode": "({ test: () => assert.match(code, /def\\s+move\\s*\\(\\s*\\)\\s*:\\s+print\\s*\\(\\s*rods\\s*\\)(?!\\s*pass)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc97005bc7943e2978df0a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc976bf864693e668d67e8",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "Now call your function and see the output on the terminal.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\ndef move():\n    print(rods)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call your `move()` function.",
          "testCode": "({test: () => assert.match(code, /^move\\(\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc976bf864693e668d67e8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc97ab25730b3e9de86ea5",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "At the end of this project, you will create a recursive solution to the Tower of Hanoi puzzle, but now you are going to explore an iterative approach to this problem.\n\nStart by adding a `for` loop to your function that iterates through the `number_of_moves` and prints the current iteration number.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write a `for` loop to iterate through the number of moves. Use the `range()` function for that.",
          "testCode": "({ test: () => {\n    const rgs = [\n        /for\\s+\\w+\\s+in\\s+range\\s*\\(\\s*number_of_moves\\s*\\)\\s*:/,\n        /for\\s+\\w+\\s+in\\s+range\\s*\\(\\s*0\\s*,\\s*number_of_moves\\s*\\)\\s*:/,\n        /for\\s+\\w+\\s+in\\s+range\\s*\\(\\s*0\\s*,\\s*number_of_moves\\s*,\\s*1\\s*\\)\\s*:/\n    ]\n    const loop = rgs.some(r => code.match(r));\n    assert.isTrue(loop);\n  }\n})"
        },
        {
          "text": "You should print the current move number at each iteration.",
          "testCode": "({ test: () => {\n    const rgs = [\n        /for\\s+(\\w+)\\s+in\\s+range\\s*\\(\\s*number_of_moves\\s*\\)\\s*:\\s+print\\s*\\(\\s*\\1\\s*\\)/,\n        /for\\s+(\\w+)\\s+in\\s+range\\s*\\(\\s*0\\s*,\\s*number_of_moves\\s*\\)\\s*:\\s+print\\s*\\(\\s*\\1\\s*\\)/,\n        /for\\s+(\\w+)\\s+in\\s+range\\s*\\(\\s*0\\s*,\\s*number_of_moves\\s*,\\s*1\\s*\\)\\s*:\\s+print\\s*\\(\\s*\\1\\s*\\)/\n    ]\n    const loop = rgs.some(r => code.match(r));\n    assert.isTrue(loop);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc97ab25730b3e9de86ea5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dc985e6720a23edac63b51",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "The allowed disk movements between the rods exhibit a repetitive pattern occurring every three moves. For example, movements between rod `A` and rod `C` are allowed on the first, the fourth and the seventh move, where the remainder of the division between the move number and 3 is equal to 1.\n\nInside the previously created `for` loop, replace the existing `print()` call with an `if` statement that is triggered when `(i + 1) % 3 == 1`. Within this `if` statement, print `f'Move {i + 1} allowed between {source} and {target}'` using an f-string. Please, note that `i + 1` is the move number since `i` is zero during the first iteration.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        print(i)\n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `if` statement that should be executed when `(i + 1) % 3 == 1`.",
          "testCode": "({test: () => assert.match(code, /if\\s+\\(\\s*i\\s*\\+\\s*1\\s*\\)\\s*%\\s*3\\s*==\\s*1\\s*:/)})"
        },
        {
          "text": "You should print the string `f'Move {i + 1} allowed between {source} and {target}'` using an f-string.",
          "testCode": "({test: () => assert.match(code, /print\\s*\\(\\s*f('|\")Move\\s\\{\\s*i\\s*\\+\\s*1\\s*\\}\\sallowed\\sbetween\\s\\{\\s*source\\s*\\}\\sand\\s\\{\\s*target\\s*\\s*\\}\\1\\s*\\)/)})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dc985e6720a23edac63b51.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dcd3d61c448e2676501f43",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "When the remainder of the move number divided by 3 is equal to 2, the movement is allowed between `'A'` and `'B'` (the source and the auxiliary rods).\n\nAdd an `elif` statement for that. Then, print the appropriate string if the condition is met.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `elif` statement to execute when `remainder == 2`.",
          "testCode": "({test: () => assert.match(code, /elif\\s+remainder\\s*==\\s*2:/)})"
        },
        {
          "text": "You should print the string `f'Move {i + 1} allowed between {source} and {auxiliary}'`.",
          "testCode": "({test: () => assert.match(code, /print\\s*\\(\\s*f('|\")Move\\s\\{\\s*i\\s*\\+\\s*1\\s*\\}\\sallowed\\sbetween\\s\\{\\s*source\\s*\\}\\sand\\s\\{\\s*auxiliary\\s*\\s*\\}\\1\\s*\\)/)})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dcd3d61c448e2676501f43.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dcd9bbc2268127e7898d77",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Finally, when the move number divided by 3 has no remainder, the movement is allowed between `'B'` and `'C'`.\n\nAdd an `elif` statement for that. Then, print the appropriate string if the condition is met.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `elif` statement to execute when `remainder == 0`.",
          "testCode": "({test: () => assert.match(code, /elif\\s+remainder\\s*==\\s*0\\s*:/)})"
        },
        {
          "text": "You should print the string `f'Move {i + 1} allowed between {auxiliary} and {target}'`.",
          "testCode": "({test: () => assert.match(code, /print\\s*\\(\\s*f('|\")Move\\s\\{\\s*i\\s*\\+\\s*1\\s*\\}\\sallowed\\sbetween\\s\\{\\s*auxiliary\\s*\\}\\sand\\s\\{\\s*target\\s*\\s*\\}\\1\\s*\\)/)})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dcd9bbc2268127e7898d77.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dcdee07a14f0299ec30559",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "You wrote the code to find the allowed movement between the rods, but the actual move could be in both directions.\nAfter the `print()` call, declare a variable named `forward` and set it to `False`. You will use that variable to check in which direction you need to move the disk between the rods.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n--fcc-editable-region--\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n--fcc-editable-region--\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `forward`.",
          "testCode": "({ test: () => assert.match(code, /forward\\s*=\\s*./) })"
        },
        {
          "text": "Your `forward` variable should be set to `False`.",
          "testCode": "({ test: () => assert.match(code, /forward\\s*=\\s*False/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dcdee07a14f0299ec30559.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dce5f6ff907c2b2c47bb05",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "When `target` is empty, the disk should be moved necessarily from `source` to `target`.\n\nAfter the declaration of `forward`, add an `if` statement to check if `rods[target]` is empty. If it is, change `forward` to `True`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n--fcc-editable-region--\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n--fcc-editable-region--\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `if` statement to check if `rods[target]` is empty, and assign `True` to `forward`.\n\n```js\n({\n    test: () => {\n        const tCode = code.replace(/\\r/g, '');\n        const ifBlock = __helpers.python.getBlock(tCode, \"if remainder == 1\");\n        const { block_body } = ifBlock\n        const if2 = __helpers.python.getBlock(block_body, /if [^:]+/);\n        const if2Indent = if2.block_body.match(/ +/)[0];\n        const ifLoc = tCode.indexOf(block_body.slice(0,20));\n        const ifLen = block_body.length;\n        const newIf = block_body + `\\n${if2Indent}__spy(forward)`\n        const newCode = `\n__counter = 0\ndef __spy(x):\n    global __counter\n    if x:\n        __counter += 1\n\n${tCode.slice(0,ifLoc)}\n${newIf}\n${tCode.slice(ifLoc + ifLen)}\n\n__counter\n`;\n        const out = runPython(newCode);\n        assert.equal(out, 3);\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dce5f6ff907c2b2c47bb05.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dce7ee2494e82bf4205a3f",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "The other case in which you have to move the disk necessarily from `source` to `target` is when the source list is **not** empty **and** the last disk in `source` is lower than the last disk in `target`.\n\nAdd an `elif` statement to check this condition. Then, set the `forward` variable to `True` if the condition is met.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n--fcc-editable-region--            \n            if not rods[target]:\n                forward = True\n--fcc-editable-region--\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `elif` statement to check if `rods[source]` is not empty and `rods[source][-1] < rods[target][-1]`.",
          "testCode": "const allowedRes = [\n    \"rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\",\n    \"len\\\\(rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\\\\s*\\\\)\\\\s*>\\\\s*0\",\n    \"len\\\\(rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\\\\s*\\\\)\\\\s*>=\\\\s*1\",\n];\nconst re = new RegExp(`elif\\\\s+((${allowedRes.join(\")|(\")}))\\\\s+and\\\\s+(rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\\\\s*\\\\[\\\\s*-\\\\s*1\\\\s*\\\\]\\\\s*<\\\\s*rods\\\\s*\\\\[\\\\s*target\\\\s*\\\\]\\\\s*\\\\[\\\\s*-\\\\s*1\\\\s*\\\\]|rods\\\\s*\\\\[\\\\s*target\\\\s*\\\\]\\\\s*\\\\[\\\\s*-\\\\s*1\\\\s*\\\\]\\\\s*>\\\\s*rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\\\\s*\\\\[\\\\s*-\\\\s*1\\\\s*\\\\])\\\\s*:`);\nassert.match(code, re);"
        },
        {
          "text": "You should set `forward` to `True` inside your new `elif` statement. You should not change the previous assignments of `forward`.",
          "testCode": "const allowedRes = [\n    \"rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\",\n    \"len\\\\(rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\\\\s*\\\\)\\\\s*>\\\\s*0\",\n    \"len\\\\(rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\\\\s*\\\\)\\\\s*>=\\\\s*1\",\n];\nconst re = new RegExp(`elif\\\\s+((${allowedRes.join(\")|(\")}))\\\\s+and\\\\s+(rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\\\\s*\\\\[\\\\s*-\\\\s*1\\\\s*\\\\]\\\\s*<\\\\s*rods\\\\s*\\\\[\\\\s*target\\\\s*\\\\]\\\\s*\\\\[\\\\s*-\\\\s*1\\\\s*\\\\]|rods\\\\s*\\\\[\\\\s*target\\\\s*\\\\]\\\\s*\\\\[\\\\s*-\\\\s*1\\\\s*\\\\]\\\\s*>\\\\s*rods\\\\s*\\\\[\\\\s*source\\\\s*\\\\]\\\\s*\\\\[\\\\s*-\\\\s*1\\\\s*\\\\])\\\\s*:\\\\s+forward\\\\s*=\\\\s*True`);\nassert.match(code, re);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dce7ee2494e82bf4205a3f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64dceadec3c9cf2ca7b56de6",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "Next, below the nested `elif` statement, add another `if` statement that should be executed when `forward` is `True`. Inside this conditional, print the following f-string: `f'Moving disk {rods[source][-1]} from {source} to {target}'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n--fcc-editable-region--\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n            if not rods[target]:\n                forward = True\n            elif rods[source] and rods[source][-1] < rods[target][-1]:\n                forward = True\n--fcc-editable-region--\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add an `if` statement to execute when `forward` is `True` after the `elif` block.",
          "testCode": "({ test: () => assert.match(code, /^\\s{12}if\\s+forward(\\s*==\\s*True)?\\s*:/m) })"
        },
        {
          "text": "You should print the provide string inside your new `if` statement.",
          "testCode": "({ test: () => assert.match(code, /if\\s+forward(\\s*==\\s*True)?\\s*:\\s+print\\s*\\(\\s*f('|\")Moving\\sdisk\\s\\{\\s*rods\\s*\\[\\s*source\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\}\\sfrom\\s\\{\\s*source\\s*\\}\\sto\\s\\{\\s*target\\s*\\}\\2\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64dceadec3c9cf2ca7b56de6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64ddcc2ee182e0164c3539f8",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "After printing the move, you need to remove the last element from the source rod and append it to target rod. Use the `.pop()` method and the `.append()` method for that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n--fcc-editable-region--\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n            if not rods[target]:\n                forward = True\n            elif rods[source] and rods[source][-1] < rods[target][-1]:\n                forward = True\n            if forward:\n                print(f'Moving disk {rods[source][-1]} from {source} to {target}')\n--fcc-editable-region--\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the last element from `rods[source]`.",
          "testCode": "({ test: () => assert.match(code, /rods\\s*\\[\\s*source\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)/) })"
        },
        {
          "text": "You should have `rods[target].append(rods[source].pop())` in your code.",
          "testCode": "({ test: () => assert.match(code, /rods\\s*\\[\\s*target\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*source\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64ddcc2ee182e0164c3539f8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64ddce6f6e8066173208235b",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "When `forward` is `False`, the disk has to be moved in the opposite direction. Write an `else` clause for that. Print the move and change the content of the lists accordingly.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n            if not rods[target]:\n                forward = True\n            elif rods[source] and rods[source][-1] < rods[target][-1]:\n                forward = True\n--fcc-editable-region--                \n            if forward:\n                print(f'Moving disk {rods[source][-1]} from {source} to {target}')\n                rods[target].append(rods[source].pop())\n--fcc-editable-region--\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `else` clause to move the disks in the opposite direction.",
          "testCode": "({ test: () => assert.match(code, /rods\\s*\\[\\s*target\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*source\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)\\s+else\\s*:/) })"
        },
        {
          "text": "You should have `print(f'Moving disk {rods[target][-1]} from {target} to {source}')` inside your `else` clause.",
          "testCode": "({ test: () => assert.match(code, /else\\s*:\\s+print\\s*\\(\\s*f('|\")Moving\\sdisk\\s\\{\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\}\\sfrom\\s\\{\\s*target\\s*\\}\\sto\\s\\{\\s*source\\s*\\}\\1\\s*\\)/) })"
        },
        {
          "text": "You should remove the last element from `rods[target]`.",
          "testCode": "({ test: () => assert.match(code, /rods\\s*\\[\\s*target\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)/) })"
        },
        {
          "text": "You should have `rods[source].append(rods[target].pop())` in your code.",
          "testCode": "({ test: () => assert.match(code, /rods\\s*\\[\\s*source\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64ddce6f6e8066173208235b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64ddd02838f36117cd9738eb",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "Outside the `else` block, add a comment saying `display our progress` and print the content of the lists to check that everything is working.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n            if not rods[target]:\n                forward = True\n            elif rods[source] and rods[source][-1] < rods[target][-1]:\n                forward = True\n--fcc-editable-region--                \n            if forward:\n                print(f'Moving disk {rods[source][-1]} from {source} to {target}')\n                rods[target].append(rods[source].pop())\n            else:\n                print(f'Moving disk {rods[target][-1]} from {target} to {source}')\n                rods[source].append(rods[target].pop())\n--fcc-editable-region--\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the provided text to add a comment outside the `else` block.",
          "testCode": "({ test: () => assert.match(code, /rods\\s*\\[\\s*source\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)\\s+#\\s*display\\sour\\sprogress/) })"
        },
        {
          "text": "You should print the `rods` object outside the `else` block, after the comment.",
          "testCode": "({ test: () => assert.match(code, /rods\\s*\\[\\s*source\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)\\s+#\\s*display\\sour\\sprogress\\s+print\\s*\\(\\s*rods\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64ddd02838f36117cd9738eb.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64ddd280d69fa818ca782d50",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "As you can see, disk 1 is going back and forth every three moves. This happens because you still need to take care of movements between the other rods.\nInstead of repeating the same code you wrote during the previous few steps and changing the rods, it would be better to move that code inside a function to call in each conditional statement. Declare an empty function named `make_allowed_move()` and don't forget the `pass` keyword.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\n\n--fcc-editable-region--\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n            if not rods[target]:\n                forward = True\n            elif rods[source] and rods[source][-1] < rods[target][-1]:\n                forward = True              \n            if forward:\n                print(f'Moving disk {rods[source][-1]} from {source} to {target}')\n                rods[target].append(rods[source].pop())\n            else:\n                print(f'Moving disk {rods[target][-1]} from {target} to {source}')\n                rods[source].append(rods[target].pop())\n            \n            # display our progress\n            print(rods)\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare an empty function named `make_allowed_move`. Remember to use the `pass` keyword inside the function body with the correct indentation.",
          "testCode": "({ test: () => assert(runPython(`\n      import inspect\n      inspect.isfunction(make_allowed_move)\n  `)) \n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64ddd280d69fa818ca782d50.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64ddd4fbb4b598199acf5ec5",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "Add two parameters called `rod1` and `rod2` to your new function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\ndef make_allowed_move():\n    pass\n--fcc-editable-region--\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n            if not rods[target]:\n                forward = True\n            elif rods[source] and rods[source][-1] < rods[target][-1]:\n                forward = True              \n            if forward:\n                print(f'Moving disk {rods[source][-1]} from {source} to {target}')\n                rods[target].append(rods[source].pop())\n            else:\n                print(f'Moving disk {rods[target][-1]} from {target} to {source}')\n                rods[source].append(rods[target].pop())\n            \n            # display our progress\n            print(rods)\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `make_allowed_move()` function should have two parameters named `rod1` and `rod2`.",
          "testCode": "({ test: () => assert(runPython(`\n      import inspect\n      str(inspect.signature(make_allowed_move)) == '(rod1, rod2)'    \n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64ddd4fbb4b598199acf5ec5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64ddd65848a12919d7e1c7d0",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "It's time to move some code from the `move()` function to the `make_allowed_move()` function. Move the code nested inside the first `if` statement (except the first `print()` call) to your new function. Pay close attention to the indentation.\nDon't forget to remove the `pass` keyword.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\ndef make_allowed_move(rod1, rod2):\n    pass\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            forward = False\n            if not rods[target]:\n                forward = True\n            elif rods[source] and rods[source][-1] < rods[target][-1]:\n                forward = True\n            if forward:\n                print(f'Moving disk {rods[source][-1]} from {source} to {target}')\n                rods[target].append(rods[source].pop())\n            else:\n                print(f'Moving disk {rods[target][-1]} from {target} to {source}')\n                rods[source].append(rods[target].pop())\n\n            # display our progress\n            print(rods)\n--fcc-editable-region--\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should move the code nested inside the first `if` statement (except the first `print()` call) to your new function.",
          "testCode": "({ test: () => {\n  assert.match(code, /def\\s+make_allowed_move\\(\\s*rod1\\s*,\\s*rod2\\s*\\):\\s+forward\\s*=\\s*False\\s+if\\s+not\\s+rods\\s*\\[\\s*target\\s*\\]\\s*:\\s+forward\\s*=\\s*True\\s+elif\\s+rods\\s*\\[\\s*source\\s*\\]\\s+and\\s+rods\\s*\\[\\s*source\\s*\\]\\s*\\[\\s*-1\\s*\\]\\s*<\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*:\\s+forward\\s*=\\s*True\\s+if\\s+forward\\s*:\\s+print\\(\\s*f'Moving\\sdisk\\s\\{\\s*rods\\s*\\[\\s*source\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\}\\sfrom\\s\\{\\s*source\\s*\\}\\sto\\s\\{\\s*target\\s*\\}'\\s*\\)\\s+rods\\s*\\[\\s*target\\s*\\]\\s*\\.append\\(\\s*rods\\s*\\[\\s*source\\s*\\]\\s*\\.pop\\(\\s*\\)\\s*\\)\\s+else\\s*:\\s+print\\(\\s*f'Moving\\sdisk\\s\\{\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\}\\sfrom\\s\\{\\s*target\\s*\\}\\sto\\s\\{\\s*source\\s*\\}'\\s*\\)\\s+rods\\s*\\[\\s*source\\s*\\]\\s*\\.append\\(\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\.pop\\(\\s*\\)\\s*\\)\\s+#\\s*display\\sour\\sprogress\\s+print\\(\\s*rods\\s*\\)/);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64ddd65848a12919d7e1c7d0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de1469fccce61940f498c4",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "The `rods` dictionary will represent the three rods with their disks. Give it the strings `'A'`, `'B'`, and `'C'` as keys and set each of them to an empty list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nrods = {}\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `rods` dictionary should have an `'A'` key.",
          "testCode": "({ test: () => assert(runPython(`'A' in rods`)) })"
        },
        {
          "text": "`rods['A']` should be an empty list.",
          "testCode": "({ test: () => assert(runPython(`\n    rods['A'] == []\n  `))\n})"
        },
        {
          "text": "Your `rods` dictionary should have a `'B'` key.",
          "testCode": "({ test: () => assert(runPython(`'B' in rods`)) })"
        },
        {
          "text": "`rods['B']` should be an empty list.",
          "testCode": "({ test: () => assert(runPython(`\n    rods['B'] == []\n  `))\n})"
        },
        {
          "text": "Your `rods` dictionary should have a `'C'` key.",
          "testCode": "({ test: () => assert(runPython(`'C' in rods`)) })"
        },
        {
          "text": "`rods['C']` should be an empty list.",
          "testCode": "({ test: () => assert(runPython(`\n    rods['C'] == []\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de1469fccce61940f498c4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de4bccf5becb208a48ca97",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "In the Tower of Hanoi puzzle, you can identify the three rods according to their purpose:\n\n- The first rod is the source, where all the disks are stacked on top of each other at the beginning of the game.\n- The second rod is an auxiliary rod, and it helps in moving the disks to the target rod.\n- The third rod is the target, where all the disks should be placed in order at the end of the game.\n\nCurrently, the `move()` function does not take any parameters. Change the function declaration to take 4 parameters: `n`, `source`, `auxiliary`, and `target`. Then, pass `NUMBER_OF_DISKS` and the strings `'A'`, `'B'`, and `'C'` as arguments to your function call. The order matters.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move():\n    print(rods)\n\nmove()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `move()` function should have `n`, `source`, `auxiliary`, and `target` as the parameters. The order matters.",
          "testCode": "({ test: () => assert(runPython(`\n      import inspect\n      str(inspect.signature(move)) == '(n, source, auxiliary, target)'    \n  `))\n})"
        },
        {
          "text": "You should pass `NUMBER_OF_DISKS` and the strings `'A'`, `'B'`, and `'C'` to `move()`. The order matters.",
          "testCode": "({test: () => assert.match(code, /^move\\(\\s*NUMBER_OF_DISKS\\s*,\\s*('|\")A\\1\\s*,\\s*('|\")B\\2\\s*,\\s*('|\")C\\3\\s*\\)/m)\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de4bccf5becb208a48ca97.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de6c8a5305d8173a3a9e09",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "`make_allowed_move()` takes in `rod1` and `rod2` as parameters. You need a little refactoring here. Change every occurrence of `source` into `rod1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\ndef make_allowed_move(rod1, rod2):\n    forward = False\n    if not rods[target]:\n        forward = True\n    elif rods[source] and rods[source][-1] < rods[target][-1]:\n        forward = True              \n    if forward:\n        print(f'Moving disk {rods[source][-1]} from {source} to {target}')\n        rods[target].append(rods[source].pop())\n    else:\n        print(f'Moving disk {rods[target][-1]} from {target} to {source}')\n        rods[source].append(rods[target].pop())\n    \n    # display our progress\n    print(rods)\n--fcc-editable-region--    \n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')            \n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should change each occurrence of `source` inside the `make_allowed_move()` function into `rod1`.",
          "testCode": "({ test: () => {\n  assert.match(code, /elif\\s+rods\\s*\\[\\s*rod1\\s*\\]\\s+and\\s+rods\\s*\\[\\s*rod1\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*<\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*:/);\n  assert.match(code, /if\\s+forward(\\s*==\\s*True)?\\s*:\\s+print\\s*\\(\\s*f('|\")Moving\\sdisk\\s\\{\\s*rods\\s*\\[\\s*rod1\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\}\\sfrom\\s\\{\\s*rod1\\s*\\}\\sto\\s\\{\\s*target\\s*\\}\\2\\s*\\)\\s+rods\\s*\\[\\s*target\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*rod1\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)/);\n  assert.match(code, /else\\s*:\\s+print\\s*\\(\\s*f('|\")Moving\\sdisk\\s\\{\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\}\\sfrom\\s\\{\\s*target\\s*\\}\\sto\\s\\{\\s*rod1\\s*\\}\\1\\s*\\)/);\n  assert.match(code, /rods\\s*\\[\\s*rod1\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*target\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)/);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de6c8a5305d8173a3a9e09.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de7357cc75bd18bdced920",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "Now change each occurrence of `target` into `rod2`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n--fcc-editable-region--\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[target]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[target][-1]:\n        forward = True              \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {target}')\n        rods[target].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[target][-1]} from {target} to {rod1}')\n        rods[rod1].append(rods[target].pop())\n    \n    # display our progress\n    print(rods)\n--fcc-editable-region--\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')            \n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should change each occurrence of `target` inside `make_allowed_move` into `rod2`.",
          "testCode": "({ test: () => {\n  assert.match(code, /if\\s+not\\s+rods\\s*\\[\\s*rod2\\s*\\]\\s*:/);\n  assert.match(code, /elif\\s+rods\\s*\\[\\s*rod1\\s*\\]\\s+and\\s+rods\\s*\\[\\s*rod1\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*<\\s*rods\\s*\\[\\s*rod2\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*:/);\n  assert.match(code, /if\\s+forward(\\s*==\\s*True)?\\s*:\\s+print\\s*\\(\\s*f('|\")Moving\\sdisk\\s\\{\\s*rods\\s*\\[\\s*rod1\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\}\\sfrom\\s\\{\\s*rod1\\s*\\}\\sto\\s\\{\\s*rod2\\s*\\}\\2\\s*\\)\\s+rods\\s*\\[\\s*rod2\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*rod1\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)/);\n  assert.match(code, /else\\s*:\\s+print\\s*\\(\\s*f('|\")Moving\\sdisk\\s\\{\\s*rods\\s*\\[\\s*rod2\\s*\\]\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\}\\sfrom\\s\\{\\s*rod2\\s*\\}\\sto\\s\\{\\s*rod1\\s*\\}\\1\\s*\\)/);\n  assert.match(code, /rods\\s*\\[\\s*rod1\\s*\\]\\s*\\.append\\s*\\(\\s*rods\\s*\\[\\s*rod2\\s*\\]\\s*\\.pop\\s*\\(\\s*\\)\\s*\\)/);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de7357cc75bd18bdced920.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de73f6c2486518e3064fec",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "Now call `make_allowed_move()` and pass in `source` and `target` as the arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True              \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods)\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n--fcc-editable-region--    \n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            \n--fcc-editable-region--            \n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')            \n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `make_allowed_move()` passing `source` and `target` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /make_allowed_move\\s*\\(\\s*source\\s*,\\s*target\\s*\\)(?=\\s+elif\\s+remainder\\s*==\\s*2\\s*:)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de73f6c2486518e3064fec.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de7662244db513d7b673ec",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "Call the `make_allowed_move()` function again inside the two `elif` clauses, and pass in the correct arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True              \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods)\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n--fcc-editable-region--\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            make_allowed_move(source, target)\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n            \n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n            \n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `make_allowed_move(source, auxiliary)` inside the first `elif` clause.",
          "testCode": "({ test: () => {\n    assert.match(code, /make_allowed_move\\s*\\(\\s*source\\s*,\\s*auxiliary\\s*\\)(?=\\s+elif\\s+remainder\\s*==\\s*0\\s*:)/);\n}})"
        },
        {
          "text": "You should call `make_allowed_move(auxiliary, target)` inside the second `elif` clause.",
          "testCode": "assert.match(code, /make_allowed_move\\s*\\(\\s*auxiliary\\s*,\\s*target\\s*\\)(?=\\s+#\\s*initiate\\scall)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de7662244db513d7b673ec.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de773f81facd14653f49c8",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "It looks like it's working! But the output is not very readable. Print a new line character after printing the rods to fix that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True\n                      \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n--fcc-editable-region--        \n    # display our progress\n    print(rods)\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n--fcc-editable-region--    \n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            make_allowed_move(source, target)\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n            make_allowed_move(source, auxiliary)\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n            make_allowed_move(auxiliary, target)\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass a string with a new line character (`'\\n'`) as the second argument for your two `print(rods)` calls.",
          "testCode": "({ test: () => assert.match(code, /print\\(\\s*rods\\s*,\\s*('|\")\\\\n\\1\\s*\\)(?=.*print\\(\\s*rods\\s*,\\s*('|\")\\\\n\\2\\s*\\))/s) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de773f81facd14653f49c8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de79de2fac6b1536ebcfdd",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "The iterative solution of Tower of Hanoi might seem complete, but change the number of disks to `4` and look at the output.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nNUMBER_OF_DISKS = 3\n--fcc-editable-region--\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True      \n                \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods, '\\n')\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods, '\\n')\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n            make_allowed_move(source, target)\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n            make_allowed_move(source, auxiliary)\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n            make_allowed_move(auxiliary, target)\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should set `NUMBER_OF_DISKS` to 4.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get('NUMBER_OF_DISKS'), 4) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de79de2fac6b1536ebcfdd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64de7be06eb689161dd63cf0",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "The conditionals you wrote previously are only valid for odd numbers of disks.\n\nAdd a nested `if` to execute when `n` is odd, and add one indent level to your `print()` and `make_allowed_move()` calls.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True\n                      \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods, '\\n')\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods, '\\n')\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n--fcc-editable-region--     \n        if remainder == 1:\n            \n            print(f'Move {i + 1} allowed between {source} and {target}')\n            make_allowed_move(source, target)\n--fcc-editable-region--            \n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n            make_allowed_move(source, auxiliary)\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n            make_allowed_move(auxiliary, target)\n           \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should nest an `if` statement to execute when `n` is odd. Don't forget to indent your `print()` and `make_allowed_move()` calls.",
          "testCode": "({ test: () => assert.match(code, /if\\s+n\\s*%\\s*2\\s*(!=\\s*0|==\\s*1)\\s*:\\s+print.*\\s+make_allowed_move\\(.*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64de7be06eb689161dd63cf0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df202aa1342114cd077920",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "If the number of disks is even and the remainder equals `1`, the move is allowed between the source rod and the auxiliary rod. Add an `else` clause to print the allowed movement and call `make_allowed_move()` with the correct arguments.\n\nIf you look at the output, you can see that the execution stops at the third move because of an `IndexError`. This happens because the code is still incomplete and needs an `else` clause that you will be writing soon. To make it work, turn your `make_allowed_move()` call into a comment.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True              \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods, '\\n')\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods, '\\n')\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n--fcc-editable-region--     \n        if remainder == 1:\n            if n % 2 != 0:\n                print(f'Move {i + 1} allowed between {source} and {target}')\n                make_allowed_move(source, target)\n            \n--fcc-editable-region--            \n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n            make_allowed_move(source, auxiliary)\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n            make_allowed_move(auxiliary, target)\n           \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add an `else` clause.",
          "testCode": "const tCode = code.replace(/\\r/g, '');\nconst ifBlock = __helpers.python.getBlock(tCode, \"if remainder == 1\");\nassert.match(ifBlock.block_body, /else:/);"
        },
        {
          "text": "You should have `print(f'Move {i + 1} allowed between {source} and {auxiliary}')` within the `else` clause.",
          "testCode": "const tCode = code.replace(/\\r/g, '');\nconst ifBlock = __helpers.python.getBlock(tCode, \"if remainder == 1\");\nconst elseBlock = __helpers.python.getBlock(ifBlock.block_body, \"else\");\nassert.match(elseBlock.block_body, /print\\(\\s*f('|\")Move\\s\\{\\s*i\\s*\\+\\s*1\\s*\\}\\sallowed\\sbetween\\s\\{\\s*source\\s*\\}\\sand\\s\\{\\s*auxiliary\\s*\\}\\1\\s*\\)/);"
        },
        {
          "text": "You should have `# make_allowed_move(source, auxiliary)` within the `else` clause.",
          "testCode": "const tCode = code.replace(/\\r/g, '');\nconst ifBlock = __helpers.python.getBlock(tCode, \"if remainder == 1\");\nconst elseBlock = __helpers.python.getBlock(ifBlock.block_body, \"else\");\nassert.match(elseBlock.block_body, /# *make_allowed_move\\(\\s*source\\s*,\\s*auxiliary\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df202aa1342114cd077920.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df332162988b13c35b7f7d",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "Now you need to do the same with your `elif` statement: put the `print()` and `make_allowed_move()` calls inside an `if` statement to execute when `n` is odd.\n\nAlso, turn the `# make_allowed_move(source, auxiliary)` comment into code.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True\n                      \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods, '\\n')\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods, '\\n')\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            if n % 2 != 0:\n                print(f'Move {i + 1} allowed between {source} and {target}')\n                make_allowed_move(source, target)\n--fcc-editable-region--                \n            else:\n                print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n                # make_allowed_move(source, auxiliary)            \n\n        elif remainder == 2:\n            print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n            make_allowed_move(source, auxiliary)\n--fcc-editable-region--            \n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n            make_allowed_move(auxiliary, target)\n           \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should nest your `print()` and `make_allowed_move()` calls inside an `if` statement to execute when `n` is odd.\n\n```js\n({ test: () => assert.match(code, /if\\s+n\\s*%\\s*2\\s*(!=\\s*0|==\\s*1)\\s*:\\s+print\\(\\s*f('|\")Move\\s\\{\\s*i\\s*\\+\\s*1\\s*\\}\\sallowed\\sbetween\\s{\\s*source\\s*\\}\\sand\\s\\{\\s*auxiliary\\s*\\}\\2\\s*\\)\\s+make_allowed_move\\(\\s*source\\s*,\\s*auxiliary\\s*\\)/) })\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df332162988b13c35b7f7d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df346f4c86461419974c1e",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "Finally, add an `else` clause that prints the allowed move and call `make_allowed_move`. Try to figure out the correct arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nnumber_of_moves = 2 ** NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True              \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods, '\\n')\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods, '\\n')\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            if n % 2 != 0:\n                print(f'Move {i + 1} allowed between {source} and {target}')\n                make_allowed_move(source, target)\n            else:\n                print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n                make_allowed_move(source, auxiliary)            \n--fcc-editable-region--\n        elif remainder == 2:\n            if n % 2 != 0:\n                print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n                make_allowed_move(source, auxiliary)\n--fcc-editable-region--\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n            make_allowed_move(auxiliary, target)\n           \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add an `else` clause.",
          "testCode": "const tCode = code.replace(/\\r/g, '');\nconst elifBlock = __helpers.python.getBlock(tCode, \"elif remainder == 2\");\nassert.match(elifBlock.block_body, /else:/);"
        },
        {
          "text": "You should have `print(f'Move {i + 1} allowed between {source} and {target}')` within the `else` block.",
          "testCode": "const tCode = code.replace(/\\r/g, '');\nconst elifBlock = __helpers.python.getBlock(tCode, \"elif remainder == 2\");\nassert.match(elifBlock.block_body, /print\\(\\s*f('|\")Move\\s\\{\\s*i\\s*\\+\\s*1\\s*\\}\\sallowed\\sbetween\\s{\\s*source\\s*\\}\\sand\\s\\{\\s*target\\s*\\}\\1\\s*\\)/);"
        },
        {
          "text": "You should have `make_allowed_move(source, target)` within the `else` block.",
          "testCode": "const tCode = code.replace(/\\r/g, '');\nconst elifBlock = __helpers.python.getBlock(tCode, \"elif remainder == 2\");\nassert.match(elifBlock.block_body, /make_allowed_move\\(\\s*source\\s*,\\s*target\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df346f4c86461419974c1e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df353d7ae6dc148fd64f53",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "That's all for the iterative solution. From now on you are going to build a function that makes use of a recursive approach. Recursion is when a function calls itself.\nIn this case, you are going to use recursion to calculate smaller versions of the same problem.\n\nDelete the whole body of the `move` function except for the comment and the first `print` call. Leave the function declaration as is.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nnumber_of_moves = 2 ** NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True              \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods, '\\n')\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods, '\\n')\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if remainder == 1:\n            if n % 2 != 0:\n                print(f'Move {i + 1} allowed between {source} and {target}')\n                make_allowed_move(source, target)\n            else:\n                print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n                make_allowed_move(source, auxiliary)\n        elif remainder == 2:\n            if n % 2 != 0:\n                print(f'Move {i + 1} allowed between {source} and {auxiliary}')\n                make_allowed_move(source, auxiliary)\n            else:\n                print(f'Move {i + 1} allowed between {source} and {target}')\n                make_allowed_move(source, target)\n        elif remainder == 0:\n            print(f'Move {i + 1} allowed between {auxiliary} and {target}')\n            make_allowed_move(auxiliary, target)           \n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete the whole body of the `move` function except for the comment and the first `print` call.\n\n```js\n({ test: () => assert.match(code, /print\\(\\s*rods\\s*,\\s*('|\")\\\\n\\1\\s*\\)\\s+(?=#\\sinitiate)/) })\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df353d7ae6dc148fd64f53.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df3e2fac34d813d048f3f9",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "You won't need `make_allowed_move` and `number_of_moves`, either. Delete the whole function and the variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nNUMBER_OF_DISKS = 4\nnumber_of_moves = 2 ** NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef make_allowed_move(rod1, rod2):    \n    forward = False\n    if not rods[rod2]:\n        forward = True\n    elif rods[rod1] and rods[rod1][-1] < rods[rod2][-1]:\n        forward = True              \n    if forward:\n        print(f'Moving disk {rods[rod1][-1]} from {rod1} to {rod2}')\n        rods[rod2].append(rods[rod1].pop())\n    else:\n        print(f'Moving disk {rods[rod2][-1]} from {rod2} to {rod1}')\n        rods[rod1].append(rods[rod2].pop())\n    \n    # display our progress\n    print(rods, '\\n')\n\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods, '\\n')\n              \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete the `number_of_moves` variable and its content.",
          "testCode": "({ test: () => assert.match(code, /NUMBER_OF_DISKS\\s*=\\s*4\\s+(?=rods\\s*=\\s*\\{)/) })"
        },
        {
          "text": "You should delete the whole `make_allowed_move` function.",
          "testCode": "({ test: () => assert.match(code, /\\}\\s+(?=def\\s+move\\(\\s*n\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target\\s*\\)\\s*:)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df3e2fac34d813d048f3f9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df3f1011888113fbd3d81b",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "To solve the puzzle with recursion, the first thing to do is break the original problem down into smaller sub-problems.\n\nThe final configuration with `n` disks piled up to the third rod in decreasing order can be obtained by moving:\n\n- `n - 1` disks from the source to the auxiliary rod\n- the largest disk from the source to the target\n- and then the `n - 1` disks from the auxiliary rod to the target.\n\nSo, the first thing the `move` function should do is calling itself with `n - 1` as the first argument. But if you try to do so without defining a base case, you will get a `RecursionError`. This happens because the function keeps calling itself indefinitely.\n\nBefore your comment and your `print()` call, add the recursive function call with `n - 1` as the first argument and make sure the function body executes only when `n` is greater than zero. For now, leave the other arguments in the same order.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods, '\\n')\n    \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `move` function body should start with an `if` statement that is triggered when `n` is greater than zero.",
          "testCode": "({ test: () => assert.match(code, /def\\s+move\\(\\s*n\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target\\s*\\)\\s*:\\s+if\\s+n\\s*>\\s*0\\s*:/) })"
        },
        {
          "text": "You should call `move(n - 1, source, auxiliary, target)` inside the `if` statement. Remember to indent your `print()` call.\n\n```js\nconst transformedCode = \"\\n\" + code.replace(/\\r/g, '');\nconst move = __helpers.python.getDef(transformedCode, \"move\");\nconst { function_parameters, function_body } = move;\n\nassert.match(function_parameters, /n\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target/);\nconst functionBodyIndent = function_body.match(/ +/)[0];\nconst re = new RegExp(`${functionBodyIndent}if\\\\s+n\\\\s*>\\\\s*0\\\\s*:\\\\s+^${functionBodyIndent}( +)move\\\\(\\\\s*n\\\\s*-\\\\s*1\\\\s*,\\\\s*source\\\\s*,\\\\s*auxiliary\\\\s*,\\\\s*target\\\\s*\\\\).+?^${functionBodyIndent}\\\\1print\\\\s*\\\\(\\\\s*rods\\\\s*,\\\\s*(\"|')\\\\\\\\n\\\\2\\\\s*\\\\)`, \"ms\");\nassert.match(function_body, re);\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df3f1011888113fbd3d81b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df45a3ad4f8719e5355244",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "The steps of moving `n - 1` disks can be broken down further until only a single disk is considered. This will be the first move occurring. After the first move occurs, the following moves are generated by the unwinding of the recursive calls. Keep in mind that in each recursive step the role played by the rods changes between source, target, and auxiliary.\n\nFor now, each recursive call prints the `rods` dictionary without performing any changes to the lists. Before the `print()` call, remove the last element from the `rods[source]` list and append it to the `rods[target]` list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, auxiliary, target)\n        \n        # display starting configuration\n        print(rods, '\\n')\n              \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the last element from the `rods[source]` list and append it to the `rods[target]` list before the `print` call.\n\n```js\n({ test: () => assert.isTrue(runPython(`\n_log = []\ndef capture_print(*args):\n    _log.append(repr(args))\n\nold_print = print\nprint = capture_print\n\nold_rods = rods\nrods2 = {\n    'A': list(range(5, 0, -1)),\n    'B': [],\n    'C': []\n}\nrods = rods2\n\nmove(5, 'A', 'B', 'C')\nrods = old_rods\nprint = old_print\n\n_expected_prints = [\nr\"({'A': [5, 4, 3, 2], 'B': [], 'C': [1]}, '\\\\n')\",\nr\"({'A': [5, 4, 3], 'B': [], 'C': [1, 2]}, '\\\\n')\",\nr\"({'A': [5, 4], 'B': [], 'C': [1, 2, 3]}, '\\\\n')\",\nr\"({'A': [5], 'B': [], 'C': [1, 2, 3, 4]}, '\\\\n')\",\nr\"({'A': [], 'B': [], 'C': [1, 2, 3, 4, 5]}, '\\\\n')\",\n]\n\nfor args in _log:\n    if not _expected_prints:\n        break\n    if args == _expected_prints[0]:\n        _expected_prints.pop(0)\n\nnot rods2['A'] and rods2['C'] == list(range(1, 6)) and not _expected_prints\n`))})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df45a3ad4f8719e5355244.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df47b32b92301a815d5ef8",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "At first, the recursive call you have just added deals with the sub-problem of moving `n - 1` disks to the second rod.\n\nFor that reason, the `target` argument corresponds to your second rod, while the `auxiliary` argument is the third rod. Keep in mind that those will keep swapping as the recursion proceeds.\n\nFix the arguments order exchanging `target` and `auxiliary` in your recursive call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, auxiliary, target)\n        \n        # move the nth disk from source to target\n        rods[target].append(rods[source].pop())\n        \n        # display our progress\n        print(rods, '\\n')\n              \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the order of the arguments in your `move(n - 1, source, auxiliary, target)` call.",
          "testCode": "({ test:  () => assert.match(code, /move\\(\\s*n\\s*-\\s*1\\s*,\\s*source\\s*,\\s*target\\s*,\\s*auxiliary\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df47b32b92301a815d5ef8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df496c6a8ddf1b38db1ed6",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "In a previous step, you wrote the code to move the largest disk of the sub-problem to the target rod.\n\nNow, all you need to do is add another recursive call to move the `n - 1` disks you have already displaced. Copy the first recursive call and paste it at the end of the `if` block.\n\nNote that the function arguments are not in the right order. Try to figure out the correct order.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, target, auxiliary)\n        \n        # move the nth disk from source to target\n        rods[target].append(rods[source].pop())\n        \n        # display our progress\n        print(rods, '\\n')\n              \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `move(n - 1,  auxiliary, source, target)` at the end of your `move` function.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}move\\(\\s*n\\s*-\\s*1\\s*,\\s*auxiliary\\s*,\\s*source\\s*,\\s*target\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df496c6a8ddf1b38db1ed6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64df72c6e0183a191fcd72dc",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "Before your function call, write a comment saying `initiate call from source A to target C with auxiliary B`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    print(rods)\n--fcc-editable-region--\n\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write the given comment before your function call.",
          "testCode": "({test: () => assert.match(code, /#\\s*initiate\\scall\\sfrom\\ssource\\sA\\sto\\starget\\sC\\swith\\sauxiliary\\sB/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64df72c6e0183a191fcd72dc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64e337e3096b7c1739d934e6",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "Before your recursive call, add a comment saying `move n - 1 disks from source to auxiliary, so they are out of the way`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        \n        move(n - 1, source, auxiliary, target)\n        \n        # display starting configuration\n        print(rods, '\\n')\n              \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a comment with the provided text before your recursive call.",
          "testCode": "({ test: () => assert.match(code, /if\\s+n\\s*>\\s*0\\s*:\\s+#\\s*move\\sn\\s-\\s1\\sdisks\\sfrom\\ssource\\sto\\sauxiliary\\s*,\\s*so\\sthey\\sare\\sout\\sof\\sthe\\sway\\s+(?=move\\(\\s*n\\s*-\\s*1\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target\\s*\\))/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64e337e3096b7c1739d934e6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64e3392996b41d17a1375643",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "Before appending the last element to the target, add a comment saying `move the nth disk from source to target`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, auxiliary, target)\n        \n        rods[target].append(rods[source].pop())\n        \n        # display starting configuration\n        print(rods, '\\n')\n              \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a comment with the provided text before `rods[target].append(rods[source].pop())`.",
          "testCode": "({ test: () => assert.match(code, /move\\(\\s*n\\s*-\\s*1\\s*,\\s*source\\s*,\\s*auxiliary\\s*,\\s*target\\s*\\)\\s+#\\s*move\\sthe\\snth\\sdisk\\sfrom\\ssource\\sto\\starget\\s+(?=rods\\s*\\[\\s*target\\s*\\]\\s*\\.append\\(\\s*rods\\s*\\[\\s*source\\s*\\]\\s*\\.pop\\(\\s*\\)\\s*\\))/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64e3392996b41d17a1375643.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64e33a488b4a2717fa22ebf3",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "Add another comment before your `print()` call saying `display starting configuration`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    \n    print(rods)\n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the provided text to add a comment before your `print()` call.",
          "testCode": "({ test: () => assert.match(code, /#\\s*display\\sstarting\\sconfiguration\\s+print\\s*\\(\\s*rods\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64e33a488b4a2717fa22ebf3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64e340302bd28513f3e73740",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "Now, change the comment above the `print()` call into `display our progress`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, auxiliary, target)\n        \n        # move the nth disk from source to target\n        rods[target].append(rods[source].pop())\n        \n        # display starting configuration\n        print(rods, '\\n')\n              \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should change `# display starting configuration` into `# display our progress`.",
          "testCode": "({ test: () => assert.match(code, /\\)\\s+#\\s*display\\sour\\sprogress\\s+(?=print\\()/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64e340302bd28513f3e73740.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64e340ecee18af1430939018",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "Above the second `move` call, add one last comment saying `move the n - 1 disks that we left on auxiliary onto target`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, target, auxiliary)\n        \n        # move the nth disk from source to target\n        rods[target].append(rods[source].pop())\n        \n        # display our progress\n        print(rods, '\\n')\n        \n        move(n - 1,  auxiliary, source, target)\n              \n--fcc-editable-region--\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a comment using the provided text.",
          "testCode": "({ test: () => assert.match(code, /#\\s*move\\sthe\\sn\\s-\\s1\\sdisks\\sthat\\swe\\sleft\\son\\sauxiliary\\sonto\\starget\\s+(?=move\\(\\s*n\\s*-\\s*1\\s*,\\s*auxiliary\\s*,\\s*source\\s*,\\s*target\\s*\\))/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64e340ecee18af1430939018.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "64e34146860065146733883b",
      "title": "Step 53",
      "challengeType": 20,
      "dashedName": "step-53",
      "description": "Although recursion can sometimes be less easy to understand, it gives you the power to create more concise code. In this case, you don't even need to differentiate between even and odd numbers of disks. \n\nSet `NUMBER_OF_DISKS` to `5` and check the output.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nNUMBER_OF_DISKS = 4\nA = list(range(NUMBER_OF_DISKS, 0, -1))\nB = []\nC = []\n\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, target, auxiliary)\n        \n        # move the nth disk from source to target\n        target.append(source.pop())\n        \n        # display our progress\n        print(A, B, C, '\\n')\n        \n        # move the n - 1 disks that we left on auxiliary onto target\n        move(n - 1,  auxiliary, source, target)\n              \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, A, B, C)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should set the `NUMBER_OF_DISKS` variable to 5.",
          "testCode": "({test: () => assert.equal(__userGlobals.get('NUMBER_OF_DISKS'), 5) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\64e34146860065146733883b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "650c6082e5586f9e3acfcd3b",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "Now, delete the `rods` dictionary and turn its keys into the variables `A`, `B`, and `C`, respectively, keeping their values. Refactor your code to reflect these changes. If you see the output on the terminal, you correctly did this step.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nNUMBER_OF_DISKS = 4\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\ndef move(n, source, auxiliary, target):\n    if n > 0:\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, target, auxiliary)\n        \n        # move the nth disk from source to target\n        rods[target].append(rods[source].pop())\n        \n        # display our progress\n        print(rods, '\\n')\n        \n        # move the n - 1 disks that we left on auxiliary onto target\n        move(n - 1,  auxiliary, source, target)\n              \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn `rods['A']` into a variable named `A` keeping its value.",
          "testCode": "assert.match(code, /A\\s*=\\s*list\\s*\\(\\s*range\\s*\\(\\s*NUMBER_OF_DISKS\\s*,\\s*0\\s*,\\s*-\\s*1\\s*\\)\\s*\\)/);"
        },
        {
          "text": "You should turn `rods['B']` into a variable named `B` keeping its value.",
          "testCode": "assert.match(code, /B\\s*=\\s*\\[\\s*\\]/);"
        },
        {
          "text": "You should turn `rods['C']` into a variable named `C` keeping its value.",
          "testCode": "assert.match(code, /C\\s*=\\s*\\[\\s*\\]/);"
        },
        {
          "text": "You should modify your `print()` call to print `A`, `B`, `C`, instead of the `rods` object. Keep the newline character in the `print()` call.",
          "testCode": "assert.match(code, /print\\s*\\(\\s*A\\s*,\\s*B\\s*,\\s*C\\s*,\\s*('|\")\\\\n\\1\\s*\\)/);"
        },
        {
          "text": "You should have `target.append(source.pop())` in your code.",
          "testCode": "assert.match(code, /target\\.append\\s*\\(\\s*source\\.pop\\s*\\(\\s*\\)\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\650c6082e5586f9e3acfcd3b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "65782342850feb3b8d62f936",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "Since you are going to use the expression `(i + 1) % 3` multiple times, it is convenient to store it in a variable.\n\nJust above your `if` statement, declare a `remainder` variable and assign the value `(i + 1) % 3` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        \n        if (i + 1) % 3 == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a `remainder` variable just above the `if` block.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}remainder\\s*=/m) })"
        },
        {
          "text": "The value of your `remainder` variable should be the expression `(i + 1) % 3`.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}remainder\\s*=\\s*\\(\\s*i\\s*\\+\\s*1\\s*\\)\\s*%\\s*3/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\65782342850feb3b8d62f936.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "6578273de26b6e5965a9107d",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "Now, replace the expression in the `if` condition with the `remainder` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 3\nnumber_of_moves = 2**NUMBER_OF_DISKS - 1\nrods = {\n    'A': list(range(NUMBER_OF_DISKS, 0, -1)),\n    'B': [],\n    'C': []\n}\n\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    # display starting configuration\n    print(rods)\n    for i in range(number_of_moves):\n        remainder = (i + 1) % 3\n        if (i + 1) % 3 == 1:\n            print(f'Move {i + 1} allowed between {source} and {target}')\n--fcc-editable-region--\n\n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, 'A', 'B', 'C')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `(i+ 1) % 3` with the `remainder` variable.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}if\\s+remainder\\s*==\\s*1\\s*:/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\6578273de26b6e5965a9107d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "657b667a772ed53e82962c81",
      "title": "Step 54",
      "challengeType": 20,
      "dashedName": "step-54",
      "description": "There's still one thing you can do to improve the readability of your code.\n\nModify your `if` to execute when `n` is less than or equal to zero and add a `return` statement to stop the function execution.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 5\nA = list(range(NUMBER_OF_DISKS, 0, -1))\nB = []\nC = []\n--fcc-editable-region--\ndef move(n, source, auxiliary, target):\n    if n > 0:\n\n--fcc-editable-region--        \n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, target, auxiliary)\n        \n        # move the nth disk from source to target\n        target.append(source.pop())\n        \n        # display our progress\n        print(A, B, C, '\\n')\n        \n        # move the n - 1 disks that we left on auxiliary onto target\n        move(n - 1,  auxiliary, source, target)\n              \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, A, B, C)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your existing `if` to check if `n` is less than or equal to `0`.",
          "testCode": "({ test: () =>\n  {\n    const hanoi = __helpers.python.getDef(code, \"move\");\n    const {function_body} = hanoi;    \n    assert(function_body.match(/^\\s{4}if\\s+n\\s*<=\\s*0\\s*:/m));\n  }\n})"
        },
        {
          "text": "You should add a `return` statement to the first line of your `if` block.",
          "testCode": "({ test: () =>\n  {\n    const hanoi = __helpers.python.getDef(code, \"move\");\n    const {function_body} = hanoi;    \n    assert(function_body.match(/^(\\s{4})if\\s+n\\s*<=\\s*0\\s*:\\s*\\1\\1return/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\657b667a772ed53e82962c81.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "657b6a4a49faec5c600287ba",
      "title": "Step 55",
      "challengeType": 20,
      "dashedName": "step-55",
      "description": "As a final step, reduce the indentation level of all the code after the `return` statement.\n\nWell done. You have completed the Tower of Hanoi practice project.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nNUMBER_OF_DISKS = 5\nA = list(range(NUMBER_OF_DISKS, 0, -1))\nB = []\nC = []\n\ndef move(n, source, auxiliary, target):\n    if n <= 0:\n        return\n        # move n - 1 disks from source to auxiliary, so they are out of the way\n        move(n - 1, source, target, auxiliary)\n        \n        # move the nth disk from source to target\n        target.append(source.pop())\n        \n        # display our progress\n        print(A, B, C, '\\n')\n        \n        # move the n - 1 disks that we left on auxiliary onto target\n        move(n - 1,  auxiliary, source, target)\n              \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, A, B, C)\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "NUMBER_OF_DISKS = 5\nA = list(range(NUMBER_OF_DISKS, 0, -1))\nB = []\nC = []\n\ndef move(n, source, auxiliary, target):\n    if n <= 0:\n        return\n    # move n - 1 disks from source to auxiliary, so they are out of the way\n    move(n - 1, source, target, auxiliary)\n        \n    # move the nth disk from source to target\n    target.append(source.pop())\n        \n    # display our progress\n    print(A, B, C, '\\n')\n        \n    # move the n - 1 disks that we left on auxiliary onto target\n    move(n - 1,  auxiliary, source, target)\n              \n# initiate call from source A to target C with auxiliary B\nmove(NUMBER_OF_DISKS, A, B, C)"
        }
      ],
      "tests": [
        {
          "text": "You should reduce the indentation level of all the code after the `return` statement.",
          "testCode": "({ test: () => assert(runPython(`\n    a, b, c = [3, 2, 1], [], []\n    move(3, a, b, c)\n    a == [] and b == [] and c == [3, 2, 1]\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-recursion-by-solving-the-tower-of-hanoi-puzzle\\657b6a4a49faec5c600287ba.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-recursion-by-solving-the-tower-of-hanoi-puzzle",
        "name": "Learn Recursion By Solving The Tower Of Hanoi Puzzle"
      }
    },
    {
      "id": "6564642ce403fe29cc23fee7",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "A Python module is a file containing code designed to perform specific tasks. The Python standard library contains many modules that you can import and use in your code. You can achieve this by using the `import` statement followed by the name of the module.\n\nStart this project by importing the `string` module.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should import the `string` module.",
          "testCode": "({ test: () => assert.match(code, /^import\\s+string/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564642ce403fe29cc23fee7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564683821b2ee3174e7250e",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "You can access the utilities defined inside the imported module through the dot notation. The dot notation works by appending a dot followed by the utility name to the module name. For example, here's how to access the `ascii_lowercase` constant:\n\n```py\nimport string\n\n\nprint(string.ascii_lowercase)\n# Output: abcdefghijklmnopqrstuvwxyz\n```\n\nIn this project, you are going to use different constants from the `string` module. \n\nDeclare a new variable called `letters` and assign `string.ascii_letters` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nimport string\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `letters`.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"letters\")) })"
        },
        {
          "text": "You should assign `string.ascii_letters` to your `letters` variable.",
          "testCode": "({ test: () => assert(runPython(`\n    import string\n    letters == string.ascii_letters\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564683821b2ee3174e7250e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656469e62377ab34a5bcb8d1",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "Declare two new variables named `digits` and `symbols` and assign them `string.digits` and `string.punctuation`, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nimport string\n\nletters = string.ascii_letters\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `digits`.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"digits\")) })"
        },
        {
          "text": "You should assign `string.digits` to your `digits` variable.",
          "testCode": "({ test: () => assert(runPython(`\n    import string\n    digits == string.digits\n  `))\n})"
        },
        {
          "text": "You should declare a variable named `symbols`.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"symbols\")) })"
        },
        {
          "text": "You should assign `string.punctuation` to your `symbols` variable.",
          "testCode": "({ test: () => assert(runPython(`\n    import string\n    symbols == string.punctuation\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656469e62377ab34a5bcb8d1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65646ab6bced52360f44670f",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Now declare a variable named `all_characters` and assign it the result of concatenating your existing variables.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import string\n\n\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `all_characters`.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"all_characters\")) })"
        },
        {
          "text": "You should concatenate `letters`, `digits`, and `symbols` and assign the result to your `all_characters` variable.",
          "testCode": "({ test: () => assert(runPython(`\n    import string\n    from itertools import permutations\n    perms = permutations([string.ascii_letters, string.digits, string.punctuation])\n    any(\"\".join(perm) == all_characters for perm in perms)\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\65646ab6bced52360f44670f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65646ffeaed2d238c562a014",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "It is a common convention to place `import` statements at the top of your code. And additionally, in case of multiple `import` statements, sort them in alphabetical order to improve readability.\n\nAt the top of your code, import the `random` module.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nimport string\n--fcc-editable-region--\n\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n\n# Combine all characters\nall_characters = letters + digits + symbols\n\nprint(all_characters)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should import the `random` module.",
          "testCode": "({ test: () => assert.match(code, /^import\\s+random/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\65646ffeaed2d238c562a014.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656470d517833a39bb8b5608",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "The `random` module contains a pseudo-random number generator. Most of its functionalities depend on the `random()` function, which returns a floating point number in the range between `0.0` (inclusive) and `1.0` (exclusive).\n\nCall the `random()` function from the `random` module and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import random\nimport string\n\n\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n\n# Combine all characters\nall_characters = letters + digits + symbols\n\nprint(all_characters)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the result of calling `random.random()`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*random\\.random\\s*\\(\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656470d517833a39bb8b5608.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656474314bf37d3c83a85143",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "The `choice()` function from the `random` module takes a sequence and returns a random item of the sequence.\n\nModify your `print()` call to use the `choice()` function and pass `all_characters` as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import random\nimport string\n\n\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n\n# Combine all characters\nall_characters = letters + digits + symbols\n\nprint(all_characters)\n--fcc-editable-region--\nprint(random.random())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your existing `print()` call to print `random.choice(all_characters)`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*random\\.choice\\s*\\(\\s*all_characters\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656474314bf37d3c83a85143.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656475bbf1c2573de1d2c69c",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "Every time the code runs, you should see a random character from the `all_characters` string. This is exactly what you want to achieve to create a random password.\n\nHowever, the algorithm on which `random` relies makes the generated pseudo-random numbers predictable. Therefore, although the `random` module is suitable for the most common applications, it cannot be used for cryptographic purposes, due to its deterministic nature. \n\nInstead of importing `random`, import the `secrets` module. Then change the `print()` call to use `secrets.choice(all_characters)`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nimport random\nimport string\n\n\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n\n# Combine all characters\nall_characters = letters + digits + symbols\n\nprint(all_characters)\nprint(random.choice(all_characters))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should import the `secrets` module instead of the `random` module.",
          "testCode": "({\n  test: () => {\n    assert.match(code, /^import\\s+secrets/m)\n    assert.isFalse( /^import\\s+random/m.test(code))\n  }\n})"
        },
        {
          "text": "You should modify your existing `print()` call to print `secrets.choice(all_characters)`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*secrets\\.choice\\s*\\(\\s*all_characters\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656475bbf1c2573de1d2c69c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656477845006313fbfea0ad1",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "Although the effect might seem equal to `random.choice()`, `secrets` ensures you the most secure source of randomness that your operating system can provide.\n\nNow, delete your two `print()` calls.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n\n# Combine all characters\nall_characters = letters + digits + symbols\n--fcc-editable-region--\nprint(all_characters)\nprint(secrets.choice(all_characters))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete your two `print()` calls.",
          "testCode": "({ test: () => assert.isFalse( /^print/m.test(code)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656477845006313fbfea0ad1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656479aa5f298441c190bf8f",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "Declare a `generate_password` function and write all your code except the `import` lines inside the function body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n--fcc-editable-region--\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n\n# Combine all characters\nall_characters = letters + digits + symbols\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a function named `generate_password`.",
          "testCode": "({\n  test: () => assert(runPython(`\n  _Node(_code).has_function('generate_password')\n  `))\n})"
        },
        {
          "text": "The import statements should still be outside the function.",
          "testCode": "({\n  test: () => assert(runPython(`\n  imports_list = _Node(_code).find_imports()\n  any([imp.is_equivalent('import secrets') for imp in imports_list]) and any([imp.is_equivalent('import string') for imp in imports_list])\n  `))\n})"
        },
        {
          "text": "The four variable declarations should be moved inside the function.",
          "testCode": "({\n  test: () => assert(runPython(`\n  func = _Node(_code).find_function('generate_password')\n  vars = ['letters', 'digits', 'symbols', 'all_characters']\n  func.find_variable('letters').is_equivalent('letters = string.ascii_letters') and \\\\\n  func.find_variable('digits').is_equivalent('digits = string.digits') and \\\\\n  func.find_variable('symbols').is_equivalent('symbols = string.punctuation') and \\\\\n  func.find_variable('all_characters').is_equivalent('all_characters = letters + digits + symbols') and \\\\\n  all(not _Node(_code).has_variable(var) for var in vars)\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656479aa5f298441c190bf8f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65647c71a5d2bd431596f629",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "Your `generate_password` function needs a few parameters. Start by adding a `length` parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nimport secrets\nimport string\n\n\ndef generate_password():    \n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `generate_password` function should take a `length` parameter.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    sig = str(inspect.signature(generate_password))\n    sig == \"(length)\"\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\65647c71a5d2bd431596f629.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656485a8a3496d4a36b1496a",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "These three variables constitute the possible characters to choose from when generating the password.\n\nJust before them, add a comment saying `Define the possible characters for the password`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nimport string\n\n\n\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add the comment just above the `letters` variable.",
          "testCode": "({ test: () => assert.match(code, /^#\\s*Define the possible characters for the password.*^letters/ms) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656485a8a3496d4a36b1496a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564883669b5af4b69f794cc",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "Your `all_characters` variable is a string formed by all lowercase and uppercase letters, all the 10 digits and several special characters. \n\nJust before it, add a comment saying `Combine all characters`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nimport string\n\n\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n\n\nall_characters = letters + digits + symbols\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add the comment just above your `all_characters` variable.",
          "testCode": "({ test: () => assert.match(code, /^#\\s*Combine all characters\\s+^all_characters/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564883669b5af4b69f794cc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656489e0a5d0954c1a64fc93",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Now print the `all_characters` variable to see what it looks like.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import string\n\n\n# Define the possible characters for the password\nletters = string.ascii_letters\ndigits = string.digits\nsymbols = string.punctuation\n--fcc-editable-region--\n# Combine all characters\nall_characters = letters + digits + symbols\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print your `all_characters` variable.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*all_characters\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656489e0a5d0954c1a64fc93.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65648e4c5b316c4ec5e4fddc",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "At the bottom of your function, declare a `password` variable and assign an empty string to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `password` variable inside your function with the value of an empty string. Pay attention to the indentation.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const generate_pw = __helpers.python.getDef(\"\\n\"+transformedCode, \"generate_password\");\n    const {function_body} = generate_pw;     \n    assert(function_body.match(/password\\s*=\\s*(\"|')\\1/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\65648e4c5b316c4ec5e4fddc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65648eefbee2014f5815f4ba",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "Below your new variable, add a comment saying `Generate password`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n--fcc-editable-region--    \n    password = ''\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add the provided comment.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const generate_pw = __helpers.python.getDef(\"\\n\"+transformedCode, \"generate_password\");\n    const {function_body} = generate_pw;     \n    assert(function_body.match(/#\\s*Generate password/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\65648eefbee2014f5815f4ba.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65648f4b2281ba50051ae39c",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "Next, write a `for` loop with `i` as the loop variable. Use the `range()` function to iterate up to the value of the `length`.\n\nInside the loop, use the addition assignment operator to add a random character from `all_characters` to the current value of `password`. Use the `choice()` function from the `secrets` module for that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\ndef generate_password(length):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n--fcc-editable-region--    \n    password = ''\n    # Generate password\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write a `for` loop that iterates over `range(length)`.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const generate_pw = __helpers.python.getDef(\"\\n\"+transformedCode, \"generate_password\");\n    const {function_body} = generate_pw;    \n    assert(function_body.match(/for\\s+i\\s+in\\s+range\\s*\\(\\s*length\\s*\\)\\s*:/));\n  }\n})"
        },
        {
          "text": "You should use the `+=` operator to add a random character from `all_characters` to the current value of `password`.",
          "testCode": "({ test: () =>\n  {\n    const generate_pwd = __helpers.python.getDef(code, \"generate_password\");\n    const {function_body} = generate_pwd;    \n    assert(function_body.match(/^(\\s*)for\\s+i\\s+in\\s+range\\s*\\(\\s*length\\s*\\)\\s*:\\s*^\\1\\1password\\s*\\+=\\s*secrets\\.choice\\s*\\(\\s*all_characters\\s*\\)/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\65648f4b2281ba50051ae39c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656490295d346850a4c4f2b5",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "After the loop, add a `return` statement to your function so it returns the `password` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n--fcc-editable-region--\n    password = ''\n    # Generate password\n    for _ in range(length):\n        password += secrets.choice(all_characters)\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `password` at the end of your function.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const generate_pw = __helpers.python.getDef(\"\\n\"+transformedCode, \"generate_password\");\n    const {function_body} = generate_pw;     \n    assert(function_body.match(/^(\\s*)for\\s+\\w\\s+in\\s+range\\s*\\(\\s*length\\s*\\)\\s*:.+^\\1return\\s+password/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656490295d346850a4c4f2b5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65649122c7f77f519aaf0975",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "Finally, declare a variable `new_password` and assign it the result of calling `generate_password`. Pass `8` as the argument to your `generate_password` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    password = ''\n    # Generate password\n    for _ in range(length):\n        password += secrets.choice(all_characters)\n        \n    return password\n    \n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `generate_password` passing `8` as the argument.",
          "testCode": "({ test: () => assert.match(code, /generate_password\\s*\\(\\s*8\\s*\\)/) })"
        },
        {
          "text": "You should assign `generate_password(8)` to the variable `new_password`.",
          "testCode": "({\n  test: () => {\n    assert(__userGlobals.has(\"new_password\"));\n    assert.match(code, /^new_password\\s*=\\s*generate_password\\s*\\(\\s*8\\s*\\)/m);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\65649122c7f77f519aaf0975.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656491fa4e69005287eb5a9a",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Check the result by printing your new variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    password = ''\n    # Generate password\n    for _ in range(length):\n        password += secrets.choice(all_characters)\n        \n    return password\n    \n--fcc-editable-region--\nnew_password = generate_password(8)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `new_password`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*new_password\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656491fa4e69005287eb5a9a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656494269ccce754411a2112",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "The `re` module allows you to use *regular expressions* in your code. You will learn more about regular expressions very soon.\n\nFor now, add an `import` statement at the top of your code to import the `re` module.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\nimport secrets\nimport string\n--fcc-editable-region--\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '')\n        ]        \n\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should import the `re` module.",
          "testCode": "({ test: () => assert.match(code, /^import\\s+re/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656494269ccce754411a2112.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65649a631440b757f9f7b428",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "A regular expression, or regex, is a pattern used to match a specific combination of characters inside a string. It is a valid alternative to `if`/`else` conditional statements when you need to match or find patterns inside a string for validation purposes, character replacement, and others.\n\nThe `compile()` function from the `re` module compiles the string passed as the argument into a regular expression object that can be used by other `re` methods.\n\nDeclare a new `pattern` variable and assign the value of `re.compile('i')` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '')\n        ]        \n\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a `pattern` variable.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"pattern\")) })"
        },
        {
          "text": "You should assign `re.compile('i')` to your `pattern` variable.",
          "testCode": "({ test: () => assert(runPython(`\n    import re\n    pattern == re.compile('i')\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\65649a631440b757f9f7b428.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564a767a7241362f7d8d664",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "A standalone single underscore is used to represent a value you don't care or that won't be used in your code.\nYour iteration variable is not actually used.\n\nModify your `i` variable into a single underscore.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n--fcc-editable-region--\n    password = ''\n    # Generate password\n    for i in range(length):\n        password += secrets.choice(all_characters)\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `i` variable into `_`.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const generate_pw = __helpers.python.getDef(\"\\n\"+transformedCode, \"generate_password\");\n    const {function_body} = generate_pw;     \n    assert(function_body.match(/for\\s+_\\s+in\\s+range\\s*\\(\\s*length\\s*\\)\\s*:/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564a767a7241362f7d8d664.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564b8c9349bd76dc037967b",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "The `search()` function from the `re` module analyzes the string passed as the argument looking for the first place where the regex pattern matches the string.\n\nDeclare a variable called `quote` and assign the string `'Not all those who wander are lost.'` to this variable. Then, print the result of `pattern.search(quote)`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '')\n        ]        \n\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = re.compile('i')\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `quote` variable.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"quote\")) })"
        },
        {
          "text": "You should assign the provided string to your new `quote` variable.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"quote\"), \"Not all those who wander are lost.\") })"
        },
        {
          "text": "You should print `pattern.search(quote)`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*pattern\\.search\\s*\\(\\s*quote\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564b8c9349bd76dc037967b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564c67db26c417561ab510d",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "As you can see from the output, now your regex matches the first `l` inside the string.\n\nIn your pattern, you can add a quantifier after a character to specify how many times that character should be repeated. For example, the `+` quantifier means it should repeat one or more times.\n\nAdd a `+` quantifier to your pattern.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = re.compile('l')\nquote = 'Not all those who wander are lost.'\nprint(pattern.search(quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `pattern` variable into `re.compile('l+')`.",
          "testCode": "({ test: () => assert(runPython(`\n    import re\n    pattern == re.compile('l+')\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564c67db26c417561ab510d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564cbb6311a40783b3f5de6",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "Character classes also allow you to indicate a range of characters to match. You need to specify the starting and the ending characters separated by an hyphen, `-`. Characters follow the Unicode order.\n\nModify your `pattern` variable to match any letter `t` preceded by a lowercase letter in the `quote` variable. Use the range of characters from `a` to `z` for that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '[0123456789]')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = 'w[ha]'\nquote = 'Not all those who wander are lost.'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `pattern` variable to match any letter `t` in `quote` preceded by a lowercase letter using the `[a-z]` class.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"pattern\"), \"[a-z]t\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564cbb6311a40783b3f5de6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564cf2e8642517abdf9d6e2",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "Now, modify the pattern in your constraint tuple to indicate the range of all digits using square brackets.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, '[0123456789]')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = '[a-z]t'\nquote = 'Not all those who wander are lost.'\n#print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have the `(nums, '[0-9]')` tuple in your `constraints` list.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*(\"|')\\[0-9\\]\\1\\s*\\)\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564cf2e8642517abdf9d6e2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564d096a55d707bd77ab67b",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "The caret, `^`, placed at the beginning of the character class, matches all the characters except those specified in the class.\n\nAdd a `^` as the first character inside your character class and see what happens.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '[0-9]')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = '[a-z]t'\nquote = 'Not all those who wander are lost.'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a `^` as the first character inside your character class.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"pattern\"), \"[^a-z]t\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564d096a55d707bd77ab67b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564d27c8e4c197d367c3b1c",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "Add a new tuple to the `constraints` list. Use `lowercase` as the first item and a regex pattern that matches a single lowercase letter as the second item.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, '[0-9]')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = '[^a-z]t'\nquote = 'Not all those who wander are lost.'\n# print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a second tuple to the `constraints` list. Use the `lowercase` parameter as the first item and `[a-z]` as the second item.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*(\"|')\\[0-9\\]\\1\\s*\\)\\s*,\\s*\\(\\s*lowercase\\s*,\\s*(\"|')\\[a-z\\]\\2\\s*\\)\\s*,?\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564d27c8e4c197d367c3b1c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564d2eeb36ebe7dd9bd1ee9",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "Add a third tuple to the `constraints` list. Use the `uppercase` parameter as the first item and a regex pattern that matches a single uppercase letter as the second item.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, '[0-9]'),\n            (lowercase, '[a-z]')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = '[^a-z]t'\nquote = 'Not all those who wander are lost.'\n# print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a third tuple to the `constraints` list using `uppercase` as the first item and a character class that matches a single uppercase letter as the second item.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*(\"|')\\[0-9\\]\\1\\s*\\)\\s*,\\s*\\(\\s*lowercase\\s*,\\s*(\"|')\\[a-z\\]\\2\\s*\\)\\s*,\\s*\\(\\s*uppercase\\s*,\\s*(\"|')\\[A-Z\\]\\3\\s*\\)\\s*,?\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564d2eeb36ebe7dd9bd1ee9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564d500f1a48e7f2b732a37",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "Add one last tuple to your list. Use the `special_chars` parameter as the first item and an empty string as the second item.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, '[0-9]'),\n            (lowercase, '[a-z]'),\n            (uppercase, '[A-Z]')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = '[^a-z]t'\nquote = 'Not all those who wander are lost.'\n# print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a fourth tuple to the `constraints` list using `special_chars` as the first item and an empty string as the second item.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*(\"|')\\[0-9\\]\\1\\s*\\)\\s*,\\s*\\(\\s*lowercase\\s*,\\s*(\"|')\\[a-z\\]\\2\\s*\\)\\s*,\\s*\\(\\s*uppercase\\s*,\\s*(\"|')\\[A-Z\\]\\3\\s*\\)\\s*,\\s*\\(\\s*special_chars\\s*,\\s*(\"|')\\4\\s*\\)\\s*,?\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564d500f1a48e7f2b732a37.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564d68c34027a8072a704f4",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "The dot character is a wildcard that matches any character in a string — except for a newline character by default. Modify `pattern` to match the entire string by replacing the current pattern with a `.` followed by the `+` quantifier.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '[0-9]'),\n            (lowercase, '[a-z]'),\n            (uppercase, '[A-Z]'),\n            (special_chars, '')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = '[^a-z]t'\nquote = 'Not all those who wander are lost.'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `pattern` variable to match the whole `quote` string.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"pattern\"), \".+\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564d68c34027a8072a704f4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564d75a923d21815caaa445",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "If you need to match a character that has a special meaning in the pattern, such as `.` or `+`, you can escape it by prepending a backslash character, `\\`. For example, this matches a literal plus sign: `\\+`.\n\nModify `pattern` so that it matches a single literal dot.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '[0-9]'),\n            (lowercase, '[a-z]'),\n            (uppercase, '[A-Z]'),\n            (special_chars, '')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = '.+'\nquote = 'Not all those who wander are lost.'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `pattern` variable into `\\.`.",
          "testCode": "({ test: () => assert.match(code, /^pattern\\s*=\\s*(\"|')\\\\\\.\\1/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564d75a923d21815caaa445.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564d97a5ef99783216a6229",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "Python provides a particular type of string called *raw* string. Raw strings are prefixed with a `r`. The key distinction from regular strings lies in how they handle the backslash character: in raw strings, backslashes are treated as literal characters rather than escape characters. When writing regular expressions, using raw strings is a good practice, since they can usually contain a lot of `\\` characters.\n\nTurn your `pattern` string into a raw string by prefixing it with a `r`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '[0-9]'),\n            (lowercase, '[a-z]'),\n            (uppercase, '[A-Z]'),\n            (special_chars, '')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = '\\.'\nquote = 'Not all those who wander are lost.'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `pattern` variable into `r'\\.'`.",
          "testCode": "({ test: () => assert.match(code, /^pattern\\s*=\\s*r(\"|')\\\\\\.\\1/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564d97a5ef99783216a6229.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564daa2725b9b8420141b1c",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "Now, turn the four patterns from the `constraints` list into raw strings.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, '[0-9]'),\n            (lowercase, '[a-z]'),\n            (uppercase, '[A-Z]'),\n            (special_chars, '')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = r'\\.'\nquote = 'Not all those who wander are lost.'\n# print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn the four strings inside the `constraints` list into raw strings.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*r(\"|')\\[0-9\\]\\1\\s*\\)\\s*,\\s*\\(\\s*lowercase\\s*,\\s*r(\"|')\\[a-z\\]\\2\\s*\\)\\s*,\\s*\\(\\s*uppercase\\s*,\\s*r(\"|')\\[A-Z\\]\\3\\s*\\)\\s*,\\s*\\(\\s*special_chars\\s*,\\s*r(\"|')\\4\\s*\\)\\s*,?\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564daa2725b9b8420141b1c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564db880cf9408535f17ff4",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "The character class `\\d` is a shorthand for `[0-9]`. Replace this character class with the shorthand inside your first constraint tuple.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, r'[0-9]'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),\n            (special_chars, r'')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = r'\\.'\nquote = 'Not all those who wander are lost.'\n# print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn the `[0-9]` class into `\\d`.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*r(\"|')\\\\d\\1\\s*\\)\\s*,\\s*\\(\\s*lowercase\\s*,\\s*r(\"|')\\[a-z\\]\\2\\s*\\)\\s*,\\s*\\(\\s*uppercase\\s*,\\s*r(\"|')\\[A-Z\\]\\3\\s*\\)\\s*,\\s*\\(\\s*special_chars\\s*,\\s*r(\"|')\\4\\s*\\)\\s*,?\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564db880cf9408535f17ff4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564dd65c3c2fa873a83d213",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "In a character class, you can combine multiple ranges by writing one range after another inside the square brackets (without any additional characters). For example: `[a-d3-6]` is the combination of `[a-d]` and `[3-6]`.\n\nNow, modify the last regex pattern to match any non-alphanumeric character. Combine the `a-z`, `A-Z`, and `0-9` ranges into a single character class and add a `^` as the first character to negate the pattern.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),\n            (special_chars, r'')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = r'\\.'\nquote = 'Not all those who wander are lost.'\n# print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should complete your fourth pattern to match any non-alphanumeric character.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*r(\"|')\\\\d\\1\\s*\\)\\s*,\\s*\\(\\s*lowercase\\s*,\\s*r(\"|')\\[a-z\\]\\2\\s*\\)\\s*,\\s*\\(\\s*uppercase\\s*,\\s*r(\"|')\\[A-Z\\]\\3\\s*\\)\\s*,\\s*\\(\\s*special_chars\\s*,\\s*r(\"|')\\[\\^a-zA-Z0-9\\]\\4\\s*\\)\\s*,?\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564dd65c3c2fa873a83d213.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564de10a0887f882b0012d3",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "In the same way the `[0-9]` class is equivalent to `\\d`, the `[^0-9]` class is equivalent to `\\D`. Alphanumeric characters can be matched with `\\w` and non-alphanumeric characters can be matched with `\\W`.\n\nReplace the `[^a-zA-Z0-9]` character class with `\\W`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),\n            (special_chars, r'[^a-zA-Z0-9]')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = r'\\.'\nquote = 'Not all those who wander are lost.'\n# print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace the `[^a-zA-Z0-9]` character class with `\\W`.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*r(\"|')\\\\d\\1\\s*\\)\\s*,\\s*\\(\\s*lowercase\\s*,\\s*r(\"|')\\[a-z\\]\\2\\s*\\)\\s*,\\s*\\(\\s*uppercase\\s*,\\s*r(\"|')\\[A-Z\\]\\3\\s*\\)\\s*,\\s*\\(\\s*special_chars\\s*,\\s*r(\"|')\\\\W\\4\\s*\\)\\s*,?\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564de10a0887f882b0012d3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564eebf0d2d6390b9377197",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "Now, turn `pattern` into the shorthand class for non-alphanumeric characters.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),\n            (special_chars, r'\\W')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = r'\\.'\nquote = 'Not all those who wander are lost.'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `pattern` variable should be `'\\W'`.",
          "testCode": "({ test: () => assert.match(code, /^pattern\\s*=\\s*r(\"|')\\\\W\\1/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564eebf0d2d6390b9377197.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564efa70114b591b74d5679",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "The space characters and the final period are matched, as they are the only non-alphanumeric characters in the string.\n\nNow turn your `quote` string into a single underscore character.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),\n            (special_chars, r'\\W')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = r'\\W'\nquote = 'Not all those who wander are lost.'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `quote` variable should be `'_'`.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"quote\"), \"_\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564efa70114b591b74d5679.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564f0279e23ce924eedd1b2",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "Since the underscore character is a valid character for variable names, it is included in the `\\w` character class (equivalent to `[a-zA-Z0-9_]`), which can be conveniently used to match variable names.\n\nTherefore, the `\\W` character class is equivalent to `[^a-zA-Z0-9_]` with the underscore character that is not matched. For this reason you cannot use it to match all your special characters.\n\nDelete the last three lines in your code.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),\n            (special_chars, r'\\W')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = r'\\W'\nquote = '_'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete the last three lines in your code.",
          "testCode": "({ test: () => {\n  const commentless_code = __helpers.python.removeComments(code);\n  assert.notMatch(commentless_code, /pattern\\s*=\\s*r(\"|')\\\\W\\1/);\n  assert.notMatch(commentless_code, /quote\\s*=\\s*(\"|')_\\1/);\n  assert.notMatch(commentless_code, /print\\(\\s*re\\.findall\\(\\s*pattern\\s*,\\s*quote\\s*\\)\\s*\\)/);\n}})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564f0279e23ce924eedd1b2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564f32b18480893cf7799fd",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "Now, combine your raw string with an f-string and interpolate your `symbols` variable inside the character class. Remember that you can interpolate a variable within an f-string using curly brackets `{ }`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),\n--fcc-editable-region--            \n            (special_chars, r'\\W')\n--fcc-editable-region--            \n        ]        \n\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The second item in your fourth constraint tuple should be the string `fr'[{symbols}]'`.",
          "testCode": "({ test: () => assert.match(code, /\\(\\s*special_chars\\s*,\\s*(fr|rf)(\"|')\\[\\{\\s*symbols\\s*\\}\\]\\2/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564f32b18480893cf7799fd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564f583ca6fbf9556098dd6",
      "title": "Step 53",
      "challengeType": 20,
      "dashedName": "step-53",
      "description": "Below the `constraints` list, add a comment saying `Check constraints`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n        \n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add the provided comment.",
          "testCode": "({ test: () => assert.match(code, /#\\s*Check\\sconstraints/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564f583ca6fbf9556098dd6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564f834dd717998092cfd47",
      "title": "Step 54",
      "challengeType": 20,
      "dashedName": "step-54",
      "description": "After your new comment, write a `for` loop to iterate over the `constraints` list. Use `constraint` and `pattern` as the loop variables.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n--fcc-editable-region--         \n        # Check constraints\n        \n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write a `for` loop to iterate over the `constraints` list.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"generate_password\").find_whiles()[0].find_bodies()[0].find_for_loops()[1].find_for_iter().is_equivalent(\"constraints\")`)) })"
        },
        {
          "text": "Your `for` loop should use `constraint` and `pattern` as the loop variables to iterate over the `constraints` list.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"generate_password\").find_whiles()[0].find_bodies()[0].find_for_loops()[1].find_for_vars().is_equivalent(\"constraint, pattern\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564f834dd717998092cfd47.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6564fd78ffff909b1531d3c3",
      "title": "Step 55",
      "challengeType": 20,
      "dashedName": "step-55",
      "description": "Inside the `for` loop, call the `findall()` function passing `pattern` and `password` as the arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n--fcc-editable-region--         \n        # Check constraints\n        for constraint, pattern in constraints:\n            pass\n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `re.findall()` passing `pattern` and `password` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /^(\\s*)for.+:\\s*^\\1\\s{4}re\\.findall\\s*\\(\\s*pattern\\s*,\\s*password\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6564fd78ffff909b1531d3c3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565012a2564509d40a90048",
      "title": "Step 56",
      "challengeType": 20,
      "dashedName": "step-56",
      "description": "You are interested in the number of elements in the list returned by the `findall()` function.\n\nPass your existent `findall()` call to the `len()` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n--fcc-editable-region--         \n        # Check constraints\n        for constraint, pattern in constraints:\n            re.findall(pattern, password)\n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `len()` function with `re.findall(pattern, password)` as the argument.",
          "testCode": "({ test: () => assert.match(code, /^(\\s*)for.+:\\s*^\\1\\s{4}len\\s*\\(\\s*re\\.findall\\s*\\(\\s*pattern\\s*,\\s*password\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565012a2564509d40a90048.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565bb128adfcd5ec362382d",
      "title": "Step 57",
      "challengeType": 20,
      "dashedName": "step-57",
      "description": "Inside your `for` loop, compare `constraint` and the length of the list returned by `findall()`. Use the `<=` operator for that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n--fcc-editable-region--         \n        # Check constraints\n        for constraint, pattern in constraints:\n            len(re.findall(pattern, password))\n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should compare `constraint` and the length of the list returned by `findall` using the `<=` operator inside your `for` loop.",
          "testCode": "({ test: () => assert.match(code, /^(\\s*)for.+:\\s*^\\1\\s{4}constraint\\s*<=\\s*len\\s*\\(\\s*re\\.findall\\s*\\(\\s*pattern\\s*,\\s*password\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565bb128adfcd5ec362382d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565bd4265158360de8e2ae7",
      "title": "Step 59",
      "challengeType": 20,
      "dashedName": "step-59",
      "description": "Turn the expression inside your `for` loop into an `if` statement. Use the existing expression `constraint <= len(re.findall(pattern, password))` as the `if` condition.\n\nInside the new conditional statement, increment the `count` value by `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n--fcc-editable-region--         \n        # Check constraints\n        count = 0\n        for constraint, pattern in constraints:\n            constraint <= len(re.findall(pattern, password))\n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn `constraint <= len(re.findall(pattern, password))` into the `if` condition.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+constraint\\s*,\\s*pattern\\s+in\\s+constraints\\s*/);\n    assert(block_body.match(/^\\s+if\\s+constraint\\s*<=\\s*len\\s*\\(\\s*re\\.findall\\s*\\(\\s*pattern\\s*,\\s*password\\s*\\)\\s*\\)\\s*:/));\n  }\n})"
        },
        {
          "text": "You should increment `count` by one inside your new `if` statement.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /if\\s+constraint\\s*<=\\s*len\\s*\\(\\s*re\\.findall\\s*\\(\\s*pattern\\s*,\\s*password\\s*\\)\\s*\\)\\s*/);\n    assert(block_body.match(/^\\s+(count\\s*\\+=\\s*1|count\\s*=\\s*count\\s*\\+\\s*1)/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565bd4265158360de8e2ae7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565c014db6e9b63c257771d",
      "title": "Step 58",
      "challengeType": 20,
      "dashedName": "step-58",
      "description": "Right before your `for` loop, declare a `count` variable and assign the value zero to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n--fcc-editable-region--         \n        # Check constraints\n        \n        for constraint, pattern in constraints:\n            constraint <= len(re.findall(pattern, password))\n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a `count` variable and assign the value `0` to this variable.",
          "testCode": "({ test: () => assert.match(code, /count\\s*=\\s*0/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565c014db6e9b63c257771d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565c084627071646f94c4b0",
      "title": "Step 60",
      "challengeType": 20,
      "dashedName": "step-60",
      "description": "Finally, after the `for` loop, create an `if` statement to check if `count` is equal to `4` and break out of the `while` loop by using the `break` statement.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n--fcc-editable-region--         \n        # Check constraints\n        count = 0\n        for constraint, pattern in constraints:\n            if constraint <= len(re.findall(pattern, password)):\n                count += 1\n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if `count` is equal to `4` after the `for` loop.",
          "testCode": "({ test: () => assert.match(code, /^(\\s*)for.+:\\s*^\\1(\\s{4})if\\s+constraint\\s*<=\\s*len\\s*\\(\\s*re\\.findall\\s*\\(\\s*pattern\\s*,\\s*password\\s*\\)\\s*\\)\\s*:\\s*^\\1\\2\\2count\\s*\\+=\\s*1\\s*^\\1if\\s+count\\s*==\\s*4\\s*:/m) })"
        },
        {
          "text": "You should use `break` inside your new `if` to break out of the `while` loop.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /if\\s+count\\s*==\\s*4\\s*/);\n    assert(block_body.match(/^\\s+break\\s*$/m));  \n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565c084627071646f94c4b0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565c13fdb798865c161d8f8",
      "title": "Step 65",
      "challengeType": 20,
      "dashedName": "step-65",
      "description": "Now it's time to test your function. Uncomment the last two lines in your code and modify the function call passing 5 arguments. Use `8` for the length and `1` for the other four constraints.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n        \n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n\n    return password\n    \n--fcc-editable-region--\n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `generate_password` with the provided arguments.",
          "testCode": "({ test: () => assert.match(code, /^new_password\\s*=\\s*generate_password\\s*\\(\\s*8\\s*,\\s*1\\s*,\\s*1\\s*,\\s*1\\s*,\\s*1\\s*\\)/m) })"
        },
        {
          "text": "You should print your `new_password` variable.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*new_password\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565c13fdb798865c161d8f8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565c234de8cdf673c96bdf3",
      "title": "Step 67",
      "challengeType": 20,
      "dashedName": "step-67",
      "description": "As long as all the arguments in a function call are keyword arguments, the order of the arguments doesn't matter.\n\nTo confirm this, try to change the order of `length=8` and `nums=1` in your function call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):   \n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \n--fcc-editable-region--\nnew_password = generate_password(length=8, nums=1, special_chars=1, uppercase=1, lowercase=1)\nprint(new_password)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should change the order of `length=8` and `nums=1` in your `generate_password()` call.",
          "testCode": "({ test: () => assert.match(code, /^new_password\\s*=\\s*generate_password\\s*\\(\\s*nums\\s*=\\s*1\\s*,\\s*length\\s*=\\s*8\\s*,\\s*special_chars\\s*=\\s*1\\s*,\\s*uppercase\\s*=\\s*1\\s*,\\s*lowercase\\s*=\\s*1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565c234de8cdf673c96bdf3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565c32f89ab8d68b42aff30",
      "title": "Step 70",
      "challengeType": 20,
      "dashedName": "step-70",
      "description": "Now, remove all the arguments from your function call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length=16, nums=1, special_chars=1, uppercase=1, lowercase=1):\n\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \n--fcc-editable-region--\nnew_password = generate_password(length=8)\nprint(new_password)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `generate_password` without arguments.",
          "testCode": "({ test: () => assert.match(code, /^new_password\\s*=\\s*generate_password\\s*\\(\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565c32f89ab8d68b42aff30.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565c3a146bd5469b62bc59e",
      "title": "Step 71",
      "challengeType": 20,
      "dashedName": "step-71",
      "description": "Modify your `print()` call to take the string `'Generated password:'` as the first argument, before `new_password`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length=16, nums=1, special_chars=1, uppercase=1, lowercase=1):\n\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \n--fcc-editable-region--\nnew_password = generate_password()\nprint(new_password)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass the string `'Generated password:'` and `new_password` to your `print()` call.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*(\"|')Generated\\spassword:\\1\\s*,\\s*new_password\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565c3a146bd5469b62bc59e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6565c4767f49286aec825c6d",
      "title": "Step 72",
      "challengeType": 20,
      "dashedName": "step-72",
      "description": "Finally, put the last two lines of your code inside an `if` statement that execute when `__name__ == '__main__'`. In this way, your code won't run when imported as a module. Otherwise, it will call `generate_password()` and print the generated password. \n\nWith that, the password generator project is complete.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length=16, nums=1, special_chars=1, uppercase=1, lowercase=1):\n\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \n--fcc-editable-region--\nnew_password = generate_password()\nprint('Generated password:', new_password)\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length=16, nums=1, special_chars=1, uppercase=1, lowercase=1):\n\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints\n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):            \n            break\n    \n    return password\n    \n\nif __name__ == '__main__':\n    new_password = generate_password()\n    print('Generated password:', new_password)"
        }
      ],
      "tests": [
        {
          "text": "You should have an `if` statement that checks if `__name__ == '__main__'`.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert(commentless_code.match(/^if\\s+__name__\\s*==\\s*(\"|')__main__\\1\\s*:\\s*$/m));"
        },
        {
          "text": "You should put the `new_password` assignment and the following `print()` call in your new `if` statement body.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /if\\s+__name__\\s*==\\s*(\"|')__main__\\3\\s*/);\n    assert(block_body.match(/^\\s+new_password\\s*=\\s*generate_password\\s*\\(\\s*\\)\\s*print\\s*\\(\\s*(\"|')Generated\\spassword:\\1\\s*,\\s*new_password\\s*\\)\\s*$/));    \n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6565c4767f49286aec825c6d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656eec2f40d18056cc58b229",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "The value `None` is returned since `'i'` is not found inside the parsed string.\n\nNow, modify the string passed to `re.compile()` into `'l'` and see the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)    \n--fcc-editable-region--\npattern = re.compile('i')\nquote = 'Not all those who wander are lost.'\nprint(pattern.search(quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `pattern` variable into `re.compile('l')`.",
          "testCode": "({ test: () => assert(runPython(`\n    import re\n    pattern == re.compile('l')\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656eec2f40d18056cc58b229.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656ef54070c72161e6feb90f",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "It seems all fine, but it would be nice to have a way to check that the generated password complies to specific features. For example, a minimum number of special characters, digits, or uppercase/lowercase letters. You are going to take care of that very soon.\n\nFor now, comment out the last two lines of your code.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    password = ''\n    # Generate password\n    for _ in range(length):\n        password += secrets.choice(all_characters)\n        \n    return password\n    \n--fcc-editable-region--\nnew_password = generate_password(8)\nprint(new_password)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn the last two lines of your code into comments.",
          "testCode": "({ test: () => {\n  assert.match(code, /#\\s*new_password\\s*=\\s*generate_password\\s*\\(\\s*8\\s*\\)/);\n  assert.match(code, /#\\s*print\\s*\\(\\s*new_password\\s*\\)/);\n} })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656ef54070c72161e6feb90f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656ef5bc5c0cd464be1df675",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "Next, you are going to give your function more parameters that will act as constraints for the generated password.\n\nModify your function declaration by adding `nums`, `special_chars`, `uppercase`, and `lowercase` in this order after the existent `length` parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n--fcc-editable-region--\ndef generate_password(length):\n--fcc-editable-region--    \n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    password = ''\n    # Generate password\n    for _ in range(length):\n        password += secrets.choice(all_characters)\n        \n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your function should take `length`, `nums`, `special_chars`, `uppercase`, and `lowercase` as the parameters. The order matters.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    sig = str(inspect.signature(generate_password))\n    sig == '(length, nums, special_chars, uppercase, lowercase)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656ef5bc5c0cd464be1df675.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656ef783bba6976de014eaa8",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "Put your `password` variable declaration and the following `for` loop inside a `while` loop. Use `True` as the condition for your new loop.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n--fcc-editable-region--\n    password = ''\n    # Generate password\n    for _ in range(length):\n        password += secrets.choice(all_characters)\n--fcc-editable-region--        \n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `while True` loop enclosing your existing `password` declaration and `for` loop.\n\n```js\n({ test: () => {\n\nconst commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /while\\s+True\\s*/);\n    assert(block_body.match(/^\\s+password\\s*=\\s*(\"|')\\1\\s*^\\s+for\\s+_\\s+in\\s+range\\s*\\(\\s*length\\s*\\s*\\)\\s*:\\s*^\\s+password\\s*\\+=\\s*secrets\\.choice\\s*\\(\\s*all_characters\\s*\\)\\s*$/m));    \n    const {block_body: for_body} = __helpers.python.getBlock(commentless_code, /for\\s+_\\s+in\\s+range\\s*\\(\\s*length\\s*\\s*\\)\\s*/);\n    assert(for_body.match(/^\\s+password\\s*\\+=\\s*secrets\\.choice\\s*\\(\\s*all_characters\\s*\\)\\s*$/m));  \n  }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656ef783bba6976de014eaa8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656ef7f792734072dedd8319",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "After your `for` loop, create a `constraints` variable and assign an empty list to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n--fcc-editable-region--\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a `constraints` variable after your `for` loop and assign an empty list to this variable.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");\n    const generate_pw = __helpers.python.getDef(\"\\n\"+transformedCode, \"generate_password\");\n    const {function_body} = generate_pw;     \n    assert(function_body.match(/^(\\s*)for.*:.*^\\1constraints\\s*=\\s*\\[\\s*\\]/ms));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656ef7f792734072dedd8319.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656ef89b4b486b7a16077864",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "A tuple is another built-in data structure in Python. Tuples are very much like lists, but they are defined with parentheses `()`, instead of square brackets. Also, tuples are immutable, unlike lists.\n\n```py\nmy_tuple = ('larch', 1, True)\n```\n\nYour `constraints` list is going to store tuples. The first item of each tuple will be a constraint parameter.\n\nModify the `constraints` list assignment by adding a tuple to your list. Use `nums` as the first item and an empty string as the second item.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = []\n        \n--fcc-editable-region--\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a tuple to the `constraints` list.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(.*\\)\\s*\\]/) })"
        },
        {
          "text": "You should add `(nums, '')` to the `constraints` list.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\(\\s*nums\\s*,\\s*(\"|')\\1\\s*\\)\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656ef89b4b486b7a16077864.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656f04b20397d9a574cc7eb2",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "You can obtain the same result without using the `compile()` function. Modify your `pattern` variable into the literal string `'l+'`. Then, change the `print()` call to print `re.search(pattern, quote)`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = re.compile('l+')\nquote = 'Not all those who wander are lost.'\nprint(pattern.search(quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `pattern` variable into the literal string `'l+'`.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"pattern\"), \"l+\") })"
        },
        {
          "text": "You should print `re.search(pattern, quote)`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*re\\.search\\s*\\(\\s*pattern\\s*,\\s*quote\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656f04b20397d9a574cc7eb2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656f0bc259c1f6b57486ed68",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "To check that the generated password meets the required features, you are going to use the `findall()` function from the `re` module. It's similar to `search` but it returns a list with all the occurrences of the matched pattern.\n\nReplace the `search()` call with `findall()` and check the output.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = 'l+'\nquote = 'Not all those who wander are lost.'\nprint(re.search(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your existing `print()` call replacing `search()` with `findall()`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*re\\.findall\\s*\\(\\s*pattern\\s*,\\s*quote\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656f0bc259c1f6b57486ed68.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656f0d6bc60b58b9777a36c9",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "A character class is indicated by square brackets and matches one character among those specified between the brackets. For example, `ma[dnt]` matches either `mad`, `man`, or `mat`.\n\nModify your pattern to match a `w` followed by either `h` or `a`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, '')\n        ]        \n\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n--fcc-editable-region--\npattern = 'l+'\nquote = 'Not all those who wander are lost.'\nprint(re.findall(pattern, quote))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your pattern should use a character class to match a `w` followed by either `h` or `a`.",
          "testCode": "({ test: () => assert(runPython(`\n    pattern == \"w[ha]\" or pattern == \"w[ah]\"    \n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656f0d6bc60b58b9777a36c9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "656f10458134d4c4e283a2f1",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "Now, turn the empty string in the constraint tuple into a regex pattern to match a single digit. Use a character class specifying each digit from `0` to `9`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n--fcc-editable-region--        \n        constraints = [\n            (nums, '')\n        ]        \n--fcc-editable-region--\n    return password\n    \n# new_password = generate_password(8)\n# print(new_password)\n\npattern = 'w[ha]'\nquote = 'Not all those who wander are lost.'\n# print(re.findall(pattern, quote))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have the `(nums, '[0123456789]')` tuple in your `constraints` list.",
          "testCode": "({ test: () => assert.match(code, /constraints\\s*=\\s*\\[\\s*\\s*\\(\\s*nums\\s*,\\s*(\"|')\\[\\d{10}\\]\\1\\s*\\)\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\656f10458134d4c4e283a2f1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6577319039f4f7de9251b822",
      "title": "Step 61",
      "challengeType": 20,
      "dashedName": "step-61",
      "description": "Instead of using a loop and a counter variable, you can achieve the same result with a different approach, which you are going to implement in the next few steps.\n\n`all()` is a built-in Python function that returns `True` if all the elements inside a given iterable evaluate to `True`. Otherwise, it returns `False`.\n\nReplace your existing `for` loop and two `if` statements with a single `if` statement. For the `if` condition, use a call to the `all()` function and pass an empty list as the argument to the function call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n\n        # Check constraints\n        count = 0\n--fcc-editable-region--\n        for constraint, pattern in constraints:\n            if constraint <= len(re.findall(pattern, password)):\n                count += 1\n            \n        if count == 4:\n--fcc-editable-region--\n            break\n\n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace your existing `for` loop and two `if` statements with a single `if` statement.",
          "testCode": "({ test: () => {\n  assert.match(code, /^(\\s{8})if\\s+.+:\\s*^\\1\\s{4}break/ms);\n  assert.isFalse(/if\\s+count\\s*==\\s*4\\s*:/.test(code));\n} })"
        },
        {
          "text": "Your new `if` condition should be `all([])`.",
          "testCode": "({ test: () => assert(runPython(`\n  _Node(_code).find_function(\"generate_password\").find_while(\"True\").find_bodies()[0].find_if(\"all([])\") != _Node()\n`)) })"
        },
        {
          "text": "You should have `break` inside your new `if` body.",
          "testCode": "({ test: () => assert(runPython(`\n  _Node(_code).find_function(\"generate_password\").find_while(\"True\").find_bodies()[0].find_if(\"all([])\").find_bodies()[0].is_equivalent(\"break\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6577319039f4f7de9251b822.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "657732654845d8e2fb1217e6",
      "title": "Step 62",
      "challengeType": 20,
      "dashedName": "step-62",
      "description": "Right now, `all()` is taking an empty list as the argument. Populate that empty list using the comprehension syntax so that the list stores the results of evaluating the expression `constraint <= len(re.findall(pattern, password))` for each `constraint`-`pattern` tuple in the `constraints` list.\n\nIn this way, you'll break out of the `while` loop only after all the requirements are fulfilled.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n\n        # Check constraints\n        count = 0\n--fcc-editable-region--        \n        if all([]):\n--fcc-editable-region--        \n            break\n    \n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `[constraint <= len(re.findall(pattern, password)) for constraint, pattern in constraints]` to the `all()` function.",
          "testCode": "({ test: () => assert(runPython(`\n  _Node(_code).find_function(\"generate_password\").find_while(\"True\").find_bodies()[0].find_ifs()[0].find_conditions()[0].is_equivalent(\"all([constraint <= len(re.findall(pattern, password)) for constraint, pattern in constraints])\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\657732654845d8e2fb1217e6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "6577333feab1e8e927014f03",
      "title": "Step 63",
      "challengeType": 20,
      "dashedName": "step-63",
      "description": "Having `all([expression for i in iterable])`, means that a new list is created by evaluating `expression` for each `i` in `iterable`. After the `all()` function iterates over the newly created list, the list is deleted automatically, since it is no longer needed.\n\nMemory can be saved by using a generator expression. Generator expressions follow the syntax of list comprehensions but they use parentheses instead of square brackets.\n\nChange your list comprehension into a generator expression by removing the square brackets.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n\n        # Check constraints\n        count = 0\n--fcc-editable-region--\n        if all(\n            [\n                constraint <= len(re.findall(pattern, password))\n                for constraint, pattern in constraints\n            ]\n        ):\n--fcc-editable-region--\n            break\n    \n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn your list comprehension into a generator expression by removing the square brackets.",
          "testCode": "({ test: () => assert.match(code, /^(\\s*)if\\s+all\\s*\\(\\s*constraint\\s*<=\\s*len\\s*\\(\\s*re\\.findall\\s*\\(\\s*pattern\\s*,\\s*password\\s*\\)\\s*\\)\\s*for\\s+constraint\\s*,\\s*pattern\\s+in\\s+constraints\\s*\\)\\s*:\\s*^\\1\\s{4}break/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\6577333feab1e8e927014f03.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "657733bc97eb83efdb7e3988",
      "title": "Step 64",
      "challengeType": 20,
      "dashedName": "step-64",
      "description": "You don't need the `count` variable anymore. Delete this variable and its value.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n       \n        constraints = [\n            (nums, r'\\d'),\n            (lowercase, r'[a-z]'),\n            (uppercase, r'[A-Z]'),            \n            (special_chars, fr'[{symbols}]')            \n        ]\n--fcc-editable-region--\n        # Check constraints\n        count = 0\n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n--fcc-editable-region--\n            break\n    \n    return password\n\n# new_password = generate_password(8)\n# print(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete the `count = 0` line.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.isFalse( /count\\s*=\\s*0/.test(commentless_code))\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\657733bc97eb83efdb7e3988.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "657dadf4d8b93c1704f3a57c",
      "title": "Step 66",
      "challengeType": 20,
      "dashedName": "step-66",
      "description": "It works, but there are still a couple of things you can improve. First of all, calling a function with 5 arguments can create confusion on which value will be assigned to which parameter.\n\nYou can call a function using keyword arguments, that is writing the parameter name explicitly followed by the assignment operator and the value. For example:\n\n```py\ndef add(x, y):\n    return x + y\n\nadd(x=1, y=7) # 8\n```\n\nModify your function call to use keyword arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n   \n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \n--fcc-editable-region-- \nnew_password = generate_password(8, 1, 1, 1, 1)\nprint(new_password)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `new_password` variable should have the value of `generate_password(length=8, nums=1, special_chars=1, uppercase=1, lowercase=1)`.",
          "testCode": "({ test: () => assert.match(code, /^new_password\\s*=\\s*generate_password\\s*\\(\\s*length\\s*=\\s*8\\s*,\\s*nums\\s*=\\s*1\\s*,\\s*special_chars\\s*=\\s*1\\s*,\\s*uppercase\\s*=\\s*1\\s*,\\s*lowercase\\s*=\\s*1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\657dadf4d8b93c1704f3a57c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "657db2114b4029241956f5d6",
      "title": "Step 68",
      "challengeType": 20,
      "dashedName": "step-68",
      "description": "Modify your function declaration to take default parameters. Use `16` for the `length` and `1` for the other constraints.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n--fcc-editable-region--\ndef generate_password(length, nums, special_chars, uppercase, lowercase):\n--fcc-editable-region--\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \n\nnew_password = generate_password(nums=1, length=8, special_chars=1, uppercase=1, lowercase=1)\nprint(new_password)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your function should take default parameters.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    sig = str(inspect.signature(generate_password))\n    sig == '(length=16, nums=1, special_chars=1, uppercase=1, lowercase=1)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\657db2114b4029241956f5d6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "657db4cb77190e33a20e852a",
      "title": "Step 69",
      "challengeType": 20,
      "dashedName": "step-69",
      "description": "When you combine default arguments with keyword arguments, you are able to explicitly pass fewer arguments than those required by the function. The arguments that are not explicitly passed to the function call will take their default values.\n\nModify your `generate_password()` call to take only `length=8`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "import re\nimport secrets\nimport string\n\n\ndef generate_password(length=16, nums=1, special_chars=1, uppercase=1, lowercase=1):\n    # Define the possible characters for the password\n    letters = string.ascii_letters\n    digits = string.digits\n    symbols = string.punctuation\n\n    # Combine all characters\n    all_characters = letters + digits + symbols\n\n    while True:\n        password = ''\n        # Generate password\n        for _ in range(length):\n            password += secrets.choice(all_characters)\n        \n        constraints = [\n            (nums, r'\\d'),\n            (special_chars, fr'[{symbols}]'),\n            (uppercase, r'[A-Z]'),\n            (lowercase, r'[a-z]')\n        ]\n\n        # Check constraints        \n        if all(\n            constraint <= len(re.findall(pattern, password))\n            for constraint, pattern in constraints\n        ):\n            break\n    \n    return password\n    \n--fcc-editable-region--\nnew_password = generate_password(nums=1, length=8, special_chars=1, uppercase=1, lowercase=1)\nprint(new_password)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass only `length=8` to your `generate_password()` call.",
          "testCode": "({ test: () => assert.match(code, /^new_password\\s*=\\s*generate_password\\s*\\(\\s*length\\s*=\\s*8\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-regular-expressions-by-building-a-password-generator\\657db4cb77190e33a20e852a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-regular-expressions-by-building-a-password-generator",
        "name": "Learn Regular Expressions By Building A Password Generator"
      }
    },
    {
      "id": "65f01969115f933073b6be03",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "A vector is an object that has a length (or magnitude) and a direction and it cannot be expressed by a single number. In physics, vectors are commonly used to represent forces, velocities, accelerations, and other quantities.\n\nIn this project you are going to build a vector space, a set in which a series of operations is defined between the elements in that set. You'll learn all the details very soon.\n\nFor now, start the project by declaring an empty class named `Vector`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare an empty class named `Vector`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_class(\"Vector\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f01969115f933073b6be03.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f03d9f92eac9183a4d3281",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "A vector can be defined by two coordinates, `x` and `y`, in the Euclidean plane. The distance between the origin of the axes and the point `(x, y)` will be its length, or norm. And the vector direction will point towards `(x, y)`.\n\n<img alt=\"a 2-dimensional vector of coordinates (2, 3)\" src=\"https://cdn.freecodecamp.org/curriculum/python/2dvector.png\" style=\"background-color: white; height: 350px; width: auto; padding: 15px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;\">\n\nWithin the `Vector` class, create an `__init__` method and give it three parameters, `self`, `x`, and `y`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `__init__` method inside the `Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Vector\").has_function(\"__init__\")`)) })"
        },
        {
          "text": "Your `__init__` method should take three parameters: `self`, `x`, and `y`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"Vector\").find_function(\"__init__\").has_args(\"self, x, y\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f03d9f92eac9183a4d3281.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f055b9190fc41ca35549b8",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "Python offers various methods that include both a leading and trailing double underscore in their names. You may already be familiar with some, such as `__init__` and `__str__`. These methods, which follow the `__<name>__` naming pattern, are referred to as special methods, magic methods, or *dunder* (which stands for double underscore) methods.\n\nDefining special methods in a class affects the behavior of that class. They are called under the hood in specific situations (e.g. `__init__` during instantiation, `__str__` when the object is printed or passed to `str()`). In this project, you are going to learn some of the most commonly used special methods.\n\nFor now, assign `x` to the `x` attribute of the `Vector` object.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `x` to `self.x`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"Vector\").find_function(\"__init__\").has_stmt(\"self.x = x\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f055b9190fc41ca35549b8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f056a405239e1dc4cc2854",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "Now, assign `y` to the `y` attribute of the `Vector` object.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `y` to `self.y`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"Vector\").find_function(\"__init__\").find_variable(\"self.y\").is_equivalent(\"self.y = y\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f056a405239e1dc4cc2854.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f058e06f34fd1f0ee6e55d",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Next, within the `Vector` class, create an empty `norm` method and give it a `self` parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `Vector` class should have a `norm` method.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"Vector\").has_function(\"norm\")\n    `))\n})"
        },
        {
          "text": "Your `norm` method should have a `self` parameter.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"Vector\").find_function(\"norm\").has_args(\"self\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f058e06f34fd1f0ee6e55d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f0694fb2296f3caadf8347",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "The length of a vector $\\mathbf{a}$, or norm, is typically indicated as $\\\\| \\mathbf{a} \\\\|$. It can be calculated as the square root of the sum of its squared components:\n\\\\[ \\\\| \\mathbf{a} \\\\| = \\sqrt{a_1^2 + a_2^2 + \\ldots + a_n^2}\n \\\\]\n\nCompute the vector norm and return the result from your `norm` method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `norm` method should use the provided formula to calculate and return a number representing the norm of the current vector instance. Do not approximate the value.",
          "testCode": "({ test: () => runPython(`\nv1 = Vector(2, 2.5)\nv2 = Vector(0, -1)\nv3 = Vector(-5, -0.3)\nassert v1.norm() == 3.2015621187164243\nassert v2.norm() == 1\nassert v3.norm() == 5.008991914547277\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f0694fb2296f3caadf8347.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f06a8e5a57673d700c79c3",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Outside the `Vector` class, create an instance of `Vector` passing the integers `2` and `3` as the `x` and `y` values and assign it to a variable named `v1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `v1` and assign it `Vector(2, 3)`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_variable(\"v1\").is_equivalent(\"v1 = Vector(2, 3)\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f06a8e5a57673d700c79c3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f07c9b1ffb814d856dcffc",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "Test that `norm` works as expected by printing the value returned by the method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n\nv1 = Vector(2, 3)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `norm()` on `v1` and print the result.",
          "testCode": "({\n    test: () => assert(runPython(`_Node(_code).has_call(\"print(v1.norm())\")`))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f07c9b1ffb814d856dcffc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f3fa097f26b510db6c710b",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "Great, `norm` is working as expected. Now, if you try to print `v1`, you'll get the default string representation of an object (something like `<__main__.Vector object at 0x11eb778>`).\n\nInside the `Vector` class, declare an empty `__str__` method to implement a readable string representation. Remember to give it a `self` parameter.\n\nPay attention to not print `v1` until `__str__` returns a string, otherwise you'll get a `TypeError`, because `__str__` must always return a string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n\nv1 = Vector(2, 3)\nprint(v1.norm())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__str__` method within the `Vector` class.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"Vector\").has_function(\"__str__\")\n    `))\n})"
        },
        {
          "text": "Your `__str__` method should have a `self` parameter.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"Vector\").find_function(\"__str__\").has_args(\"self\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f3fa097f26b510db6c710b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f3fa60a93b84110b3f1708",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "You want to return a meaningful string representation. For example, in the case of `v1`, you want to return a string containing the tuple with the values of the vector components: `(2, 3)`.\n\nFrom the `__str__` method, return a string representing the vector as a tuple containing the vector components in order. Then, go outside the `Vector` class and print `v1` to check the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        pass\n\nv1 = Vector(2, 3)\nprint(v1.norm())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `__str__` method should return a string representing the vector as a tuple containing the vector components in order.",
          "testCode": "({ test: () => runPython(`\nv1 = Vector(2, 3)\nv2 = Vector(0, 0)\nv3 = Vector(-2, -3.5)\nassert str(v1) == '(2, 3)'\nassert str(v2) == '(0, 0)'\nassert str(v3) == '(-2, -3.5)'\n`) })"
        },
        {
          "text": "You should print `v1`.",
          "testCode": "({\n    test: () => assert(runPython(`_Node(_code).has_call(\"print(v1)\")`))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f3fa60a93b84110b3f1708.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f3fe07cc763212efe91285",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "A vector can have a number `n` of dimensions (components). Here's a representation of a 3-dimensional vector:\n\n<img alt=\"a 3-dimensional vector of coordinates (4, 6, 3)\" src=\"https://cdn.freecodecamp.org/curriculum/python/3dvector.png\" style=\"background-color: white; height: 350px; width: auto; padding: 15px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;\">\n\nSo far, you created a 2-dimensional vector. You want to be able to represent vectors with a different number of dimensions without rewriting the necessary code for each specific case. For that, you will use inheritance.\n\nStart by renaming the `Vector` class into `R2Vector` to specify that this class is going to deal with 2-dimensional vectors. Remember to modify the instantiation of `v1`, too.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n\nv1 = Vector(2, 3)\nprint(v1.norm())\nprint(v1)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should rename the `Vector` class into `R2Vector`. Remember to modify the instantiation of `v1`, too.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).has_class(\"R2Vector\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f3fe07cc763212efe91285.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f40051d6b09a139f253e8e",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "Inheritance enables you to define a class from an existing one. The new class, called child, inherits all the methods and properties of the existing class, called parent.\n\n```py\nclass Tree:\n    def sprout(self):\n        print('Making new leaves!')\n\nclass Oak(Tree):\n    pass\n    \nOak().sprout() # Output: Making new leaves!\n```\n\nIn the example above, the child class `Oak` inherits from `Tree` and inherits the `sprout` method from the parent class `Tree`.\n\nCreate a new class named `R3Vector` and follow the example above to make it inherit from the `R2Vector` class.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n--fcc-editable-region--\n\n--fcc-editable-region--\nv1 = R2Vector(2, 3)\nprint(v1.norm())\nprint(v1)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a new class `R3Vector`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).has_class(\"R3Vector\")\n    `))\n})"
        },
        {
          "text": "Your new class `R3Vector` should inherit from `R2Vector`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R3Vector\").inherits_from(\"R2Vector\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f40051d6b09a139f253e8e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f40401e6ef53173c04e27d",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "Within your new class, declare an `__init__` method. Give it `self`, `x`, `y`, and `z` as the parameters.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    pass\n--fcc-editable-region--\nv1 = R2Vector(2, 3)\nprint(v1.norm())\nprint(v1)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `__init__` method inside your `R3Vector` class.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R3Vector\").has_function(\"__init__\")\n    `))\n})"
        },
        {
          "text": "Your `__init__` method should have four parameters `self`, `x`, `y`, and `z`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").has_args(\"self, x, y, z\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f40401e6ef53173c04e27d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f407ea37ad6e181b90462e",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "You could assign each `i` parameter to `self.i` as you did before. Although in this case you have few lines to repeat, one way to avoid this repetition is using the `super()` function. `super()` enables you to refer implicitly to the parent class: `super().__init__(x, y)` calls the `__init__` method of the parent class.\n\nAdd a `super().__init__(x, y)` call to your `__init__` method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, x, y, z):\n        pass\n--fcc-editable-region--\nv1 = R2Vector(2, 3)\nprint(v1.norm())\nprint(v1)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `super().__init__(x, y)` call in your `__init__` method.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").has_stmt(\"super().__init__(x, y)\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f407ea37ad6e181b90462e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f40f8af784751c613d638a",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "Now, you need to assign `z` to the `z` attribute of your `R3Vector` object.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, x, y, z):\n        super().__init__(x, y)\n--fcc-editable-region--\nv1 = R2Vector(2, 3)\nprint(v1.norm())\nprint(v1)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `z` to `self.z` after the `super` call.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").is_ordered(\"super().__init__(x, y)\", \"self.z = z\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f40f8af784751c613d638a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f40fdb3579aa1ced28b2eb",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "Create an `R3Vector` instance with `2`, `2`, and `3` as the values of `x`, `y`, and `z`, respectively. Assign the new instance to `v2`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n\nclass R3Vector(R2Vector):\n    def __init__(self, x, y, z):\n        super().__init__(x, y)\n        self.z = z\n\nv1 = R2Vector(2, 3)\nprint(v1.norm())\nprint(v1)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `v2` and assign it `R3Vector(2, 2, 3)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"v2\").is_equivalent(\"v2 = R3Vector(2, 2, 3)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f40fdb3579aa1ced28b2eb.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f412c208c3791fee305acf",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "In Python, you can enforce the use of keyword-only arguments by adding a `*` as an additional argument to the function or method signature. Modify both `__init__` methods by adding a `*` as the second parameter (after `self`). Every parameter placed after that will require the use of a keyword argument in the function/method call.\n\nThis means that you need to modify the `super().__init__(x, y)` call, too. Do it by giving `x` the value `x`, and `y` the value `y`.\n\nFinally, modify the instantiation of `v1` and `v2` by using keyword arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass R2Vector:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n\nclass R3Vector(R2Vector):\n    def __init__(self, x, y, z):\n        super().__init__(x, y)\n        self.z = z\n\nv1 = R2Vector(2, 3)\nprint(v1.norm())\nprint(v1)\nv2 = R3Vector(2, 2, 3)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should enforce keyword arguments by adding a `*` as the second parameter in both your `__init__` methods.",
          "testCode": "({ test: () => {\n  assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__init__\").has_args(\"self, *, x, y\")`));\n  assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").has_args(\"self, *, x, y, z\")`));\n} })"
        },
        {
          "text": "You should modify your `super.__init__(x, y)` call to  use keyword arguments.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"__init__\").find_body().is_equivalent(\"super().__init__(x=x, y=y)\\\\nself.z = z\")`)) })"
        },
        {
          "text": "You should modify the assignment of `v1` to be `R2Vector(x=2, y=3)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"v1\").is_equivalent(\"v1 = R2Vector(x=2, y=3)\")`)) })"
        },
        {
          "text": "You should modify the assignment of `v2` to be `R3Vector(x=2, y=2, z=3)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"v2\").is_equivalent(\"v2 = R3Vector(x=2, y=2, z=3)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f412c208c3791fee305acf.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f4148dea0f802040225e0c",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "Remove the existing `print` calls. Then, as you did before for `v1`, print `v2` and the value returned by `v2.norm()`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nprint(v1.norm())\nprint(v1)\n\nv2 = R3Vector(x=2, y=2, z=3)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(v1)` and `print(v1.norm())` in your code.",
          "testCode": "({\n    test: () => {\n      assert.isFalse(runPython(`_Node(_code).has_call(\"print(v1)\")`));\n      assert.isFalse(runPython(`_Node(_code).has_call(\"print(v1.norm())\")`));\n    }\n})"
        },
        {
          "text": "You should print `v2` and `v2.norm()`.",
          "testCode": "({\n    test: () => {\n      assert(runPython(`_Node(_code).has_call(\"print(v2)\")`));\n      assert(runPython(`_Node(_code).has_call(\"print(v2.norm())\")`));\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f4148dea0f802040225e0c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f4520e363e2642f8112e33",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "As you can see, something is not quite right. The `norm` and `__str__` methods inherited from `R2Vector` cannot adapt to a 3-dimensional vector. Their implementation has to be more flexible.\n\nEvery object in Python has a special attribute named `__dict__`, which is a dictionary that stores the object attributes.\n\nRemove the existing `print` calls. Then, print the `__dict__` attribute of your `v1` and `v2` vectors to see what they look like.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n        \n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n        \n    def __str__(self):\n        return f'{self.x, self.y}'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(v2.norm())\nprint(v2)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(v2)` and `print(v2.norm())` in your code.",
          "testCode": "({\n    test: () => {\n      assert.isFalse(runPython(`_Node(_code).has_call(\"print(v2)\")`));\n      assert.isFalse(runPython(`_Node(_code).has_call(\"print(v2.norm())\")`));\n    }\n})"
        },
        {
          "text": "You should print the `__dict__` attribute of `v1` and `v2`.",
          "testCode": "({ test: () => assert(runPython(`\n(_Node(_code).has_call(\"print(v1.__dict__)\") and _Node(_code).has_call(\"print(v2.__dict__)\")) or _Node(_code).has_call(\"print(v1.__dict__, v2.__dict__)\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f4520e363e2642f8112e33.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f4535bbdb28d436ff3ddc9",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "As you can see from the output, `__dict__` contains the values of your instance attributes. Instead of explicitly adding the squares of `self.x` and `self.y`, you are going to iterate over the values stored in `__dict__` to calculate the value of the norm.\n\nWithin the `norm` method body, replace the content of the parentheses with a generator expression that elevates each value `val` in `self.__dict__.values()` to the power of `2`. Also, pass that generator expression as the argument to the `sum` function, so that all the squares are added together before calculating the square root.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n--fcc-editable-region--\n    def norm(self):\n        return (self.x**2 + self.y**2)**0.5\n--fcc-editable-region--        \n    def __str__(self):\n        return f'{self.x, self.y}'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(v1.__dict__)\nprint(v2.__dict__)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `sum(val**2 for val in self.__dict__.values())**0.5` from `norm()` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"norm\").has_return(\"sum(val**2 for val in self.__dict__.values())**0.5\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f4535bbdb28d436ff3ddc9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f870003444fb1a2ad171f2",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Modify the two `print` calls to print the norm of your vectors and verify that the `norm()` method works fine.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in self.__dict__.values())**0.5\n\n    def __str__(self):\n        return f'{self.x, self.y}'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(v1.__dict__)\nprint(v2.__dict__)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `v1.norm()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(v1.norm())\")`)) })"
        },
        {
          "text": "You should print `v2.norm()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(v2.norm())\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f870003444fb1a2ad171f2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f8709620b2ce1a62608f5a",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "When you need to dynamically access some attributes starting from a string input, the built-in `getattr()` function is what you need. It takes an object as its first argument, and a string containing the attribute name as its second attribute.\n\nStart to fix the `__str__` method by replacing the string returned by `__str__()` with a generator expression that iterates through the object attributes and calls `getattr()` for each attribute `i`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n--fcc-editable-region--\n    def __str__(self):\n        return f'{self.x, self.y}'\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(v1.norm())\nprint(v2.norm())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return a generator expression that iterates over `vars(self)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").find_return().find_comp_iters()[0].is_equivalent(\"vars(self)\")`)) })"
        },
        {
          "text": "You should return a generator expression that uses `i` as the iteration variable.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").find_return().find_comp_targets()[0].is_equivalent(\"i\")`)) })"
        },
        {
          "text": "You should return a generator expression that calls `getattr(self, i)` for each item `i` in `vars(self)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").find_return().find_comp_expr().is_equivalent(\"getattr(self, i)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f8709620b2ce1a62608f5a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f8720685ec351abef26740",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "To obtain a proper string representation, call the `tuple()` constructor and pass it the generator expression you wrote in the previous step as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n--fcc-editable-region--\n    def __str__(self):\n        return (getattr(self, i) for i in vars(self))\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(v1.norm())\nprint(v2.norm())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass the expression returned by the `__str__` method to the `tuple()` constructor.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").has_return(\"tuple(getattr(self, i) for i in vars(self))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f8720685ec351abef26740.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f872a0fe6aa21b456ad4fe",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "Finally, pass the `tuple()` call as the argument to the `str()` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n--fcc-editable-region--\n    def __str__(self):\n        return tuple(getattr(self, i) for i in vars(self))\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(v1.norm())\nprint(v2.norm())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass the `tuple()` call you are currently returning from the `__str__` method to the `str()` function.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__str__\").has_return(\"str(tuple(getattr(self, i) for i in vars(self)))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f872a0fe6aa21b456ad4fe.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f8749b13774b1d2e4a7fba",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "While the `__str__` method returns a human-readable string representation of an object, the `__repr__` method is supposed to return the string needed to instantiate the object.\n\nAdd a `__repr__` method with a `self` parameter within the `R2Vector` class.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n--fcc-editable-region--\n    \n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `R2Vector` class should have a `__repr__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__repr__\")`)) })"
        },
        {
          "text": "Your `__repr__` method should have a `self` parameter.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").has_args(\"self\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f8749b13774b1d2e4a7fba.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f876d17832001e8e1abb05",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "Declare a variable `arg_list`. Give it the value of a list comprehension that iterates over `key` and `val` for each key-value pair in `vars(self).items()` and computes the f-string `f'{key}={val}'` at each iteration.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n--fcc-editable-region--\n    def __repr__(self):\n        pass\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `arg_list`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").has_variable(\"arg_list\")`)) })"
        },
        {
          "text": "You should assign a list comprehension that iterates over `vars(self).items()` to `arg_list`.",
          "testCode": "({ test: () => runPython(`\nimport ast\nvar = _Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").find_variable(\"arg_list\")\nassert isinstance(var.tree.value, ast.ListComp), \"Expected arg_list to be a list comprehension\"\nassert (actual := var.find_comp_iters()[0].is_equivalent(\"vars(self).items()\")), f\"Expected vars(self).items(), got {actual}\"\n`) })"
        },
        {
          "text": "The list comprehension assigned to `arg_list` should use `key` and `val` to iterate over `vars(self).items()`.",
          "testCode": "({ test: () => assert(runPython(`\n_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").find_variable(\"arg_list\").find_comp_targets()[0].is_equivalent(\"key, val\")\n`)) })"
        },
        {
          "text": "The list comprehension assigned to `arg_list` should compute the string `f'{key}={val}'` for each key-value pair in `vars(self).items()`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").find_variable(\"arg_list\").find_comp_expr().is_equivalent(\"f'{key}={val}'\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f876d17832001e8e1abb05.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f93acbb514857003510e79",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "Declare a variable `args` and assign it the value returned by joining the elements in `arg_list` with the string `', '`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n--fcc-editable-region--\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `args` and assign it the value returned by joining the elements in `arg_list` with the string `', '`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").find_variable(\"args\").is_equivalent(\"args = ', '.join(arg_list)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f93acbb514857003510e79.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f93b67169a9c703264458a",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "Since the method should return the string to instantiate the object for `R2Vector` as well as `R3Vector` when inherited, you cannot build the string specifying the class name.\n\nYou can access the name of a class with `__class__.__name__`. Add a `return` statement to the `__repr__` method and return the string necessary to instantiate the object.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n--fcc-editable-region--\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use `__class__.__name__` to build the f-string needed to instantiate a vector object and return it from the `__repr__` method.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__repr__\").has_return(\"f'{self.__class__.__name__}({args})'\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f93b67169a9c703264458a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f93d4647ce2670dc6f095c",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "The `__repr__` method is called under the hood by the `repr` function. Verify that `__repr__` works properly by adding `f'\\nrepr = {repr(v1)}'` and `f'\\nrepr = {repr(v2)}'` as the second argument to your first and second `print` calls, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add `f'\\nrepr = {repr(v1)}'` as the second argument to your `print(f'v1 = {v1}')` call.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 = {v1}', f'\\\\\\\\nrepr = {repr(v1)}')\")`)) })"
        },
        {
          "text": "You should add `f'\\nrepr = {repr(v2)}'` as the second argument to your `print(f'v2 = {v2}')` call.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v2 = {v2}', f'\\\\\\\\nrepr = {repr(v2)}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f93d4647ce2670dc6f095c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f93e54a9121571dcdd3e79",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "The output is correct, `repr` is giving you the string required to instantiate the objects.\n\nNow comment out both your `print` calls.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\nprint(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should comment out both your `print()` calls.",
          "testCode": "({ test: () => {\n  assert.match(code, /#\\s*print\\s*\\(\\s*f('|\")v1 = \\{\\s*v1\\s*\\}\\1\\s*,\\s*f('|\")\\\\nrepr = \\{\\s*repr\\s*\\(\\s*v1\\s*\\)\\s*\\}\\2\\s*\\)/);\n  assert.match(code, /#\\s*print\\s*\\(\\s*f('|\")v2 = \\{\\s*v2\\s*\\}\\1\\s*,\\s*f('|\")\\\\nrepr = \\{\\s*repr\\s*\\(\\s*v2\\s*\\)\\s*\\}\\2\\s*\\)/);\n} })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f93e54a9121571dcdd3e79.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9b17a638f0d0dcce8c354",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "To create a vector space, you need to define how vectors should behave in several cases. Vectors can be added, forming a new vector.\n\nThe special method `__add__` can be implemented to override what happens by default when two objects are added together using the `+` operator.\n\nRight now, trying to add two instances of `R2Vector` or `R3Vector` would raise an exception. Create an empty `__add__` method within the `R2Vector` class and give it two parameters: `self`, and `other`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    \n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `__add__` method within the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__add__\")`)) })"
        },
        {
          "text": "Your `__add__` method should have two parameters, `self` and `other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").has_args(\"self, other\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9b17a638f0d0dcce8c354.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9b486989cb90ff3e77ac8",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "The `other` parameter of your `__add__` method represents the operand placed at the right side of the `+` operator in an addition operation.\n\nYou want to verify that the right-hand operand is not an object of the same class as the left-hand operand (i.e. `self`). Create an `if` statement that verifies that by checking the type of the operands.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    def __add__(self, other):\n        pass\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if `type(self)` and `type(other)` are different.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_ifs()[0].find_conditions()[0]\nnode.is_equivalent(\"type(self) != type(other)\") or node.is_equivalent(\"type(other) != type(self)\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9b486989cb90ff3e77ac8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9b9710cca621244d3bde1",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "In Python, `NotImplemented` is a special value used to indicate that an operation is not implemented for a specific case.\n\n`NotImplemented` does not raise an exception immediately. Instead, it signals to ask to the other operand how to perform the operation. If the request cannot be satisfied, a `TypeError` is returned by default.\n\nBecause you want to be able to sum two vectors only if they belong to the same class, return `NotImplemented` from the `if` statement you created in the previous step.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    def __add__(self, other):\n        if type(self) != type(other):\n            pass\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `NotImplemented` from within the `if` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9b9710cca621244d3bde1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9bb7c0d524612b2a88a4b",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "After the `if` statement, declare a variable `kwargs` and assign it an empty dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `kwargs` and assign it an empty dictionary after the `if` statement.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").has_stmt(\"kwargs = {}\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9bb7c0d524612b2a88a4b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9bc10a9fb1612e066e9e8",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "When adding two vectors, each component of one vector is added to the same component of the other vector. For example, adding `(1, 2)` and `(2, 4)` generates a third vector `(3, 6)`, where `3` is the sum of `1` and `2` and `6` is the sum of `2` and `4`.\n\nThe `kwargs` dictionary will contain the key-value pairs needed to instantiate a new vector of the same class of the two vectors added together.\n\nTurn the empty dictionary into a dictionary comprehension that iterates through `vars(self)` and for each key (`i`) creates a key-value pair, where the key is the same key of the current iteration and its value is the sum of the values of the `i` attributes of the two operands.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {}\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn the empty dictionary assigned to `kwargs` into a dictionary comprehension that iterates over `vars(self)`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_variable(\"kwargs\").find_comp_iters()[0].is_equivalent(\"vars(self)\")\n    `))\n})"
        },
        {
          "text": "The dictionary comprehension assigned to `kwargs` should use the variable `i` to iterate over `vars(self)`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_variable(\"kwargs\").find_comp_targets()[0].is_equivalent(\"i\")\n    `))\n})"
        },
        {
          "text": "The dictionary comprehension assigned to `kwargs` should use `i` as the key.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_variable(\"kwargs\").find_comp_key().is_equivalent(\"i\")\n    `))\n})"
        },
        {
          "text": "The dictionary comprehension assigned to `kwargs` should assign the sum of the `i` attribute of `self` and the `i` attribute of `other` to the `i` key for each `i` in `vars(self)`. Use the `getattr()` function for that.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").find_variable(\"kwargs\").find_comp_expr()\nnode.is_equivalent(\"getattr(self, i) + getattr(other, i)\") or node.is_equivalent(\"getattr(other, i) + getattr(self, i)\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9bc10a9fb1612e066e9e8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9c2c2006feb1428ad2d4c",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "You can unpack a dictionary into keyword arguments by using the `**` operator:\n\n```py\ndef spam(a, b):\n    return a + b\n\nmy_dict = {a: 11, b: 4}\n\nspam(**my_dict) # 15\n```\n\nReturn an instance of the current class by using `__class__` and passing `**kwargs` as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `self.__class__(**kwargs)` from the `__add__` method.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__add__\").has_return(\"self.__class__(**kwargs)\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9c2c2006feb1428ad2d4c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9cb678070ca1668898c70",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "In the same way `__add__` is called under the hood when two objects are added together, the `__sub__` method is called implicitly in case of subtraction.\n\nNow, define an empty `__sub__` method and give two parameters: `self`, and `other`. Inside your new method, create an if statement to check if `self` and `other` do not belong to the same class and return `NotImplemented`, as you did previously.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n--fcc-editable-region--\n    \n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__sub__` method within the `R2Vector` class.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").has_function(\"__sub__\")\n    `))\n})"
        },
        {
          "text": "Your `__sub__` method should have two parameters, `self` and `other`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").has_args(\"self, other\")\n    `))\n})"
        },
        {
          "text": "You should create an `if` statement that checks if `self` and `other` does not belong to the same class.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_ifs()[0].find_conditions()[0]\nnode.is_equivalent(\"type(self) != type(other)\") or node.is_equivalent(\"type(other) != type(self)\")\n    `))\n})"
        },
        {
          "text": "You should return `NotImplemented` from within the `if` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9cb678070ca1668898c70.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9dd6e5a08af19c196c2df",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "The vector resulting from the subtraction of one vector from another is obtained by calculating the difference of each of their components. For example, subtracting `(2, 4)` from `(7, 3)` generates a third vector `(5, -1)`, where `5` is the difference between `7` and `2` and `-1` is the difference between `3` and `4`.\n\nAs you did before inside the `__add__` method, declare a `kwargs` variable after the `if` statement. Assign it a dictionary comprehension that iterates through the object attributes and creates a key-value pair for each key `i`, where the key is the same key as the current iteration and its value is the difference between the values of the `i` attributes of two operands.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n--fcc-editable-region--\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `kwargs` and assign it a dictionary comprehension that iterates over the object attributes.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_variable(\"kwargs\").find_comp_iters()[0]\nnode.is_equivalent(\"vars(self)\") or node.is_equivalent(\"self.__dict__\")`)) })"
        },
        {
          "text": "The dictionary comprehension assigned to `kwargs` should use the variable `i` to iterate over the object attributes.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_variable(\"kwargs\").find_comp_targets()[0].is_equivalent(\"i\")\n    `))\n})"
        },
        {
          "text": "The dictionary comprehension assigned to `kwargs` should use `i` as the key.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_variable(\"kwargs\").find_comp_key().is_equivalent(\"i\")`)) })"
        },
        {
          "text": "The dictionary comprehension assigned to `kwargs` should assign the difference between the `i` attribute of `self` and the `i` attribute of `other` to the `i` key for each `i`.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").find_variable(\"kwargs\").find_comp_expr()\nnode.is_equivalent(\"getattr(self, i) - getattr(other, i)\") or node.is_equivalent(\"self.__getattribute__(i) - other.__getattribute__(i)\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9dd6e5a08af19c196c2df.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9dfd2e75e291a38695f13",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "Finally, return a new vector object. Use `__class__` and unpack `kwargs` to instantiate the new vector.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n--fcc-editable-region--\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return a new vector using `__class__` and unpacking `kwargs` from the `__sub__` method.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__sub__\").has_return(\"self.__class__(**kwargs)\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9dfd2e75e291a38695f13.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65f9e0a578b22c1a736f3d82",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "Modify your `v2` variable assignment to be an `R2Vector` instance having `x=0.5` and `y=1.25`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `v2` variable assignment to be an `R2Vector` instance having `x=0.5` and `y=1.25`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).has_stmt(\"v2 = R2Vector(x=0.5, y=1.25)\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65f9e0a578b22c1a736f3d82.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fa8d5cf0ef3b141010f5d8",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "It's time to verify that the addition and subtraction operations work as expected. Declare another variable `v3` and assign it the sum of `v1` plus `v2`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `v3` and assign it the sum of `v1` and `v2`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).has_stmt(\"v3 = v1 + v2\") or _Node(_code).has_stmt(\"v3 = v2 + v1\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fa8d5cf0ef3b141010f5d8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fa8df56a0e2c149b4d24fe",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "Next, check the new vector by printing the following f-string `f'v1 + v2 = {v3}'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `f'v1 + v2 = {v3}'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 + v2 = {v3}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fa8df56a0e2c149b4d24fe.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fa9402d1fb5516aa42159d",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "Feel free to modify `v3` so that it sums an `R2Vector` instance with an object of a different type, such as an integer or a string. You will be able to see a `TypeError` message printed on the console.\n\nThen, restore the original line and create a new variable `v4`. Assign the difference between `v1` and `v2` to your new variable and print the result following the same structure as the previous f-string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `v4` and assign it the difference between `v1` and `v2`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).has_stmt(\"v4 = v1 - v2\")\n    `))\n})"
        },
        {
          "text": "You should print `f'v1 - v2 = {v4}'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 - v2 = {v4}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fa9402d1fb5516aa42159d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fa9e1b6c6db919385359ec",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "The special method `__mul__` can be implemented to specify what should happen when the current instance is multiplied by another object.\n\nCreate an empty `__mul__` method within the `R2Vector` class and give it two parameters: `self`, and `other`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n--fcc-editable-region--\n    \n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__mul__` method within the `R2Vector` class.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").has_function(\"__mul__\")\n    `))\n})"
        },
        {
          "text": "Your `__mul__` method should have two parameters, `self` and `other`.",
          "testCode": "({\n    test: () => assert(runPython(`\n      _Node(_code).find_class(\"R2Vector\").find_function(\"__mul__\").has_args(\"self, other\")\n    `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fa9e1b6c6db919385359ec.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65faaed8f7a9772f023ea816",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "Vectors can be multiplied by a *scalar*, i.e. a number that multiplies each single component. The result of scalar multiplication is a vector with the same orientation as the original vector but a different magnitude.\n\nImplement the scalar multiplication by checking if `other` is either an `int` or a `float`. If it is, return a new instance of the current class that has each component of the starting vector multiplied by `other`. This will be the vector resulting from the scalar multiplication.\n\nMake sure the methods can be applied to compute the scalar multiplication of vectors with any number of dimensions.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n--fcc-editable-region--\n    def __mul__(self, other):\n        pass\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your method should return a new instance of the current class only when the type of `other` is either `int` or `float`.",
          "testCode": "({ test: () => runPython(`\nv1 = R2Vector(x=0, y=0)\nv2 = R3Vector(x=0, y=0, z=0)\ntypes = [\"\", True, [], {}]\nassert all((v1 * i) is None for i in types)\ntypes = [1, 1.0]\nassert all(type(v1 * i) is type(v1) for i in types)\nassert all(type(v2 * i) is type(v2) for i in types)\n`) })"
        },
        {
          "text": "The vector resulting from the scalar multiplication should have each component of the starting vector multiplied by the scalar.",
          "testCode": "({ test: () => runPython(`\nv1 = R2Vector(x=1, y=1.5)\nv2 = R3Vector(x=2.2, y=3, z=-1)\nassert vars(v1 * 3) == vars(R2Vector(x=3, y=4.5))\nassert vars(v2 * (-2.0)) == vars(R3Vector(x=-4.4, y=-6.0, z=2.0))\n`) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65faaed8f7a9772f023ea816.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fc87e19930a503e5f05500",
      "title": "Step 53",
      "challengeType": 20,
      "dashedName": "step-53",
      "description": "A vector can be multiplied by another vector, too. This operation is called *dot product*, or *scalar product*.\n\nCreate an `elif` clause that checks if `other` is an object of the same class of the current instance.\n\nYou are going to implement the dot product inside this block during the next step.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n--fcc-editable-region--\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `elif` clause that checks if `other` is an object of the same class of the current instance.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__mul__\").find_ifs()[0].find_conditions()[1]\nnode.is_equivalent(\"type(self) == type(other)\") or node.is_equivalent(\"type(other) == type(self)\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fc87e19930a503e5f05500.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fc899d77495504d6deeccc",
      "title": "Step 54",
      "challengeType": 20,
      "dashedName": "step-54",
      "description": "The scalar product between two vectors $\\mathbf{a}$ and $\\mathbf{b}$ is indicated as:\n\n\\\\( \\mathbf{a} \\cdot \\mathbf{b} = a_1 \\cdot b_1 + a_2 \\cdot b_2 + \\ldots + a_n \\cdot b_n = \\sum_{i=1}^{n} a_i \\cdot b_i \\\\)\n\nWhere each component of $\\mathbf{a}$ is multiplied by the correspondent component of $\\mathbf{b}$, and all the products are summed together, resulting in a number.\n\nWithin the `elif` clause, implement the above formula to compute the result of a scalar product and return the result. Remember that your implementation must be valid for any vector, independently from the number of components, when the method is inherited.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n--fcc-editable-region--\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)\n        \n        elif type(self) == type(other):\n            pass\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should implement the scalar product calculation and return the result inside the `elif` body of your `__mul__` method.",
          "testCode": "({ test: () => assert(runPython(`\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nv3 = R3Vector(x=2, y=3, z=1.5)\nv4 = R3Vector(x=0.5, y=1.25, z=1.5)\nv1*v2 == 4.75 and v3*v4 == 7.0      \n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fc899d77495504d6deeccc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fc8e7c766ab1070213aadb",
      "title": "Step 55",
      "challengeType": 20,
      "dashedName": "step-55",
      "description": "In case `other` is not an integer, a floating point number, or another instance of the current class, no product can be computed.\n\nAfter the `elif` clause, return `NotImplemented`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n--fcc-editable-region--\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)\n        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `NotImplemented` after the `elif` clause.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__mul__\").has_return(\"NotImplemented\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fc8e7c766ab1070213aadb.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fc8fa7e7860407ab479bf0",
      "title": "Step 56",
      "challengeType": 20,
      "dashedName": "step-56",
      "description": "It's time to test the multiplication. Declare a new variable `v5` and assign it the scalar multiplication `v1 * 3`.\nThen, call the `print` function and pass it the following f-string: `f'v1 * 3 = {v5}'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a new variable `v5` and assign it the scalar multiplication `v1 * 3`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"v5\").is_equivalent(\"v5 = v1 * 3\")`)) })"
        },
        {
          "text": "You should print the f-string `f'v1 * 3 = {v5}'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 * 3 = {v5}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fc8fa7e7860407ab479bf0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fd681b20b7e45f55def415",
      "title": "Step 57",
      "challengeType": 20,
      "dashedName": "step-57",
      "description": "The scalar multiplication works fine. Now, modify the assignment of `v5` to be the dot product `v1 * v2`. Also, update the `print` call.\n\nBefore doing that, feel free to experiment and multiply `v1` by an object of invalid type to see the error message printed on the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * 3\nprint(f'v1 * 3 = {v5}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should update the assignment of `v5` assigning it the scalar product `v1 * v2`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"v5\").is_equivalent(\"v5 = v1 * v2\")`)) })"
        },
        {
          "text": "You should update your `print` call to print the f-string `f'v1 * v2 = {v5}'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 * v2 = {v5}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fd681b20b7e45f55def415.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fd9250db0d6b8198cf29ef",
      "title": "Step 58",
      "challengeType": 20,
      "dashedName": "step-58",
      "description": "The `__eq__` method can be implemented to specify what should happen in case the comparison operator (`==`) is used to compare an object with something else.\n\nWithin the `R2Vector` class, create an `__eq__` method and give it two parameters: `self` and `other`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n--fcc-editable-region--\n    \n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__eq__` method within the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__eq__\")`)) })"
        },
        {
          "text": "Your `__eq__` method should take two parameters: `self` and `other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__eq__\").has_args(\"self, other\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fd9250db0d6b8198cf29ef.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fd95c23beef982af29004c",
      "title": "Step 59",
      "challengeType": 20,
      "dashedName": "step-59",
      "description": "You want to compare two vectors, only when they belong to the same class. For that create an `if` statement that checks if `self` and `other` do not belong to the same class and return `NotImplemented` in that case.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n--fcc-editable-region--\n    def __eq__(self, other):\n        pass\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if `self` and `other` do not belong to the same class.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__eq__\").find_ifs()[0].find_conditions()[0]\nconditions = [\"type(self) != type(other)\", \"type(other) != type(self)\", \"self.__class__ != other.__class__\", \"other.__class__ != self.__class__\"]\nany(node.is_equivalent(condition) for condition in conditions)`)) })"
        },
        {
          "text": "You should return `NotImplemented` from your `if` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__eq__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fd95c23beef982af29004c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fd97f3c1b4c4839bdeb8d2",
      "title": "Step 60",
      "challengeType": 20,
      "dashedName": "step-60",
      "description": "To compare two vectors, you are going to check that each component of the first vector is equal to the same component of the second vector.\n\nAfter the `if` statement you created in the previous step, return `True` if each attribute of the current instance is equal to the same attribute of `other` and `False` otherwise.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n--fcc-editable-region--\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `__eq__` method should return `True` if each attribute of the current instance is equal to the same attribute of `other` and `False` otherwise.",
          "testCode": "({ test: () => assert(runPython(`\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=2, y=3)\nv3 = R2Vector(x=0.5, y=1.25)\nv4 = R3Vector(x=2, y=3, z=1.5)\nv5 = R3Vector(x=2, y=3, z=1.5)\nv6 = R3Vector(x=0.5, y=1.25, z=1.5)\nv1 == v2 and not v1 == v3 and v4 == v5 and not v5 == v6\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fd97f3c1b4c4839bdeb8d2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fd9aa649f6cc84631882a9",
      "title": "Step 61",
      "challengeType": 20,
      "dashedName": "step-61",
      "description": "The `__ne__` method is called under the hood when the `!=` operator is used. Define a `__ne__` method with two parameters `self` and `other`. From your new method, return the opposite of `self == other`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n--fcc-editable-region--\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__ne__` method within the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__ne__\")`)) })"
        },
        {
          "text": "Your `__ne__` method should have two parameters, `self` and `other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__ne__\").has_args(\"self, other\")`)) })"
        },
        {
          "text": "The `__ne__` method should return `False` if each attribute of the current instance is equal to the same attribute of `other` and `True` otherwise.",
          "testCode": "({ test: () => assert(runPython(`\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=2, y=3)\nv3 = R2Vector(x=0.5, y=1.25)\nv4 = R3Vector(x=2, y=3, z=1.5)\nv5 = R3Vector(x=2, y=3, z=1.5)\nv6 = R3Vector(x=0.5, y=1.25, z=1.5)\nnot v1 != v2 and v1 != v3 and not v4 != v5 and v5 != v6\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fd9aa649f6cc84631882a9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fd9c6e49d7cd8513ab1005",
      "title": "Step 62",
      "challengeType": 20,
      "dashedName": "step-62",
      "description": "At the end of your code, use the equality operator to compare `v1` and `R2Vector(x=2, y=3)` and print the result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the result of comparing `v1` and `R2Vector(x=2, y=3)` using the equality operator.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(v1 == R2Vector(x=2, y=3))\") or _Node(_code).has_call(\"print(R2Vector(x=2, y=3) == v1)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fd9c6e49d7cd8513ab1005.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fd9d6203afea85931094c9",
      "title": "Step 63",
      "challengeType": 20,
      "dashedName": "step-63",
      "description": "The comparison returns `True`, since the two vectors have the same components. Now, modify the argument of the `print` call you added in the previous step to use the inequality operator.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nprint(v1 == R2Vector(x=2, y=3))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the `print` call you added in the previous step using the inequality operator to compare `v1` and `R2Vector(x=2, y=3)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(v1 != R2Vector(x=2, y=3))\") or _Node(_code).has_call(\"print(R2Vector(x=2, y=3) != v1)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fd9d6203afea85931094c9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fd9e2c56ff19862dfb8cbb",
      "title": "Step 64",
      "challengeType": 20,
      "dashedName": "step-64",
      "description": "The `__lt__` method is called under the hood when the `<` operator is used to compare an object with something else.\n\nAdd an empty `__lt__` method and give it two parameters: `self`, `other`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n--fcc-editable-region--\n    \n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nprint(v1 != R2Vector(x=2, y=3))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__lt__` method within the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__lt__\")`)) })"
        },
        {
          "text": "Your `__lt__` method should have two parameters, `self` and `other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__lt__\").has_args(\"self, other\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fd9e2c56ff19862dfb8cbb.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fdc3c8478ee70fc7966151",
      "title": "Step 65",
      "challengeType": 20,
      "dashedName": "step-65",
      "description": "In the same way you did before for the `__eq__` method, create an `if` statement that checks if `self` and `other` do not belong to the same class and return `NotImplemented`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n--fcc-editable-region--\n    def __lt__(self, other):\n        pass\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nprint(v1 != R2Vector(x=2, y=3))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if `self` and `other` do not belong to the same class.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__lt__\").find_ifs()[0].find_conditions()[0]\nconditions = [\"type(self) != type(other)\", \"type(other) != type(self)\", \"self.__class__ != other.__class__\", \"other.__class__ != self.__class__\"]\nany(node.is_equivalent(condition) for condition in conditions)\n`)) })"
        },
        {
          "text": "You should return `NotImplemented` from your `if` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__lt__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fdc3c8478ee70fc7966151.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "65fdc496f4440e1055a2ac1b",
      "title": "Step 66",
      "challengeType": 20,
      "dashedName": "step-66",
      "description": "After the `if` statement, return the result of comparing the norm of the current instance with the norm of `other` using the less than operator.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n--fcc-editable-region--\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nprint(v1 != R2Vector(x=2, y=3))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `__lt__` method should return the result of comparing the norm of the current instance with the norm of `other` using the `<` operator.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__lt__\").has_return(\"self.norm() < other.norm()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\65fdc496f4440e1055a2ac1b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6601918b44a11b4a8c986c6a",
      "title": "Step 67",
      "challengeType": 20,
      "dashedName": "step-67",
      "description": "The `__gt__` method is called under the hood when the `>` operator is used to compare an object with something else.\n\nAfter the `__lt__` method, in the same way you did for `__lt__`, implement the `__gt__` method. Pay attention to use the appropriate operator.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n--fcc-editable-region--\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nprint(v1 != R2Vector(x=2, y=3))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__gt__` method within the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__gt__\")`)) })"
        },
        {
          "text": "Your `__lt__` method should have two parameters, `self` and `other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__gt__\").has_args(\"self, other\")`)) })"
        },
        {
          "text": "You should create an `if` statement that checks if `self` and `other` do not belong to the same class.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R2Vector\").find_function(\"__gt__\").find_ifs()[0].find_conditions()[0]\nnode.is_equivalent(\"type(self) != type(other)\") or node.is_equivalent(\"type(other) != type(self)\")`)) })"
        },
        {
          "text": "You should return `NotImplemented` from your `if` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__gt__\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })"
        },
        {
          "text": "The `__gt__` method should return the result of comparing the norm of the current instance with the norm of `other` using the greater than operator.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__gt__\").has_return(\"self.norm() > other.norm()\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6601918b44a11b4a8c986c6a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "66019258a7c71d4ae50da42e",
      "title": "Step 68",
      "challengeType": 20,
      "dashedName": "step-68",
      "description": "There are still two possible comparisons to implement. The `__le__` method is called when the `<=` operator is used to compare two objects.\n\nDefine a `__le__` method with `self` and `other` as the parameters and make it return the opposite of `self > other`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n--fcc-editable-region--\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nprint(v1 != R2Vector(x=2, y=3))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__le__` method within the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__le__\")`)) })"
        },
        {
          "text": "Your `__le__` method should have two parameters, `self` and `other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__le__\").has_args(\"self, other\")`)) })"
        },
        {
          "text": "Your `__le__` method return the opposite of `self > other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__le__\").has_return(\"not self > other\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\66019258a7c71d4ae50da42e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "66019319edb1cb4b57d3a793",
      "title": "Step 69",
      "challengeType": 20,
      "dashedName": "step-69",
      "description": "The last method you need is `__ge__`, which is called when the `>=` is used to compare two objects.\n\nDefine a `__ge__` method with `self` and `other` as the parameters and make it return the opposite of `self < other`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n--fcc-editable-region--\n\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nprint(v1 != R2Vector(x=2, y=3))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `__ge__` method within the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__ge__\")`)) })"
        },
        {
          "text": "Your `__ge__` method should have two parameters, `self` and `other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__ge__\").has_args(\"self, other\")`)) })"
        },
        {
          "text": "Your `__ge__` method should return the opposite of `self < other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__ge__\").has_return(\"not self < other\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\66019319edb1cb4b57d3a793.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "660193a2a71faa4bd8f10970",
      "title": "Step 70",
      "challengeType": 20,
      "dashedName": "step-70",
      "description": "Feel free to play around with the new comparison operations you implemented. Then, remove your last `print` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nprint(v1 != R2Vector(x=2, y=3))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(v1 != R2Vector(x=2, y=3))` in your code.",
          "testCode": "({test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(v1 != R2Vector(x=2, y=3))\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\660193a2a71faa4bd8f10970.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "66019977710caa516276c0a8",
      "title": "Step 71",
      "challengeType": 20,
      "dashedName": "step-71",
      "description": "The *cross product*, or *vector product*, is defined between 3-dimensional vectors and results in a third vector perpendicular to both of them.\n\nThe `R3Vector` class inherits from `R2Vector`, meaning it has access to all the methods and properties defined in `R2Vector`. A child class can implement additional features. You already saw a way to change the implementation of a method. Now, you are going to give the child class `R3Vector` a new method instead.\n\nWithin the `R3Vector` class, define a `cross` method and give it two parameters: `self`, and `other`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `cross` method within the `R3Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").has_function(\"cross\")`)) })"
        },
        {
          "text": "Your `cross` method should have two parameters, `self` and `other`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"cross\").has_args(\"self, other\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\66019977710caa516276c0a8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6601a7eb860fb8546516674d",
      "title": "Step 72",
      "challengeType": 20,
      "dashedName": "step-72",
      "description": "Create an `if` statement that checks if `self` and `other` do not belong to the same class and return `NotImplemented`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n        \n    def cross(self, other):\n        pass\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if `self` and `other` do not belong to the same class.",
          "testCode": "({ test: () => assert(runPython(`\nnode = _Node(_code).find_class(\"R3Vector\").find_function(\"cross\").find_ifs()[0].find_conditions()[0]\nconditions = [\"type(self) != type(other)\", \"type(other) != type(self)\", \"self.__class__ != other.__class__\", \"other.__class__ != self.__class__\"]\nany(node.is_equivalent(condition) for condition in conditions)\n`)) })"
        },
        {
          "text": "You should return `NotImplemented` from your `if` body.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"cross\").find_ifs()[0].find_bodies()[0].has_return(\"NotImplemented\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6601a7eb860fb8546516674d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6601a88a6e2ccc550d7d7208",
      "title": "Step 73",
      "challengeType": 20,
      "dashedName": "step-73",
      "description": "After the `if` statement, declare a variable `kwargs` and assign it an empty dictionary.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n        \n    def cross(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable `kwargs` and assign it an empty dictionary after the `if` statement.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R3Vector\").find_function(\"cross\").find_variable(\"kwargs\").is_equivalent(\"kwargs = {}\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6601a88a6e2ccc550d7d7208.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6601a8fb2e993b55912f9e9f",
      "title": "Step 74",
      "challengeType": 20,
      "dashedName": "step-74",
      "description": "The cross product between two 3D vectors \\\\( \\mathbf{a} \\\\) and \\\\( \\mathbf{b} \\\\) can be computed as it follows:\n\n\\\\[ \\mathbf{a} \\times \\mathbf{b} = \\begin{pmatrix} a_yb_z - a_zb_y \\\\\\ a_zb_x - a_xb_z \\\\\\ a_xb_y - a_yb_x \\end{pmatrix}\n \\\\]\n \nWhere the resulting vector is represented as a column vector.\n \nImplement the formula above to compute the cross product between two 3-dimensional vectors and return the resulting vector from the `cross()` method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n        \n    def cross(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {}\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `cross()` method should return a new `R3Vector` instance resulting from the cross product computation.",
          "testCode": "({ test: () => assert(runPython(`\nv1 = R3Vector(x=2, y=3, z=1)\nv2 = R3Vector(x=0.5, y=1.25, z=2)\nv1.cross(v2) == R3Vector(x=4.75, y=-3.5, z=1.0) and v2.cross(v1) == R3Vector(x=-4.75, y=3.5, z=-1.0) and v1.cross(v1) == R3Vector(x=0, y=0, z=0)\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6601a8fb2e993b55912f9e9f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6601ab2809898f57591f2f7f",
      "title": "Step 75",
      "challengeType": 20,
      "dashedName": "step-75",
      "description": "Now, modify the assignments of `v1` and `v2`. Turn them into `R3Vector` instances and pass `z=1` and `z=2` to `v1` and `v2`, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n        \n    def cross(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {\n            'x': self.y * other.z - self.z * other.y,\n            'y': self.z * other.x - self.x * other.z,\n            'z': self.x * other.y - self.y * other.x\n        }\n        \n        return self.__class__(**kwargs)\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R2Vector(x=0.5, y=1.25)\n--fcc-editable-region--\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the assignment of `v1` to be an `R3Vector` instance.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"v1\").is_equivalent(\"v1 = R3Vector(x=2, y=3, z=1)\")`)) })"
        },
        {
          "text": "You should modify the assignment of `v2` to be an `R3Vector` instance.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"v2\").is_equivalent(\"v2 = R3Vector(x=0.5, y=1.25, z=2)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6601ab2809898f57591f2f7f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6601ac48a2ee6b59e6a5060d",
      "title": "Step 76",
      "challengeType": 20,
      "dashedName": "step-76",
      "description": "Call `cross()` on `v1` and pass `v2` as the argument. Assign this call to a new variable `v6`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n        \n    def cross(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {\n            'x': self.y * other.z - self.z * other.y,\n            'y': self.z * other.x - self.x * other.z,\n            'z': self.x * other.y - self.y * other.x\n        }\n        \n        return self.__class__(**kwargs)\n--fcc-editable-region--\nv1 = R3Vector(x=2, y=3, z=1)\nv2 = R3Vector(x=0.5, y=1.25, z=2)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `v6` and assign it a call to the `cross()` method on `v1` passing it `v2` as the `argument`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_variable(\"v6\").is_equivalent(\"v6 = v1.cross(v2)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6601ac48a2ee6b59e6a5060d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6601ad0fe415985a5c83f3cc",
      "title": "Step 77",
      "challengeType": 20,
      "dashedName": "step-77",
      "description": "As a final step, call the `print` function and pass it the f-string `f'v1 x v2 = {v6}'` to see the output of the cross product.\n\nWith that, you have completed the vector space project. Well done!",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n        \n    def cross(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {\n            'x': self.y * other.z - self.z * other.y,\n            'y': self.z * other.x - self.x * other.z,\n            'z': self.x * other.y - self.y * other.x\n        }\n        \n        return self.__class__(**kwargs)\n--fcc-editable-region--\nv1 = R3Vector(x=2, y=3, z=1)\nv2 = R3Vector(x=0.5, y=1.25, z=2)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nv6 = v1.cross(v2)\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __add__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) + getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __sub__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {i: getattr(self, i) - getattr(other, i) for i in vars(self)}\n        return self.__class__(**kwargs)\n\n    def __mul__(self, other):\n        if type(other) in (int, float):\n            kwargs = {i: getattr(self, i) * other for i in vars(self)}\n            return self.__class__(**kwargs)        \n        elif type(self) == type(other):\n            args = [getattr(self, i) * getattr(other, i) for i in vars(self)]\n            return sum(args)            \n        return NotImplemented\n\n    def __eq__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return all(getattr(self, i) == getattr(other, i) for i in vars(self))\n        \n    def __ne__(self, other):\n        return not self == other\n\n    def __lt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() < other.norm()\n\n    def __gt__(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        return self.norm() > other.norm()\n\n    def __le__(self, other):\n        return not self > other\n\n    def __ge__(self, other):\n        return not self < other\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n        \n    def cross(self, other):\n        if type(self) != type(other):\n            return NotImplemented\n        kwargs = {\n            'x': self.y * other.z - self.z * other.y,\n            'y': self.z * other.x - self.x * other.z,\n            'z': self.x * other.y - self.y * other.x\n        }\n        \n        return self.__class__(**kwargs)\n\nv1 = R3Vector(x=2, y=3, z=1)\nv2 = R3Vector(x=0.5, y=1.25, z=2)\nprint(f'v1 = {v1}')\nprint(f'v2 = {v2}')\nv3 = v1 + v2\nprint(f'v1 + v2 = {v3}')\nv4 = v1 - v2\nprint(f'v1 - v2 = {v4}')\nv5 = v1 * v2\nprint(f'v1 * v2 = {v5}')\nv6 = v1.cross(v2)\nprint(f'v1 x v2 = {v6}')"
        }
      ],
      "tests": [
        {
          "text": "You should print `f'v1 x v2 = {v6}'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 x v2 = {v6}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6601ad0fe415985a5c83f3cc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6659875502b6d7765498f324",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "Use f-strings to modify your `print` calls so that they result in the output `v1 = (2, 3)` and `v2 = (2, 2, 3)`, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in self.__dict__.values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n--fcc-editable-region--\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(v1.norm())\nprint(v2.norm())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use an f-string to interpolate `v1` and generate the output `v1 = (2, 3)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v1 = {v1}')\")`)) })"
        },
        {
          "text": "You should use an f-string to interpolate `v2` and generate the output `v2 = (2, 2, 3)`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).has_call(\"print(f'v2 = {v2}')\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6659875502b6d7765498f324.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "66680ddfd0f8c76782923cb0",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "The `norm()` method is returning the correct values, but there's still something you can improve: readability. \n\nThe `vars()` built-in function takes an object as its argument and returns the `__dict__` attribute of that object.\n\nInstead of directly accessing the `__dict__` attribute of `self`, modify the `norm` method to use the `vars()` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n--fcc-editable-region--\n    def norm(self):\n        return sum(val**2 for val in self.__dict__.values())**0.5\n--fcc-editable-region--\n    def __str__(self):\n        return f'{self.x, self.y}'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\nprint(v1.norm())\nprint(v2.norm())"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `norm` method to use `vars(self)` instead of `self.__dict__`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"norm\").has_return(\"sum(val**2 for val in vars(self).values())**0.5\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\66680ddfd0f8c76782923cb0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "66682150151af29efec9727d",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "The `__getattribute__` method is called under the hood any time you try to access an instance attribute. If the attribute is not found at the instance level, the method will search for it at the class level, and eventually in parent classes.\n\nInside your class, define a `__getattribute__` method with two parameters, `self` and `attr`, and make it return the string `'calling __getattribute__'`. You'll override momentarily the default implementation just to see how the attribute access works.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    \n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\n# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method named `__getattribute__` with two parameters, `self` and `attr`, inside the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__getattribute__\").has_args(\"self, attr\")`)) })"
        },
        {
          "text": "Your `__getattribute__` method should return the string `'calling __getattribute__'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__getattribute__\").has_return(\"'calling __getattribute__'\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\66682150151af29efec9727d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "666826f258fda1ab3396a509",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "Now, print the result of accessing the `x` attribute of `v1` both with the dot operator and the `getattr()` built-in function.\n\nYou will see that `__getattribute__` is called in both cases.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n    \n    def __getattribute__(self, attr):                \n        return 'calling __getattribute__'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\n# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the `x` attribute of `v1` using both the dot operator and the `getattr()` function.",
          "testCode": "({ test: () => assert(runPython(`\nn = _Node(_code)\n(n.has_call(\"print(v1.x)\") and n.has_call(\"print(getattr(v1, 'x'))\")) or n.has_call(\"print(v1.x, getattr(v1, 'x'))\") or n.has_call(\"print(getattr(v1, 'x'), v1.x)\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\666826f258fda1ab3396a509.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "666827a6fd0dbaafe8330ea6",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "`__getattr__` is another special method that plays a role in accessing attributes.\n\nThe default implementation of `__getattribute__` is to raise an `AttributeError` when the requested attribute is not an instance attribute or it is not present in the class tree.\n\nIn that case, `__getattr__` is called if defined by the class. You can consider it as a sort of fallback when the usual attribute accessing procedure fails.\n\nTurn the `__getattribute__` method into `__getattr__` and modify the string returned by the method into `'calling __getattr__'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    def __getattribute__(self, attr):                \n        return 'calling __getattribute__'\n--fcc-editable-region--\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\n# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n\nprint(v1.x)\nprint(getattr(v1, 'x'))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method named `__getattr__` with two parameters, `self` and `attr`, inside the `R2Vector` class.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__getattr__\").has_args(\"self, attr\")`)) })"
        },
        {
          "text": "Your `__getattr__` method should return the string `'calling __getattr__'`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"R2Vector\").find_function(\"__getattr__\").has_return(\"'calling __getattr__'\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\666827a6fd0dbaafe8330ea6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "666832e427d70bc5219dc62a",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "As you can see from the output, although you defined `__getattr__` in your class, this method is not called yet. This happens because the default attribute access occurs through `__getattribute__`. Therefore, you can see the attribute value printed on the terminal.\n\nNow modify the last two lines of code to access the `z` attribute of `v1` in both your `print()` calls. This time, you are going to access an attribute that `v1` does not have. As a result, `__getattribute__` will raise an error and `__getattr__` will be called.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n\n    def __getattr__(self, attr):                \n        return 'calling __getattr__'\n\nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\n# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\n--fcc-editable-region--\nprint(v1.x)\nprint(getattr(v1, 'x'))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your code to print the `z` attribute of `v1` using both the dot operator and the `getattr()` function.",
          "testCode": "({ test: () => assert(runPython(`\nn = _Node(_code)\n(n.has_call(\"print(v1.z)\") and n.has_call(\"print(getattr(v1, 'z'))\")) or n.has_call(\"print(v1.z, getattr(v1, 'z'))\") or n.has_call(\"print(getattr(v1, 'z'), v1.z)\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\666832e427d70bc5219dc62a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6668374ed18b7fce10259cb3",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "Now that you have an idea of how the attribute access work, remove the last two lines of your code together with the `__getattr__` method.\n\nThen, restore the `print()` calls you commented out before and delete the second argument from both of them.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class R2Vector:\n    def __init__(self, *, x, y):\n        self.x = x\n        self.y = y\n\n    def norm(self):\n        return sum(val**2 for val in vars(self).values())**0.5\n\n    def __str__(self):\n        return str(tuple(getattr(self, i) for i in vars(self)))\n\n    def __repr__(self):\n        arg_list = [f'{key}={val}' for key, val in vars(self).items()]\n        args = ', '.join(arg_list)\n        return f'{self.__class__.__name__}({args})'\n--fcc-editable-region--\n    def __getattr__(self, attr):                \n        return 'calling __getattr__'\n        \nclass R3Vector(R2Vector):\n    def __init__(self, *, x, y, z):\n        super().__init__(x=x, y=y)\n        self.z = z\n\nv1 = R2Vector(x=2, y=3)\nv2 = R3Vector(x=2, y=2, z=3)\n# print(f'v1 = {v1}', f'\\nrepr = {repr(v1)}')\n# print(f'v2 = {v2}', f'\\nrepr = {repr(v2)}')\nprint(v1.z)\nprint(getattr(v1, 'z'))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have a `__getattr__` method.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).find_class(\"R2Vector\").has_function(\"__getattr__\")`)) })"
        },
        {
          "text": "You should not have `print(v1.z)`and `print(getattr(v1, 'z'))` in your code.",
          "testCode": "({ test: () => assert.isFalse(runPython(`\nn = _Node(_code)\nn.has_call(\"print(v1.z)\") or n.has_call(\"print(getattr(v1, 'z'))\")\n`)) })"
        },
        {
          "text": "You should restore the `print()` calls you commented out before and remove the second argument from both of them.",
          "testCode": "({ test: () => assert(runPython(`\n_Node(_code).has_call(\"print(f'v1 = {v1}')\") and _Node(_code).has_call(\"print(f'v2 = {v2}')\")\n`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-special-methods-by-building-a-vector-space\\6668374ed18b7fce10259cb3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-special-methods-by-building-a-vector-space",
        "name": "Learn Special Methods By Building A Vector Space"
      }
    },
    {
      "id": "6551ecf597038c36637f3759",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "Variables are an essential part of Python and any programming language. A variable is a name that references or points to an object. You can declare a variable by writing the variable name on the left side of the assignment operator `=` and specifying the value to assign to that variable on the right side of the assignment operator:\n\n```py\nvariable_name = value\n```\n\nCreate a variable called `number` and assign the value `5` to your new variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable called `number`. Pay attention to place the variable name at the beginning of the line.",
          "testCode": "assert.match(code, /^number\\s*=/m)"
        },
        {
          "text": "You should assign the value `5` to your `number` variable.",
          "testCode": "assert.match(code, /^number\\s*=\\s*5\\s*(#.*)?$/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551ecf597038c36637f3759.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551eebe6cbb2e6cadf9b468",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "Variables can store values of different data types. You just assigned an integer value, but if you want to represent some text, you need to assign a string. Strings are sequences of characters enclosed by single or double quotes, but you cannot start a string with a single quote and end it with a double quote or vice versa:\n\n```py\nstring_1 = \"I am a string\"\nstring_2 = 'I am also a string'\nstring_3 = 'This is not valid\"\n```\n\nDelete your `number` variable and its value. Then, declare another variable called `text` and assign the string `'Hello World'` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nnumber = 5\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `number = 5` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.isFalse(/number\\s*=\\s*5/.test(commentless_code))"
        },
        {
          "text": "You should declare a variable called `text`. Pay attention to place the variable name at the beginning of the line.",
          "testCode": "assert.match(code, /^text\\s*=/m)"
        },
        {
          "text": "You should assign the string `'Hello World'` to your `text` variable. Remember to use either single or double quotes to enclose the string and pay attention to the letter case.",
          "testCode": "assert.match(code, /^text\\s*=\\s*(\"|')Hello World\\1\\s*(#.*)?$/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551eebe6cbb2e6cadf9b468.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551ef504d91936d2d4e54f8",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "An *argument* is an object or an expression passed to a function — added between the opening and closing parentheses — when it is called:\n\n```py\ngreet = 'Hello!'\nprint(greet)\n```\n\nThe code in the example above would print the string `'Hello!'`, which is the value of the variable `greet` passed to `print()` as the argument.\n\nPrint your `text` variable to the screen by passing the `text` variable as the argument to the `print()` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `text` to the `print()` function by adding the name of this variable within the opening and closing parentheses. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*text\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551ef504d91936d2d4e54f8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551f1e8737dbe6e0cb08ea4",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "And now print your new variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint(type(text))\nshift = 3\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not remove your existing `print(type(text))` call.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /print\\s*\\(\\s*type\\s*\\(\\s*text\\s*\\)\\s*\\)/)"
        },
        {
          "text": "You should call the `print()` function passing in the `shift` variable. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*shift\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551f1e8737dbe6e0cb08ea4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551f22653e6ce6e4f1d1370",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "Modify your `print(shift)` call to print the data type of your `shift` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint(type(text))\nshift = 3\nprint(shift)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should keep your existing `print(type(text))` call.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*type\\s*\\(\\s*text\\s*\\)\\s*\\)/m)"
        },
        {
          "text": "You should pass `shift` to the `type()` function.",
          "testCode": "assert.match(code, /type\\s*\\(\\s*shift\\s*\\)/)"
        },
        {
          "text": "You should pass `type(shift)` to your `print()` function. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*type\\s*\\(\\s*shift\\s*\\)\\s*\\)/m)"
        },
        {
          "text": "You should not have `print(shift)` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code)\nassert.notMatch(commentless_code, /print\\s*\\(\\s*shift\\s*\\)/)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551f22653e6ce6e4f1d1370.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551f3bfed58796ebb1268dc",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Each string character can be referenced by a numerical index. The index count starts at zero. So the first character of a string has an index of `0`. For example, in the string `'Hello World'`, `'H'` is at index `0`, `'e'` is at index `1`, and so on. \n\nEach character of a string can be accessed by using bracket notation. You need to write the variable name followed by square brackets and add the index of the character between the brackets:\n\n```py\ntext = 'Hello World'\nr = text[8]\n```\n\nNow, instead of printing `text`, print just the character at index `6`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint(text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should still call the `print()` function.",
          "testCode": "assert.match(code, /print\\s*\\(.*\\)/)"
        },
        {
          "text": "You should pass `text[6]` to the `print()` function by including it between the parentheses. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*text\\s*\\[\\s*6\\s*\\]\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551f3bfed58796ebb1268dc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551f4259d66026ee28cb205",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "You can also access string characters starting from the end of the string. The last character has an index of `-1`, the second to last `-2` and so on.\n\nNow modify your existing `print()` call to print the last character in your string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint(text[6])\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should still call the `print()` function.",
          "testCode": "assert.match(code, /print\\s*\\(.*\\)/)"
        },
        {
          "text": "You should pass `text[-1]` to the `print()` function by including it between the parentheses. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*text\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551f4259d66026ee28cb205.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551f5756c20146fc94f8675",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "You can access the number of characters in a string with the built-in `len()` function.\n\nModify your existing `print()` call by passing `len(text)` instead of `text[-1]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint(text[-1])\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `len()` function.",
          "testCode": "assert.match(code, /len\\s*\\(.*\\)/)"
        },
        {
          "text": "You should pass the variable `text` to the `len()` function by including it between the parentheses.",
          "testCode": "assert.match(code, /len\\s*\\(\\s*text\\s*\\)/)"
        },
        {
          "text": "You should pass `len(text)` to the `print()` function by including it between the parentheses. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*len\\s*\\(\\s*text\\s*\\)\\s*\\)/m)"
        },
        {
          "text": "You should not have `print(text[-1])` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code)\nassert.notMatch(commentless_code, /print\\s*\\(\\s*text\\s*\\[\\s*-\\s*1\\s*\\]\\s*\\)/)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551f5756c20146fc94f8675.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551f6f9ec6db270eb83f3db",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "You can see `11` printed on the terminal because `'Hello World'` contains 11 characters.\n\nAnother useful built-in function is `type()`, which returns the data type of a variable. Modify your `print()` call to print the data type of `text`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint(len(text))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `type()` function.",
          "testCode": "assert.match(code, /type\\s*\\(.*\\)/)"
        },
        {
          "text": "You should pass `text` to the `type()` function by including it between the parentheses.",
          "testCode": "assert.match(code, /type\\s*\\(\\s*text\\s*\\)/)"
        },
        {
          "text": "You should pass `type(text)` to the `print()` function by including it between the parentheses. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*type\\s*\\(\\s*text\\s*\\)\\s*\\)/m)"
        },
        {
          "text": "You should not have `print(len(text))` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code)\nassert.notMatch(commentless_code, /print\\s*\\(\\s*len\\s*\\(\\s*text\\s*\\)\\s*\\)/)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551f6f9ec6db270eb83f3db.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551fb531ce7f773071a0b84",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "As you can see, the output of printing `type(text)` is `<class 'str'>`, which means that your variable is a string, indicated as `str`.\n\nNow go to a new line and create another variable called `shift` and assign the value `3` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint(type(text))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable called `shift`. Pay attention to place the variable name at the beginning of the line.",
          "testCode": "assert.match(code, /^shift\\s*=/m)"
        },
        {
          "text": "You should assign the value `3` to your `shift` variable.",
          "testCode": "assert.match(code, /^shift\\s*=\\s*3\\s*(#.*)?$/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551fb531ce7f773071a0b84.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6551fe3b1df7c9740f13f270",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "Key aspects of variable naming in Python are:\n\n- Some words are reserved keywords (e.g. `for`, `while`, `True`). They have a special meaning in Python, so you cannot use them for variable names.\n- Variable names cannot start with a number, and they can only contain alpha-numeric characters or underscores.\n- Variable names are case sensitive, i.e. `my_var` is different from `my_Var` and `MY_VAR`.\n- Finally, it is a common convention to write variable names using `snake_case`, where each space is replaced by an underscore character and the words are written in lowercase letters.\n\nRemove both calls to `print()` and declare another variable called `alphabet`. Assign the string `'abcdefghijklmnopqrstuvwxyz'` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nprint(type(text))\nshift = 3\nprint(type(shift))\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(type(text))` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.notMatch(commentless_code, /print\\s*\\(\\s*type\\s*\\(\\s*text\\s*\\)\\s*\\)/)"
        },
        {
          "text": "You should not have `print(type(shift))` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.notMatch(commentless_code, /print\\s*\\(\\s*type\\s*\\(\\s*shift\\s*\\)\\s*\\)/)"
        },
        {
          "text": "You should declare a variable called `alphabet`. Pay attention to place the variable name at the beginning of the line.",
          "testCode": "assert.match(code, /^alphabet\\s*=/m)"
        },
        {
          "text": "You should assign the string `'abcdefghijklmnopqrstuvwxyz'` to your `alphabet` variable. Remember to use either single or double quotes to enclose the string.",
          "testCode": "assert.match(code, /^alphabet\\s*=\\s*(\"|')abcdefghijklmnopqrstuvwxyz\\1\\s*(#.*)?$/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6551fe3b1df7c9740f13f270.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6552008c0d9d9075cbec9772",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "You are going to use the `.find()` method to find the position in the alphabet of each letter in your message. A method is similar to a function, but it belongs to an object.\n\n```py\nsentence = 'My brain hurts!'\nsentence.find('r')\n```\n\nAbove, the `.find()` method is *called on* `sentence` (the string to search in), and `'r'` (the character to locate) is passed as the argument. The `sentence.find('r')` call will return `4`, which is the index of the first occurrence of `'r'` in `sentence`.\n\nAt the end of your code, call `.find()` on `alphabet` and pass `'z'` as the argument to the method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `.find()` method.",
          "testCode": "assert.match(code, /find\\s*\\(.*\\)/)"
        },
        {
          "text": "You should call the `.find()` method on the `alphabet` variable.",
          "testCode": "assert.match(code, /alphabet\\.find\\s*\\(.*\\)/)"
        },
        {
          "text": "You should call the `.find()` method on the `alphabet` variable and pass `'z'` to the method. Pay attention to place the method call at the beginning of the line.",
          "testCode": "assert.match(code, /^alphabet\\.find\\s*\\(\\s*('|\")z\\1\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6552008c0d9d9075cbec9772.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655208d59b131e7816f18c96",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "The `print()` function gives you only an output in the console, but functions and methods can have a return value that you can use in your code.\n\nNow assign `alphabet.find(text[0])` to a variable named `index`. In this way, `index` will store the value returned by `alphabet.find(text[0])`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nalphabet.find(text[0])\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `index`. Pay attention to place the variable name at the beginning of the line.",
          "testCode": "assert.match(code, /^index\\s*=/m)"
        },
        {
          "text": "You should assign the value returned by `alphabet.find(text[0])` to your `index` variable.",
          "testCode": "assert.match(code, /^index\\s*=\\s*alphabet\\.find\\s*\\(\\s*text\\s*\\[\\s*\\s*0\\s*\\]\\s*\\)\\s*(#.*)?$/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655208d59b131e7816f18c96.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655209a4a27dd37873c4cac3",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "`.find()` returns the index of the matching character inside the string. If the character is not found, it returns `-1`. As you can see, the first character in `text`, uppercase `'H'`, is not found, since `alphabet` contains only lowercase letters.\n\nYou can transform a string into its lowercase equivalent with the `.lower()` method. Add another `print()` call to print `text.lower()` and see the output.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nindex = alphabet.find(text[0])\nprint(index)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should still have `print(index)` in your code. Pay attention to have the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*index\\s*\\)/m)"
        },
        {
          "text": "You should print `text.lower()`. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*text\\.lower\\s*\\(\\s*\\)\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655209a4a27dd37873c4cac3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65520e6f2b9678799977f24d",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "Remove the last `print()` call. Then, instead of `text[0]`, pass `text[0].lower()` as the argument to your `.find()` call and see the output.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nindex = alphabet.find(text[0])\nprint(index)\nprint(text.lower())\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(text.lower())` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.notMatch(commentless_code, /print\\s*\\(\\s*text\\.lower\\s*\\(\\s*\\)\\s*\\)/);"
        },
        {
          "text": "You should still print your `index` variable.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*index\\s*\\)/m);"
        },
        {
          "text": "You should update your `alphabet.find(text[0])` call to use `text[0].lower()` as the argument. Pay attention to place the method call at the beginning of the line.",
          "testCode": "assert.match(code, /^index\\s*=\\s*alphabet\\.find\\s*\\(\\s*text\\s*\\[\\s*\\s*0\\s*\\]\\s*\\.lower\\s*\\(\\s*\\)\\s*\\)\\s*(#.*)?$/m);"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65520e6f2b9678799977f24d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65520f8282faf57a0db4f7fe",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "As you can see from the output, `'h'` is at index `7` in the `alphabet` string. Now you need to find the letter at index `7` plus the value of `shift`. For that, you can use the addition operator, `+`, in the same way you would use it for a mathematical addition.\n\nModify your `shifted` variable so that it stores the value of `alphabet` at index `index + shift`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nindex = alphabet.find(text[0].lower())\nprint(index)\nshifted = alphabet[index]\nprint(shifted)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `alphabet[index + shift]` to your `shifted` variable.",
          "testCode": "assert.match(code, /^shifted\\s*=\\s*alphabet\\s*\\[\\s*(index|shift)\\s*\\+\\s*(?!\\1)(index|shift)\\s*\\]\\s*(#.*)?$/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65520f8282faf57a0db4f7fe.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65521203d7165c7b84b22ad4",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "A loop allows you to systematically go through a sequence of elements and execute actions on each one.\n\nIn this case, you'll employ a `for` loop. Here's how you can iterate over `text`:\n\n```py\nfor i in text:\n```\n\n`for` is the keyword denoting the loop type. `i` is a variable that sequentially takes the value of the elements in `text`. The statement ends with a colon, `:`.\n\nBelow the line where you declared `alphabet`, write a `for` loop to iterate over `text`. Use `i` as the loop variable.\n\nDoing so, there is an error in the terminal. You will learn about it in the next step.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `for` keyword to create a loop. Make sure to place the `for` keyword at the beginning of the line and leave a white space after the keyword.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^for\\s+/m)"
        },
        {
          "text": "You should write the `i` variable after the `for` keyword.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^for\\s+i/m)"
        },
        {
          "text": "You should write the `in` keyword after `for i `. Make sure to leave a space around the `in` keyword.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^for\\s+i\\s+in\\s+/m)"
        },
        {
          "text": "You should write `text` after `for i in `. Don't forget to add the final `:`.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^for\\s+i\\s+in\\s+text\\s*:\\s*$/m)"
        },
        {
          "text": "Your `for` loop should be placed below the line of code `alphabet = 'abcdefghijklmnopqrstuvwxyz'`.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^alphabet\\s*=\\s*(\"|')abcdefghijklmnopqrstuvwxyz\\1\\s*^for\\s+i\\s+in\\s+text\\s*:\\s*$/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65521203d7165c7b84b22ad4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65521fc818947e800bffe48a",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "Inside the `for` loop, before printing the current character, declare a variable called `index` and assign the value returned by `alphabet.find(char)` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n--fcc-editable-region--\nfor char in text:\n    print(char)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a new variable named `index` at the beginning of your `for` loop.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\s*/);\nassert(block_body.match(/^\\s*index\\s*=/));"
        },
        {
          "text": "You should assign `alphabet.find(char)` to your new `index` variable.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\s*/);\nassert(block_body.match(/index\\s*=\\s*alphabet\\.find\\s*\\(\\s*char\\s*\\)\\s*(#.*)?$/m));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65521fc818947e800bffe48a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655220953ba90d80514d7ee2",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "Currently, the `print()` function is taking a single argument `char`, but it can take multiple arguments, separated by a comma.\n\nAdd a second argument to `print(char)` so that it prints the character and its index inside the alphabet.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text:\n    index = alphabet.find(char)\n    print(char)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add `index` as the second argument to your existing `print(char)` call. Don't forget to separate the arguments with a comma.",
          "testCode": "({test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\s*/);\n    assert(block_body.match(/print\\s*\\(\\s*char\\s*,\\s*index\\s*\\)\\s*$/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655220953ba90d80514d7ee2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65522255d5b9cd80f335c6f2",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "At the end of your loop body, declare a variable called `new_index` and assign the value of `index + shift` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    print(char, index)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable called `new_index` inside your `for` loop.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\nassert(block_body.match(/new_index\\s*=/));"
        },
        {
          "text": "You should assign `index + shift` to your new variable at the end of your `for` loop body.",
          "testCode": "({test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_indentation, block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/new_index\\s*=\\s*index\\s*\\+\\s*shift\\s*$/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65522255d5b9cd80f335c6f2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6552487e689f6e895f658717",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "Now you need to create a `new_char` variable at the end of your loop body. Set its value to `alphabet[new_index]`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    print(char, index)\n    new_index = index + shift\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `new_char` variable inside your `for` loop.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\nassert(block_body.match(/new_char\\s*=/));"
        },
        {
          "text": "You should set your `new_char` variable to `alphabet[new_index]` at the end of your loop body.",
          "testCode": "({test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/new_char\\s*=\\s*alphabet\\s*\\[\\s*new_index\\s*\\]\\s*$/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6552487e689f6e895f658717.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65524b3aa6a1938a069a91ab",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "Next, print `new_char` and see the output.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    print(char, index)\n    new_index = index + shift\n    new_char = alphabet[new_index]\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print your `new_char` variable.",
          "testCode": "assert.match(code, /print\\s*\\(\\s*new_char\\s*\\)/)"
        },
        {
          "text": "You should print your `new_char` variable at the end of your loop body.",
          "testCode": "({test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/print\\s*\\(\\s*new_char\\s*\\)\\s*$/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65524b3aa6a1938a069a91ab.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65524b790ba8558a2f1c9fe5",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "Clean the output a bit. Delete `print(char, index)`, and turn the last `print()` call into `print('char:', char, 'new char:', new_char)`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    print(char, index)\n    new_index = index + shift\n    new_char = alphabet[new_index]\n    print(new_char)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(char, index)` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.isFalse(/print\\s*\\(\\s*char\\s*,\\s*index\\s*\\)/.test(commentless_code))"
        },
        {
          "text": "You should change `print(new_char)` into `print('char:', char, 'new char:', new_char)`.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.isFalse(/print\\s*\\(\\s*new_char\\s*\\)/.test(commentless_code));\nconst {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\nassert(block_body.match(/print\\s*\\(\\s*(\"|')char:\\1\\s*,\\s*char\\s*,\\s*(\"|')new\\schar:\\2\\s*,\\s*new_char\\s*\\)\\s*$/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65524b790ba8558a2f1c9fe5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65524d2a1a253b8bb5197ae2",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "`find` is again returning `-1` for uppercase letters, and for the space character, too. You are going to take care of the space later on.\n\nFor now, instead of iterating over `text`, change the `for` loop to iterate over `text.lower()`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text:\n    index = alphabet.find(char)\n    print(char, index)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your `for` loop to iterate over `text.lower()` instead of `text`.",
          "testCode": "({test: () => assert.match(code, /^for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*:/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65524d2a1a253b8bb5197ae2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655251308f31958d06cdf267",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "At the moment, the encrypted character is updated in every iteration. It would be better to store the encrypted string in a new variable. Before your `for` loop, declare a variable called `encrypted_text` and assign an empty string (`''`) to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    new_index = index + shift\n    new_char = alphabet[new_index]\n    print('char:', char, 'new char:', new_char)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable called `encrypted_text` before your `for` loop.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"encrypted_text\")) })"
        },
        {
          "text": "You should assign an empty string to your `encrypted_text` variable.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"encrypted_text\"), \"\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655251308f31958d06cdf267.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65525e359ca28d938baa82c5",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "You can obtain the same effect of `a = a + b` by using the addition assignment operator:\n\n```py\na += b\n```\n\nThe addition assignment operator enables you to add a value to a variable and then assign the result to that variable.\n\nUse the `+=` operator to add a value and assign it at the same time to `encrypted_text`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n--fcc-editable-region--\nfor char in text.lower():\n    index = alphabet.find(char)\n    new_index = index + shift\n    encrypted_text = encrypted_text + alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the addition assignment operator to add `alphabet[new_index]` to the current value of `encrypted_text` inside your loop body.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/encrypted_text\\s*\\+=\\s*alphabet\\s*\\[\\s*new_index\\s*\\]/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65525e359ca28d938baa82c5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655261b2e1f2c197093f3993",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "Currently, spaces get encrypted as `'c'`. To maintain the original spacing in the plain message, you'll require a conditional `if` statement. This is composed of the `if` keyword, a condition, and a colon `:`.\n\n```py\nif x != 0:\n    print(x)\n```\n\nIn the example above, the condition of the `if` statement is `x != 0`. The code `print(x)`, inside the `if` statement body, runs only when the condition evaluates to `True` (in this example, meaning that `x` is different from zero).\n\nAt the top of your for loop, replace `print(char == ' ')` with an `if` statement.  The condition of this `if` statement should evaluate to `True` if `char` is an empty space and `False` otherwise. Inside the `if` body, print the string `'space!'`. Remember to indent this line.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    print(char == ' ')\n    index = alphabet.find(char)\n    new_index = index + shift\n    encrypted_text += alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print(char == ' ')` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\nassert.notMatch(block_body, /print\\s*\\(\\s*char\\s*==\\s*(\"|')\\s\\1\\s*\\)/);"
        },
        {
          "text": "You should replace `print(char == ' ')` with an `if` statement that triggers when `char == ' '`. Do not use parentheses to enclose the `if` condition and remember to include the final colon.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\nassert(block_body.match(/if\\s+char\\s*==\\s*(\"|')\\s\\1\\s*:/));"
        },
        {
          "text": "You should print the string `'space!'` inside your new `if` statement.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /if\\s+char\\s*==\\s*(\"|')\\s\\3\\s*/);    \nassert(block_body.match(/print\\s*\\(\\s*(\"|')space!\\1\\s*\\)/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655261b2e1f2c197093f3993.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553980e0527fa115c705646",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "Now, instead of printing `'space!'`, use the addition assignment operator to add the space (currently stored in `char`) to the current value of `encrypted_text`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    if char == ' ':\n        print('space!')\n    index = alphabet.find(char)\n    new_index = index + shift\n    encrypted_text += alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `print('space!')` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.notMatch(commentless_code, /print\\s*\\(\\s*(\"|')space!\\1\\s*\\)/);"
        },
        {
          "text": "You should use the `+=` operator to add `char` to the current value of `encrypted_text` inside your new `if` statement.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);    \nconst {block_body} = __helpers.python.getBlock(commentless_code, /if\\s+char\\s*==\\s*(\"|')\\s\\3\\s*/);\nassert(block_body.match(/encrypted_text\\s*\\+=\\s*char/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553980e0527fa115c705646.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553995f412dd8122ed38e4a",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "A conditional statement can also have an `else` clause. This clause can be added to the end of an `if` statement to execute alternative code if the condition of the `if` statement is false:\n\n```py\nif x != 0:\n    print(x)\nelse:\n    print('x = 0')\n```\n\nAs you can see in your output, when the loop iterations reach the space, a space is added to the encrypted string. Then the code outside the `if` block executes and a `c` is added to the encrypted string.\n\nTo fix it, add an `else` clause after `encrypted_text += char` and indent all the subsequent lines of code except the `print()` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    if char == ' ':\n        encrypted_text += char\n    index = alphabet.find(char)\n    new_index = index + shift\n    encrypted_text += alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `else` clause. Remember to include the final colon.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\nassert(block_body.match(/else\\s*:/));"
        },
        {
          "text": "You should indent the lines of code after your `else` clause except the `print()` call.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /else/);\nassert(block_body.match(/index\\s*=\\s*alphabet\\.find\\s*\\(\\s*char\\s*\\)\\s*new_index\\s*=\\s*index\\s*\\+\\s*shift\\s*encrypted_text\\s*\\+=\\s*alphabet\\s*\\[\\s*new_index\\s*\\]\\s*$/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553995f412dd8122ed38e4a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553a44b1801991847d8cc69",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "Next, modify your `print()` call to print `'encrypted text:', encrypted_text` and put it outside the `for` loop, so that the encrypted string is printed one time.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    if char == ' ':\n        encrypted_text += char\n    else:\n        index = alphabet.find(char)\n        new_index = (index + shift) % len(alphabet)\n        encrypted_text += alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `'encrypted text:', encrypted_text` after your for loop.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*(\"|')encrypted\\stext:\\1\\s*,\\s*encrypted_text\\s*\\)/m) })"
        },
        {
          "text": "You should not have `print('char:', char, 'encrypted text:', encrypted_text)` in your code.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.notMatch(commentless_code, /print\\s*\\(\\s*(\"|')char:\\1\\s*,\\s*char\\s*,\\s*(\"|')encrypted\\stext:\\2\\s*,\\s*encrypted_text\\s*\\)/)\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553a44b1801991847d8cc69.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553a572f7a65718f1e42e18",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "A function is essentially a reusable block of code. You have already met some built-in functions, like `print()`, `find()` and `len()`. But you can also define custom functions like this:\n\n```py\ndef function_name():\n    <code>\n```\n\nA function declaration starts with the `def` keyword followed by the function name — a valid variable name — and a pair of parentheses. The declaration ends with a colon.\n\nRight after your `shift` variable, declare a function called `caesar` and indent all the following lines to give your new function a body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\n\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    if char == ' ':\n        encrypted_text += char\n    else:\n        index = alphabet.find(char)\n        new_index = (index + shift) % len(alphabet)\n        encrypted_text += alphabet[new_index]\nprint('plain text:', text)\nprint('encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `def` keyword to declare a new function.",
          "testCode": "assert.match(code, /^def\\s+/m)"
        },
        {
          "text": "You should write `caesar` as the function name after the `def` keyword. Remember to add a space after `def`.",
          "testCode": "assert.match(code, /^def\\s+caesar/m)"
        },
        {
          "text": "You should add a pair of parentheses after the function name. Don't forget the final colon.",
          "testCode": "assert.match(code, /^def\\s+caesar\\s*\\(\\s*\\)\\s*:/m)"
        },
        {
          "text": "You should indent all the lines after `shift = 3` so that they become your new function body.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {def} = __helpers.python.getDef(commentless_code, \"caesar\");    \n    const replacement = def.replace(/print\\s*\\(\\s*(\"|')plain\\stext:\\1\\s*,\\s*text\\s*\\)\\s*print\\s*\\(\\s*(\"|')encrypted\\stext:\\2\\s*,\\s*encrypted_text\\s*\\)/, \"return encrypted_text\")\n    const py_code = `\ntext = \"Hello Zaira\"\nshift = 3\n${replacement}\ncaesar()\n`\n    const out = runPython(py_code, {});\n    assert.equal(out, \"khoor cdlud\");\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553a572f7a65718f1e42e18.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553a755879b131a445e664c",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "Try to assign the string `'Hello Zaira'` to your `text` variable and see what happens in the terminal.\n\nYou'll see a `string index out of range` exception. Don't worry, you'll figure out how to fix it soon!",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    if char == ' ':\n        encrypted_text += char\n    else:\n        index = alphabet.find(char)\n        new_index = index + shift\n        encrypted_text += alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `text` variable.",
          "testCode": "assert.match(code, /^text\\s*=/m)"
        },
        {
          "text": "You should assign the string `'Hello Zaira'` to your `text` variable.",
          "testCode": "assert.match(code, /^text\\s*=\\s*(\"|')Hello\\sZaira\\1/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553a755879b131a445e664c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553a7d8d05cbb1ae335a665",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "When the loop reaches the letter `Z`, the sum `index + shift` exceeds the last index of the string `alphabet`. Therefore, `alphabet[new_index]` is trying to use an invalid index, which causes an `IndexError` to be thrown.\n\nYou can notice that the output in the terminal stops at the space immediately before the `Z`, the last `print` before the error is thrown.\n\nIn this case, the modulo operator (`%`) can be used to return the remainder of the division between two numbers. For example: `5 % 2` is equal to `1`, because 5 divided by 2 has a quotient of 2 and a remainder of 1.\n\nSurround `index + shift` with parentheses, and modulo the expression with `26`, which is the `alphabet` length.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    if char == ' ':\n        encrypted_text += char\n    else:\n        index = alphabet.find(char)\n        new_index = index + shift\n        encrypted_text += alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `new_index = (index + shift) % 26` in your `else` statement.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);  \nconst {block_body} = __helpers.python.getBlock(commentless_code, /else/);\nassert(block_body.match(/new_index\\s*=\\s*\\(\\s*index\\s*\\+\\s*shift\\s*\\)\\s*%\\s*26/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553a7d8d05cbb1ae335a665.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553ed69ece88d29594748aa",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "To execute, a function needs to be called (or invoked) by appending a pair of parentheses after its name, like this:\n\n```py\nfunction_name()\n```\n\nAt the end of your code, call your `caesar` function. Pay attention to the indentation.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\nshift = 3\n\ndef caesar():\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in text.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + shift) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', text)\n    print('encrypted text:', encrypted_text)\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call your `caesar` function. Make sure to write the function call at the beginning of the line.",
          "testCode": "({ test: () => assert.match(code, /^caesar\\s*\\(\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553ed69ece88d29594748aa.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553efd6ada3f42aa2d75448",
      "title": "Step 53",
      "challengeType": 20,
      "dashedName": "step-53",
      "description": "Now you should see the output again. Although this approach works, it doesn't significantly enhance the code's reusability. Repeatedly calling your function will result in the same outcome. However, functions can be declared with *parameters* to introduce versatility and customization:\n\n```py\ndef function_name(param_1, param_2):\n    <code>\n```\n\nParameters are variables that you can use inside your function. A function can be declared with different number of parameters. In the example above, `param_1` and `param_2` are parameters.\n\nModify your function declaration so that it takes two parameters called `message` and `offset`.\n\nAfter that, you'll see an error appear in the terminal. You'll see how to solve it in the next steps.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\nshift = 3\n--fcc-editable-region--\ndef caesar():\n--fcc-editable-region--\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in text.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + shift) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', text)\n    print('encrypted text:', encrypted_text)\n\ncaesar()"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `caesar` function should take `message` and `offset` as the parameters. Remember to separate the parameters with a comma.",
          "testCode": "assert.match(code, /^def\\s+caesar\\s*\\(\\s*message\\s*,\\s*offset\\s*\\)\\s*:/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553efd6ada3f42aa2d75448.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553f3fc92741c2bf8ded140",
      "title": "Step 54",
      "challengeType": 20,
      "dashedName": "step-54",
      "description": "Inside your function body, rename the `text` and `shift` variables to `message` and `offset`, respectively.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\nshift = 3\n--fcc-editable-region--\ndef caesar(message, offset):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in text.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + shift) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', text)\n    print('encrypted text:', encrypted_text)\n\ncaesar()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should rename all occurrences of `text` to `message`.",
          "testCode": "assert.match(code, /for\\s+char\\s+in\\s+message\\.lower\\s*\\(\\s*\\)\\s*:/);\nassert.match(code, /print\\s*\\(\\s*(\"|')(plain text|(plain )?message):\\1\\s*,\\s*message\\s*\\)/);"
        },
        {
          "text": "You should rename `shift` to `offset`.",
          "testCode": "assert.match(code, /new_index\\s*=\\s*\\(\\s*index\\s*\\+\\s*offset\\s*\\)\\s*%\\s*len\\s*\\(\\s*alphabet\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553f3fc92741c2bf8ded140.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553f4f66099802c6ae94613",
      "title": "Step 55",
      "challengeType": 20,
      "dashedName": "step-55",
      "description": "Currently, your code raises a `TypeError`, because the `caesar` function is defined with two parameters (`message` and `offset`), therefore it expects to be called with two *arguments*.\n\nCalling `caesar()` without the required arguments stops the execution of the code.\n\nGive `message` and `offset` values, by passing `text` and `shift` as arguments to the `caesar` function call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\nshift = 3\n\ndef caesar(message, offset):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)\n--fcc-editable-region--\ncaesar()\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should pass `text` and `shift` as the arguments to your function call by including them inside the parentheses. Don't forget to separate the arguments with a comma.",
          "testCode": "({\n    test: () => assert(runPython(\n        `_Node(_code).find_calls('caesar')[0].is_equivalent('caesar(text, shift)')`\n    ))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553f4f66099802c6ae94613.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553f6086add4b2cbb99fd78",
      "title": "Step 56",
      "challengeType": 20,
      "dashedName": "step-56",
      "description": "At the bottom of your code, after your existing `caesar(text, shift)` call, call your function again.\n\nThis time, pass the `text` variable and the integer `13` as arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\n\ndef caesar(message, offset):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)\n\ncaesar(text, shift)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call your function again, this time passing `text` and `13` as arguments.",
          "testCode": "({ test: () => assert.match(code, /^caesar\\s*\\(\\s*text\\s*,\\s*13\\s*\\)/m) })"
        },
        {
          "text": "You should keep the existing function call.",
          "testCode": "({ test: () => assert.match(code, /^caesar\\s*\\(\\s*text\\s*,\\s*shift\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553f6086add4b2cbb99fd78.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553f6b4ec51112d44d737c8",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "Right before the `print` call, add another one and pass `'plain text:', text` as the arguments to `print()`. Use the same indentation.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    if char == ' ':\n        encrypted_text += char\n    else:\n        index = alphabet.find(char)\n        new_index = (index + shift) % len(alphabet)\n        encrypted_text += alphabet[new_index]\nprint('encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print `'plain text:', text` after your for loop.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*(\"|')plain\\stext:\\1\\s*,\\s*text\\s*\\)\\s*^print/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553f6b4ec51112d44d737c8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6553f8c570f9982e013a8886",
      "title": "Step 57",
      "challengeType": 20,
      "dashedName": "step-57",
      "description": "Currently, every single letter is always encrypted with the same letter, depending on the specified offset. What if the offset were different for each letter? That would be much more difficult to decrypt. This algorithm is referred to as the Vigenère cipher, where the offset for each letter is determined by another text, called the *key*.\n\nStart transforming your Caesar cipher into a Vigenère cipher by removing the two function calls.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\n\ndef caesar(message, offset):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)\n\ncaesar(text, shift)\ncaesar(text, 13)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove your two `caesar()` function calls.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.isFalse(/^caesar\\s*\\(\\s*text\\s*,\\s*shift\\s*\\)/m.test(commentless_code))\n    assert.isFalse(/^caesar\\s*\\(\\s*text\\s*,\\s*13\\s*\\)/m.test(commentless_code))\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6553f8c570f9982e013a8886.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655491bd5b98b813fa5bedca",
      "title": "Step 58",
      "challengeType": 20,
      "dashedName": "step-58",
      "description": "Now modify your function declaration: change the function name into `vigenere` and the second parameter into `key`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\n\ndef caesar(message, offset):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your function name into `vigenere`.",
          "testCode": "assert.match(code, /^def\\s+vigenere\\s*\\(.*\\)\\s*:/m)"
        },
        {
          "text": "Your `vigenere` function should take `message` and `key` as the parameters.",
          "testCode": "assert.match(code, /^def\\s+vigenere\\s*\\(\\s*message\\s*,\\s*key\\s*\\)\\s*:/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655491bd5b98b813fa5bedca.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554930320d70414e7b6acc6",
      "title": "Step 59",
      "challengeType": 20,
      "dashedName": "step-59",
      "description": "Delete your `shift` variable. Then, declare a new variable called `custom_key` and assign the value of the string `'python'` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\n--fcc-editable-region--\ndef vigenere(message, key):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete the `shift` variable and its value.",
          "testCode": "({ test: () => assert.isFalse(__userGlobals.has(\"shift\")) })"
        },
        {
          "text": "You should declare a variable called `custom_key`.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"custom_key\")) })"
        },
        {
          "text": "You should assign the string `'python'` to your `custom_key` variable.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"custom_key\"), \"python\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554930320d70414e7b6acc6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65549561463f0016876e852c",
      "title": "Step 60",
      "challengeType": 20,
      "dashedName": "step-60",
      "description": "Since your key is shorter than the text that you will have to encrypt, you will need to repeat it to generate the whole encrypted text.\nAt the beginning of your function body, declare a `key_index` variable and set it to zero.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable called `key_index` at the beginning of your function body.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {function_body} = __helpers.python.getDef(commentless_code, \"vigenere\");\nassert(function_body.match(/^\\s*key_index\\s*=/));"
        },
        {
          "text": "You should assign `0` to your `key_index` variable.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {function_body} = __helpers.python.getDef(commentless_code, \"vigenere\");   \nassert(function_body.match(/key_index\\s*=\\s*0/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65549561463f0016876e852c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65549f90cf78131c96ebcf28",
      "title": "Step 61",
      "challengeType": 20,
      "dashedName": "step-61",
      "description": "When coding, readability is key. Comments serve as effective notes, explaining the logic behind your code. They prove valuable when returning to a project after some time and also aid your colleagues in understanding the code.\n\nIn Python, you can write a comment using a `#`. Anything that comes after the `#` won't be executed.\n\nBefore your `if` statement, add a comment saying `Append space to the message`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n--fcc-editable-region--\n        \n        if char == ' ':\n            encrypted_text += char\n--fcc-editable-region--            \n        else:\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add a comment saying `Append space to the message`. Don't forget the `#` character at the beginning.",
          "testCode": "({ test: () => assert.match(code, /#\\s*Append\\sspace\\sto\\sthe\\smessage/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65549f90cf78131c96ebcf28.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554a334a40edb1fb4eff827",
      "title": "Step 62",
      "challengeType": 20,
      "dashedName": "step-62",
      "description": "Next, inside the `else` block, declare a variable called `key_char` and assign it the value of `key` at the index `key_index` mod(`%`) the length of `key`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n--fcc-editable-region--        \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:\n--fcc-editable-region--        \n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable called `key_char` at the beginning of your `else` clause body.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, \"else\");\nassert(block_body.match(/^\\s*key_char\\s*=/));"
        },
        {
          "text": "You should assign `key[key_index % len(key)]` to your `key_char` variable.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, \"else\");    \nassert(block_body.match(/key_char\\s*=\\s*key\\s*\\[\\s*key_index\\s*%\\s*len\\s*\\(\\s*key\\s*\\)\\s*\\]/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554a334a40edb1fb4eff827.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554a49a4f782f208abcc87e",
      "title": "Step 63",
      "challengeType": 20,
      "dashedName": "step-63",
      "description": "You will need to increase the `key_index` count for the next iteration.\nTo do this, after the line you just added and in the same code block, use the addition assignment operator to increment `key_index` by one.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n--fcc-editable-region--\n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:\n            key_char = key[key_index % len(key)]\n--fcc-editable-region--\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `+=` operator to add `1` to `key_index` inside the `else` clause body.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, \"else\");\nassert(block_body.match(/key_char\\s*=\\s*key\\s*\\[\\s*key_index\\s*%\\s*len\\s*\\(\\s*key\\s*\\)\\s*\\]\\s*key_index\\s*\\+=\\s*1/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554a49a4f782f208abcc87e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554a57ec0a2c52106e7ee50",
      "title": "Step 64",
      "challengeType": 20,
      "dashedName": "step-64",
      "description": "Inside the `else` clause, write a comment saying `Find the right key character to encode`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n--fcc-editable-region--\n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:\n            \n            key_char = key[key_index % len(key)]\n            key_index += 1\n--fcc-editable-region--\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a comment saying `Find the right key character to encode`. Don't forget  the `#` at the beginning.",
          "testCode": "({ test: () => assert.match(code, /#\\s*Find\\sthe\\sright\\skey\\scharacter\\sto\\sencode/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554a57ec0a2c52106e7ee50.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554a88d5af937226f4a9121",
      "title": "Step 65",
      "challengeType": 20,
      "dashedName": "step-65",
      "description": "The `.index()` method is identical to the `.find()` method but it throws a `ValueError` exception if it is unable to find the substring.\n\nA `ValueError` is a built-in exception that is raised when an argument with the right type but inappropriate value is passed to a function.\n\nAfter incrementing `key_index`, declare a variable named `offset`. Find the index that `key_char` has in `alphabet` and assign it to `offset`. Use the `.index()` to find the index.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n--fcc-editable-region--\n        else:\n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n            \n--fcc-editable-region--            \n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable called `offset`.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /else/);\nassert(block_body.match(/offset\\s*=/));"
        },
        {
          "text": "Your `offset` variable should store the value of `alphabet.index(key_char)`.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nconst {block_body} = __helpers.python.getBlock(commentless_code, /else/);\nassert(block_body.match(/offset\\s*=\\s*alphabet\\.index\\s*\\(\\s*key_char\\s*\\)/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554a88d5af937226f4a9121.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554ac937a49be2701af4f2f",
      "title": "Step 66",
      "challengeType": 20,
      "dashedName": "step-66",
      "description": "Above the `offset` variable, create another comment saying `Define the offset and the encrypted letter`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:\n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n--fcc-editable-region--\n            \n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a comment saying `Define the offset and the encrypted letter`. Don't forget the `#` at the beginning.",
          "testCode": "({ test: () => assert.match(code, /#\\s*Define\\sthe\\soffset\\sand\\sthe\\sencrypted\\sletter/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554ac937a49be2701af4f2f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554ad2463b8892748f8efdd",
      "title": "Step 67",
      "challengeType": 20,
      "dashedName": "step-67",
      "description": "At the moment, your function prints some strings, but these values cannot be used by other parts of code to perform any actions.\n\nFor that purpose, you need to use a `return` statement:\n\n```python\ndef foo():\n    return 'spam'\n```\n\nYou need to write `return` followed by a space and the value that the function should return. Once the `return` statement is found, that value is returned and the execution of the function stops, proceeding to the next line of code after the function call. In the example above, the `foo` function returns the string `'spam'`.\n\nRemove the two `print()` calls from your function and return `encrypted_text`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n--fcc-editable-region--\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', message)\n    print('encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the two `print()` calls from your function.",
          "testCode": "({ \n  test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.isFalse(/print\\s*\\(\\s*(\"|')plain\\stext:\\1\\s*,\\s*message\\s*\\)/.test(commentless_code))\n    assert.isFalse(/print\\s*\\(\\s*(\"|')encrypted\\stext:\\1\\s*,\\s*encrypted_text\\s*\\)/.test(commentless_code))\n  }\n})"
        },
        {
          "text": "Your function should return `encrypted_text`.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {function_body} = __helpers.python.getDef(commentless_code, \"vigenere\");\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+message\\.lower\\s*\\(\\s*\\)\\s*/);\n    const regex = /return\\s+encrypted_text/\n    assert(function_body.match(regex));\n    assert.notMatch(block_body, regex);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554ad2463b8892748f8efdd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554d0332949b133a0b35eaa",
      "title": "Step 68",
      "challengeType": 20,
      "dashedName": "step-68",
      "description": "Call your function passing `text` and `custom_key` as the arguments. Store the return value of the function call in a variable called `encryption`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    \n    return encrypted_text\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `vigenere` passing `text` and `custom_key` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /vigenere\\s*\\(\\s*text\\s*,\\s*custom_key\\s*\\)/) })"
        },
        {
          "text": "You should have an `encryption` variable.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"encryption\")) })"
        },
        {
          "text": "You should assign your function call to the `encryption` variable.",
          "testCode": "({ test: () => assert.match(code, /encryption\\s*=\\s*vigenere\\s*\\(\\s*text\\s*,\\s*custom_key\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554d0332949b133a0b35eaa.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554d15c8acb5f34499ad789",
      "title": "Step 69",
      "challengeType": 20,
      "dashedName": "step-69",
      "description": "And now, try to print `encryption` to see the actual output on the terminal.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    \n    return encrypted_text\n\n--fcc-editable-region--\nencryption = vigenere(text, custom_key)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print your `encryption` variable.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*encryption\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554d15c8acb5f34499ad789.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554d25dc5ceaa354307a77e",
      "title": "Step 70",
      "challengeType": 20,
      "dashedName": "step-70",
      "description": "Encryption and decryption are opposite processes and your function can do both with a couple of tweaks.\n\nAdd a third parameter called `direction` to your function definition. Also, comment out the last two lines of code to avoid errors in the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    \n    return encrypted_text\n    \nencryption = vigenere(text, custom_key)\nprint(encryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn the last two lines in your code into comments. Put a `#` at the beginning of each line.",
          "testCode": "({ test: () => assert.match(code, /#\\s*encryption\\s*=\\s*vigenere\\s*\\(\\s*text\\s*,\\s*custom_key\\s*\\)\\s*#\\s*print\\s*\\(\\s*encryption\\s*\\)/) })"
        },
        {
          "text": "You should add `direction` as the third parameter of your function.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect    \n    sig = str(inspect.signature(vigenere))\n    sig == '(message, key, direction)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554d25dc5ceaa354307a77e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554de295ade563a069936a1",
      "title": "Step 71",
      "challengeType": 20,
      "dashedName": "step-71",
      "description": "All you need to do is multiply the `offset` by the `direction` in the `new_index` assignment. The multiplication operator in Python is `*`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n--fcc-editable-region--\n            new_index = (index + offset) % len(alphabet)\n--fcc-editable-region--\n            encrypted_text += alphabet[new_index]\n    \n    return encrypted_text\n    \n#encryption = vigenere(text, custom_key)\n#print(encryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should multiply `offset` by `direction` in the `new_index` assignment. Do not add other parentheses.",
          "testCode": "({ test: () => assert.match(code, /new_index\\s*=\\s*\\(\\s*index\\s*\\+\\s*offset\\s*\\*\\s*direction\\s*\\)\\s*%\\s*len\\s*\\(\\s*alphabet\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554de295ade563a069936a1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554dfce1683be3c0c9609a6",
      "title": "Step 72",
      "challengeType": 20,
      "dashedName": "step-72",
      "description": "Now you can uncomment the last two lines and modify your function call passing `1` as the third argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    \n    return encrypted_text\n    \n--fcc-editable-region--\n#encryption = vigenere(text, custom_key)\n#print(encryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should restore the last two lines of your code and pass `1` as the third argument to your function call.",
          "testCode": "({ test: () => assert.match(code, /^encryption\\s*=\\s*vigenere\\s*\\(\\s*text\\s*,\\s*custom_key\\s*,\\s*1\\s*\\)\\s*print\\s*\\(\\s*encryption\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554dfce1683be3c0c9609a6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554e0adc7bb193cbfdb36d5",
      "title": "Step 73",
      "challengeType": 20,
      "dashedName": "step-73",
      "description": "Check if the function can decrypt the string back to the plain text.\n\nDeclare another variable called `decryption` and assign it `vigenere(encryption, custom_key, -1)`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    \n    return encrypted_text\n--fcc-editable-region--    \nencryption = vigenere(text, custom_key, 1)\nprint(encryption)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `vigenere` passing `encryption`, `custom_key` and `-1` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /vigenere\\s*\\(\\s*encryption\\s*,\\s*custom_key\\s*,\\s*-\\s*1\\s*\\)/) })"
        },
        {
          "text": "You should declare a `decryption` variable.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"decryption\")) })"
        },
        {
          "text": "Your `decryption` variable should have the value of `vigenere(encryption, custom_key, -1)`.",
          "testCode": "({ test: () => assert.match(code, /^decryption\\s*=\\s*vigenere\\s*\\(\\s*encryption\\s*,\\s*custom_key\\s*,\\s*-\\s*1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554e0adc7bb193cbfdb36d5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554e2ee23bfd93f2c83640f",
      "title": "Step 74",
      "challengeType": 20,
      "dashedName": "step-74",
      "description": "Now print your `decryption` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    \n    return encrypted_text\n--fcc-editable-region--    \nencryption = vigenere(text, custom_key, 1)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print your new `decryption` variable.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*decryption\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554e2ee23bfd93f2c83640f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6554e343caea913ffba7bec6",
      "title": "Step 75",
      "challengeType": 20,
      "dashedName": "step-75",
      "description": "Now, your function can be used both to encrypt and decrypt a message. Clean up your code with better variable names.\n\nChange each occurrence of `encrypted_text` into `final_message`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n--fcc-editable-region--\ndef vigenere(message, key, direction):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            encrypted_text += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    \n    return encrypted_text\n--fcc-editable-region--    \nencryption = vigenere(text, custom_key, 1)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should change each occurrence of `encrypted_text` into `final_message`.",
          "testCode": "({\n  test: () => {\n    const l = code.match(/final_message/g).length\n    assert.equal(l, 4)\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6554e343caea913ffba7bec6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655516e410b8e30fb4fb64e8",
      "title": "Step 76",
      "challengeType": 20,
      "dashedName": "step-76",
      "description": "Update your comments too. Your second comment should say `encode/decode` in place of `encode`. Your third comment should say `encrypted/decrypted` in place of `encrypted`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            final_message += char\n        else:        \n            # Find the right key character to encode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n    \nencryption = vigenere(text, custom_key, 1)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your second comment should be `Find the right key character to encode/decode`.",
          "testCode": "({ test: () => assert.match(code, /#\\s*Find\\sthe\\sright\\skey\\scharacter\\sto\\sencode\\/decode/) })"
        },
        {
          "text": "Your third comment should be `Define the offset and the encrypted/decrypted letter`.",
          "testCode": "({ test: () => assert.match(code, /#\\s*Define\\sthe\\soffset\\sand\\sthe\\sencrypted\\/decrypted\\sletter/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655516e410b8e30fb4fb64e8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65551a628bcb7e121e32d04b",
      "title": "Step 79",
      "challengeType": 20,
      "dashedName": "step-79",
      "description": "Right now, punctuation, special characters or digits are not encoded/decoded correctly.\n\nCheck this by adding an exclamation mark at the end of the `text` string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\ncustom_key = 'python'\n--fcc-editable-region--\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n    \nencryption = vigenere(text, custom_key)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `text` variable.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"text\")) })"
        },
        {
          "text": "Your `text` variable should be equal to the string `'Hello Zaira!'`.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"text\"), \"Hello Zaira!\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65551a628bcb7e121e32d04b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555201d9b7fc917399f9f0b",
      "title": "Step 80",
      "challengeType": 20,
      "dashedName": "step-80",
      "description": "The `.isalpha()` method returns `True` if all of the characters of the string on which it is called are letters. For example, the code below returns `True`:\n\n```py\n'freeCodeCamp'.isalpha()\n# True\n```\n\nDelete the condition `char == ' '` and replace it by calling the `.isalpha()` method on `char`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira!'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n--fcc-editable-region--    \n        # Append space to the message\n        if char == ' ':\n            final_message += char\n--fcc-editable-region--\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n    \nencryption = vigenere(text, custom_key)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `if char.isalpha():` in your code.",
          "testCode": "({ test: () => assert.match(code, /if\\s+char\\.isalpha\\s*\\(\\s*\\)\\s*:/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555201d9b7fc917399f9f0b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655520c20cb1e6177b0641d6",
      "title": "Step 81",
      "challengeType": 20,
      "dashedName": "step-81",
      "description": "The `not` operator is used to negate an expression. When placed before a truthy value — a value that evaluates to `True` — it returns `False` and vice versa.\n\nAdd the `not` operator at the beginning of the `if` condition to check if the character is not alphabetic.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira!'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n--fcc-editable-region--\n        # Append space to the message\n        if char.isalpha():\n            final_message += char\n--fcc-editable-region--\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n    \nencryption = vigenere(text, custom_key)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `not` operator in the condition of your `if` statement.",
          "testCode": "({ test: () => assert.match(code, /if\\s+not\\s+char\\.isalpha\\s*\\(\\s*\\)\\s*:/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655520c20cb1e6177b0641d6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655522883e66f618e03a9411",
      "title": "Step 82",
      "challengeType": 20,
      "dashedName": "step-82",
      "description": "Modify your comment into `Append any non-letter character to the message`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira!'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n--fcc-editable-region--\n        # Append space to the message\n        if not char.isalpha():\n            final_message += char\n--fcc-editable-region--\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n    \nencryption = vigenere(text, custom_key)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should turn your first comment into `Append any non-letter character to the message`.",
          "testCode": "({ test: () => assert.match(code, /#\\s*Append\\sany\\snon-letter\\scharacter\\sto\\sthe\\smessage/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655522883e66f618e03a9411.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555231eac4d9f19bd3d44b5",
      "title": "Step 83",
      "challengeType": 20,
      "dashedName": "step-83",
      "description": "The `pass` keyword can be used as a placeholder for future code. It does not have any effect in your code but it can save you from errors you would get in case of incomplete code:\n\n```py\ndef foo():\n    pass\n```\n\nCalling `vigenere` with `1` to encrypt and `-1` to decrypt is fine but it might be a little bit cryptic. Create a new function called `encrypt` that takes `message` and `key` parameters, and use `pass` to fill the function body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira!'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n--fcc-editable-region--\n\nencryption = vigenere(text, custom_key)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a new function called `encrypt`. Remember to use the `pass` keyword inside the body.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    inspect.isfunction(encrypt)\n  `))\n})"
        },
        {
          "text": "Your `encrypt` function should take `message` and `key` as the parameters. The order matters.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    sig = inspect.signature(encrypt)\n    str(sig) == \"(message, key)\"\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555231eac4d9f19bd3d44b5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65552a111190e11f0963949e",
      "title": "Step 84",
      "challengeType": 20,
      "dashedName": "step-84",
      "description": "Delete the `pass` keyword, and return `vigenere(message, key)` from your new function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira!'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n--fcc-editable-region--\ndef encrypt(message, key):\n    pass\n\nencryption = vigenere(text, custom_key)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `encrypt` function should return `vigenere(message, key)`. Remember to delete `pass`.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {function_body} = __helpers.python.getDef(commentless_code, \"encrypt\");\n    assert(function_body.match(/return\\s+vigenere\\s*\\(\\s*message\\s*,\\s*key\\s*\\)/));\n    assert.notMatch(function_body, /pass/);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65552a111190e11f0963949e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65552a9593755e1fb2f5ab50",
      "title": "Step 85",
      "challengeType": 20,
      "dashedName": "step-85",
      "description": "Define another function named `decrypt` with the same parameters as `encrypt`. This time return `vigenere(message, key, -1)`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira!'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n--fcc-editable-region--\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \nencryption = vigenere(text, custom_key)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a new function called `decrypt`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    inspect.isfunction(decrypt)\n  `))\n})"
        },
        {
          "text": "Your `decrypt` function should take `message` and `key` as the parameters.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    sig = inspect.signature(decrypt)\n    str(sig) == \"(message, key)\"\n  `))\n})"
        },
        {
          "text": "Your `decrypt` function should return `vigenere(message, key, -1)`.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {function_body} = __helpers.python.getDef(commentless_code, \"decrypt\");\n    assert(function_body.match(/return\\s+vigenere\\s*\\(\\s*message\\s*,\\s*key\\s*,\\s*-\\s*1\\s*\\)/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65552a9593755e1fb2f5ab50.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65552b14e803731fe3c1e4ca",
      "title": "Step 86",
      "challengeType": 20,
      "dashedName": "step-86",
      "description": "Next, modify your `encryption` and `decryption` variables by calling `encrypt` and `decrypt`, respectively, in place of `vigenere`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira!'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n--fcc-editable-region--\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n    \nencryption = vigenere(text, custom_key)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `encryption` variable should have the value of `encrypt(text, custom_key)`.",
          "testCode": "({ test: () => assert.match(code, /^encryption\\s*=\\s*encrypt\\s*\\(\\s*text\\s*,\\s*custom_key\\s*\\)/m) })"
        },
        {
          "text": "Your `decryption` variable should have the value of `decrypt(encryption, custom_key)`.",
          "testCode": "({ test: () => assert.match(code, /^decryption\\s*=\\s*decrypt\\s*\\(\\s*encryption\\s*,\\s*custom_key\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65552b14e803731fe3c1e4ca.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65553159615a8123b190ee43",
      "title": "Step 87",
      "challengeType": 20,
      "dashedName": "step-87",
      "description": "It works! Now, you are going to start with an encrypted message to be decrypted.\n\nChange the value of `text` to the string `'mrttaqrhknsw ih puggrur'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira!'\ncustom_key = 'python'\n--fcc-editable-region--\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n    \nencryption = encrypt(text, custom_key)\nprint(encryption)\ndecryption = decrypt(encryption, custom_key)\nprint(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should still have a `text` variable.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"text\")) })"
        },
        {
          "text": "Your `text` variable should have the value of `'mrttaqrhknsw ih puggrur'`.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"text\"), \"mrttaqrhknsw ih puggrur\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65553159615a8123b190ee43.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555d6e12c95701172b55709",
      "title": "Step 77",
      "challengeType": 20,
      "dashedName": "step-77",
      "description": "Functions can be called with default arguments. A default argument indicates the value that the function should take if the argument is not passed. For example, the function below accepts three arguments but you can call it passing two arguments. The third one will assume the specified value by default:\n\n```py\ndef foo(a, b, c=value):\n    <code>\n```\n\nModify the `vigenere` function so that its `direction` parameter has a default value of `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\n--fcc-editable-region--\ndef vigenere(message, key, direction):\n--fcc-editable-region--\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n    \nencryption = vigenere(text, custom_key, 1)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `direction` parameter of your `vigenere` function should have a default value of `1`.",
          "testCode": "({ test: () => assert(runPython(`\n    import inspect\n    sig = str(inspect.signature(vigenere))\n    sig == '(message, key, direction=1)'\n  `))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555d6e12c95701172b55709.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555d8b0b3d20b128bdadd37",
      "title": "Step 78",
      "challengeType": 20,
      "dashedName": "step-78",
      "description": "Now you can remove the third argument from your first function call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n    \n        # Append space to the message\n        if char == ' ':\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n--fcc-editable-region--    \nencryption = vigenere(text, custom_key, 1)\nprint(encryption)\ndecryption = vigenere(encryption, custom_key, -1)\nprint(decryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the third argument from `vigenere(text, custom_key, 1)`.",
          "testCode": "({ test: () => assert.match(code, /vigenere\\s*\\(\\s*text\\s*,\\s*custom_key\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555d8b0b3d20b128bdadd37.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555db4a7b788e15795674e5",
      "title": "Step 89",
      "challengeType": 20,
      "dashedName": "step-89",
      "description": "Two or more strings can be concatenated by using the `+` operator. For example: `'Hello' + ' there!'` results in `'Hello there!'`.\n\nCall the `print()` function and use the `+` operator to concatenate the `text` variable to the string `'Encrypted text: '`. Pay attention to the spacing.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n--fcc-editable-region--    \n\n--fcc-editable-region--\n#decryption = decrypt(encryption, custom_key)\n#print(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `print()` and pass `'Encrypted text: ' + text` as the arguments.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^print\\s*\\(\\s*(\"|')Encrypted\\stext:\\s\\1\\s*\\+\\s*text\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555db4a7b788e15795674e5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555df0c81300b175308557d",
      "title": "Step 90",
      "challengeType": 20,
      "dashedName": "step-90",
      "description": "Below the `print()` call you just added, add another `print()` call to print `Key: python` by concatenating the string `'Key: '` and the value of the `custom_key` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n--fcc-editable-region--\nprint('Encrypted text: ' + text)\n\n--fcc-editable-region--\n#decryption = decrypt(encryption, custom_key)\n#print(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `print()` call that prints `Key: python` by concatenating the string `'Key: '` and the value of the `custom_key` variable.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^print\\s*\\(\\s*(\"|')Key:\\s\\1\\s*\\+\\s*custom_key\\s*\\)/m);"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555df0c81300b175308557d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555e1bfcd374e18c6be8e58",
      "title": "Step 91",
      "challengeType": 20,
      "dashedName": "step-91",
      "description": "In Python, there's a way to easily format strings. *f-strings* enable you to interpolate values in your strings. \n\nInterpolation means writing placeholders that will be replaced by the specified values when the program runs. For example, you can get the same result of `'Encrypted text: ' + text` with `f'Encrypted text: {text}'`. You need to put an `f` before the quotes to create the f-string and write the variables or expressions you want to interpolate between curly braces.\n\nModify the first `print()` call to use an f-string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n--fcc-editable-region--\nprint('Encrypted text: ' + text)\nprint('Key: ' + custom_key)\n--fcc-editable-region--\n#decryption = decrypt(encryption, custom_key)\n#print(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the `print('Encrypted text: ' + text)` call so that it prints the same result using an f-string.",
          "testCode": "({ test: () => assert.match(code, /print\\s*\\(\\s*f(\"|')Encrypted\\stext:\\s\\{\\s*text\\s*\\}\\1\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555e1bfcd374e18c6be8e58.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555e3f387381a19d5e00333",
      "title": "Step 92",
      "challengeType": 20,
      "dashedName": "step-92",
      "description": "Next, modify `print('Key: ' + custom_key)` to use an f-string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n--fcc-editable-region--\nprint(f'Encrypted text: {text}')\nprint('Key: ' + custom_key)\n--fcc-editable-region--\n#decryption = decrypt(encryption, custom_key)\n#print(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the `print('Key: ' + custom_key)` call so that it prints the same result using an f-string.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*f(\"|')Key:\\s\\{\\s*custom_key\\s*\\}\\1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555e3f387381a19d5e00333.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555e43e783ed31a0532b1b2",
      "title": "Step 93",
      "challengeType": 20,
      "dashedName": "step-93",
      "description": "The newline character `\\n` is a special sequence used to represent a new line. You can write a backslash `\\` followed by an `n` as a normal sequence of characters in a string and it will be replaced by a new line in the output when the program runs.\n\nPut a newline character at the beginning of your first `print` call and see the output.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n--fcc-editable-region--\nprint(f'Encrypted text: {text}')\nprint(f'Key: {custom_key}')\n--fcc-editable-region--\n#decryption = decrypt(encryption, custom_key)\n#print(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your first print call into `print(f'\\nEncrypted text: {text}')`.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*f(\"|')\\\\nEncrypted\\stext:\\s\\{\\s*text\\s*\\}\\1\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555e43e783ed31a0532b1b2.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555e547c18a2b1a7b795bd8",
      "title": "Step 95",
      "challengeType": 20,
      "dashedName": "step-95",
      "description": "Uncomment your last `print()` call and change it to use the f-string `f'\\nDecrypted text: {decryption}\\n'` as the argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n--fcc-editable-region--\nprint(f'\\nEncrypted text: {text}')\nprint(f'Key: {custom_key}')\ndecryption = decrypt(text, custom_key)\n#print(decryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should uncomment your last `print()` call and change it to use `f'\\nDecrypted text: {decryption}\\n'` as the argument.",
          "testCode": "({\n  test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.match(commentless_code, /^print\\s*\\(\\s*f(\"|')\\\\nDecrypted\\stext:\\s\\{\\s*decryption\\s*\\}\\\\n\\1\\s*\\)/m)\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555e547c18a2b1a7b795bd8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6555e5991af57d1ae0e35f0a",
      "title": "Step 96",
      "challengeType": 20,
      "dashedName": "step-96",
      "description": "Wait a minute! You cannot decrypt anything with the wrong key. Try with `'happycoding'`.\n\nWith that, your cipher project is complete.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n\nprint(f'\\nEncrypted text: {text}')\nprint(f'Key: {custom_key}')\ndecryption = decrypt(text, custom_key)\nprint(f'\\nDecrypted text: {decryption}\\n')\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'happycoding'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n\nprint(f'\\nEncrypted text: {text}')\nprint(f'Key: {custom_key}')\ndecryption = decrypt(text, custom_key)\nprint(f'\\nDecrypted text: {decryption}\\n')"
        }
      ],
      "tests": [
        {
          "text": "You should still have a `custom_key` variable.",
          "testCode": "({ test: () => assert(__userGlobals.has(\"custom_key\")) })"
        },
        {
          "text": "You should modify the `custom_key` value into `'happycoding'`.",
          "testCode": "({ test: () => assert.equal(__userGlobals.get(\"custom_key\"), \"happycoding\") })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6555e5991af57d1ae0e35f0a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655619327c7b364166f8dd6f",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "If you wish to incorporate additional characters into the `alphabet` string, such as digits or special characters, you'll find it's necessary to manually modify the right operand of the modulo operation.\n\nReplace `26` with `len(alphabet)` to avoid this issue.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello Zaira'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    if char == ' ':\n        encrypted_text += char\n    else:\n        index = alphabet.find(char)\n        new_index = (index + shift) % 26\n        encrypted_text += alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify the `new_index` value replacing `26` with `len(alphabet)`.",
          "testCode": "({ test: () => {\n  const commentless_code = __helpers.python.removeComments(code);\n  const {block_body} = __helpers.python.getBlock(commentless_code, /else/);\n  assert(block_body.match(/new_index\\s*=\\s*\\(\\s*index\\s*\\+\\s*shift\\s*\\)\\s*%\\s*len\\s*\\(\\s*alphabet\\s*\\)/));\n} })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655619327c7b364166f8dd6f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "655a2a7210094920069b117c",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "Comparison operators allow you to compare two objects based on their values. You can use a comparison operator by placing it between the objects you want to compare.\nThey return a *Boolean* value — namely `True` or `False` — depending on the truthfulness of the expression.\n\nPython has the following comparison operators:\n\n<table>\n  <thead>\n    <tr>\n      <th>Operator</th>\n      <th>Meaning</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>==</td>\n      <td>Equal</td>\n    </tr>\n    <tr>\n      <td>!=</td>\n      <td>Not equal</td>\n    </tr>\n    <tr>\n      <td>&gt;</td>\n      <td>Greater than</td>\n    </tr>\n    <tr>\n      <td>&lt;</td>\n      <td>Less than</td>\n    </tr>\n    <tr>\n      <td>&gt;=</td>\n      <td>Greater than or equal to</td>\n    </tr>\n    <tr>\n      <td>&lt;=</td>\n      <td>Less than or equal to</td>\n    </tr>\n  </tbody>\n</table>\n\nAt the beginning of your loop body, print the result of comparing `char` with a space (`' '`). Use the equality operator `==` for that.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    new_index = index + shift\n    encrypted_text += alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should compare `char` with a space using the equality operator inside your `for` loop.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/char\\s*==\\s*(\"|')\\s\\1/));\n  }\n})"
        },
        {
          "text": "You should print the result of comparing `char` with a space inside your `for` loop.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/print\\s*\\(\\s*char\\s*==\\s*(\"|')\\s\\1\\s*\\)/));\n  }\n})"
        },
        {
          "text": "You should print the result of comparing `char` with a space at the beginning of your loop.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/^\\s+print\\s*\\(\\s*char\\s*==\\s*(\"|')\\s\\1\\s*\\)/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\655a2a7210094920069b117c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65687d2f8c7ee27b0446cef3",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "The code to execute at each iteration — placed after the `:` — constitutes the body of the loop. This code must be indented. In Python, it is recommended to use 4 spaces per indentation level. This indented level is a code block.\n\n```py\nfor i in text:\n    print(i)\n```\n\nPython relies on indentation to indicate blocks of code. A colon at the end of a line is a signal that a new indented block of code will follow.\n\nSo, when no indented block is found after the final colon, the code execution stops and an `IndentationError` is thrown. This code will not show the output and instead raise an `IndentationError`:\n\n```py\nfor i in text:\nprint(i)\n```\n\nGive your `for` loop a body by adding a call to `print(i)`. Remember to indent the loop body.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor i in text:\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add `print(i)` to your `for` loop body. Pay attention to the indentation.",
          "testCode": "assert.match(code, /^for\\s+i\\s+in\\s+text:\\s+print\\s*\\(\\s*i\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65687d2f8c7ee27b0446cef3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "656886ec4e4d9b96ded3c565",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "The iteration variable can have any valid name, but it's convenient to give it a meaningful name.\n\nRename your `i` variable to `char`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n--fcc-editable-region--\nfor i in text:\n    print(i)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `i` with `char`.",
          "testCode": "assert.match(code, /^for\\s+char\\s+in\\s+text:\\s+print\\s*\\(\\s*char\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\656886ec4e4d9b96ded3c565.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65688a50e6c998a21d8e41d3",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "Strings are immutable, which means they cannot be changed once created. For example, you might think that the following code changes the value of `my_string` into the string `'train'`, but this is not valid:\n\n```py\nmy_string = 'brain'\nmy_string[0] = 't'\n```\n\nConfirm that by using the bracket notation to access the first letter in `text` and try to change it into a character of your choice. You will see the ouput disappear and an error appear.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\n\n--fcc-editable-region--\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    print(char, index)\n    new_index = index + shift"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should still have `text = 'Hello World'` in your code.",
          "testCode": "assert.match(code, /^text\\s*=\\s*(\"|')Hello World\\1/m)"
        },
        {
          "text": "You should access the first letter in `text` with `text[0]`.",
          "testCode": "assert.match(code, /^text\\s*\\[\\s*0\\s*\\]\\s*/m)"
        },
        {
          "text": "You should use the `=` operator to assign a character of your choice to `text[0]`. Don't forget to enclose the character in either single or double quotes.",
          "testCode": "assert.match(code, /^text\\s*\\[\\s*0\\s*\\]\\s*\\=\\s*(\"|').\\1/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65688a50e6c998a21d8e41d3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65688b5a1655a7a6caede847",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "When you try to change the individual characters of a string as you did in the previous step, you get a `TypeError`, which occurs when an object of inappropriate type is used in your code.\n\nAs you can see from the error message, strings do not support item assignment, because they are immutable. However, a variable can be reassigned another string:\n\n```py\nmessage = 'Hello World'\nmessage = 'Hello there!'\n```\n\nDelete the `text[0]` line and reassign `text` the string `'Albatross'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\ntext[0] = 'C'\n--fcc-editable-region--\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    print(char, index)\n    new_index = index + shift"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `text[0] = 'C'` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.isFalse( /text\\s*\\[\\s*0\\s*\\]\\s*\\=\\s*(\"|')\\w\\1/.test(commentless_code));"
        },
        {
          "text": "You should reassign `text` the string `'Albatross'`. Do not modify `text = 'Hello World'`.",
          "testCode": "({test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.match(commentless_code.replace(/\\r/g, ''), /text\\s*=\\s*(\"|')Hello World\\1\\s+text\\s*=\\s*(\"|')Albatross\\2/m);\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65688b5a1655a7a6caede847.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6568b7a40c7ba0ccbc4b4425",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "As you can see, each character of the reassigned string gets printed inside the loop.\n\nGo back to the original string by deleting the `text` reassignment.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\ntext = 'Albatross'\n--fcc-editable-region--\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\n\nfor char in text.lower():\n    index = alphabet.find(char)\n    print(char, index)\n    new_index = index + shift"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `text = 'Albatross'` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.isFalse( /text\\s*=\\s*(\"|')Albatross\\1/.test(commentless_code))"
        },
        {
          "text": "You should still have a `text` variable with the value `'Hello World'`.",
          "testCode": "({test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    assert.match(commentless_code, /text\\s*=\\s*(\"|')Hello World\\1/)\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6568b7a40c7ba0ccbc4b4425.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6568c86dc9193000d11ca5e0",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "Instead of assigning `alphabet[new_index]` to `encrypted_text`, assign the current value of `encrypted_text` plus `alphabet[new_index]` to this variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n--fcc-editable-region--\nfor char in text.lower():\n    index = alphabet.find(char)\n    new_index = index + shift\n    encrypted_text = alphabet[new_index]\n    print('char:', char, 'encrypted text:', encrypted_text)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `encrypted_text + alphabet[new_index]` to your `encrypted_text` variable.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/encrypted_text\\s*=\\s*encrypted_text\\s*\\+\\s*alphabet\\s*\\[\\s*new_index\\s*\\]/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6568c86dc9193000d11ca5e0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6568cc9301a0c41058ed95c5",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "Now, replace `new_char` with `encrypted_text`. Also, modify the `print()` call into `print('char:', char, 'encrypted text:', encrypted_text)` to reflect this change.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nencrypted_text = ''\n\nfor char in text.lower():\n    index = alphabet.find(char)    \n    new_index = index + shift\n    new_char = alphabet[new_index]\n    print('char:', char, 'new char:', new_char)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should replace `new_char` with `encrypted_text` inside your `for` loop.",
          "testCode": "({ test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert(block_body.match(/encrypted_text\\s*=\\s*alphabet\\s*\\[\\s*new_index\\s*\\]/));\n  }\n})"
        },
        {
          "text": "You should turn your `print()` call into `print('char:', char, 'encrypted text:', encrypted_text)` inside your `for` loop.",
          "testCode": "({\n  test: () => {\n    const commentless_code = __helpers.python.removeComments(code);\n    const {block_body} = __helpers.python.getBlock(commentless_code, /for\\s+char\\s+in\\s+text\\.lower\\s*\\(\\s*\\)\\s*/);\n    assert.isFalse(/print\\s*\\(\\s*new_char\\s*\\)/.test(commentless_code));\n    assert(block_body.match(/print\\s*\\(\\s*(\"|')char:\\1\\s*,\\s*char\\s*,\\s*(\"|')encrypted\\stext:\\2\\s*,\\s*encrypted_text\\s*\\)/));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6568cc9301a0c41058ed95c5.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65951b637ddec63611c482c0",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "You can use the built-in function `print()` to print the output of your code on the terminal.\n\nFunctions are reusable code blocks that you can call, or invoke, to run their code when you need them. To call a function, you just need to write a pair of parentheses next to its name. You will learn more about functions very soon.\n\nFor now, go to a new line and add an empty call to the `print()` function. You should not see any output yet.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print()` in your code. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65951b637ddec63611c482c0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "659526f3e5424b3eac4b6aa7",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "Next, print the `index` variable to the console.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nindex = alphabet.find(text[0])\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print your `index` variable. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*index\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\659526f3e5424b3eac4b6aa7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65952b70924edb449faf1950",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "Declare a new variable named `shifted`. Use the bracket notation to access the value of `alphabet` at index `index` and assign it to your new variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nindex = alphabet.find(text[0].lower())\nprint(index)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a variable named `shifted`. Pay attention to place the variable name at the beginning of the line.",
          "testCode": "assert.match(code, /^shifted\\s*=/m)"
        },
        {
          "text": "You should assign `alphabet[index]` to your `shifted` variable.",
          "testCode": "assert.match(code, /^shifted\\s*=\\s*alphabet\\s*\\[\\s*index\\s*\\]\\s*(#.*)?$/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65952b70924edb449faf1950.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "659530ca823d6c47f61daa8a",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "Print your `shifted` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nindex = alphabet.find(text[0].lower())\nprint(index)\nshifted = alphabet[index]\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print your `shifted` variable. Pay attention to place the function call at the beginning of the line.",
          "testCode": "assert.match(code, /^print\\s*\\(\\s*shifted\\s*\\)/m)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\659530ca823d6c47f61daa8a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "659db3e3670d3e712be82593",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "Repeating the process of locating the letter inside the alphabet and determine the shifted letter for each character in `text` can be tedious. Thankfully, you can simplify it using a loop.\n\nFor now, remove all the lines of code below the declaration of the `alphabet` variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nindex = alphabet.find(text[0].lower())\nprint(index)\nshifted = alphabet[index + shift]\nprint(shifted)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should still have `text = 'Hello World'` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^text\\s*=\\s*(\"|')Hello World\\1/m)"
        },
        {
          "text": "You should still have `shift = 3` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^shift\\s*=\\s*3/m)"
        },
        {
          "text": "You should still have `alphabet = 'abcdefghijklmnopqrstuvwxyz'` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.match(commentless_code, /^alphabet\\s*=\\s*(\"|')abcdefghijklmnopqrstuvwxyz\\1/m)"
        },
        {
          "text": "You should delete `index` variable and its value.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.notMatch(commentless_code, /index\\s*=/)"
        },
        {
          "text": "You should not have `print(index)` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.notMatch(commentless_code, /print\\s*\\(\\s*index\\s*\\)/)"
        },
        {
          "text": "You should delete the `shifted` variable and its value.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.notMatch(commentless_code, /shifted\\s*=/)"
        },
        {
          "text": "You should not have `print(shifted)` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.notMatch(commentless_code, /print\\s*\\(\\s*shifted\\s*\\)/)"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\659db3e3670d3e712be82593.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65a450e8fb2c9d75c7378d28",
      "title": "Step 88",
      "challengeType": 20,
      "dashedName": "step-88",
      "description": "Since this time you are starting from an encrypted string to decrypt, you won't need the `encryption` variable anymore.\n\nDelete `encryption` and the `print(encryption)` call. Also, comment out the last two lines of your code.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n--fcc-editable-region--\nencryption = encrypt(text, custom_key)\nprint(encryption)\ndecryption = decrypt(encryption, custom_key)\nprint(decryption)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should delete the `encryption` variable and its value.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.isFalse(/encryption\\s*=\\s*encrypt\\s*\\(\\s*text\\s*,\\s*custom_key\\s*\\)/.test(commentless_code))"
        },
        {
          "text": "You should not have `print(encryption)` in your code.",
          "testCode": "const commentless_code = __helpers.python.removeComments(code);\nassert.isFalse(/print\\s*\\(\\s*encryption\\s*\\)/.test(commentless_code))"
        },
        {
          "text": "You should turn `decryption = decrypt(encryption, custom_key)` into a comment.",
          "testCode": "assert(code.match(/#\\s*decryption\\s*=/));"
        },
        {
          "text": "You should turn `print(decryption)` into a comment.",
          "testCode": "assert(code.match(/#\\s*print\\s*\\(\\s*decryption\\s*\\)/));"
        },
        {
          "text": "Your code contains invalid syntax and/or invalid indentation.",
          "testCode": "({test: () => assert(true) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65a450e8fb2c9d75c7378d28.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65a51c9e000b660122b8b29e",
      "title": "Step 94",
      "challengeType": 20,
      "dashedName": "step-94",
      "description": "Uncomment the `decryption` variable and change its value by passing `text` as the first argument to `decrypt`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'mrttaqrhknsw ih puggrur'\ncustom_key = 'python'\n\ndef vigenere(message, key, direction=1):\n    key_index = 0\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    final_message = ''\n\n    for char in message.lower():\n\n        # Append any non-letter character to the message\n        if not char.isalpha():\n            final_message += char\n        else:        \n            # Find the right key character to encode/decode\n            key_char = key[key_index % len(key)]\n            key_index += 1\n\n            # Define the offset and the encrypted/decrypted letter\n            offset = alphabet.index(key_char)\n            index = alphabet.find(char)\n            new_index = (index + offset*direction) % len(alphabet)\n            final_message += alphabet[new_index]\n    \n    return final_message\n\ndef encrypt(message, key):\n    return vigenere(message, key)\n    \ndef decrypt(message, key):\n    return vigenere(message, key, -1)\n--fcc-editable-region--\nprint(f'\\nEncrypted text: {text}')\nprint(f'Key: {custom_key}')\n#decryption = decrypt(encryption, custom_key)\n--fcc-editable-region--\n#print(decryption)"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your `decryption` variable should have the value of `decrypt(text, custom_key)`.",
          "testCode": "({ test: () => assert.match(code, /^decryption\\s*=\\s*decrypt\\s*\\(\\s*text\\s*,\\s*custom_key\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\65a51c9e000b660122b8b29e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "6624e0ec0bf47017eed84b1f",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "The first kind of cipher you are going to build is called a *Caesar* cipher.  Specifically, you will take each letter in your message, find its position in the alphabet, take the letter located after 3 positions in the alphabet, and replace the original letter with the new letter.\n\nTo implement this, you will use the `.find()` method discussed in the previous step. Modify your existing `.find()` call passing it `text[0]` as the argument instead of `'z'`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ntext = 'Hello World'\nshift = 3\nalphabet = 'abcdefghijklmnopqrstuvwxyz'\nalphabet.find('z')\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should modify your existing `alphabet.find('z')` call passing `text[0]` to the method.",
          "testCode": "assert.match(code, /^alphabet\\.find\\s*\\(\\s*text\\s*\\[\\s*0\\s*\\]\\s*\\)/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\6624e0ec0bf47017eed84b1f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "66605a64a9822f01ec5ae8ce",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "In Python, the *scope* of a variable determines where that variable can be accessed:\n\n- Variables defined outside a function have a *global* scope and they can be accessed from any part of your code.\n\n- Variables defined inside a function are *local* to that function and cannot be accessed outside of it.\n\nTo see this in action, try to print the `alphabet` variable at the end of your code. This will raise a `NameError` exception.\n\nYou should see an error message indicating that `alphabet` is not defined. This is because `alphabet` is defined inside the `caesar` function and is not accessible outside of it.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\nshift = 3\n\ndef caesar():\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in text.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + shift) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', text)\n    print('encrypted text:', encrypted_text)\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should attempt to print the `alphabet` variable outside the caesar function.",
          "testCode": "assert.match(code, /^print\\(\\s*alphabet\\s*\\)/m)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\66605a64a9822f01ec5ae8ce.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "666064e915eba7aa1de03f6b",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "Now, fix the error by removing the line that tries to print the `alphabet` variable outside of the `caesar` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "text = 'Hello Zaira'\nshift = 3\n\ndef caesar():\n    alphabet = 'abcdefghijklmnopqrstuvwxyz'\n    encrypted_text = ''\n\n    for char in text.lower():\n        if char == ' ':\n            encrypted_text += char\n        else:\n            index = alphabet.find(char)\n            new_index = (index + shift) % len(alphabet)\n            encrypted_text += alphabet[new_index]\n    print('plain text:', text)\n    print('encrypted text:', encrypted_text)\n\n--fcc-editable-region--\nprint(alphabet)\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `print(alphabet)` line.",
          "testCode": "({ test: () => assert.isFalse(runPython(`_Node(_code).has_call(\"print(alphabet)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-string-manipulation-by-building-a-cipher\\666064e915eba7aa1de03f6b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-string-manipulation-by-building-a-cipher",
        "name": "Learn String Manipulation By Building A Cipher"
      }
    },
    {
      "id": "65ef181dad3d96b14a21a03e",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "In this project, you will find the approximate square root of a given number using the bisection method.\n\nThe bisection method is a technique for finding the roots of a real-valued function. It works by narrowing down an interval where the square root lies until it converges to a value within a specified tolerance.\n\nBegin by creating a function named `square_root_bisection`. Leave the parameters empty for now.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define the function `square_root_bisection` with no parameters.",
          "testCode": "({\n    test: () => {\n        assert(runPython(`\n        import inspect        \n        inspect.isfunction(square_root_bisection)\n        `))\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef181dad3d96b14a21a03e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef190c6b51e9b5a5f7ed29",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "Give the `square_root_bisection` function the following parameters:\n\n- `square_target`: The number for which you want to find the square root.\n- `tolerance` (optional): The acceptable difference between the square of the approximate root value and the actual target value (default is `1e-7`).  The tolerance `1e-7` implies that the solution will be accurate to within `0.0000001` of the true value and is a good default choice that balances accuracy and performance.\n- `max_iterations` (optional): The maximum number of iterations to perform (default is `100`). If the method doesn't converge within this limit, you'll assume the solution is not found.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef square_root_bisection():\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your function should have these parameters: `square_target`, `tolerance = 1e-7`, and `max_iterations = 100`. The order matters.",
          "testCode": "({\n    test: () => assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").has_args(\"square_target, tolerance=1e-7, max_iterations=100\")`))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef190c6b51e9b5a5f7ed29.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef19425d1b27b6c930bae6",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "If the number for which you want to find the square root is negative, the code should raise an error as the square root of a negative number is not defined in real numbers.\n\nRemove the `pass` statement and create an `if` statement to check if `square_target` is less than `0`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef square_root_bisection(square_target, tolerance = 1e-7, max_iterations = 100):\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword.",
          "testCode": "({\n    test: () => {\n        assert.isFalse(runPython(`_Node(_code).find_function(\"square_root_bisection\").has_pass()`))\n    }\n})"
        },
        {
          "text": "You should create an `if` statement to check if `square_target < 0`.\n\n```js\n({\n    test: () => {\n       assert.isFalse(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_if(\"square_target < 0\").is_empty()`))\n\n}\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef19425d1b27b6c930bae6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef198fde24dfb7ff675b42",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "The `raise` statement allows you to force a specific exception to occur. It consists of the `raise` keyword followed by the exception type, and enables you to provide a custom error message:\n\n```py\nraise ValueError(\"Invalid value\")\n```\n\nWhen the code above runs, a `ValueError` is raised and the message `\"Invalid value\"` is shown to the user.\n\nIf the `square_target` is less than `0`, no real-valued square root can be computed. Therefore, raise a `ValueError` with the message `'Square root of negative number is not defined in real numbers'`. Don't forget to remove the `pass` keyword.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword.",
          "testCode": "({\n    test: () => {\n        assert.isFalse(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[0].find_bodies()[0].has_pass()`))\n    }\n})"
        },
        {
          "text": "You should raise a `ValueError` with the message `'Square root of negative number is not defined in real numbers'` inside the `if` body.\n\n```js\n({\n    test: () => {\n\nassert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[0].find_bodies()[0].is_equivalent(\"raise ValueError('Square root of negative number is not defined in real numbers')\")`))\n    }\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef198fde24dfb7ff675b42.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef19ec318e2fb9066381e3",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "You'll create separate cases for when `square_target` is `0` or `1`. \n\nBegin by creating an `if` statement to check if `square_target` is equal to `1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement to check that `square_target == 1`.",
          "testCode": "({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_conditions()[0].is_equivalent(\"square_target == 1\")`))\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef19ec318e2fb9066381e3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1a1fcb527bba0ca82ccf",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "If the `square_target` is equal to  `1`, declare a variable `root` and assign it the value `1` . Also, print the message `'The square root of {square_target} is 1'`. Remember to format the message using an f-string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword.",
          "testCode": "({\n     test: () => \n     {\n        assert.isFalse(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[0].has_pass()`))\n    }\n})"
        },
        {
          "text": "You should assign the value `1` to the `root` variable and print the message `'The square root of {square_target} is 1'` inside the `if` body.\n\n```js\n\n({\n    test: () => \n    {        \n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[0].is_equivalent(\"root = 1\\\\nprint(f'The square root of {square_target} is 1')\")`));\n    }\n})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1a1fcb527bba0ca82ccf.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1a50049cf9bada13266f",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Create an `elif` statement to check if `square_target` is equal to `0`. If it is, assign the value `0` to the `root` variable. Also, print the message `'The square root of {square_target} is 0'`. Remember to format the message using an f-string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\ndef square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `elif` statement to check the condition `square_target == 0`.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_conditions()[1].is_equivalent(\"square_target == 0\")`));\n    }\n})\n\n```\n\nYou should assign the value `0` to the `root` variable and pass the argument `f'The square root of {square_target} is 0'` to a `print` call.\n\n```js\n\n({\n    test: () => \n    {        \n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[1].is_equivalent(\"root = 0\\\\nprint(f'The square root of {square_target} is 0')\")`));\n    }\n})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1a50049cf9bada13266f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1a720d6e65bbb0d22463",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "Next, you are going to work on the cases where the `square_target` is a positive number apart from `1` or `0`.\n\nCreate an `else` clause to handle these cases.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n--fcc-editable-region--\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Create an `else` clause and do not forget to add a `pass` keyword.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_conditions()[2] == _Node()`))\n    }\n})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1a720d6e65bbb0d22463.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1aacca094bbcc2e2a3c8",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "In Python, the `max()` function returns the largest of the input values.\n\n```python\nmax(1, 2, 3) # Output: 3\n```\n\nThe variables `low` and `high` will be used to define the initial interval where the square root lies.\n\nInside the `else` clause, initialize the `low` variable to `0` and the `high` variable to be the maximum of either `1` or `square_target` as the square root of a number is always less than or equal to the number itself.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n--fcc-editable-region--\n    else:\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword.",
          "testCode": "({\n    test: () => \n    {\n        assert.isFalse(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].has_pass()`))\n    }\n})"
        },
        {
          "text": "You should declare a variable `low` and assign it `0`.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_variable(\"low\").is_equivalent(\"low = 0\")`));    }\n})\n\n```\n\nYou should declare a variable `high` and use the `max()` function to assign it the maximum value between `1` and `square_target`.\n\n```js\n\n({ test: () => assert(runPython(`\nnode = _Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_variable(\"high\")\nvalues = [\"high = max(1, square_target)\", \"high = max(square_target, 1)\"]\nany(node.is_equivalent(val) for val in values)\n`)) })\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1aacca094bbcc2e2a3c8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1afca9a8f6be0d4150ba",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "Set the value of `root` to `None` as at this point, you don't have an approximate value yet.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n--fcc-editable-region--\n    else:\n        low = 0\n        high = max(1, square_target)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The value of `root` should be `None`.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].is_equivalent(\"low = 0\\\\nhigh = max(1, square_target)\\\\nroot = None\")`));\n    }\n})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1afca9a8f6be0d4150ba.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1be2b958cabf712296cd",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "Now you'll repeatedly narrow down the interval by finding the midpoint of the current interval and comparing the square of the midpoint with the target value.\n\nFor that, inside the `else` block, create a `for` loop that runs up to `max_iterations` times.\n\nFor your loop, use the `range` function, which generates a sequence of numbers you can iterate over. The syntax is `range(start, stop, step)`, where `start` is the starting integer (inclusive), `stop` is the last integer (not inclusive), and `step` is the difference between a number and the previous one in the sequence.\n\nAlso, use `_` as a loop variable. The `_` acts as a placeholder and is useful when you need to use a variable but don't actually need its value.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create a `for` loop to iterate over `range(max_iterations)`. Use `_` as the loop variable.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].is_equivalent(\"for _ in range(max_iterations):\\\\n    pass\")`));\n    }\n})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1be2b958cabf712296cd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1c0a03fcabc04ded7e69",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "Inside the for loop, calculate the midpoint of the interval ranging from `low` to `high`. Assign this value to a variable `mid`.\n\nAlso, calculate the square of the midpoint (`mid`) and store it in the variable `square_mid`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n--fcc-editable-region--\n        for _ in range(max_iterations):\n            pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword.\n\n```js\n({\n    test: () => \n    {\n        assert.isFalse(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_bodies()[0].has_pass()`))\n\n}\n\n})\n\n```\n\nYou should declare a variable `mid` and assign it `(low + high) / 2` inside the body of the `for` loop.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`\n\tnode = _Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_bodies()[0].find_variable(\"mid\")\n\tvalues = [\"mid = (low + high) / 2\", \"mid = (high + low) / 2\"]\n\tany(node.is_equivalent(val) for val in values)\n\t`))\n\n}\n\n})\n```\n\nYou should declare a variable `square_mid` and assign it `mid**2` inside the body of the for loop.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_bodies()[0].find_variable(\"square_mid\").is_equivalent(\"square_mid = mid**2\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1c0a03fcabc04ded7e69.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1c34a541afc12dbb849d",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "The `abs()` function returns the absolute value of a number, which is always positive, regardless of the number sign. You will use it to check that the estimated square root is close enough to the actual value.\n\nNow, create an `if` statement to check if the absolute value of the difference between `square_mid` and `square_target` is within the specified `tolerance`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n--fcc-editable-region--\n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n            \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `if` statement with the condition `abs(square_mid - square_target) < tolerance:` inside the body of the `for` loop.",
          "testCode": "({\n    test: () =>\n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_ifs()[0].find_conditions()[0].is_equivalent(\"abs(square_mid - square_target) < tolerance\")`))\n    } \n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1c34a541afc12dbb849d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1cb031de30c2cde64c12",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "If the difference is within the specified `tolerance`, set the value of `root` to `mid` and break out of the loop.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n--fcc-editable-region--       \n            if abs(square_mid - square_target) < tolerance:\n                pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the existing `pass` statement.\n\n```js\n({\n    test: () => \n    {\n        assert.isFalse(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_ifs()[0].find_bodies()[0].has_pass()`))\n    }\n\n})\n\n```\n\nYou should assign the value of `mid` to `root` and break out of the loop.\n\n```js\n({\n    test: () => \n    {\n          assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_ifs()[0].find_bodies()[0].is_equivalent(\"root = mid\\\\nbreak\")`))\n    }\n\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1cb031de30c2cde64c12.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1cda150a59c3b8306944",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "If the difference is not within the specified `tolerance`, create an `elif` statement to check if `square_mid` is less than `square_target`.\n\nAssign the value of `mid` to `low` as the square root would now lie between `low` and `mid`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n--fcc-editable-region--\n            if abs(square_mid - square_target) < tolerance:\n                root = mid\n                break\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `elif` statement that checks if `square_mid < square_target`.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_ifs()[0].find_conditions()[1].is_equivalent(\"square_mid < square_target\")`))\n\n}\n\n})\n```\n\nYou should assign the value of `mid` to `low`.\n\n```js\n({\n    test: () => \n    {\n          assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_ifs()[0].find_bodies()[1].is_equivalent(\"low = mid\")`))\n    }\n\n})\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1cda150a59c3b8306944.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1d104c2be9c4d8e22075",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "If both the `if` and `elif` conditions are not met, the value of `mid` would be greater than `square_target`. In this case, create an `else` clause and assign the value of `mid` to `high`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n            if abs(square_mid - square_target) < tolerance:\n                root = mid\n                break\n\n--fcc-editable-region--\n            elif square_mid < square_target:\n                low = mid\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `else` clause.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_ifs()[0].find_conditions()[2]== _Node()`));\n    }\n})\n\n```\n\nYou should assign the value of `mid` to `high` in the `else` clause.",
          "testCode": "({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_for_loops()[0].find_ifs()[0].find_bodies()[2].is_equivalent(\"high = mid\")`));\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1d104c2be9c4d8e22075.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1d5e3d2927c5e0f4997b",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "In Python, the `is` keyword checks for object identity. It's used to determine if two variables point to the same object in memory. In contrast to `is`, the equality operator (`==`) determines if the values of two objects are the same, regardless of whether they are the same object in memory.\n\nOutside the for loop, create an `if` statement to check if  `root is None`. If it is, print the message `'Failed to converge within {max_iterations} iterations.'`. Remember to format the message using an f-string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n            if abs(square_mid - square_target) < tolerance:\n                root = mid\n                break\n\n            elif square_mid < square_target:\n                low = mid\n            else:\n                high = mid\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `if` statement that checks if `root is None`.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_ifs()[0].find_conditions()[0].is_equivalent(\"root is None\")`));\n\n}\n})\n```\n\nYou should pass the argument `f'Failed to converge within {max_iterations} iterations.'` to the `print` function.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_ifs()[0].is_equivalent(\"if root is None:\\\\n    print(f'Failed to converge within {max_iterations} iterations.')\")`));\n\n}\n})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1d5e3d2927c5e0f4997b.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1d924ff2e5c7031c6ce8",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "Create an `else` clause to handle the case where the value of `root` is not `None`, indicating that a root has been found. If it is not `None`, print the message `'The square root of {square_target} is approximately {root}'`. Remember to format using an f-string.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n            if abs(square_mid - square_target) < tolerance:\n                root = mid\n                break\n\n            elif square_mid < square_target:\n                low = mid\n            else:\n                high = mid\n\n--fcc-editable-region--\n        if root is None:\n            print(f\"Failed to converge within {max_iterations} iterations.\")\n        \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `else` clause.\n\n```js\n({\n    test: () => \n    {\n         assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_ifs()[0].find_conditions()[1] == _Node()`));\n    }\n})\n\n```\n\nYou should print `f'The square root of {square_target} is approximately {root}'` within the `else` body.\n\n```js\n({\n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_function(\"square_root_bisection\").find_ifs()[1].find_bodies()[2].find_ifs()[0].find_bodies()[1].is_equivalent(\"print(f'The square root of {square_target} is approximately {root}')\")`));\n    }\n})\n\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1d924ff2e5c7031c6ce8.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1dd722f6e7c8294eeec4",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "Finally, return the value of `root` from the `square_root_bisection` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n            if abs(square_mid - square_target) < tolerance:\n                root = mid\n                break\n\n            elif square_mid < square_target:\n                low = mid\n            else:\n                high = mid\n\n--fcc-editable-region--\n        if root is None:\n            print(f\"Failed to converge within {max_iterations} iterations.\")\n        \n        else:   \n            print(f'The square root of {square_target} is approximately {root}')\n  \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return `root` at the end of the function.",
          "testCode": "({ \n    test: () => \n    {\n        const pyClassStr = runPython(`str(_Node(_code).find_function(\"square_root_bisection\"))`);\n        assert.match(pyClassStr, /return\\s*root/)\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1dd722f6e7c8294eeec4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1e10268f8ec9121446d1",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "Outside the function definiton, create a variable `N` and assign the value of `16` to it.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n            if abs(square_mid - square_target) < tolerance:\n                root = mid\n                break\n\n            elif square_mid < square_target:\n                low = mid\n            else:\n                high = mid\n\n        if root is None:\n            print(f\"Failed to converge within {max_iterations} iterations.\")\n        \n        else:   \n            print(f'The square root of {square_target} is approximately {root}')\n    \n    return root\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have the variable `N = 16` outside the function definition.",
          "testCode": "({ \n    test: () => \n    {\n        assert(runPython(`_Node(_code).find_variable(\"N\").is_equivalent(\"N = 16\")`))\n    }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1e10268f8ec9121446d1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65ef1eac497754cafa12a26c",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Call the `square_root_bisection` function with the `N` variable as the argument. This will print the result to the console.\n\nExperiment with larger values.\n\nWith this, you have successfully implemented the bisection method to find the square root of a number.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n            if abs(square_mid - square_target) < tolerance:\n                root = mid\n                break\n\n            elif square_mid < square_target:\n                low = mid\n            else:\n                high = mid\n\n        if root is None:\n            print(f\"Failed to converge within {max_iterations} iterations.\")\n    \n        else:   \n            print(f'The square root of {square_target} is approximately {root}')\n    \n    return root\n\n--fcc-editable-region--\nN = 16\n\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "def square_root_bisection(square_target, tolerance=1e-7, max_iterations=100):\n    if square_target < 0:\n        raise ValueError('Square root of negative number is not defined in real numbers')\n    if square_target == 1:\n        root = 1\n        print(f'The square root of {square_target} is 1')\n    elif square_target == 0:\n        root = 0\n        print(f'The square root of {square_target} is 0')\n\n    else:\n        low = 0\n        high = max(1, square_target)\n        root = None\n        \n        for _ in range(max_iterations):\n            mid = (low + high) / 2\n            square_mid = mid**2\n\n            if abs(square_mid - square_target) < tolerance:\n                root = mid\n                break\n\n            elif square_mid < square_target:\n                low = mid\n            else:\n                high = mid\n\n        if root is None:\n            print(f\"Failed to converge within {max_iterations} iterations.\")\n    \n        else:   \n            print(f'The square root of {square_target} is approximately {root}')\n    \n    return root\n\nN = 16\nsquare_root_bisection(N)"
        }
      ],
      "tests": [
        {
          "text": "You should call the `square_root_bisection` function with the variable `N` as the argument.",
          "testCode": "({ \n    test: () => assert(runPython(`_Node(_code).has_call(\"square_root_bisection(N)\")`))\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-the-bisection-method-by-finding-the-square-root-of-a-number\\65ef1eac497754cafa12a26c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-the-bisection-method-by-finding-the-square-root-of-a-number",
        "name": "Learn The Bisection Method By Finding The Square Root Of A Number"
      }
    },
    {
      "id": "65c4eb814cc977c95cd7df0e",
      "title": "Step 1",
      "challengeType": 20,
      "dashedName": "step-1",
      "description": "In this project, you are going to create a Binary Search Tree (BST). A BST is a data structure in which each node has at most two children, with the left child containing values less than the parent node and the right child containing values greater than the parent node, allowing for efficient searching and sorting operations.\n\nThis is what a Binary Search Tree looks like:\n\n<img alt=\"a binary search tree\" src=\"https://cdn.freecodecamp.org/curriculum/python/bst-example.png\" style=\"background-color: white; height:500px; width:500px; padding: 10px; display: block; margin-right: auto; margin-left: auto; margin-bottom: 1.2rem;\">\n\nBegin by defining an empty `TreeNode` class. The `TreeNode` class represents a node in a binary search tree. Use the `pass` keyword to fill the class body and avoid an error.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should use the `class` keyword to declare an empty class named `TreeNode`.",
          "testCode": "({\n  test: () => {\n    assert(runPython(`\n      import inspect\n      inspect.isclass(TreeNode)\n    `));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4eb814cc977c95cd7df0e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4ef8463f869d0eaf87c67",
      "title": "Step 2",
      "challengeType": 20,
      "dashedName": "step-2",
      "description": "Inside the `TreeNode` class, replace `pass` with an `__init__` method so that you can initialize the attributes of the object. Don't add any parameters for now.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass TreeNode:\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove `pass` keyword from the `TreeNode` class and move it inside the `__init__` method.",
          "testCode": "({\n  test: () => {\n    const pyClassStr = runPython(`str(_Node(_code).find_class(\"TreeNode\"))`);\n    const to_test = pyClassStr.split(\"\\n\");\n    assert.notInclude(to_test[1], \"pass\");\n  },\n});"
        },
        {
          "text": "You should define an `__init__` method inside your `TreeNode` class. Remember to use the `pass` keyword inside.",
          "testCode": "({\n  test: () => {\n    assert(\n      runPython(`_Node(_code).find_class(\"TreeNode\").has_function(\"__init__\")`)\n    );\n  },\n});"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4ef8463f869d0eaf87c67.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f013851cefd1a4fe4c96",
      "title": "Step 3",
      "challengeType": 20,
      "dashedName": "step-3",
      "description": "The `__init__` method takes two parameters: `self` (which represents the instance of the class being created) and `key` (the value to be stored in the node). Add those two parameters to the `__init__()` method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass TreeNode:\n    def __init__():\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add the `self` parameter to the method.",
          "testCode": "({ test: () => assert.match(code, /def\\s+__init__\\s*\\(\\s*self\\s*/) });"
        },
        {
          "text": "You should add the `key` parameter to the method.",
          "testCode": "({\n  test: () => assert.match(code, /def\\s+__init__\\s*\\(\\s*self\\s*,\\s*key\\s*\\)/)\n});"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f013851cefd1a4fe4c96.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f02dbd3557d23f12db62",
      "title": "Step 4",
      "challengeType": 20,
      "dashedName": "step-4",
      "description": "Inside the `__init__` method, delete `pass` and assign the value of the `key` parameter to the `key` attribute of the node using `self.key`.\n\nThis means that the `key` attribute of the `TreeNode` instance will be set to the value passed during the object's creation.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass TreeNode:\n    def __init__(self, key):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` statement from the `__init__` method.\n\n```js\n({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"TreeNode\").find_function(\"__init__\").has_pass()`\n      )\n    );\n  },\n});\n\n```\n\nYou should assign the value of the `key` parameter to the `key` attribute of the node using `self.key`.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}self\\.key\\s*=\\s*key/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f02dbd3557d23f12db62.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f07da204f4d2f325fbd3",
      "title": "Step 5",
      "challengeType": 20,
      "dashedName": "step-5",
      "description": "Inside the `__init__` method, initialize the `left` and `right` attributes of the node to `None`. This is because when a node is first created, it doesn't have any left or right children. Remember to use the `self` keyword.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "--fcc-editable-region--\nclass TreeNode:    \n    def __init__(self, key):\n        self.key = key\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `None` to the `left` attribute of the node using `self.left`.",
          "testCode": "({ test: () => assert.match(code, /self\\.left\\s*=\\s*None/m) })"
        },
        {
          "text": "You should assign `None` to the `right` attribute of the node using `self.right`.",
          "testCode": "({ test: () => assert.match(code, /self\\.right\\s*=\\s*None/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f07da204f4d2f325fbd3.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f09e074dd8d37830ea00",
      "title": "Step 6",
      "challengeType": 20,
      "dashedName": "step-6",
      "description": "Create another empty class called `BinarySearchTree` that represents a binary search tree.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a class named `BinarySearchTree`. Remember to use the `pass` keyword.",
          "testCode": "({\n  test: () => {\n    assert(runPython(`\n      import inspect\n      inspect.isclass(BinarySearchTree)\n    `));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f09e074dd8d37830ea00.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f0b82db314d3fcc0b8e1",
      "title": "Step 7",
      "challengeType": 20,
      "dashedName": "step-7",
      "description": "Within the `BinarySearchTree` class, replace `pass` with an `__init__` method and add a `self` parameter to this method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n        \n--fcc-editable-region--\nclass BinarySearchTree:\n    pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `BinarySearchTree` class.\n\n```js\n({\n  test: () => {\n    const pyClassStr = runPython(\n      `str(_Node(_code).find_class(\"BinarySearchTree\"))`\n    );\n    const to_test = pyClassStr.split(\"\\n\");\n    assert.notInclude(to_test[1], \"pass\");\n  },\n});\n\n```\n\nYou should define an `__init__` method and add a `self` parameter to this method. Remember to use the `pass` keyword inside the method body.",
          "testCode": "({ test: () => assert.match(code, /^\\s{4}def\\s+__init__\\s*\\(\\s*self\\s*\\)\\s*:/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f0b82db314d3fcc0b8e1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f0d32ca17ad4b1636b0e",
      "title": "Step 8",
      "challengeType": 20,
      "dashedName": "step-8",
      "description": "Inside the `__init__` method, delete `pass` and initialize `root` to the value `None`. \n\nThe `root` attribute represents the root node of the binary search tree. Since this is the constructor when a new `BinarySearchTree` object is created, it starts with an empty tree, so the `root` attribute is set to `None`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n--fcc-editable-region--\nclass BinarySearchTree:\n    def __init__(self):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` statement from the `__init__` method.\n\n```js\n({\n  test: () => {\n    const pyClassStr = runPython(\n      `str(_Node(_code).find_class(\"BinarySearchTree\"))`\n    );\n    assert.notInclude(pyClassStr, \"pass\");\n  },\n});\n\n```\n\nYou should initialize the `root` attribute to `None` using `self.root`.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}self\\.root\\s*=\\s*None/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f0d32ca17ad4b1636b0e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f195de7e2ad5932be717",
      "title": "Step 9",
      "challengeType": 20,
      "dashedName": "step-9",
      "description": "Next, you need to define a mechanism to insert nodes in the tree. For that, you need to define an `_insert` method, which is a helper function and would be used by the actual `insert` method later on. \n\nThis method is recursive, meaning it calls itself to traverse the tree until the appropriate location for the new node is found.\n\nDefine an `_insert` method with the parameters `self`, `node` and `key`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n--fcc-editable-region--\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `_insert` method within the `BinarySearchTree` class. Remember to use `pass`.",
          "testCode": "({ test: () => assert.match(code, /def\\s+_insert\\s*\\([^(]*\\)\\s*:/m) })"
        },
        {
          "text": "Your `_insert` method should take three parameters: `self`, `node` and `key`.",
          "testCode": "({ test: () => assert.match(code, /def\\s+_insert\\s*\\(\\s*self\\s*,\\s*node\\s*,\\s*key\\s*\\)\\s*:/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f195de7e2ad5932be717.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f22498d22ed775ef8efb",
      "title": "Step 10",
      "challengeType": 20,
      "dashedName": "step-10",
      "description": "Now you need to check if the `node` parameter is `None`. If it is, this means that the method has reached a leaf node or an empty spot in the tree where the new node should be inserted.\n\nInside the `_insert` method body, replace `pass` with an `if` statement that checks if `node is None`.\n\nInside the new `if` block, return `TreeNode(key)` to  create a new `TreeNode` instance with the provided key. This will become the new leaf node, effectively inserting the key into the tree.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n--fcc-editable-region--\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should not have `pass` in your `_insert` method.\n\n```js\n({ test: () => assert.isFalse(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_insert\").has_pass()`)) })\n\n```\n\nYou should write an `if` statement to check if `node is None`.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");        \n    const ins = __helpers.python.getDef(\"\\n\"+transformedCode, \"_insert\");\n    const {function_body} = ins;    \n    assert(function_body.match(/^\\s{8}if\\s+node\\s+is\\s+None\\s*:/m));\n  }\n})"
        },
        {
          "text": "You should return `TreeNode(key)` from the `if` block.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");        \n    const ins = __helpers.python.getDef(\"\\n\"+transformedCode, \"_insert\");\n    const {function_body} = ins;    \n    assert(function_body.match(/^(\\s{8})if\\s+node\\s+is\\s+None\\s*:\\s*^\\1\\s{4}return\\s+TreeNode\\s*\\(\\s*key\\s*\\)/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f22498d22ed775ef8efb.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f2851645e8d84d14f5d1",
      "title": "Step 11",
      "challengeType": 20,
      "dashedName": "step-11",
      "description": "Now you need to recursively traverse the tree and insert the values using the principle for binary trees:\n\n- Values smaller than the key are placed in the left subtree\n- Values greater than the key are placed in the right subtree\n\nAfter your existing conditional statement, write another `if` statement to check if `key` is less than `node.key`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n--fcc-editable-region--\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write another if statement to check if `key` is less than `node.key`. Remember to use the `pass` keyword.",
          "testCode": "({ test: () => assert(runPython(` _Node(_code).find_class(\"BinarySearchTree\").find_function(\"_insert\").find_ifs()[1].find_conditions()[0].is_equivalent(\"key < node.key\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f2851645e8d84d14f5d1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f2b7178afed8e88f782f",
      "title": "Step 12",
      "challengeType": 20,
      "dashedName": "step-12",
      "description": "If `key` < `node.key` evaluates to `True`, then the new node should be placed in the left subtree.\n\nDelete `pass` and recursively call the `_insert` method with left child as the first argument and `key` as the second argument. Assign the result to the `left` attribute of the current node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n--fcc-editable-region--    \n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `if` block.",
          "testCode": "({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_insert\").find_if(\"key < node.key\").find_bodies()[0].has_pass()`\n      )\n    );\n  },\n});"
        },
        {
          "text": "You should call the `self._insert` method passing `node.left` and `key` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /self\\._insert\\(\\s*node\\.left\\s*,\\s*key\\s*\\)/) });"
        },
        {
          "text": "You should assign the result of your `self._insert()` call to the `left` attribute of the current node.",
          "testCode": "({ test: () => assert.match(code, /node\\.left\\s*=\\s*self\\._insert\\(\\s*node\\.left\\s*,\\s*key\\s*\\)/) });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f2b7178afed8e88f782f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f2d9fd872fd99ac659dd",
      "title": "Step 13",
      "challengeType": 20,
      "dashedName": "step-13",
      "description": "Add an `elif` conditional statement that checks if `key` > `node.key`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n--fcc-editable-region--    \n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add an `elif` conditional statement to check if `key > node.key`. Remember to use the `pass` keyword.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_insert\").find_ifs()[1].find_conditions()[1].is_equivalent(\"key > node.key\")`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f2d9fd872fd99ac659dd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f300da28d8da361bfa93",
      "title": "Step 14",
      "challengeType": 20,
      "dashedName": "step-14",
      "description": "Inside your `elif` clause, replace `pass` with a call to the `_insert` method with right child of the current node as the first argument  and `key` as the second argument. Assign the result to the `right` attribute of the current node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n--fcc-editable-region--\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `elif` block.\n\n```js\n({\n  test: () => {\n    const pyClassStr = runPython(\n      `str(_Node(_code).find_class(\"BinarySearchTree\"))`\n    );\n    assert.notInclude(pyClassStr, \"pass\");\n  },\n});\n\n```\n\nYou should call the `self._insert()` method passing `node.right` and `key` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /self\\._insert\\(\\s*node\\.right\\s*,\\s*key\\s*\\)/) });"
        },
        {
          "text": "You should assign the result of your `self._insert()` call to the right attribute (`node.right`) of the current node.",
          "testCode": "({ test: () => assert.match(code, /node\\.right\\s*=\\s*self\\._insert\\(\\s*node\\.right\\s*,\\s*key\\s*\\)/) });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f300da28d8da361bfa93.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f3258d2e4cdacc919dfd",
      "title": "Step 15",
      "challengeType": 20,
      "dashedName": "step-15",
      "description": "At the end of your `_insert` method, after the insertion process is complete, return the current node to update the tree structure at the higher levels of the recursive call stack.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n--fcc-editable-region--    \n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return the current node outside the conditional blocks.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}return\\s+node/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f3258d2e4cdacc919dfd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f33bc3c3d8db7f732787",
      "title": "Step 16",
      "challengeType": 20,
      "dashedName": "step-16",
      "description": "Now, to perform the actual insertion, define an empty `insert` method within the `BinarySearchTree` class and give it a `self` parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        return node\n--fcc-editable-region--    \n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `insert` method with a `self` parameter within the `BinarySearchTree` class. Remember the `pass` keyword.",
          "testCode": "({ test: () => assert.match(code, /^\\s{4}def\\s+insert\\s*\\(\\s*self\\s*\\)\\s*:/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f33bc3c3d8db7f732787.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f37ba6cbcfdc77e24165",
      "title": "Step 17",
      "challengeType": 20,
      "dashedName": "step-17",
      "description": "The `insert` method will be called by the user. In addition to the `self` parameter, it will also need a `key` parameter. This parameter will be the key value to insert into the binary search tree.\n\nAdd `key` as the second parameter to the function definition.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        return node\n\n--fcc-editable-region--            \n    def insert(self):\n        pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "The `insert` method should contain the `self` parameter.",
          "testCode": "({ test: () => assert.match(code, /def\\s+insert\\s*\\(\\s*self\\s*,/) });"
        },
        {
          "text": "The `insert` method should contain the `key` parameter.",
          "testCode": "({ test: () => assert.match(code, /def\\s+insert\\s*\\(\\s*self\\s*,\\s*key\\s*\\)/) });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f37ba6cbcfdc77e24165.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c4f3aee69d11dcfdbcfc00",
      "title": "Step 18",
      "challengeType": 20,
      "dashedName": "step-18",
      "description": "Now, inside the `insert` method, you need to call the helper method `_insert()` that we defined earlier. \nHere, `_insert` has encapsulated the implementation of the insertion logic. This is useful for recursion and for keeping the implementation details hidden from the user.\n\nDelete `pass` and assign `self._insert(self.root, key)` to `self.root`.\n\nNote that:\n\n- `self.root` passes the root node of the tree as the first argument. This is the starting point for the insertion process.\n- `key`: passes the `key` value you want to insert as the second argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n--fcc-editable-region--\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        pass\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `insert` method.\n\n```js\n({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"insert\").has_pass()`\n      )\n    );\n  },\n});\n\n```\n\nYou should recursively call the `_insert()` method using `self._insert()`",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");        \n    const ins = __helpers.python.getDef(\"\\n\"+transformedCode, \"insert\");\n    const {function_body} = ins;    \n    assert(function_body.match(/self\\._insert\\s*\\([^(]*\\)/));\n  }\n})"
        },
        {
          "text": "You should pass `self.root` and `key` to your `_insert()` call.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");        \n    const ins = __helpers.python.getDef(\"\\n\"+transformedCode, \"insert\");\n    const {function_body} = ins;    \n    assert(function_body.match(/self\\._insert\\s*\\(\\s*self\\.root\\s*,\\s*key\\s*\\)/));\n  }\n})"
        },
        {
          "text": "You should assign the return value of your `_insert()` call to `self.root`.",
          "testCode": "({ test: () =>\n  {\n    const transformedCode = code.replace(/\\r/g, \"\");        \n    const ins = __helpers.python.getDef(\"\\n\"+transformedCode, \"insert\");\n    const {function_body} = ins;    \n    assert(function_body.match(/^\\s{8}self\\.root\\s*=\\s*self\\._insert\\s*\\(\\s*self\\.root\\s*,\\s*key\\s*\\)/m));\n  }\n})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c4f3aee69d11dcfdbcfc00.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c63a4c4da62e9ae18e321a",
      "title": "Step 19",
      "challengeType": 20,
      "dashedName": "step-19",
      "description": "It's time to work on the search functionality. Just like you created a helper method `_insert` for the `insert` method, you need to create a helper method `_search` for the `search` method.\n\nDefine the `_search` method with three parameters, namely `self`,`node` and `key`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should declare a `_search` method. Note the leading underscore and remember to use `pass`.",
          "testCode": "({ test: () => assert.match(code, /def\\s+_search/) });"
        },
        {
          "text": "Your `_search` method should take three parameters: `self`, `node`, and `key`.",
          "testCode": "({ test: () => assert.match(code, /def\\s+_search\\(\\s*self\\s*,\\s*node\\s*,\\s*key\\s*\\)/) });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c63a4c4da62e9ae18e321a.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c63da2ed6769a10e141341",
      "title": "Step 20",
      "challengeType": 20,
      "dashedName": "step-20",
      "description": "Now you are going to define a base case for the recursive search. Remove the current `pass` and write an `if` statement that checks two conditions:\n\n- If `node` is `None`: This indicates that the search has reached the end of a branch without finding the key.\n- If `node.key == key`: This means that the key has been found in the current node.\n\nCombine the two conditions with the `or` operator and return the current node inside the `if` block.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n--fcc-editable-region--\n    def _search(self, node, key):\n        pass\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `_search` method.\n\n```js\n({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_search\").has_pass()`\n      )\n    );\n  },\n});\n\n```\n\nYou should write an `if` statement that checks if `node` is `None` or if `node.key` is equal to `key`.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}if\\s+node\\s+is\\s+None\\s+or\\s+node\\.key\\s*==\\s*key\\s*:/m) })"
        },
        {
          "text": "You should return `node` from the `if` block.",
          "testCode": "({ test: () => assert.match(code, /^(\\s{8})if\\s+node\\s+is\\s+None\\s+or\\s+node\\.key\\s*==\\s*key\\s*:\\s*^\\1\\s{4}return\\s+node/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c63da2ed6769a10e141341.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c63df529bd15a24c187c62",
      "title": "Step 21",
      "challengeType": 20,
      "dashedName": "step-21",
      "description": "Write another `if` statement that checks if the target key is less than the key of the current node.\n\nInside the `if` block, return the result of calling the `_search` method with the left child of the current node and `key` as the arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n--fcc-editable-region--\n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write another `if` statement to check if `key` < `node.key`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_search\").find_ifs()[1].find_conditions()[0].is_equivalent(\"key < node.key\")`)) })"
        },
        {
          "text": "You should return `self._search(node.left, key)` from your new `if` block.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_search\").find_ifs()[1].find_bodies()[0].is_equivalent(\"return self._search(node.left, key)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c63df529bd15a24c187c62.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c63e6962159fa372ecdbec",
      "title": "Step 22",
      "challengeType": 20,
      "dashedName": "step-22",
      "description": "If the second `if` statement is not `True`, it means that the target key is greater than or equal to the current node key. \n\nIn a binary search tree, if the target key is greater than the current node's key, the search continues in the right subtree.\n\nAfter the `if` block, return the result of calling the `_search` method with the right child of the current node and the key as arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n--fcc-editable-region--\n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should recursively call the `_search` method using `self._search()`.",
          "testCode": "const after_split = code.split('return self._search(node.left, key)')[1];\nassert.match(after_split, /self\\._search/);"
        },
        {
          "text": "You should pass two arguments to the call of the `_search` method: `node.right` and `key`.",
          "testCode": "({ test: () => assert.match(code, /self\\._search\\(\\s*node\\.right\\s*,\\s*key\\s*\\)/) });"
        },
        {
          "text": "You should return the result of the `_search` method call.",
          "testCode": "({\n  test: () => assert.match(code, /return\\s+self\\._search\\(\\s*node\\.right\\s*,\\s*key\\s*\\)/)\n});"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c63e6962159fa372ecdbec.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c63eb01b9563a4b8a046b6",
      "title": "Step 23",
      "challengeType": 20,
      "dashedName": "step-23",
      "description": "Next, define the method named `search` inside the `BinarySearchTree` class. Give the `search` method two parameters: `self` and `key`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n        \n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method named `search`. Remember the `pass` keyword.",
          "testCode": "({ test: () => assert.match(code, /def\\s+search/) });"
        },
        {
          "text": "The `search` method should take two parameters: `self` and `key`.",
          "testCode": "({ test: () => assert.match(code, /def\\s+search\\(\\s*self\\s*,\\s*key\\s*\\)/) });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c63eb01b9563a4b8a046b6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c63fd9b387f0a6c5bf6a72",
      "title": "Step 24",
      "challengeType": 20,
      "dashedName": "step-24",
      "description": "Inside the `search` method, delete `pass` and call the helper method `_search` with the following arguments.\n\n- `self.root`: This is the root of the binary search tree. The search starts from the root.\n- `key`: This is the value that the user wants to find in the binary search tree.\n\nInternally, `search` delegates the actual search logic to the `_search` helper method that performs the actual recursive search within the binary search tree.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n--fcc-editable-region--\n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        pass\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `search` method.\n\n```js\n({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"search\").has_pass()`\n      )\n    );\n  },\n});\n\n```\n\nYou should call the `_search` method within the `search` method.",
          "testCode": "({ test: () => assert(runPython(`\n  str(_Node(_code).find_class(\"BinarySearchTree\").find_function(\"search\").find_calls(\"_search\")[0]).startswith(\"self._search(\")\n`)) });"
        },
        {
          "text": "You should call the `_search` method passing `self.root` and `key` as the arguments.",
          "testCode": "({ test: () => assert(runPython(`\n  _Node(_code).find_class(\"BinarySearchTree\").find_function(\"search\").find_calls(\"_search\")[0].is_equivalent(\"self._search(self.root, key)\")\n`)) });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c63fd9b387f0a6c5bf6a72.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c64057a080baa7d60523ed",
      "title": "Step 25",
      "challengeType": 20,
      "dashedName": "step-25",
      "description": "Now, make the `search` method return the result of the `_search()` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n--fcc-editable-region--\n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        self._search(self.root, key)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should prepend the `return` statement to your `_search()` call.",
          "testCode": "({ test: () => assert.match(code, /return\\s+self\\._search\\(\\s*self\\.root\\s*,\\s*key\\s*\\)/) });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c64057a080baa7d60523ed.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c6409418806da8d0636ffc",
      "title": "Step 26",
      "challengeType": 20,
      "dashedName": "step-26",
      "description": "The `insert` and `search` functionalities are complete, it's time to test them.\n\nNote that, at this point, the nodes are not sorted and just inserted. You'll work on sorting using inorder traversal later on.\n\nYou can create an instance of a class in Python like this:\n\n```python\nobject_name = ClassName()\n```\n\nOutside the class definitions, create an instance of the `BinarySearchTree` class and assign it to the variable `bst`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an instance of the `BinarySearchTree` class.",
          "testCode": "assert.match(code, /BinarySearchTree\\(\\s*\\)/);"
        },
        {
          "text": "You should assign the new instance of `BinarySearchTree` to the variable `bst`.",
          "testCode": "assert.match(code, /bst\\s*=\\s*BinarySearchTree\\(\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c6409418806da8d0636ffc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c644829cfb63acf3479d09",
      "title": "Step 28",
      "challengeType": 20,
      "dashedName": "step-28",
      "description": "Insert the nodes in the list `nodes` into the `bst` instance by iterating over the list and calling the `insert` method on each node in the list. Use `node` as the iteration variable.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have a `for node in nodes` loop.",
          "testCode": "({ test: () => (runPython(`assert _Node(_code).find_for_loops()[0].find_for_vars().is_equivalent(\"node\") and _Node(_code).find_for_loops()[0].find_for_iter().is_equivalent(\"nodes\")`)) });"
        },
        {
          "text": "You should have `bst.insert(node)` inside the `for` loop.",
          "testCode": "({ test: () => (runPython(`assert _Node(_code).find_for(\"node\", \"nodes\").find_body().is_equivalent(\"bst.insert(node)\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c644829cfb63acf3479d09.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c645b838e7deb080fc25e0",
      "title": "Step 29",
      "challengeType": 20,
      "dashedName": "step-29",
      "description": "Now, the nodes have been inserted. To see if they have been correctly inserted, you can search for a node in the tree.\n\nOutside the for loop, search for node `80` in the `bst` instance and add it to a `print` call. Also the first argument of the `print` function should be the `'Search for 80:'`",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should print the result of calling `bst.search(80)` and your `print` statement should have the first argument as `'Search for 80:'`.",
          "testCode": "assert.match(code, /^print\\(('|\")Search for 80:('|\"),\\s*bst\\.search\\(80\\)/gm);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c645b838e7deb080fc25e0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c646d4148ae3b2d1cbcac4",
      "title": "Step 30",
      "challengeType": 20,
      "dashedName": "step-30",
      "description": "Note that, your search returns something like `80: <__main__.TreeNode object at 0x108b3e0>`. This is the default string representation when printing an instance of a class.\n\nTo change that to print a useful value, define another method named `__str__` in the `TreeNode` class. It takes a single argument `self`.\n\nAfter defining `__str__` you'll get an exception in the console because the `__str__` method doesn't return anything yet. You'll work on the method body in the next step.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\nprint('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method `__str__` that takes a single argument `self`. Remember to use `pass`.",
          "testCode": "assert.match(code, /^(\\s+)def\\s+__init__.+?^\\1def\\s+__str__\\(\\s*self\\s*\\)\\s*:\\s*\\n^\\1\\1pass/ms)"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c646d4148ae3b2d1cbcac4.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c9ddd336596e30a4266a50",
      "title": "Step 31",
      "challengeType": 20,
      "dashedName": "step-31",
      "description": "In the body of the `__str__` method, delete `pass` and return the result of calling the `str()` function with `self.key` as the argument.  This is the attribute of the current node object that stores the value associated with the node.\n\nAfter returning the result, you should see the exception disappear from the console and the output should now display the value of the `key` associated with the node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n--fcc-editable-region--\n    def __str__(self):\n        pass\n\n--fcc-editable-region--\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\nprint('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `__str__` method.\n\n```js\n({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"TreeNode\").find_function(\"__str__\").has_pass()`\n      )\n    );\n  },\n});\n\n```\n\nYou should return the string value of `self.key` from your `__str__` method.",
          "testCode": "({ test: () => assert.match(code, /^\\s{8}return\\s+str\\(\\s*self\\.key\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c9ddd336596e30a4266a50.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65c9de201959f73591b606e6",
      "title": "Step 32",
      "challengeType": 20,
      "dashedName": "step-32",
      "description": "As you can see, now you get a readable output in the console.\n\nNow, comment out the `print` call.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n--fcc-editable-region--\n\nprint('Search for 80:', bst.search(80))\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should comment out the line `print('Search for 80:', bst.search(80))`",
          "testCode": "assert(code.match(/#\\s*print\\s*\\(\\s*'Search\\s*for\\s*80:\\s*',\\s*bst\\.search\\s*\\(\\s*80\\s*\\)\\s*\\)/));"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65c9de201959f73591b606e6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca03bd8eb5faf24b250c56",
      "title": "Step 33",
      "challengeType": 20,
      "dashedName": "step-33",
      "description": "The next step is to work on the deletion of nodes.\nFor that, you would follow the same approach by first defining a helper method and then the actual method.\n\nInside the `BinarySearchTree` class, define a new helper method called `_delete`  that takes three parameters: `self`, `node`, and `key`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define the `_delete` method inside the `BinarySearchTree` class with the parameters `self`, `node` and `key`. Remember to use the `pass` keyword.",
          "testCode": "({ test: () => assert.match(code, /def\\s+_delete\\(\\s*self\\s*,\\s*node\\s*,\\s*key\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca03bd8eb5faf24b250c56.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca05f7cba1e6fe70527534",
      "title": "Step 34",
      "challengeType": 20,
      "dashedName": "step-34",
      "description": "Inside your `_delete` method, replace `pass` with an `if` statement that checks if the current `node` is `None`.\n\nWhen the current node is `None`, the key to be deleted was not found. Therefore, return `node` from your `if` block.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        pass\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `_delete` method.\n\n```js\n({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_delete\").has_pass()`\n      )\n    );\n  },\n});\n\n```\n\nYou should write an `if` statement that checks if the current `node` is `None`.",
          "testCode": "const after_split = code.split('def _delete(self, node, key):')[1];\nassert.match(after_split, /if\\s+node\\s+is\\s+None/);"
        },
        {
          "text": "You should return `node` inside your `if` block.",
          "testCode": "const after_split = code.split('def _delete(self, node, key):')[1];\nassert.match(after_split, /return\\s+node/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca05f7cba1e6fe70527534.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca06475e9b8aff8ea5a5f1",
      "title": "Step 35",
      "challengeType": 20,
      "dashedName": "step-35",
      "description": "After your existing `if`, write another one that checks if the target key is less than the current node key.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have an `if` condition that checks if `key` is less than `node.key`. Remember to use `pass`.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_delete\").find_ifs()[1].find_conditions()[0].is_equivalent(\"key < node.key\")`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca06475e9b8aff8ea5a5f1.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca06864129380054b55dc0",
      "title": "Step 36",
      "challengeType": 20,
      "dashedName": "step-36",
      "description": "Within the `if` block, replace `pass` with a call to the `_delete` method, passing the left child of the current node and the `key` as arguments. Assign the function call to the left node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            pass\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `if` statement.",
          "testCode": "({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_delete\").find_if(\"key < node.key\").find_bodies()[0].has_pass()`\n      )\n    );\n  },\n});"
        },
        {
          "text": "You should call the `_delete` method with `node.left` and the `key` as the arguments.",
          "testCode": "assert.match(code, /self\\._delete\\(\\s*node\\.left\\s*,\\s*key\\s*\\)/);"
        },
        {
          "text": "You should assign the result of the `_delete()` call to the left child (`node.left`) of the current node.",
          "testCode": "assert.match(code, /node\\.left\\s*=\\s*self\\._delete\\(\\s*node\\.left\\s*,\\s*key\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca06864129380054b55dc0.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca06c9f918730107c9908d",
      "title": "Step 37",
      "challengeType": 20,
      "dashedName": "step-37",
      "description": "Write an `elif` statement that checks if `key > node.key`.\n\nInside your `elif` block, call the `_delete` method with the right child of the current node and `key` as the arguments and assign the result to the right node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should write an `elif` statement that checks if `key > node.key`.",
          "testCode": "const after_split = code.split('def _delete(self, node, key):')[1];\nassert.match(after_split, /elif\\s+key\\s+>\\s+node\\.key/);"
        },
        {
          "text": "You should call the `_delete` method with `node.right` and `key` as the arguments.",
          "testCode": "assert.match(code, /self\\._delete\\(\\s*node\\.right\\s*,\\s*key\\s*\\)/);"
        },
        {
          "text": "You should assign the result of the `_delete()` call to `node.right`.",
          "testCode": "assert.match(code, /node\\.right\\s*=\\s*self\\._delete\\(\\s*node\\.right\\s*,\\s*key\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca06c9f918730107c9908d.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca071d5921760254949f76",
      "title": "Step 38",
      "challengeType": 20,
      "dashedName": "step-38",
      "description": "The conditionals you wrote in the previous steps are valid for nodes with either zero or one child. The upcoming conditionals will be valid if there are 2 children.\n\nFor that, add an `else` clause to the conditional.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n            \n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should add an `else` clause. Remember to use the `pass` keyword.",
          "testCode": "({ test: () => assert(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_delete\").find_ifs()[1].find_conditions()[2].tree is None`)) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca071d5921760254949f76.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca075e3184180309f4c1d9",
      "title": "Step 39",
      "challengeType": 20,
      "dashedName": "step-39",
      "description": "Inside the `else` block, replace `pass` with an `if` statement to check if the left child of the current node is `None`.\n\nWhen `node.left` is `None`, there is no left child. Therefore, return the right child from the new `if` block as a replacement.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            pass   \n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `else` block.",
          "testCode": "({\n  test: () => {\n    const pyClassStr = runPython(\n      `str(_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_delete\"))`\n    );\n    assert.notInclude(pyClassStr, \"pass\");\n  },\n});"
        },
        {
          "text": "You should write an `if` statement that checks if `node.left` is `None`.",
          "testCode": "assert.match(code, /if\\s+node\\.left\\s*is\\s*None/);"
        },
        {
          "text": "You should return the right child of the current node.",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca075e3184180309f4c1d9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca0794ec3ed103bca67ed7",
      "title": "Step 40",
      "challengeType": 20,
      "dashedName": "step-40",
      "description": "Below the `if` statement, add an `elif` clause to check if the right child of the current node (`node.right`) is `None`.\n\nIf the previous condition is met, it means there is no right child. So, return the left child of the current node from the `elif` block as a replacement.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n    \n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should create an `elif` statement that checks if the right child of the current node is `None`.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_delete\").find_ifs()[1].find_conditions()[3].is_equivalent(\"node.right is None\")`))})"
        },
        {
          "text": "You should return the left child of the current node.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_delete\").find_ifs()[1].find_bodies()[3].is_equivalent(\"return node.left\")`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca0794ec3ed103bca67ed7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca07dd6fa8840491b7a5cd",
      "title": "Step 41",
      "challengeType": 20,
      "dashedName": "step-41",
      "description": "If neither one of the previous conditions is met, it means the node has both left and right children.\n\nTo choose the successor, you need to find the minimum value in the right subtree.\nThe smallest value will be the in-order successor of the current node.\n\nTo find the smallest value, create a helper function `_min_value` that takes two parameters: `self` and `node`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n--fcc-editable-region--\n    \n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n    \n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define the `_min_value` method with `self` and `node` as the parameters. Remember to use the `pass` keyword.",
          "testCode": "({ test: () => assert.match(code, /def\\s+_min_value\\(\\s*self\\s*,\\s*node\\s*\\)\\s*:/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca07dd6fa8840491b7a5cd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca085a19adaa057302a3d6",
      "title": "Step 43",
      "challengeType": 20,
      "dashedName": "step-43",
      "description": "Inside the `while` loop body, replace `pass` with `node` and assign it the left child of the node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left    \n             \n--fcc-editable-region--\n    def _min_value(self, node):\n        while node.left is not None:\n            pass\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `while` loop.\n\n```js\n({\n  test: () => {\n    const pyClassStr = runPython(\n      `str(_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_min_value\"))`\n    );\n    assert.notInclude(pyClassStr, \"pass\");\n  },\n});\n\n```\n\nYou should assign `node.left` to `node` inside your `while` loop.",
          "testCode": "({ test: () => assert.match(code, /node\\s*=\\s*node\\.left/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca085a19adaa057302a3d6.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca089e848eca0672b9cd77",
      "title": "Step 45",
      "challengeType": 20,
      "dashedName": "step-45",
      "description": "Now, back to the `_delete` method, you have to choose the successor, using the `_min_value` helper function.\n\nAdd a `_min_value` call after your `elif` block, passing `node.right` as the argument. Assign it to the current node key.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n--fcc-editable-region--\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should assign `self._min_value(node.right)` to `node.key` after your `elif` block.\n\n```js\n({ test: () => (runPython(`\nimport ast\n\nassign_after_elif = _Node(_code).find_class(\"BinarySearchTree\").find_function(\"_delete\").find_ifs()[1].tree.orelse[0].orelse[1]\nassign_code = ast.get_source_segment(_code, assign_after_elif)\nassert _Node(assign_code).is_equivalent(\"node.key = self._min_value(node.right)\")`)) })\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca089e848eca0672b9cd77.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca0a1f27596a089b0363b9",
      "title": "Step 49",
      "challengeType": 20,
      "dashedName": "step-49",
      "description": "Inside the `delete` method, delete `pass` and call the helper method `_delete` with the root of the Binary Search Tree and the key to delete as the arguments.\n\nAlso, assign the result of  the `_delete` method to `self.root` in the `delete` method.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n    \n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n        \n--fcc-editable-region--\n    def delete(self, key):\n        pass        \n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `delete` method.",
          "testCode": "({ test: () => {\n  assert.isFalse(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"delete\").has_pass()`))\n}})"
        },
        {
          "text": "Your `delete` method should call the `_delete` method with two arguments: `self.root` and `key`.",
          "testCode": "({ test: () => assert.match(code, /self\\._delete\\(\\s*self\\.root\\s*,\\s*key\\s*\\)/) });"
        },
        {
          "text": "You should assign the result of the `_delete` method to `self.root` in the `delete` method.",
          "testCode": "const after_split = code.split('def delete(self, key):')[1];\nassert.match(after_split, /self\\.root\\s*=\\s*self\\._delete\\(self\\.root,\\s*key\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca0a1f27596a089b0363b9.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca0d5adf39c410cd1177cc",
      "title": "Step 50",
      "challengeType": 20,
      "dashedName": "step-50",
      "description": "Now, you'll work on traversing the tree based on the in-order traversal method. In-order traversal is a depth-first binary tree traversal algorithm that visits the left subtree, the current node, and then the right subtree.\n\nDefine the `_inorder_traversal` method within the `BinarySearchTree` class and give it three parameters: `self`, `node` and `result`. Where `node` is the current node being considered during the traversal and `result` is the list to which the keys are appended in sorted order.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a method `_inorder_traversal` that takes three parameters: `self`, `node`, and `result`. Remember to use `pass`.",
          "testCode": "assert.match(code, /def\\s+_inorder_traversal\\(\\s*self\\s*,\\s*node\\s*,\\s*result\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca0d5adf39c410cd1177cc.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca0dc5dbf42a11c3cf1098",
      "title": "Step 51",
      "challengeType": 20,
      "dashedName": "step-51",
      "description": "Replace `pass` with an `if` statement that checks if the current node (`node`) is not empty. Then, recursively call `_inorder_traversal` with `node.left` and `result` as the arguments.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n--fcc-editable-region--\n    def _inorder_traversal(self, node, result):\n        pass\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the existing `pass` keyword from the `_inorder_traversal` method.\n\n```js\n({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_inorder_traversal\").has_pass()`\n      )\n    );\n  },\n});\n\n```\n\nYour check condition should be `if node`.",
          "testCode": "assert.match(code, /if\\s+node:/);"
        },
        {
          "text": "You should call `_inorder_traversal` on the `node.left` inside the `if` block.",
          "testCode": "assert.match(code, /self\\._inorder_traversal\\(\\s*node\\.left\\s*,\\s*result\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca0dc5dbf42a11c3cf1098.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca0dfaea3f4112afde6e26",
      "title": "Step 52",
      "challengeType": 20,
      "dashedName": "step-52",
      "description": "Still inside the `if` block, append the `key` of the current node to the `result` list.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n--fcc-editable-region--\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result) \n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n    \n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should append `node.key` to the `result` list.",
          "testCode": "assert.match(code, /result\\.append\\(\\s*node\\.key\\s*\\)/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca0dfaea3f4112afde6e26.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca0e2d05557a13a40b1243",
      "title": "Step 53",
      "challengeType": 20,
      "dashedName": "step-53",
      "description": "Finally, recursively call the `_inorder_traversal` method on the right child of the current node.\n\nThis recursive call explores the entire right subtree in an in-order manner.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n--fcc-editable-region--\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n    \n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `_inorder_traversal` passing `node.right` and `result` as the arguments.",
          "testCode": "({test: () => assert(runPython(`_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_inorder_traversal\").find_ifs()[0].find_bodies()[0].find_body()[2].is_equivalent(\"self._inorder_traversal(node.right, result)\")`))})"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca0e2d05557a13a40b1243.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca0e8eb2c9c215269d6a66",
      "title": "Step 54",
      "challengeType": 20,
      "dashedName": "step-54",
      "description": "The `inorder_traversal` method is responsible for performing an in-order traversal of the binary search tree. It returns the keys of the nodes in sorted order. It will use the helper method `_inorder_traversal` to achieve this.\n\nCreate an `inorder_traversal` method that takes `self` as the only parameter.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define an `inorder_traversal` method that takes `self` as the parameter. Remember to use `pass`.",
          "testCode": "({ test: () => assert.match(code, /def\\s+inorder_traversal\\(\\s*self\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca0e8eb2c9c215269d6a66.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca1181e5b9b41c47632127",
      "title": "Step 55",
      "challengeType": 20,
      "dashedName": "step-55",
      "description": "Inside the `inorder_traversal` method, replace `pass` with an empty list named `result` that will store the keys of the nodes in sorted order.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n--fcc-editable-region--\n    def inorder_traversal(self):\n        pass\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should remove the `pass` keyword from the `inorder_traversal` method.",
          "testCode": "({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"inorder_traversal\").has_pass()`\n      )\n    );\n  },\n});"
        },
        {
          "text": "You should initialize an empty list named `result` inside the method.",
          "testCode": "({ test: () => assert.match(code, /result\\s*=\\s*\\[\\s*\\]/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca1181e5b9b41c47632127.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca11a86801bc1d254da83c",
      "title": "Step 56",
      "challengeType": 20,
      "dashedName": "step-56",
      "description": "Within the `inorder_traversal` method, start the in-order traversal by calling the helper method `_inorder_traversal` and pass the BST root and the `result` list as the arguments.\n\nThis will start the traversal from the root of the binary search tree (`self.root`), and the `result` list will be passed to accumulate the keys during the traversal.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n--fcc-editable-region--\n    def inorder_traversal(self):\n        result = []\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n    \n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `_inorder_traversal` and pass `self.root` and `result` as the arguments.",
          "testCode": "({ test: () => assert.match(code, /self\\._inorder_traversal\\(\\s*self\\.root\\s*,\\s*result\\s*\\)/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca11a86801bc1d254da83c.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca11d8f3e8a71de41d0e32",
      "title": "Step 57",
      "challengeType": 20,
      "dashedName": "step-57",
      "description": "Finally, return the sorted list of keys.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n--fcc-editable-region--\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n    \n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return the `result` list from your `inorder_traversal` method.",
          "testCode": "assert.match(code, /return\\s+result/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca11d8f3e8a71de41d0e32.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca120111bd521ea8b73e75",
      "title": "Step 58",
      "challengeType": 20,
      "dashedName": "step-58",
      "description": "Now it's time to put everything into use. Uncomment the given line of code.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n        return result\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n--fcc-editable-region--\n    \n# print('Search for 80:', bst.search(80))\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should uncomment the `print('Search for 80:', bst.search(80))` line.",
          "testCode": "assert.match(code, /^print\\(\\s*'Search\\s*for\\s*80:\\s*',\\s*bst\\.search\\(\\s*80\\s*\\)\\s*\\)/m);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca120111bd521ea8b73e75.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca294e05dc032bf8922dc7",
      "title": "Step 59",
      "challengeType": 20,
      "dashedName": "step-59",
      "description": "Below the `print()` call, call the `print()` function again and pass it the string `'Inorder traversal:'` as the first argument and the `bst.inorder_traversal()` call as the second argument to print the result of the inorder traversal.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n        return result\n\n--fcc-editable-region--\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\nprint('Search for 80:', bst.search(80))\n    \n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call `print()` and pass the string `'Inorder traversal:'` and the `bst.inorder_traversal()` call as the arguments.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*(\"|')Inorder traversal:\\1\\s*,\\s*bst\\.inorder_traversal\\s*\\(\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca294e05dc032bf8922dc7.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca29b3a07d662de018ac13",
      "title": "Step 60",
      "challengeType": 20,
      "dashedName": "step-60",
      "description": "Next, call the `delete` method of `bst` and delete `40` from the binary search tree.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n        return result\n\n--fcc-editable-region--\nbst = BinarySearchTree()\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\nprint('Search for 80:', bst.search(80))\n\nprint(\"Inorder traversal:\", bst.inorder_traversal())\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `delete` method of `bst` passing `40` as the argument.",
          "testCode": "({ test: () => assert.match(code, /print\\s*\\(.*\\)\\s*^bst\\.delete\\s*\\(\\s*40\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca29b3a07d662de018ac13.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca2a18039c942f04ddde83",
      "title": "Step 61",
      "challengeType": 20,
      "dashedName": "step-61",
      "description": "Confirm that `40` has been deleted.\n\nCall `print()` by passing the string `'Search for 40:'` as the first argument and an `bst.search(40)` call as the second argument.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n        return result\n\n--fcc-editable-region--\nbst = BinarySearchTree()\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\nprint('Search for 80:', bst.search(80))\n\nprint(\"Inorder traversal:\", bst.inorder_traversal())\n\nbst.delete(40)\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should have `print('Search for 40:', bst.search(40))` in your code.",
          "testCode": "({ test: () => assert.match(code, /^print\\(\\s*(\"|')Search for 40:(\"|')\\s*,\\s*bst\\.search\\(\\s*40\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca2a18039c942f04ddde83.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65ca2a52d579b22feb89177f",
      "title": "Step 62",
      "challengeType": 20,
      "dashedName": "step-62",
      "description": "As a last step, print the whole tree.\n\nCall `print()` by passing the string `'Inorder traversal after deleting 40:'` as the first argument and an `inorder_traversal()` call as the second argument.\n\nWith this, you have finished the implementation of the binary search tree. Great work!",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left   \n            \n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)   \n        \n        return node\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n        return result\n\n--fcc-editable-region--\nbst = BinarySearchTree()\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\nprint('Search for 80:', bst.search(80))\n\nprint(\"Inorder traversal:\", bst.inorder_traversal())\n\nbst.delete(40)\n\nprint(\"Search for 40:\", bst.search(40))\n\n--fcc-editable-region--"
        }
      ],
      "solution": [
        {
          "language": "py",
          "code": "class TreeNode:\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\n\nclass BinarySearchTree:\n    def __init__(self):\n        self.root = None\n\n    def insert(self,key):\n        self.root = self._insert(self.root, key)\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n            node.right = self._insert(node.right, key)\n        return node\n\n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n\n    def delete(self, key):\n        self.root = self._delete(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.key = self._min_value(node.right)\n            node.right = self._delete(node.right, node.key)\n        return node\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n\n    def inorder_traversal(self):\n        result = []\n        self._inorder_traversal(self.root, result)\n        return result\n\n    def _inorder_traversal(self, node, result):\n        if node:\n            self._inorder_traversal(node.left, result)\n            result.append(node.key)\n            self._inorder_traversal(node.right, result)\n\n\nbst = BinarySearchTree()\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\nprint(\"Inorder traversal:\", bst.inorder_traversal())\n\nprint(\"Search for 40:\", bst.search(40))\n\nbst.delete(40)\n\nprint(\"Search for 40:\", bst.search(40))\n\nprint(\"Inorder traversal after deleting 40:\", bst.inorder_traversal())"
        }
      ],
      "tests": [
        {
          "text": "You should call `print` passing the string `'Inorder traversal after deleting 40:'` as the first argument and an `inorder_traversal()` call as the second argument.",
          "testCode": "({ test: () => assert.match(code, /^print\\s*\\(\\s*(\"|')Inorder traversal after deleting 40:\\1\\s*,\\s*bst\\.inorder_traversal\\s*\\(\\s*\\)\\s*\\)/m) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65ca2a52d579b22feb89177f.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65cb45d130c97cb459439fac",
      "title": "Step 42",
      "challengeType": 20,
      "dashedName": "step-42",
      "description": "To find the smallest value in the right subtree, you need to iterate through the left children of the given node until you reach the leftmost (smallest) node in the subtree.\n\nTo do this, write a `while` loop that runs when `node.left is not None` and move `pass` inside the `while` block. This condition checks if there is a left child. As long as there is a left child, the loop continues and there is a smaller value to be found.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left  \n\n--fcc-editable-region--\n    def _min_value(self, node):\n        pass\n\n--fcc-editable-region--   \n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "you should remove the `pass` keyword from the `_min_value` method.",
          "testCode": "({\n  test: () => {\n    assert.isFalse(\n      runPython(\n        `_Node(_code).find_class(\"BinarySearchTree\").find_function(\"_min_value\").has_pass()`\n      )\n    );\n  },\n});"
        },
        {
          "text": "You should use the condition `node.left is not None` in the `while` loop.",
          "testCode": "({ test: () => assert.match(code, /while\\s+node\\.left\\s+is\\s+not\\s+None\\s*:/) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65cb45d130c97cb459439fac.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65d8a6fcb15a3a239ba35dfd",
      "title": "Step 46",
      "challengeType": 20,
      "dashedName": "step-46",
      "description": "After finding the minimum value, you will need to recursively delete the node with the minimum value from the right subtree.\n\nThis step ensures that the node with the minimum value is removed from the tree while maintaining the binary search tree (BST) property.\n\nCall the `_delete` method recursively with `node.right` and `node.key` as the arguments. Assign the return value of the `_delete()` call to the right child of the current node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.key = self._min_value(node.right) \n            \n--fcc-editable-region--\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should call the `_delete` method recursively with `node.right` and `node.key` as the arguments.",
          "testCode": "assert.match(code, /self\\._delete\\(\\s*node\\.right\\s*,\\s*node\\.key\\s*/);"
        },
        {
          "text": "You should assign the return value of the `_delete()` call to the right child of the current node.",
          "testCode": "assert.match(code, /node\\.right\\s*=\\s*self\\._delete\\(\\s*node\\.right\\s*,\\s*node\\.key/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65d8a6fcb15a3a239ba35dfd.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65d8a8773c816a273653fd0e",
      "title": "Step 47",
      "challengeType": 20,
      "dashedName": "step-47",
      "description": "Finally, after your `else` clause, return the current node.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.key = self._min_value(node.right) \n            node.right = self._delete(node.right, node.key)\n\n--fcc-editable-region--\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n\n# bst = BinarySearchTree()\n\n# nodes = [50, 30, 20, 40, 70, 60, 80]\n\n# for node in nodes:\n#    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should return the current node after the `else` clause.",
          "testCode": "({ test: () => assert.match(code, /^(\\s+)else\\s*:.+?^\\1return\\s+node/ms) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65d8a8773c816a273653fd0e.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65d8a90640d40c2927ebbd94",
      "title": "Step 48",
      "challengeType": 20,
      "dashedName": "step-48",
      "description": "Next, you'll work on the delete method.\n\nWithin the `BinarySearchTree` class, define a `delete` method. It takes two parameters: `self` and `key`.\n\n`key` is the value that the user wants to delete from the binary search tree.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key)\n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left\n\n            node.key = self._min_value(node.right) \n            node.right = self._delete(node.right, node.key)\n        return node\n\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n        return node.key\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "You should define a `delete` method with two parameters: `self` and `key`. Remember to use `pass`.",
          "testCode": "({ test: () => assert.match(code, /def\\s+delete\\(\\s*self\\s*,\\s*key\\s*\\)/) });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65d8a90640d40c2927ebbd94.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65d8b58074495d3f94977dca",
      "title": "Step 44",
      "challengeType": 20,
      "dashedName": "step-44",
      "description": "Once the leftmost node is found (that is, when `node.left` becomes `None`), the loop exits.\n\nAfter the `while` loop, return the key of the leftmost node, which represents the minimum value in the given subtree.\n\nWith this, you are able to get the value that will replace the node after it is deleted.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n    def __str__(self):\n        return str(self.key)\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n    def _delete(self, node, key):\n        if node is None:\n            return node\n        if key < node.key:\n            node.left = self._delete(node.left, key)\n        elif key > node.key:\n            node.right = self._delete(node.right, key) \n        else:\n            if node.left is None:\n                return node.right\n            elif node.right is None:\n                return node.left    \n             \n--fcc-editable-region--\n    def _min_value(self, node):\n        while node.left is not None:\n            node = node.left\n\n--fcc-editable-region--\n\nbst = BinarySearchTree()\n\nnodes = [50, 30, 20, 40, 70, 60, 80]\n\nfor node in nodes:\n    bst.insert(node)\n\n# print('Search for 80:', bst.search(80))"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "After the `while` loop, return `node.key` as the result of the function.",
          "testCode": "({ test: () => assert.match(code, /^(\\s+)while.*:.+?^\\1return\\s+node\\.key/ms) })"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65d8b58074495d3f94977dca.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    },
    {
      "id": "65f97131a0709033d6911558",
      "title": "Step 27",
      "challengeType": 20,
      "dashedName": "step-27",
      "description": "Create a list named `nodes` with values `50, 30, 20, 40, 70, 60, 80`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "py",
          "code": "class TreeNode:\n\n    def __init__(self, key):\n        self.key = key\n        self.left = None\n        self.right = None\n\n\nclass BinarySearchTree:\n\n    def __init__(self):\n        self.root = None\n\n    def _insert(self, node, key):\n        if node is None:\n            return TreeNode(key)\n\n        if key < node.key:\n            node.left = self._insert(node.left, key)\n        elif key > node.key:\n\n            node.right = self._insert(node.right, key)\n        return node\n\n    def insert(self, key):\n        self.root = self._insert(self.root, key)\n        \n    def _search(self, node, key):\n        if node is None or node.key == key:\n            return node\n        if key < node.key:\n            return self._search(node.left, key)\n        return self._search(node.right, key)\n    \n    def search(self, key):\n        return self._search(self.root, key)\n\n--fcc-editable-region--\nbst = BinarySearchTree()\n\n\n--fcc-editable-region--"
        }
      ],
      "solution": [],
      "tests": [
        {
          "text": "Your list should have the values `50, 30, 20, 40, 70, 60, 80`.",
          "testCode": "assert.match(code, /\\s*\\[50,\\s*30,\\s*20,\\s*40,\\s*70,\\s*60,\\s*80\\]/);"
        },
        {
          "text": "Your list should be assigned to nodes.",
          "testCode": "assert.match(code, /nodes\\s*=\\s*\\[50,\\s*30,\\s*20,\\s*40,\\s*70,\\s*60,\\s*80\\]/);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": "",
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\07-scientific-computing-with-python\\learn-tree-traversal-by-building-a-binary-search-tree\\65f97131a0709033d6911558.md"
      },
      "section": {
        "id": "07-scientific-computing-with-python",
        "name": "07-scientific-computing-with-python"
      },
      "lesson": {
        "id": "learn-tree-traversal-by-building-a-binary-search-tree",
        "name": "Learn Tree Traversal By Building A Binary Search Tree"
      }
    }
  ],
  "metadata": {
    "total_challenges": 759,
    "challenges_with_content": 759
  }
}