{
  "title": "Learn Functional Programming By Building A Spreadsheet",
  "description": "A project-based course on javascript imported from freeCodeCamp.",
  "language": "javascript",
  "lessons": [
    {
      "title": "Step 1",
      "description": "Your project starts with a basic HTML container and some corresponding CSS. Your first task will be to programmatically generate the cells for your spreadsheet.\n\nThe global `window` object represents the browser window (or tab). It has an `onload` property which allows you to define behavior when the window has loaded the entire page, including stylesheets and scripts.\n\nStart by setting the `onload` property of `window` to an arrow function with no parameters. In the function, declare a `container` variable and assign it the value of getting the element by the `id` of `\"container\"`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should access the `onload` property of the `window` object.\n\n```js\nassert.match(code, /window\\.onload/);\n```\n\nYou should set the `onload` property to a function.\n\n```js\nassert.isFunction(window.onload);\n```\n\nYou should use arrow syntax.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(/);\n```\n\nYour `onload` function should not take any parameters.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)/);\n```\n\nYou should declare a `container` variable in your `onload` function.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*(?:let|var|const)\\s+container/);\n```\n\nYour `container` variable should be declared with `const`.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*const\\s+container/);\n```\n\nYou should use `document.getElementById()`\n\n```js\nassert.match(code, /document\\.getElementById\\(/);\n```\n\nYou should get the element with the `id` of `\"container\"`.\n\n```js\nassert.match(code, /document\\.getElementById\\(\\s*('|\"|`)container\\1\\s*\\)/);\n```\n\nYou should assign the `#container` element to `container`.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*const\\s+container\\s*=\\s*document\\.getElementById\\(\\s*('|\"|`)container\\1\\s*\\)/);\n```"
    },
    {
      "title": "Step 2",
      "description": "Functions are ideal for reusable logic. When a function itself needs to reuse logic, you can declare a nested function to handle that logic. Here is an example of a nested function:\n\n```js\nconst outer = () => {\n  const inner = () => {\n\n  };\n};\n```\n\nDeclare a nested `createLabel` function using arrow syntax. It should take a `name` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should declare a `createLabel` variable in your `onload` function.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*(?:const\\s+container\\s*=\\s*document\\.getElementById\\(\\s*('|\"|`)container\\1\\s*\\)\\s*;?)?\\s*(?:let|var|const)\\s+createLabel/);\n```\n\nYour `createLabel` variable should be declared after your `container` variable.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*const\\s+container\\s*=\\s*document\\.getElementById\\(\\s*('|\"|`)container\\1\\s*\\)\\s*;?\\s*(?:let|var|const)\\s+createLabel/);\n```\n\nYour `createLabel` variable should be declared with `const`.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*const\\s+container\\s*=\\s*document\\.getElementById\\(\\s*('|\"|`)container\\1\\s*\\)\\s*;?\\s*const\\s+createLabel/);\n```\n\nYour `createLabel` variable should be an arrow function.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*const\\s+container\\s*=\\s*document\\.getElementById\\(\\s*('|\"|`)container\\1\\s*\\)\\s*;?\\s*const\\s+createLabel\\s*=\\s*(\\(.*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `createLabel` function should have a `name` parameter.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*const\\s+container\\s*=\\s*document\\.getElementById\\(\\s*('|\"|`)container\\1\\s*\\)\\s*;?\\s*const\\s+createLabel\\s*=\\s*(\\(\\s*name\\s*\\)|name)\\s*=>/);\n```\n\nYour `createLabel` function should be empty.\n\n```js\nassert.match(code, /window\\.onload\\s*=\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*const\\s+container\\s*=\\s*document\\.getElementById\\(\\s*('|\"|`)container\\1\\s*\\)\\s*;?\\s*const\\s+createLabel\\s*=\\s*(\\(\\s*name\\s*\\)|name)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 3",
      "description": "Remember that the `document` object has a `.createElement()` method which allows you to dynamically create new HTML elements.\n\nIn your `createLabel` function, declare a `label` variable and assign it a new `div` element.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n\n  }\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should declare a `label` variable in your `createLabel` function.\n\n```js\nassert.match(code, /const\\s+createLabel\\s*=\\s*(\\(\\s*name\\s*\\)|name)\\s*=>\\s*\\{\\s*(?:const|let|var)\\s+label/);\n```\n\nYour `label` variable should be declared with `const`.\n\n```js\nassert.match(code, /const\\s+createLabel\\s*=\\s*(\\(\\s*name\\s*\\)|name)\\s*=>\\s*\\{\\s*const\\s+label/);\n```\n\nYou should use the `.createElement()` method of the `document` object.\n\n```js\nassert.match(code, /document\\.createElement\\(/);\n```\n\nYou should pass the string `\"div\"` to the `.createElement()` method.\n\n```js\nassert.match(code, /document\\.createElement\\(\\s*('|\"|`)div\\1\\s*\\)/);\n```\n\nYou should assign your new `div` element to `label`.\n\n```js\nassert.match(code, /const\\s+label\\s*=\\s*document\\.createElement\\(\\s*('|\"|`)div\\1\\s*\\)/)\n```"
    },
    {
      "title": "Step 4",
      "description": "Set the `className` of the `label` element to `\"label\"`, and set the `textContent` to the `name` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n\n  }\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should access the `className` property of the `label` element.\n\n```js\nassert.match(code, /label\\.className/);\n```\n\nYou should set the `className` property to the string `\"label\"`.\n\n```js\nassert.match(code, /label\\.className\\s*=\\s*('|\"|`)label\\1/);\n```\n\nYou should access the `textContent` property of the `label` element.\n\n```js\nassert.match(code, /label\\.textContent/);\n```\n\nYou should set the `textContent` property to the value of `name`.\n\n```js\nassert.match(code, /label\\.textContent\\s*=\\s*name/);\n```"
    },
    {
      "title": "Step 5",
      "description": "Finally, use the `.appendChild()` method to add your `label` element to the `container` element.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n\n  }\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should access the `.appendChild()` method of the `container` element.\n\n```js\nassert.match(code, /container\\.appendChild\\(/);\n```\n\nYou should pass your `label` element to the `.appendChild()` method.\n\n```js\nassert.match(code, /container\\.appendChild\\(\\s*label\\s*\\)/);\n```\n\nYou should append `label` after setting the attributes.\n\n```js\nassert.match(code, /const\\s+label\\s*=\\s*document\\.createElement\\(\\s*('|\"|`)div\\1\\s*\\)\\s*;?\\s*label\\.className\\s*=\\s*('|\"|`)label\\2\\s*;?\\s*label\\.textContent\\s*=\\s*name\\s*;?\\s*container\\.appendChild\\(\\s*label\\s*\\)/);\n```"
    },
    {
      "title": "Step 6",
      "description": "You will need a function to generate a range of numbers.\n\nDeclare an empty `range` function which takes a `start` and `end` parameter. Use the `Array()` constructor and implicitly return an empty array.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\n\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n}"
        }
      ],
      "testCode": "You should declare a `range` variable.\n\n```js\nassert.match(code, /(?:let|var|const)\\s+range/);\n```\n\nYou should use `const` to declare your `range` variable.\n\n```js\nassert.match(code, /const\\s+range/);\n```\n\nYour `range` variable should be a function.\n\n```js\nassert.isFunction(range);\n```\n\nYour `range` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(.*\\)\\s*=>/);\n```\n\nYour `range` function should take a `start` parameter first.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start/)\n```\n\nYour `range` function should take an `end` parameter second.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)/);\n```\n\nYour `range` function should use an implicit return. Remember that this means you will not use curly brackets.\n\n```js\nassert.notMatch(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*{/);\n```\n\nYour `range` function should use the `Array()` constructor. Primitive constructors do not need the `new` keyword.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(/);\n```\n\nYou should not pass anything to the `Array()` constructor.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*\\)/);\n```"
    },
    {
      "title": "Step 7",
      "description": "Your array will need to be the size of the range. You can calculate this by finding the difference between `end` and `start`, and adding `1` to the result.\n\nPass this calculation as the argument for your `Array()` constructor.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nconst range = (start, end) => Array();\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n}"
        }
      ],
      "testCode": "You should subtract `start` from `end`.\n\n```js\nassert.match(code, /end\\s*-\\s*start/);\n```\n\nYou should add `1` to your `end - start` calculation.\n\n```js\nassert.match(code, /end\\s*-\\s*start\\s*\\+\\s*1/);\n```\n\nYou should pass your calculation to the `Array()` constructor.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)/);\n```"
    },
    {
      "title": "Step 8",
      "description": "The `Array()` constructor has a `.fill()` method which can be used to fill an array with a value. You can use this to fill your array with the `start` value.\n\nChain the `.fill()` method to your `Array()` constructor, and pass it the `start` value.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nconst range = (start, end) => Array(end - start + 1);\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n}"
        }
      ],
      "testCode": "You should use the `.fill()` method.\n\n```js\nassert.match(code, /\\.fill\\(/);\n```\n\nYou should call the `.fill()` method on your `Array()` constructor.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)\\.fill\\(/);\n```\n\nYou should pass `start` to the `.fill()` method.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)\\.fill\\(\\s*start\\s*\\)/);\n```"
    },
    {
      "title": "Step 9",
      "description": "Currently your `range` function returns an array with the correct length, but all of the values are the value of `start`. To fix this, chain the `.map()` method to your `.fill()` method.\n\nPass the `.map()` method a callback which takes `element` and `index` as parameters and returns the sum of those parameters.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nconst range = (start, end) => Array(end - start + 1).fill(start);\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n}"
        }
      ],
      "testCode": "You should use the `.map()` method.\n\n```js\nassert.match(code, /\\.map\\(/);\n```\n\nYou should chain the `.map()` method to your `.fill()` method.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)\\.fill\\(\\s*start\\s*\\)\\.map\\(/);\n```\n\nYou should pass a callback function to `.map()` using arrow syntax.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)\\.fill\\(\\s*start\\s*\\)\\.map\\(\\s*\\(.*\\)\\s*=>/);\n```\n\nYour `.map()` callback should take `element` as the first parameter.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)\\.fill\\(\\s*start\\s*\\)\\.map\\(\\s*\\(\\s*element/);\n```\n\nYour `.map()` callback should take `index` as the second parameter.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)\\.fill\\(\\s*start\\s*\\)\\.map\\(\\s*\\(\\s*element\\s*,\\s*index\\s*\\)\\s*=>/);\n```\n\nYour `.map()` callback should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)\\.fill\\(\\s*start\\s*\\)\\.map\\(\\s*\\(\\s*element\\s*,\\s*index\\s*\\)\\s*=>\\s*\\{/);\n```\n\nYour `.map()` callback should implicitly return the sum of `element` and `index`.\n\n```js\nassert.match(code, /const\\s+range\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*Array\\(\\s*end\\s*-\\s*start\\s*\\+\\s*1\\s*\\)\\.fill\\(\\s*start\\s*\\)\\.map\\(\\s*\\(\\s*element\\s*,\\s*index\\s*\\)\\s*=>\\s*(element\\s*\\+\\s*index|index\\s*\\+\\s*element)/);\n```"
    },
    {
      "title": "Step 10",
      "description": "Now that you have a `range` function, you can use it to create a range of letters as well.\n\nDeclare a `charRange` function using `const` and arrow syntax. It should take a `start` and `end` parameter. The function should implicitly return the result of calling `range()` with `start` and `end` as the arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n}"
        }
      ],
      "testCode": "You should declare a `charRange` variable.\n\n```js\nassert.match(code, /(?:let|const|var)\\s+charRange/);\n```\n\nYour `charRange` variable should be declared with `const`.\n\n```js\nassert.match(code, /const\\s+charRange/);\n```\n\nYour `charRange` variable should be a function.\n\n```js\nassert.isFunction(charRange);\n```\n\nYour `charRange` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(.*\\)\\s*=>/);\n```\n\nYour `charRange` function should take `start` as the first parameter.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start/);\n```\n\nYour `charRange` function should take `end` as the second parameter.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)/);\n```\n\nYour `charRange` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*{/);\n```\n\nYour `charRange` function should call your `range` function.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(/);\n```\n\nYou should pass `start` and `end` as the arguments to your `range` call.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(\\s*start\\s*,\\s*end\\s*\\)/);\n```"
    },
    {
      "title": "Step 11",
      "description": "Your `range` function expects numbers, but your `start` and `end` values will be strings (specifically, they will be single characters such as `A`).\n\nConvert your `start` and `end` values in your `range()` call to numbers by using the `.charCodeAt()` method on them, passing the number `0` as the argument to that method.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\n--fcc-editable-region--\nconst charRange = (start, end) => range(start, end);\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n}"
        }
      ],
      "testCode": "You should use the `.charCodeAt()` method.\n\n```js\nassert.match(code, /\\.charCodeAt\\(/);\n```\n\nYou should call the `.charCodeAt()` method on `start`.\n\n```js\nassert.match(code, /start\\.charCodeAt\\(/);\n```\n\nYou should pass `0` to the `.charCodeAt()` method of `start`.\n\n```js\nassert.match(code, /start\\.charCodeAt\\(\\s*0\\s*\\)/);\n```\n\nYou should call the `.charCodeAt()` method on `end`.\n\n```js\nassert.match(code, /end\\.charCodeAt\\(/);\n```\n\nYou should pass `0` to the `.charCodeAt()` method of `end`.\n\n```js\nassert.match(code, /end\\.charCodeAt\\(\\s*0\\s*\\)/);\n```\n\nYou should use the `.charCodeAt()` methods directly in your `range` call.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(\\s*start\\.charCodeAt\\(\\s*0\\s*\\)\\s*,\\s*end\\.charCodeAt\\(\\s*0\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 12",
      "description": "`range()` will return an array of numbers, which you need to convert back into characters. Chain the `.map()` method to your `range()` call.\n\nPass a callback function that takes `code` as the parameter and implicitly returns the value of passing `code` to the `String.fromCharCode()` method.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\n--fcc-editable-region--\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0));\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n}"
        }
      ],
      "testCode": "You should use the `.map()` method.\n\n```js\nassert.lengthOf(code.match(/\\.map\\(/g), 2);\n```\n\nYou should chain the `.map()` method to your `range` call.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(\\s*start\\.charCodeAt\\(\\s*0\\s*\\)\\s*,\\s*end\\.charCodeAt\\(\\s*0\\s*\\)\\s*\\)\\.map\\(/);\n```\n\nYou should use arrow syntax for the `.map()` callback.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(\\s*start\\.charCodeAt\\(\\s*0\\s*\\)\\s*,\\s*end\\.charCodeAt\\(\\s*0\\s*\\)\\s*\\)\\.map\\(\\s*(\\(.*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `.map()` callback should take a `code` parameter.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(\\s*start\\.charCodeAt\\(\\s*0\\s*\\)\\s*,\\s*end\\.charCodeAt\\(\\s*0\\s*\\)\\s*\\)\\.map\\(\\s*(\\(\\s*code\\s*\\)|code)\\s*=>/);\n```\n\nYour `.map()` callback should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(\\s*start\\.charCodeAt\\(\\s*0\\s*\\)\\s*,\\s*end\\.charCodeAt\\(\\s*0\\s*\\)\\s*\\)\\.map\\(\\s*(\\(\\s*code\\s*\\)|code)\\s*=>\\s*\\{/);\n```\n\nYour `.map()` callback should return the result of calling `String.fromCharCode()`.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(\\s*start\\.charCodeAt\\(\\s*0\\s*\\)\\s*,\\s*end\\.charCodeAt\\(\\s*0\\s*\\)\\s*\\)\\.map\\(\\s*(\\(\\s*code\\s*\\)|code)\\s*=>\\s*String\\.fromCharCode\\(/);\n```\n\nYou should pass the variable `code` to `String.fromCharCode()`.\n\n```js\nassert.match(code, /const\\s+charRange\\s*=\\s*\\(\\s*start\\s*,\\s*end\\s*\\)\\s*=>\\s*range\\(\\s*start\\.charCodeAt\\(\\s*0\\s*\\)\\s*,\\s*end\\.charCodeAt\\(\\s*0\\s*\\)\\s*\\)\\.map\\(\\s*(\\(\\s*code\\s*\\)|code)\\s*=>\\s*String\\.fromCharCode\\(\\s*code\\s*\\)/);\n```"
    },
    {
      "title": "Step 13",
      "description": "Now that your helper functions are complete, back in your `onload` event handler you should declare a `letters` variable. Assign it the result of calling `charRange()` with the letters `\"A\"` and `\"J\"` as arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n--fcc-editable-region--\n\n--fcc-editable-region--\n}"
        }
      ],
      "testCode": "You should declare a `letters` variable.\n\n```js\nassert.match(code, /(?:let|const|var)\\s+letters/);\n```\n\nYou should use `const` to declare your `letters` variable.\n\n```js\nassert.match(code, /const\\s+letters/);\n```\n\nYou should assign a `charRange()` call to your `letters` variable.\n\n```js\nassert.match(code, /const\\s+letters\\s*=\\s*charRange\\(/);\n```\n\nYou should pass `\"A\"` as the first argument to your `charRange()` call.\n\n```js\nassert.match(code, /const\\s+letters\\s*=\\s*charRange\\(\\s*('|\"|`)A\\1/);\n```\n\nYou should pass `\"J\"` as the second argument to your `charRange()` call.\n\n```js\nassert.match(code, /const\\s+letters\\s*=\\s*charRange\\(\\s*('|\"|`)A\\1\\s*,\\s*('|\"|`)J\\2\\s*\\)/)\n```"
    },
    {
      "title": "Step 14",
      "description": "Now call the `.forEach()` method of your `letters` array, and pass your `createLabel` function reference as the callback.\n\nYou should see some letters appear across the top of your spreadsheet.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n--fcc-editable-region--\n\n--fcc-editable-region--\n}"
        }
      ],
      "testCode": "You should call the `.forEach()` method on your `letters` array.\n\n```js\nassert.match(code, /letters\\.forEach\\(/);\n```\n\nYou should pass your `createLabel` function reference to the `.forEach()` method.\n\n```js\nassert.match(code, /letters\\.forEach\\(\\s*(?:\\(\\s*([\\S]*)\\s*\\)|\\s*([\\S]*))\\s*=>\\s*createLabel\\(\\s*\\1\\2\\s*\\)\\s*\\)|letters\\.forEach\\(\\s*createLabel\\s*\\)/);\n```\n\nYou should not pass a `createLabel` function call.\n\n```js\nassert.notMatch(code, /letters\\.forEach\\(\\s*createLabel\\(\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 15",
      "description": "Remember that `range()` returns an array, so you can chain array methods directly to the function call.\n\nCall `range()` with `1` and `99` as the arguments, and chain the `.forEach()` method. Pass the `.forEach()` method an empty callback which takes `number` as the parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n--fcc-editable-region--\n\n--fcc-editable-region--\n}"
        }
      ],
      "testCode": "You should call your `range()` function.\n\n```js\nassert.lengthOf(code.match(/range\\(/g), 2);\n```\n\nYou should pass `1` as the first argument to your `range()` call.\n\n```js\nassert.match(code, /range\\(\\s*1/);\n```\n\nYou should pass `99` as the second argument to your `range()` call.\n\n```js\nassert.match(code, /range\\(\\s*1\\s*,\\s*99\\s*\\)/);\n```\n\nYou should chain the `.forEach()` method to your `range()` call.\n\n```js\nassert.match(code, /range\\(\\s*1\\s*,\\s*99\\s*\\)\\.forEach\\(/);\n```\n\nYou should pass a callback function to `.forEach()` using arrow syntax.\n\n```js\nassert.match(code, /range\\(\\s*1\\s*,\\s*99\\s*\\)\\.forEach\\(\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour callback function should have `number` as the only parameter.\n\n```js\nassert.match(code, /range\\(\\s*1\\s*,\\s*99\\s*\\)\\.forEach\\(\\s*(\\(\\s*number\\s*\\)|number)\\s*=>/);\n```"
    },
    {
      "title": "Step 16",
      "description": "In your callback, you will need to make two function calls. Start by calling `createLabel()` and pass `number` as the argument. You should see some numbers appear in your spreadsheet.\n\nThen call the `.forEach()` method on your `letters` array. Pass an empty callback function which takes a `letter` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n--fcc-editable-region--\n  range(1, 99).forEach(number => {\n\n  })\n--fcc-editable-region--\n}"
        }
      ],
      "testCode": "You should call your `createLabel()` function.\n\n```js\nassert.match(code, /range\\(\\s*1\\s*,\\s*99\\s*\\)\\.forEach\\(\\s*(\\(\\s*number\\s*\\)|number)\\s*=>\\s*\\{\\s*createLabel\\(/);\n```\n\nYou should pass `number` to your `createLabel()` call.\n\n```js\nassert.match(code, /range\\(\\s*1\\s*,\\s*99\\s*\\)\\.forEach\\(\\s*(\\(\\s*number\\s*\\)|number)\\s*=>\\s*\\{\\s*createLabel\\(/)\n```\n\nYou should call the `.forEach()` method on your `letters` array.\n\n```js\nassert.lengthOf(code.match(/letters\\.forEach\\(/g), 2)\n```\n\nYou should pass a callback function with arrow syntax to your `.forEach()` method.\n\n```js\nassert.match(code, /letters\\.forEach\\(\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>\\s*\\{/)\n```\n\nYour callback function should have a `letter` parameter.\n\n```js\nassert.match(code, /letters\\.forEach\\(\\s*(\\(\\s*letter\\s*\\)|letter)\\s*=>\\s*\\{/)\n```\n\nYour callback function should be empty.\n\n```js\nassert.match(code, /letters\\.forEach\\(\\s*(\\(\\s*letter\\s*\\)|letter)\\s*=>\\s*\\{\\s*\\}/)\n```\n\nYour `letters.forEach()` callback function should be nested inside the `range(1, 99).forEach(number => {}` callback function.\n\n```js\nassert.match(code, /range\\s*\\(\\s*1\\s*,\\s*99\\s*\\)\\s*.forEach\\s*\\(\\s*(\\(\\s*number\\s*\\)|number)\\s*=>\\s*\\{\\s*[^}]*letters\\.forEach\\(\\s*(\\(\\s*letter\\s*\\)|letter)\\s*=>\\s*\\{\\s*\\}\\s*\\)\\s*;?\\s*\\}\\s*\\)/)\n```"
    },
    {
      "title": "Step 17",
      "description": "Now in your nested `.forEach()` call, declare an `input` variable. Use the `.createElement()` method of the `document` object to create an `input` element. Set the `type` attribute to `\"text\"` and the `id` attribute to `letter + number`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n--fcc-editable-region--\n    letters.forEach(letter => {\n\n    })\n--fcc-editable-region--\n  })\n}"
        }
      ],
      "testCode": "You should declare an `input` variable.\n\n```js\nassert.match(code, /(?:var|let|const)\\s+input/)\n```\n\nYou should use `const` to declare your `input` variable.\n\n```js\nassert.match(code, /const\\s+input/)\n```\n\nYou should call the `.createElement()` method of the `document` object.\n\n```js\nassert.lengthOf(code.match(/document\\.createElement\\(/g), 2)\n```\n\nYou should pass the string `\"input\"` to the `.createElement()` method.\n\n```js\nassert.match(code, /document\\.createElement\\(\\s*('|\"|`)input\\1\\s*\\)/)\n```\n\nYou should assign your new `input` element to your `input` variable.\n\n```js\nassert.match(code, /const\\s+input\\s*=\\s*document\\.createElement\\(\\s*('|\"|`)input\\1\\s*\\)/)\n```\n\nYou should access the `type` property of your `input` element.\n\n```js\nassert.match(code, /input\\.type/);\n```\n\nYou should set the `type` attribute of your `input` element to `\"text\"`.\n\n```js\nassert.match(code, /input\\.type\\s*=\\s*('|\"|`)text\\1/)\n```\n\nYou should access the `id` property of your `input` element.\n\n```js\nassert.match(code, /input\\.id/);\n```\n\nYou should set the `id` attribute of your `input` element to `letter + number`.\n\n```js\nassert.match(code, /input\\.id\\s*=\\s*letter\\s\\+\\snumber/)\n```"
    },
    {
      "title": "Step 19",
      "description": "Append the `input` element to your `container` element as a child.\n\nYou should now be able to see the cells of your spreadsheet.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n--fcc-editable-region--\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n\n    })\n--fcc-editable-region--\n  })\n}"
        }
      ],
      "testCode": "You should call the `.appendChild()` method on your `container` element.\n\n```js\nassert.lengthOf(code.match(/container\\.appendChild\\(/g), 2);\n```\n\nYou should pass your `input` element to the `.appendChild()` method.\n\n```js\nassert.match(code, /container\\.appendChild\\(\\s*input\\s*\\)/);\n```"
    },
    {
      "title": "Step 20",
      "description": "Most spreadsheet programs include built-in functions for calculation.\n\nDeclare a `sum` function that takes a `nums` parameter, which will be an array of numbers. It should return the result of calling `reduce` on the array to sum all of the numbers.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\n\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      container.appendChild(input);\n    })\n  })\n}"
        }
      ],
      "testCode": "You should declare a `sum` variable.\n\n```js\nassert.match(code, /(?:let|const|var)\\s+sum/);\n```\n\nYou should use `const` to declare your `sum` variable.\n\n```js\nassert.match(code, /const\\s+sum/);\n```\n\nYour `sum` variable should be a function.\n\n```js\nassert.isFunction(sum);\n```\n\nYour `sum` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+sum\\s*=\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `sum` function should have a `nums` parameter.\n\n```js\nassert.match(code, /const\\s+sum\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>/);\n```\n\nYour `sum` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+sum\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*{/);\n```\n\nYour `sum` function should return the result of calling `.reduce()` on `nums`.\n\n```js\nassert.match(code, /const\\s+sum\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*nums\\.reduce\\(/);\n```\n\nYour `sum` function should return the sum of all numbers in `nums`.\n\n```js\nconst numbers = [1, 2, 3, 4, 5];\nassert.equal(sum(numbers), 15);\n```"
    },
    {
      "title": "Step 21",
      "description": "Declare an `isEven` function, which takes a `num` parameter and returns `true` if the number is even, and `false` otherwise. Use the modulo operator `%` to determine if a number is even or odd.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\n\n--fcc-editable-region--\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      container.appendChild(input);\n    })\n  })\n}"
        }
      ],
      "testCode": "You should declare an `isEven` variable.\n\n```js\nassert.match(code, /(?:let|const|var)\\s+isEven/);\n```\n\nYou should use `const` to declare your `isEven` variable.\n\n```js\nassert.match(code, /const\\s+isEven/);\n```\n\nYour `isEven` variable should be a function.\n\n```js\nassert.isFunction(isEven);\n```\n\nYour `isEven` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+isEven\\s*=\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `isEven` function should have a `num` parameter.\n\n```js\nassert.match(code, /const\\s+isEven\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>/);\n```\n\nYour `isEven` function should use the modulo operator `%`.\n\n```js\nassert.match(isEven.toString(),  /%/);\n```\n\nYour `isEven` function should return `true` for even numbers.\n\n```js\nassert.isTrue(isEven(2));\nassert.isTrue(isEven(1000));\nassert.isTrue(isEven(42));\n```\n\nYour `isEven` function should return `false` for odd numbers.\n\n```js\nassert.isFalse(isEven(1));\nassert.isFalse(isEven(333));\nassert.isFalse(isEven(777777777));\n```"
    },
    {
      "title": "Step 22",
      "description": "Declare an `average` function which takes an array of numbers as the `nums` parameter. It should return the average of all the numbers in the array.\n\nThe average can be calculated by dividing the sum of all the numbers in the array by the length of the array. Remember that you have a `sum` function you can use.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      container.appendChild(input);\n    })\n  })\n}"
        }
      ],
      "testCode": "You should declare an `average` variable.\n\n```js\nassert.match(code, /(?:let|const|var)\\s+average/);\n```\n\nYou should use `const` to declare your `average` variable.\n\n```js\nassert.match(code, /const\\s+average/);\n```\n\nYour `average` variable should be a function.\n\n```js\nassert.isFunction(average);\n```\n\nYour `average` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+average\\s*=\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `average` function should have a `nums` parameter.\n\n```js\nassert.match(code, /const\\s+average\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)/);\n```\n\nYour `average` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+average\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*{/);\n```\n\nYour `average` function should return the average value of the `nums` array.\n\n```js\nassert.equal(average([1,2,3]), 2);\nassert.equal(average([1,2,3,4,5]), 3);\n```"
    },
    {
      "title": "Step 23",
      "description": "Your next function will calculate the median value of an array of numbers. Start by declaring a `median` arrow function that takes a `nums` parameter.\n\nIn the function, declare a `sorted` variable and assign it the value of sorting a copy of the `nums` array.\n\nYou should use the `slice()` method for creating a shallow copy of the array.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      container.appendChild(input);\n    })\n  })\n}"
        }
      ],
      "testCode": "You should declare a `median` variable.\n\n```js\nassert.match(code, /(?:let|const|var)\\s+median/);\n```\n\nYou should use `const` to declare your `median` variable.\n\n```js\nassert.match(code, /const\\s+median/);\n```\n\nYour `median` variable should be a function.\n\n```js\nassert.isFunction(median);\n```\n\nYour `median` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*\\(?/);\n```\n\nYour `median` function should have a `nums` parameter.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)/);\n```\n\nYour `median` function should not use an implicit return.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*\\{/);\n```\n\nYour `median` function should have a `sorted` variable.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*\\{\\s*(?:let|var|const)\\s+sorted/);\n```\n\nYou should use `const` to declare your `sorted` variable.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*\\{\\s*const\\s+sorted/);\n```\n\nYou should use `.slice()` to assign a copy of the `nums` array to `sorted`.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)/);\n```\n\nYou should chain the `.sort()` method to your `.slice()` method.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(/);\n```\n\nYou should pass a callback function to your `sort` method to accurately sort the numbers in ascending order. Use an implicit return for clarity.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(\\s*\\(\\s*a\\s*,\\s*b\\s*\\)\\s*=>\\s*a\\s*-\\s*b\\s*\\)\\s*\\s*;?\\s*\\}/);\n```"
    },
    {
      "title": "Step 24",
      "description": "Now declare a `length` variable and assign it the length of your sorted array, and a `middle` variable that has the value of the length divided by `2`, subtracted by `1`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\n--fcc-editable-region--\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      container.appendChild(input);\n    })\n  })\n}"
        }
      ],
      "testCode": "You should declare a `length` variable after your `sorted` variable.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*nums\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(\\s*\\(\\s*a\\s*,\\s*b\\s*\\)\\s*=>\\s*a\\s*-\\s*b\\s*\\)\\s*\\s*;?\\s*(?:var|let|const)\\s+length/);\n```\n\nYou should use `const` to declare your `length` variable.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*nums\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(\\s*\\(\\s*a\\s*,\\s*b\\s*\\)\\s*=>\\s*a\\s*-\\s*b\\s*\\)\\s*\\s*;?\\s*const\\s+length/);\n```\n\nYou should assign the length of the `sorted` array to your `length` variable.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*nums\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(\\s*\\(\\s*a\\s*,\\s*b\\s*\\)\\s*=>\\s*a\\s*-\\s*b\\s*\\)\\s*\\s*;?\\s*const\\s+length\\s*=\\s*sorted\\.length\\s*;?/);\n```\n\nYou should declare a `middle` variable after your `length` variable.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*nums\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(\\s*\\(\\s*a\\s*,\\s*b\\s*\\)\\s*=>\\s*a\\s*-\\s*b\\s*\\)\\s*\\s*;?\\s*const\\s+length\\s*=\\s*sorted\\.length\\s*;?\\s*(?:var|let|const)\\s+middle/);\n```\n\nYou should use `const` to declare your `middle` variable.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*nums\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(\\s*\\(\\s*a\\s*,\\s*b\\s*\\)\\s*=>\\s*a\\s*-\\s*b\\s*\\)\\s*\\s*;?\\s*const\\s+length\\s*=\\s*sorted\\.length\\s*;?\\s*const\\s+middle/);\n```\n\nYou should assign `middle` the value of dividing your `length` variable by `2`.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*nums\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(\\s*\\(\\s*a\\s*,\\s*b\\s*\\)\\s*=>\\s*a\\s*-\\s*b\\s*\\)\\s*\\s*;?\\s*const\\s+length\\s*=\\s*sorted\\.length\\s*;?\\s*const\\s+middle\\s*=\\s*length\\s*\\/\\s*2/);\n```\n\nYou should subtract `1` from your `length / 2` calculation.\n\n```js\nassert.match(code, /const\\s+median\\s*=\\s*nums\\s*=>\\s*\\{\\s*const\\s+sorted\\s*=\\s*nums\\.slice\\(\\s*\\)\\.sort\\(\\s*\\(\\s*a\\s*,\\s*b\\s*\\)\\s*=>\\s*a\\s*-\\s*b\\s*\\)\\s*\\s*;?\\s*const\\s+length\\s*=\\s*sorted\\.length\\s*;?\\s*const\\s+middle\\s*=\\s*length\\s*\\/\\s*2\\s*-\\s*1/);\n```"
    },
    {
      "title": "Step 25",
      "description": "Check if `length` is even using your `isEven` function. If it is, return the average of the number at the `middle` index and the number after that. If it's odd, return the number at the `middle` index  you'll need to round the `middle` value up.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\n--fcc-editable-region--\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      container.appendChild(input);\n    })\n  })\n}"
        }
      ],
      "testCode": "You should return a value from the `median` function. \n\n```js\nassert.exists(median([2,4,6,8]));\n```\n\nIf `length` is even, you should return the average of the number at the `middle` index and the number after it. \n\n```js\nassert.strictEqual(median([2,4,6,8]),5); \nassert.strictEqual(median([6,12,18,24]),15); \n```\n\n\nIf `length` is odd, you should return the value at the `middle` index. \n\n```js\nassert.strictEqual(median([2,4,6,8,10]),6); \nassert.strictEqual(median([3,6,9,12,15]),9); \n```"
    },
    {
      "title": "Step 26",
      "description": "Object properties consist of key/value pairs. You can use shorthand property names when declaring an object literal. When using the shorthand property name syntax, the name of the variable becomes the property key and its value the property value.\n\nThe following example declares a `user` object with the properties `userId`, `firstName`, and `loggedIn`.\n\n```js\nconst userId = 1;\nconst firstName = \"John\";\nconst loggedIn = true;\n\nconst user = {\n  userId,\n  firstName,\n  loggedIn,\n};\n\nconsole.log(user); // { userId: 1, firstName: 'John', loggedIn: true }\n```\n\nTo keep track of all of your spreadsheet's functions, declare a `spreadsheetFunctions` object. Using the shorthand notation syntax, set `sum`, `average`, and `median` as properties on the `spreadsheetFunctions` object.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      container.appendChild(input);\n    })\n  })\n}"
        }
      ],
      "testCode": "You should declare a `spreadsheetFunctions` variable.\n\n```js\nassert.match(code, /(?:const|let|var)\\s+spreadsheetFunctions/);\n```\n\nYou should use `const` to declare your `spreadsheetFunctions` variable.\n\n```js\nassert.match(code, /const\\s+spreadsheetFunctions/);\n```\n\nYour `spreadsheetFunctions` variable should be an object.\n\n```js\nassert.isObject(spreadsheetFunctions);\n```\n\nYour `spreadsheetFunctions` object should have a `sum` property.\n\n```js\nassert.property(spreadsheetFunctions, \"sum\");\n```\n\nYour `sum` property should be your `sum` function.\n\n```js\nassert.equal(spreadsheetFunctions?.sum, sum);\n```\n\nYour `spreadsheetFunctions` object should have an `average` property.\n\n```js\nassert.property(spreadsheetFunctions, \"average\");\n```\n\nYour `average` property should be your `average` function.\n\n```js\nassert.equal(spreadsheetFunctions?.average, average);\n```\n\nYour `spreadsheetFunctions` object should have a `median` property.\n\n```js\nassert.property(spreadsheetFunctions, \"median\");\n```\n\nYour `median` property should be your `median` function.\n\n```js\nassert.equal(spreadsheetFunctions?.median, median);\n```\n\nYou should use destructuring syntax to assign your properties.\n\n```js\nconst objectText = code.replace(/.*const\\s+spreadsheetFunctions\\s*=\\s*\\{([^}]*)}.*/s, \"$1\");\nassert.include(objectText, \"sum\");\nassert.include(objectText, \"average\");\nassert.include(objectText, \"median\");\nassert.notInclude(objectText, \":\");\n```"
    },
    {
      "title": "Step 27",
      "description": "Now you can start using your spreadsheet functions. Begin by declaring an `update` arrow function. It should take an `event` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\n\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should declare an `update` variable.\n\n```js\nassert.match(code, /(?:let|const|var)\\s+update/);\n```\n\nYou should use `const` to declare your `update` variable.\n\n```js\nassert.match(code, /const\\s+update/);\n```\n\nYour `update` variable should be a function.\n\n```js\nassert.isFunction(update);\n```\n\nYour `update` function should take an `event` parameter.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>/);\n```\n\nYour `update` function should be empty.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 28",
      "description": "In your `window.onload` function, you need to tell your `input` elements to call the `update` function when the value changes. You can do this by directly setting the `onchange` property.\n\nSet the `onchange` property to be a reference to your `update` function.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n--fcc-editable-region--\n\n--fcc-editable-region--\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n\n}"
        }
      ],
      "testCode": "Your `window.onload` function should access the `onchange` property of the `input` element.\n\n```js\nassert.match(window.onload.toString(), /input\\.onchange/);\n```\n\nYour `window.onload` function should set the `onchange` property to `update`.\n\n```js\nassert.match(window.onload.toString(), /input\\.onchange\\s*=\\s*update/);\n```\n\nYour `window.onload` function should not call your `update` function.\n\n```js\nassert.notMatch(window.onload.toString(), /update\\(\\s*\\)/);\n```\n\nYour `input` elements should all have your `update` function as the `onchange` property.\n\n```js\nconst inputs = document.querySelectorAll('input');\ninputs.forEach(input => {\n  assert.property(input, 'onchange');\n  assert.equal(input.onchange, update);\n})\n```"
    },
    {
      "title": "Step 29",
      "description": "Since your `update` event is running as a `change` event listener, the `event` parameter will be a change event.\n\nThe `target` property of the change event represents the element that changed. Assign the `target` property to a new variable called `element`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\nconst update = event => {\n\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should declare an `element` variable in your `update` function.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*(?:var|let|const)\\s+element/);\n```\n\nYou should use `const` to declare your `element` variable.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(?\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element/);\n```\n\nYou should assign the `target` property of the `event` parameter to your `element` variable.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target/);\n```"
    },
    {
      "title": "Step 30",
      "description": "Because the `change` event is triggering on an `input` element, the element will have a `value` property that represents the current value of the input.\n\nAssign the `value` property of `element` to a new variable called `value`, and use `.replace()` to remove all whitespace.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\nconst update = event => {\n  const element = event.target;\n\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should declare a `value` variable after your `element` variable.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*(?:const|let|var)\\s+value/);\n```\n\nYou should use `const` to declare your `value` variable.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value/);\n```\n\nYou should assign the `value` property of `element` to your `value` variable.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value/);\n```\n\nYou should call the `.replace()` method on the `value` property of the `element`.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(/);\n```\n\nYou should pass a regular expression to match whitespace to your `.replace()` method. Use the `\\s` character class.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\//);\n```\n\nYou should make your regular expression global.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g/);\n```\n\nYou should pass an empty string as your second argument to the `.replace()` method.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1/);\n```"
    },
    {
      "title": "Step 31",
      "description": "Now you need to check if the `value` does not include the `id` of the element. Create an `if` condition to do so.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should create an `if` block.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(/);\n```\n\nYour `if` condition should check that `value` does not include the `id` of the `element`.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*!value\\.includes\\(\\s*element\\.id\\s*\\)/);\n```\n\nYour `if` block should be empty.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*\\)\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 32",
      "description": "Spreadsheet software typically uses `=` at the beginning of a cell to indicate a calculation should be used, and spreadsheet functions should be evaluated.\n\nUse the `&&` operator to add a second condition to your `if` statement that also checks if the first character of `value` is `\"=\"`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id)) {\n\n  }\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should use the `&&` operator to add a second condition to your `if` statement that also checks if the first character of `value` is `\"=\"`. You may use `[0]`, `.startsWith()`, or `.charAt(0)`.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 33",
      "description": "In order to run your spreadsheet functions, you need to be able to parse and evaluate the input string. This is a great time to use another function.\n\nDeclare an `evalFormula` arrow function which takes the parameters `x` and `cells`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `evalFormula` variable.\n\n```js\nassert.match(code, /(?:let|const|var)\\s+evalFormula/);\n```\n\nYou should use `const` to declare your `evalFormula` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula/);\n```\n\nYour `evalFormula` variable should be a function.\n\n```js\nassert.isFunction(evalFormula);\n```\n\nYour `evalFormula` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(/);\n```\n\nYour `evalFormula` function should have `x` as the first parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x/);\n```\n\nYour `evalFormula` function should have `cells` as the second parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>/);\n```\n\nYour `evalFormula` function should be empty.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*}/);\n```"
    },
    {
      "title": "Step 34",
      "description": "In your `evalFormula`, declare an `idToText` arrow function which takes an `id` parameter.\n\nYour `idToText` function should return the result of calling `.find()` on the `cells` array with a callback function that takes an `cell` parameter and returns `cell.id === id`.\n\nBoth of your functions should use implicit returns.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `idToText` variable in your `evalFormula` function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*(?:const|let|var)\\s+idToText/);\n```\n\nYou should use `const` to declare your `idToText` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText/);\n```\n\nYour `idToText` variable should be an arrow function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `idToText` function should have an `id` parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>/);\n```\n\nYour `idToText` function should return the result of calling the `.find()` method on your `cells` array. Your callback function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*\\{/);\n```\n\nYour `idToText` function should use an implicit return.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(/);\n```\n\nYou should pass a callback function to your `.find()` method. Use arrow syntax.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour callback function should have a `cell` parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>/);\n```\n\nYour callback function should return whether `cell.id` is strictly equal to `id`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)/);\n```"
    },
    {
      "title": "Step 35",
      "description": "Your `idToText` function currently returns an `input` element. Update it to return the `value` of that `input` element.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id);\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should return the `value` property of the return value of the `.find()` method.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value/);\n```"
    },
    {
      "title": "Step 36",
      "description": "You need to be able to match cell ranges in a formula. Cell ranges can look like `A1:B12` or `A3:A25`. You can use a regular expression to match these patterns.\n\nStart by declaring a `rangeRegex` variable and assign it a regular expression that matches `A` through `J` (the range of columns in your spreadsheet). Use a capture group with a character class to achieve this.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `rangeRegex` variable after your `idToText` function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*(?:var|let|const)\\s+rangeRegex/);\n```\n\nYou should use `const` to declare your `rangeRegex` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex/);\n```\n\nYour `rangeRegex` variable should be a regular expression.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/.*\\/\\s*;?/);\n```\n\nYour `rangeRegex` should use a capture group.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(.*\\)\\/\\s*;?/);\n```\n\nYour `rangeRegex` should use a character class in the capture group.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[.*\\]\\)\\/\\s*;?/);\n```\n\nYour `rangeRegex` should use a character class to match `A` through `J`.\n\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\/\\s*;?/);\n```"
    },
    {
      "title": "Step 37",
      "description": "After matching a cell letter successfully, your `rangeRegex` needs to match the cell number. Cell numbers in your sheet range from `1` to `99`.\n\nAdd a capture group after your letter capture group. Your new capture group should match one or two digits  the first digit should be `1` through `9`, and the second digit should be `0` through `9`. The second digit should be optional.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])/;\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should add a second capture group to your `rangeRegex`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(.*\\)\\/\\s*;?/);\n```\n\nYour second capture group should have a character class.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[.*\\]\\??\\)\\/\\s*;?/);\n```\n\nYour second capture group should have two character classes.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[.*\\]\\[.*\\]\\??\\)\\/\\s*;?/);\n```\n\nYour first new character class should match the digits `1` through `9`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[.*\\]\\??\\)\\/\\s*;?/);\n```\n\nYour second new character class should match the digits `0` through `9`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\??\\)\\/\\s*;?/);\n```\n\nYour second new character class should be optional.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/\\s*;?/);\n```"
    },
    {
      "title": "Step 38",
      "description": "Ranges are separated by a colon. After your two capture groups, your `rangeRegex` should look for a colon.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?)/;\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should add a colon after your second capture group.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\/\\s*;?/);\n```"
    },
    {
      "title": "Step 39",
      "description": "After your `rangeRegex` finds the `:`, it needs to look for the same letter and number pattern as it did before.\n\nCopy your two existing capture groups and paste them after the colon.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):/;\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should add a third capture group to your `rangeRegex`, after the colon.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(.*\\)/);\n```\n\nYour third capture group should use a character class.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[.*\\]\\)/);\n```\n\nYour third capture group should match the characters `A` through `J`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)/);\n```\n\nYou should add a fourth capture group to your `rangeRegex`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(.*\\)/);\n```\n\nYour fourth capture group should match one or two digits.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)/);\n```"
    },
    {
      "title": "Step 40",
      "description": "Finally, make your `rangeRegex` global and case-insensitive.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/;\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `rangeRegex` should be case-insensitive.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/g?i/);\n```\n\nYour `rangeRegex` should be global.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/i?g/);\n```\n\nYour `rangeRegex` should be both global and case-insensitive.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)/);\n```"
    },
    {
      "title": "Step 41",
      "description": "Declare a `rangeFromString` arrow function that takes two parameters, `num1` and `num2`. The function should implicitly return the result of calling `range` with `num1` and `num2` as arguments.\n\nTo be safe, parse `num1` and `num2` into integers as you pass them into `range`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `rangeFromString` variable after your `rangeRegex`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*(?:var|let|const)\\s+rangeFromString/);\n```\n\nYou should use `const` to declare your `rangeFromString` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString/);\n```\n\nYour `rangeFromString` variable should be an arrow function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(.*\\)\\s*=>/);\n```\n\nYour `rangeFromString` function should have `num1` as the first parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1/);\n```\n\nYour `rangeFromString` function should have `num2` as the second parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>/);\n```\n\nYour `rangeFromString` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*\\{/);\n```\n\nYour `rangeFromString` function should return the result of calling your `range` function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(/);\n```\n\nYou should call `parseInt` with `num1` as an argument and pass the result to the `range` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)/);\n```\n\nYou should call `parseInt` with `num2` as the argument and pass the result to the `range` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 42",
      "description": "Declare a function `elemValue` which takes a `num` parameter. The function should be empty.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `elemValue` variable after your `rangeFromString()` function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*(?:var|let|const)\\s+elemValue/);\n```\n\nYou should use `const` to declare your `elemValue` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue/);\n```\n\nYour `elemValue` variable should be an arrow function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(.*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `elemValue` function should have `num` as the only parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>/);\n```\n\nYour `elemValue` function should be empty.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 43",
      "description": "In your `elemValue` function, declare a function called `inner` which takes a `character` parameter.\n\nThen, return your `inner` function.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => {\n\n  }\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `inner` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*(?:var|let|const)\\s+inner/);\n```\n\nYou should use `const` to declare your `inner` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner/);\n```\n\nYour `inner` variable should be an arrow function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(.*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `inner` function should have `character` as the only parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>/);\n```\n\nYour `inner` function should be empty.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*\\}/);\n```\n\nYou should explicitly return your `inner` function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*\\}\\s*;?\\s*return\\s+inner/);\n```"
    },
    {
      "title": "Step 44",
      "description": "In your `inner` function, return the result of calling `idToText` with `character + num` as the argument.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => {\n    const inner = character => {\n\n    }\n    return inner;\n  }\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `inner` function should use an explicit return.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return/);\n```\n\nYour `inner` function should return the result of calling your `idToText` function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(/);\n```\n\nYou should pass `character + num` as the argument to your `idToText` function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner/);\n```"
    },
    {
      "title": "Step 45",
      "description": "The concept of returning a function within a function is called <dfn>currying</dfn>. This approach allows you to create a variable that holds a function to be called later, but with a reference to the parameters of the outer function call.\n\nFor example:\n\n```js\nconst innerOne = elemValue(1);\nconst final = innerOne(\"A\");\n```\n\n`innerOne` would be your `inner` function, with `num` set to `1`, and `final` would have the value of the cell with the `id` of `\"A1\"`. This is possible because functions have access to all variables declared at their creation. This is called <dfn>closure</dfn>.\n\nYou'll get some more practice with this. Declare a function called `addCharacters` which takes a `character1` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => {\n    const inner = character => {\n      return idToText(character + num);\n    }\n    return inner;\n  }\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `addCharacters` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*(?:var|let|const)\\s+addCharacters/);\n```\n\nYou should use `const` to declare your `addCharacters` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters/);\n```\n\nYour `addCharacters` variable should be an arrow function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(.*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `addCharacters` function should not use an implicit return.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(.*\\)|[^\\s()]+)\\s*=>\\s*\\{/);\n```\n\nYour `addCharacters` function should have a `character1` parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>/);\n```"
    },
    {
      "title": "Step 46",
      "description": "In your `elemValue` function, you explicitly declared a function called `inner` and returned it. However, because you are using arrow syntax, you can implicitly return a function. For example:\n\n```js\nconst curry = soup => veggies => {};\n```\n\n`curry` is a function which takes a `soup` parameter and returns a function which takes a `veggies` parameter. Using this syntax, update your `addCharacters` function to return an empty function which takes a `character2` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => {\n    const inner = character => {\n      return idToText(character + num);\n    }\n    return inner;\n  }\n  const addCharacters = character1 => {\n\n  }\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `addCharacters` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|characters1)\\s*=>\\s*\\{/);\n```\n\nYour `addCharacters` function should return an arrow function which has a `character2` parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>/);\n```\n\nYour inner arrow function should be empty.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 47",
      "description": "Your inner functions can also return a function. Using the same arrow syntax, update your `addCharacters` function to return a third function which takes a `num` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => {\n    const inner = character => {\n      return idToText(character + num);\n    }\n    return inner;\n  }\n  const addCharacters = character1 => character2 => {\n\n  }\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your inner arrow function should return another arrow function with a `num` parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>/);\n```\n\nYour inner-most arrow function should be empty.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 48",
      "description": "Now update your innermost function in the `addCharacters` chain to implicitly return the result of calling `charRange()` with `character1` and `character2` as the arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => {\n    const inner = character => {\n      return idToText(character + num);\n    }\n    return inner;\n  }\n  const addCharacters = character1 => character2 => num => {\n\n  }\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your innermost function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{/);\n```\n\nYour innermost function should return the result of calling `charRange()`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(/);\n```\n\nYou should pass `character1` as the first argument to your `charRange()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1/);\n```\n\nYou should pass `character2` as the second argument to your `charRange()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{\\s*const\\s+inner\\s*=\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{\\s*return\\s+idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*}\\s*;?\\s*return\\s+inner\\s*;?\\s*\\}\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)/);\n```"
    },
    {
      "title": "Step 49",
      "description": "Use the same syntax as your `addCharacters` function to update your `elemValue` function. It should no longer declare `inner`, but should return the function implicitly.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => {\n    const inner = character => {\n      return idToText(character + num);\n    }\n    return inner;\n  }\n  const addCharacters = character1 => character2 => num => charRange(character1, character2);\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `elemValue` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*\\{/);\n```\n\nYour `elemValue` function should implicitly return an arrow function with a `character` parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>/);\n```\n\nYour inner arrow function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*\\{/);\n```\n\nYour inner arrow function should return the result of calling `idToText()` with `character + num` as the argument.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)/);\n```"
    },
    {
      "title": "Step 50",
      "description": "Your `addCharacters` function ultimately returns a range of characters. You want it to return an array of cell ids. Chain the `.map()` method to your `charRange()` call. Do not pass a callback function yet.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2);\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should chain `.map()` to your `charRange()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(/);\n```\n\nYou should not pass anything to your `.map()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*\\)/);\n```"
    },
    {
      "title": "Step 51",
      "description": "You can pass a function <dfn>reference</dfn> as a callback parameter. A function reference is a function name without the parentheses. For example:\n\n```js\nconst myFunc = (val) => `value: ${val}`;\nconst array = [1, 2, 3];\nconst newArray = array.map(myFunc);\n```\n\nThe `.map()` method here will call the `myFunc` function, passing the same arguments that a `.map()` callback takes. The first argument is the value of the array at the current iteration, so `newArray` would be `[value: 1, value: 2, value: 3]`.\n\nPass a reference to your `elemValue` function as the callback to your `.map()` method.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map();\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should not call your `elemValue` function.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*\\)\\s*\\)/);\n```\n\nYou should pass a reference to `elemValue` as the callback to your `.map()` method.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\s*\\)/);\n```"
    },
    {
      "title": "Step 52",
      "description": "Because `elemValue` returns a function, your `addCharacters` function ultimately returns an array of function references. You want the `.map()` method to run the inner function of your `elemValue` function, which means you need to call `elemValue` instead of reference it. Pass `num` as the argument to your `elemValue` function.\n\n<!-- TODO: Explain further? -->",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue);\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should call `elemValue()` in your `.map()` method.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(/);\n```\n\nYou should pass `num` to your `elemValue()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 53",
      "description": "Declare a `rangeExpanded` variable and assign it the result of calling the `.replace()` method of your `x` parameter. Pass the `rangeRegex` variable as the argument.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `rangeExpanded` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*(?:let|var|const)\\s+rangeExpanded/);\n```\n\nYou should use `const` to declare your `rangeExpanded` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded/);\n```\n\nYou should assign the result of calling `.replace()` on `x` to your `rangeExpanded` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(/);\n```\n\nYou should pass `rangeRegex` as the argument to `.replace()`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*\\)/);\n```"
    },
    {
      "title": "Step 54",
      "description": "The second argument to the `.replace()` method does not have to be a string. You can instead pass a callback function to run more complex logic on the matched string.\n\nThe callback function takes a few parameters. The first is the matched string. Pass an empty callback function to your `.replace()` call, and give it a `match` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex);\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should pass an arrow function as the second argument to your `.replace()` method.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*(\\(.*\\)|[^\\s()]+)\\s*=>\\s*\\{\\s*\\}\\s*\\)/);\n```\n\nYour arrow function should take a `match` parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*\\{\\s*\\}\\s*\\)/);\n```"
    },
    {
      "title": "Step 55",
      "description": "The callback function should have a parameter for each capture group in the regular expression. In your case, `rangeRegex` has four capture groups: the first letter, the first numbers, the second letter, and the second numbers.\n\nGive your callback function four more parameters to match those capture groups: `char1`, `num1`, `char2`, and `num2`. `char` will be short for `character`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (match) => {});\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your callback function should have `char1` as the second parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1/);\n```\n\nYour callback function should have `num1` as the third parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1/);\n```\n\nYour callback function should have `char2` as the fourth parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2/);\n```\n\nYour callback function should have `num2` as the fifth parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)/);\n```"
    },
    {
      "title": "Step 56",
      "description": "Have your callback implicitly return the result of calling `rangeFromString()` with `num1` and `num2` as the arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (match, char1, num1, char2, num2) => {});\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your callback should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*\\{/);\n```\n\nYour callback should return the result of calling `rangeFromString()`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(/);\n```\n\nYou should pass `num1` as the first argument to your `rangeFromString()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1/);\n```\n\nYou should pass `num2` as the second argument to your `rangeFromString()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)/);\n```"
    },
    {
      "title": "Step 57",
      "description": "Call the `.map()` method on your `rangeFromString()` call, passing a reference to `addCharacters` as the callback function.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (match, char1, num1, char2, num2) => rangeFromString(num1, num2));\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should call the `.map()` method on your `rangeFromString()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(/);\n```\n\nYou should pass a reference to `addCharacters` as the callback to your `.map()` method.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\)/);\n```"
    },
    {
      "title": "Step 58",
      "description": "`addCharacters` returns a function, so you'll want to call it. Pass `char1` as the argument.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters));\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should call your `addCharacters()` function in your `.map()` method.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*/);\n```\n\nYou should pass `char1` as the argument to your `addCharacters()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 59",
      "description": "Your `addCharacters(char1)` is also returning a function, which returns another function. You need to make another function call to access that innermost function reference for the `.map()` callback. JavaScript allows you to immediately invoke returned functions:\n\n```js\nmyFunc(1)(\"hi\");\n```\n\nImmediately invoke the function returned from your `addCharacters(char1)` call, and pass `char2` as the argument.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)));\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should chain a function call to your `addCharacters(char1)` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(/);\n```\n\nYou should pass `char2` as the argument to your chained function call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 60",
      "description": "Now that your `.map()` function is receiving the returned `num => charRange(...).map(...)` function reference from the curried `addCharacters` calls, it will properly iterate over the elements and pass each element as `n` to that function.\n\nYou'll notice that you are not using your `match` parameter. In JavaScript, it is common convention to prefix an unused parameter with an underscore `_`. You could also leave the parameter empty like so: `(, char1)` but it is often clearer to name the parameter for future readability.\n\nPrefix your `match` parameter with an underscore.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should prefix your `match` parameter with an underscore.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 61",
      "description": "Declare a variable `cellRegex` to match cell references. It should match a letter from `A` to `J`, followed by a digit from `1` to `9`, and an optional digit from `0` to `9`. Make the regular expression case-insensitive and global.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `cellRegex` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:var|let|const)\\s+cellRegex/);\n```\n\nYou should use `const` to declare your `cellRegex` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex/);\n```\n\nYou should assign a regular expression to your `cellRegex` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\//);\n```\n\nYour regular expression should use a character class to match the characters from `A` to `J`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]/);\n```\n\nYour regular expression should use a character class to match the digits from `1` to `9`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]/);\n```\n\nYour regular expression should use a character class to match the digits from `0` to `9`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]/);\n```\n\nYour third character class should be optional.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?/);\n```\n\nYour regular expression should be case-insensitive and global.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)/);\n```"
    },
    {
      "title": "Step 62",
      "description": "Declare a `cellExpanded` variable and assign it the value of calling `.replace()` on your `rangeExpanded` variable. Pass it your `cellRegex` and an empty callback function. The callback function should take a `match` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `cellExpanded` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*(var|let|const)\\s+cellExpanded/);\n```\n\nYou should use `const` to declare your `cellExpanded` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded/);\n```\n\nYou should assign `cellExpanded` the result of calling the `.replace()` method of `rangeExpanded`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(/);\n```\n\nYou should pass `cellRegex` as the first argument to your `.replace()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex/);\n```\n\nYou should pass a callback function using arrow syntax as the second argument to your `.replace()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*(?:match)?\\s*\\)|match)\\s*=>/);\n```\n\nYour callback function should have a `match` parameter.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>/);\n```\n\nYour callback function should be empty.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 63",
      "description": "Update your callback function to return the result of calling `idToText()` with `match` as the argument. Remember that your regular expression is case-insensitive, so you will need to call `toUpperCase()` on `match` before passing it to `idToText()`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => {})\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your callback function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*\\{/);\n```\n\nYour callback function should call `idToText()`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(/);\n```\n\nYou should pass `match` to your `idToText()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\s*/);\n```\n\nYou should call the `.toUpperCase()` method of `match` as you pass it to `idToText()`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 64",
      "description": "In mathematics, an <dfn>infix</dfn> is a mathematical operator that appears between its two operands. For example, `1 + 2` is an infix expression.\n\nTo parse these expressions, you will need to map the symbols to relevant functions. Declare an `infixToFunction` variable, and assign it an empty object.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\n\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `infixToFunction` variable.\n\n```js\nassert.match(code, /(?:const|let|var)\\s+infixToFunction/);\n```\n\nYou should use `const` to declare your `infixToFunction` variable.\n\n```js\nassert.match(code, /const\\s+infixToFunction/);\n```\n\nYour `infixToFunction` variable should be an object.\n\n```js\nassert.isObject(infixToFunction);\n```\n\nYour `infixToFunction` object should be empty.\n\n```js\nassert.lengthOf(Object.keys(infixToFunction), 0);\n```"
    },
    {
      "title": "Step 65",
      "description": "Object values do not have to be primitive types, like a string or a number. They can also be functions.\n\nGive your `infixToFunction` object a `+` property. That property should be a function that takes an `x` and `y` parameter and implicitly returns the sum of those two parameters.\n\nBecause `+` is not alphanumeric, you'll need to wrap it in quotes for your property.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nconst infixToFunction = {\n\n}\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `infixToFunction` object should have a `+` property.\n\n```js\nassert.property(infixToFunction, '+');\n```\n\nYour `+` property should be a function.\n\n```js\nassert.isFunction(infixToFunction['+']);\n```\n\nYour `+` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+infixToFunction\\s*=\\s*\\{\\s*('|\"|`)\\+\\1\\s*:\\s*\\(/);\n```\n\nYour `+` function should have `x` as its first parameter.\n\n```js\nassert.match(code, /const\\s+infixToFunction\\s*=\\s*\\{\\s*('|\"|`)\\+\\1\\s*:\\s*\\(\\s*x/);\n```\n\nYour `+` function should have `y` as its second parameter.\n\n```js\nassert.match(code, /const\\s+infixToFunction\\s*=\\s*\\{\\s*('|\"|`)\\+\\1\\s*:\\s*\\(\\s*x\\s*,\\s*y\\s*\\)/);\n```\n\nYour `+` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+infixToFunction\\s*=\\s*\\{\\s*('|\"|`)\\+\\1\\s*:\\s*\\(\\s*x\\s*,\\s*y\\s*\\)\\s*\\{/);\n```\n\nYour `+` function should return the sum of `x` and `y`.\n\n```js\nassert.equal(infixToFunction['+'](1, 2), 3);\n```"
    },
    {
      "title": "Step 66",
      "description": "Now create a `-` property that is a function that takes an `x` and `y` parameter and implicitly returns the result of subtracting `y` from `x`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nconst infixToFunction = {\n  \"+\": (x, y) => x + y,\n\n}\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `infixToFunction` object should have a `-` property.\n\n```js\nassert.property(infixToFunction, '-');\n```\n\nYour `-` property should be a function.\n\n```js\nassert.isFunction(infixToFunction['-']);\n```\n\nYour `-` function should use arrow syntax.\n\n```js\nassert.match(code, /('|\"|`)-\\1\\s*:\\s*\\(/);\n```\n\nYour `-` function should have `x` as its first parameter.\n\n```js\nassert.match(code, /('|\"|`)-\\1\\s*:\\s*\\(\\s*x/);\n```\n\nYour `-` function should have `y` as its second parameter.\n\n```js\nassert.match(code, /('|\"|`)-\\1\\s*:\\s*\\(\\s*x\\s*,\\s*y\\s*\\)/);\n```\n\nYour `-` function should use an implicit return.\n\n```js\nassert.notMatch(code, /('|\"|`)-\\1\\s*:\\s*\\(\\s*x\\s*,\\s*y\\s*\\)\\s*\\{/);\n```\n\nYour `-` function should return the result of subtracting `y` from `x`.\n\n```js\nassert.equal(infixToFunction['-'](1, 2), -1);\n```"
    },
    {
      "title": "Step 67",
      "description": "Following the same pattern, add a property for multiplication `*` and division `/` with the appropriate functions.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "--fcc-editable-region--\nconst infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n\n}\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `infixToFunction` object should have a `*` property.\n\n```js\nassert.property(infixToFunction, '*');\n```\n\nYour `*` property should be a function.\n\n```js\nassert.isFunction(infixToFunction['*']);\n```\n\nYour `*` function should use arrow syntax.\n\n```js\nassert.match(code, /('|\"|`)\\*\\1\\s*:\\s*\\(/);\n```\n\nYour `*` function should have `x` as its first parameter.\n\n```js\nassert.match(code, /('|\"|`)\\*\\1\\s*:\\s*\\(\\s*x/);\n```\n\nYour `*` function should have `y` as its second parameter.\n\n```js\nassert.match(code, /('|\"|`)\\*\\1\\s*:\\s*\\(\\s*x\\s*,\\s*y\\s*\\)/);\n```\n\nYour `*` function should use an implicit return.\n\n```js\nassert.notMatch(code, /('|\"|`)\\*\\1\\s*:\\s*\\(\\s*x\\s*,\\s*y\\s*\\)\\s*\\{/);\n```\n\nYour `*` function should return the result of multiplying `x` by `y`.\n\n```js\nassert.equal(infixToFunction['*'](2, 5), 10);\n```\n\nYour `infixToFunction` object should have a `/` property.\n\n```js\nassert.property(infixToFunction, '/');\n```\n\nYour `/` property should be a function.\n\n```js\nassert.isFunction(infixToFunction['/']);\n```\n\nYour `/` function should use arrow syntax.\n\n```js\nassert.match(code, /('|\"|`)\\/\\1\\s*:\\s*\\(/);\n```\n\nYour `/` function should have `x` as its first parameter.\n\n```js\nassert.match(code, /('|\"|`)\\/\\1\\s*:\\s*\\(\\s*x/);\n```\n\nYour `/` function should have `y` as its second parameter.\n\n```js\nassert.match(code, /('|\"|`)\\/\\1\\s*:\\s*\\(\\s*x\\s*,\\s*y\\s*\\)/);\n```\n\nYour `/` function should use an implicit return.\n\n```js\nassert.notMatch(code, /('|\"|`)\\/\\1\\s*:\\s*\\(\\s*x\\s*,\\s*y\\s*\\)\\s*\\{/);\n```\n\nYour `/` function should return the result of dividing `x` by `y`.\n\n```js\nassert.equal(infixToFunction['/'](10, 2), 5);\n```"
    },
    {
      "title": "Step 68",
      "description": "Now that you have your infix functions, you need a way to evaluate them. Declare an `infixEval` function which takes two parameters, `str` and `regex`. It should implicitly return the `.replace()` method of `str`, with `regex` and an empty callback as the arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `infixEval` variable.\n\n```js\nassert.match(code, /(?:var|let|const)\\s+infixEval\\s*=/);\n```\n\nYou should use `const` to declare your `infixEval` variable.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=/);\n```\n\nYour `infixEval` variable should be a function.\n\n```js\nassert.isFunction(infixEval);\n```\n\nYour `infixEval` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(/);\n```\n\nYour `infixEval` function should have `str` as its first parameter.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str/);\n```\n\nYour `infixEval` function should have `regex` as its second parameter.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)/);\n```\n\nYour `infixEval` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*\\{/);\n```\n\nYour `infixEval` function should return the result of calling the `.replace()` method on `str`.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(/);\n```\n\nYou should pass `regex` as the first argument to the `.replace()` method.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex/);\n```\n\nYou should pass an empty arrow function as the second argument to the `.replace()` method.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*\\}\\s*\\)/);\n```"
    },
    {
      "title": "Step 69",
      "description": "Your callback needs four parameters. `match`, `arg1`, `operator`, and `arg2`.\n\nYou will not be using the `match` parameter, so remember to prefix it.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\n--fcc-editable-region--\nconst infixEval = (str, regex) => str.replace(regex, () => {});\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your callback function should have `match` as the first parameter.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_?match/);\n```\n\nYour `match` parameter should be prefixed with an underscore.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match/);\n```\n\nYour callback function should have `arg1` as the second parameter.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1/);\n```\n\nYour callback function should have `operator` as the third parameter.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator/);\n```\n\nYour callback function should have `arg2` as the fourth parameter.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)/);\n```\n\nYour callback function should still be empty.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*\\{\\s*\\}\\s*\\)/);\n```"
    },
    {
      "title": "Step 70",
      "description": "The `regex` you will be passing to your `infixEval` function will match two numbers with an operator between them. The first number will be assigned to `arg1` in the callback, the second to `arg2`, and the operator to `operator`.\n\nHave your callback function implicitly return the `operator` property of your `infixToFunction` object. Remember that `operator` is a variable which holds the property name, not the actual property name.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\n--fcc-editable-region--\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => {});\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your callback should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*\\{/);\n```\n\nYour callback function should access the `infixToFunction` object.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*infixToFunction/);\n```\n\nYour callback function should use bracket notation to access the property of the `infixToFunction` object that matches the value of the `operator` parameter.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*infixToFunction\\s*\\[\\s*operator\\s*\\]\\s*\\)/);\n```"
    },
    {
      "title": "Step 71",
      "description": "`infixToFunction[operator]` returns a function. Call that function directly, passing `arg1` and `arg2` as the arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\n--fcc-editable-region--\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator]);\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your callback function should return the result of calling `infixToFunction[operator]`.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*infixToFunction\\s*\\[\\s*operator\\s*\\]\\s*\\(/);\n```\n\nYou should pass `arg1` as the first argument to your `infixToFunction[operator]` call.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*infixToFunction\\s*\\[\\s*operator\\s*\\]\\s*\\(\\s*arg1/);\n```\n\nYou should pass `arg2` as the second argument to your `infixToFunction[operator]` call.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*infixToFunction\\s*\\[\\s*operator\\s*\\]\\s*\\(\\s*arg1\\s*,\\s*arg2\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 72",
      "description": "You have a slight bug. `arg1` and `arg2` are strings, not numbers. `infixToFunction['+'](\"1\", \"2\")` would return `12`, which is not mathematically correct.\n\nWrap each of your `infixToFunction[operator]` arguments in a `parseFloat()` call.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\n--fcc-editable-region--\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](arg1, arg2));\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should wrap `arg1` in a `parseFloat()` call.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*infixToFunction\\s*\\[\\s*operator\\s*\\]\\s*\\(\\s*parseFloat\\(\\s*arg1\\s*\\)\\s*,/);\n```\n\nYou should wrap `arg2` in a `parseFloat()` call.\n\n```js\nassert.match(code, /const\\s+infixEval\\s*=\\s*\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*=>\\s*str\\.replace\\(\\s*regex\\s*,\\s*\\(\\s*_match\\s*,\\s*arg1\\s*,\\s*operator\\s*,\\s*arg2\\s*\\)\\s*=>\\s*infixToFunction\\s*\\[\\s*operator\\s*\\]\\s*\\(\\s*parseFloat\\(\\s*arg1\\s*\\)\\s*,\\s*parseFloat\\(\\s*arg2\\s*\\)\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 73",
      "description": "Now that you can evaluate mathematical expressions, you need to account for order of operations. Declare a `highPrecedence` function that takes a `str` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `highPrecedence` variable.\n\n```js\nassert.match(code, /(?:var|let|const)\\s+highPrecedence/);\n```\n\nYou should use `const` to declare your `highPrecedence` variable.\n\n```js\nassert.match(code, /const\\s+highPrecedence/);\n```\n\nYour `highPrecedence` variable should be a function.\n\n```js\nassert.isFunction(highPrecedence);\n```\n\nYour `highPrecedence` function should use arrow syntax.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `highPrecedence` function should have a `str` parameter.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>/);\n```\n\nYour `highPrecedence` function should be empty.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*}/);\n```"
    },
    {
      "title": "Step 74",
      "description": "In your `highPrecedence` function, declare a variable using `const` and assign it a regex that checks if the string passed to the `str` parameter matches the pattern of a number followed by a `*` or `/` operator followed by another number.\n\nYour function should return a boolean value. Remember that you can use the `test()` method for this.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\n--fcc-editable-region--\nconst highPrecedence = str => {\n\n}\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a variable in your `highPrecedence` function for your regex.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*(?:const|let|var)\\s+\\w+/);\n```\n\nYou should use `const` to declare your regex variable.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+\\w+/);\n```\n\nYour regex variable should contain a regular expression.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+\\w+\\s*=\\s*\\//);\n```\n\nYour `highPrecedence` function should return a boolean value.\n\n```js\nassert.isBoolean(highPrecedence(\"12*2\"));\n```\n\nYour `highPrecedence` function should correctly check if the string matches the pattern of a number followed by a `*` or `/` operator followed by another number.\n\n```js\nassert.isTrue(highPrecedence(\"5*3\"));\nassert.isFalse(highPrecedence(\"5\"));\nassert.isTrue(highPrecedence(\"10/2\"));\nassert.isFalse(highPrecedence(\"*\"));\n```"
    },
    {
      "title": "Step 77",
      "description": "Now that you have a regular expression to match multiplication or division, you can evaluate that expression.\n\nDeclare a `str2` variable and assign it the result of calling `infixEval` with `str` and `regex` as arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\n--fcc-editable-region--\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n\n}\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `str2` variable.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*(?:const|let|var)\\s+str2/);\n```\n\nYou should use `const` to declare your `str2` variable.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2/);\n```\n\nYou should assign `str2` the result of calling your `infixEval` function.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(/);\n```\n\nYou should pass `str` as the first argument to your `infixEval` call.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*str/);\n```\n\nYou should pass `regex` as the second argument to your `infixEval` call.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*str\\s*,\\s*regex\\s*\\)/);\n```"
    },
    {
      "title": "Step 78",
      "description": "Your `infixEval` function will only evaluate the first multiplication or division operation, because `regex` isn't global. This means you'll want to use a recursive approach to evaluate the entire string.\n\nIf `infixEval` does not find any matches, it will return the `str` value as-is. Using a ternary expression, check if `str2` is equal to `str`. If it is, return `str`, otherwise return the result of calling `highPrecedence()` on `str2`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\n--fcc-editable-region--\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n\n}\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `highPrecedence` function should use the `return` keyword.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*;?\\s*return/);\n```\n\nYou should use the `return` keyword with a condition to check if `str` is equal to `str2`.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*;?\\s*return\\s+(?:str\\s*===\\s*str2|str2\\s*===\\s*str)/);\n```\n\nYou should use ternary syntax with your `return` statement.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*;?\\s*return\\s+(?:str\\s*===\\s*str2|str2\\s*===\\s*str)\\s*\\?/);\n```\n\nIf the ternary condition is true, you should return `str`.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*;?\\s*return\\s+(?:str\\s*===\\s*str2|str2\\s*===\\s*str)\\s*\\?\\s*str/);\n```\n\nIf the ternary condition is false, you should return the result of calling `highPrecedence()`.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*;?\\s*return\\s+(?:str\\s*===\\s*str2|str2\\s*===\\s*str)\\s*\\?\\s*str\\s*:\\s*highPrecedence\\(/);\n```\n\nYou should pass `str2` to your `highPrecedence()` call.\n\n```js\nassert.match(code, /const\\s+highPrecedence\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*{\\s*const\\s+regex\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\*\\\\\\/|\\\\\\/*)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*str\\s*,\\s*regex\\s*\\)\\s*;?\\s*return\\s+(?:str\\s*===\\s*str2|str2\\s*===\\s*str)\\s*\\?\\s*str\\s*:\\s*highPrecedence\\(\\s*str2\\s*\\)/);\n```"
    },
    {
      "title": "Step 79",
      "description": "Now you can start applying your function parsing logic to a string. Declare a function called `applyFunction`, which takes a `str` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\n\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `applyFunction` variable.\n\n```js\nassert.match(code, /(?:var|let|const)\\s+applyFunction\\s*=/);\n```\n\nYou should use `const` to declare your `applyFunction` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=/);\n```\n\nYour `applyFunction` variable should be a function.\n\n```js\nassert.isFunction(applyFunction);\n```\n\nYour `applyFunction` function should use arrow syntax.\n\n```js\nassert.match(code,  /const\\s+applyFunction\\s*=\\s*(\\([^)]*\\)|[^\\s()]+)\\s*=>/);\n```\n\nYour `applyFunction` function should have a `str` parameter.\n\n```js\nassert.match(code,  /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>/);\n```\n\nYour `applyFunction` should be empty.\n\n```js\nassert.match(code,  /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 80",
      "description": "First you need to handle the higher precedence operators. Declare a `noHigh` variable, and assign it the result of calling `highPrecedence()` with `str` as an argument.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `noHigh` variable.\n\n```js\nassert.match(code,  /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*(?:var|let|const)\\s+noHigh\\s*=/);\n```\n\nYou should use `const` to declare your `noHigh` variable.\n\n```js\nassert.match(code,  /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=/);\n```\n\nYou should assign `noHigh` the result of calling `highPrecedence()`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(/);\n```\n\nYou should pass `str` as the argument to your `highPrecedence()` call.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)/);\n```"
    },
    {
      "title": "Step 81",
      "description": "Now that you've parsed and evaluated the multiplication and division operators, you need to do the same with the addition and subtraction operators.\n\nDeclare an `infix` variable, and assign it a regular expression that matches a number (including decimal numbers) followed by a `+` or `-` operator followed by another number.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `infix` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+infix\\s*=/);\n```\n\nYou should use `const` to declare your `infix` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=/);\n```\n\nYour `infix` variable should be a regular expression.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\//);\n```\n\nYour `infix` regex should use a capture group.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(/);\n```\n\nYour first capture group should use a character class.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[/);\n```\n\nYour first capture group should match one or more digits or decimal points. Use the `\\d` character class.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)/);\n```\n\nYour `infix` regex should use a second capture group.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(/);\n```\n\nYour second capture group should use a character class.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[/);\n```\n\nYour second capture group should match either the `+` or `-` operator.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)/);\n```\n\nYour `infix` regex should use a third capture group.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(/);\n```\n\nYour third capture group should be the same as your first capture group.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?/);\n```"
    },
    {
      "title": "Step 82",
      "description": "Declare a `str2` variable, and assign it the result of calling `infixEval()` with `noHigh` and `infix` as arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `str2` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*(?:let|var|const)\\s+str2/);\n```\n\nYou should use `const` to declare your `str2` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2/);\n```\n\nYou should assign `str2` the result of calling `infixEval()`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(/);\n```\n\nYou should pass `noHigh` as the first argument to `infixEval()`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh/);\n```\n\nYou should pass `infix` as the second argument to `infixEval()`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?/);\n```"
    },
    {
      "title": "Step 83",
      "description": "Declare a `functionCall` variable, and assign it this regular expression: `/([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i`\n\nThis expression will look for function calls like `sum(1, 4)`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `functionCall` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionCall\\s*=/);\n```\n\nYou should use `const` to declare your `functionCall` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=/);\n```\n\nYou should assign `functionCall` the provided regular expression.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*\\,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i/);\n```"
    },
    {
      "title": "Step 84",
      "description": "Declare a `toNumberList` function that takes an `args` parameter and implicitly returns the result of splitting the `args` by commas. Then chain a `map` method to your `split` method and pass in `parseFloat` as the argument to the `map` method.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `toNumberList` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*(?:const|let|var)\\s+toNumberList\\s*=/);\n```\n\nYou should use `const` to declare your `toNumberList` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=/);\n```\n\nYour `toNumberList` variable should be an arrow function.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(\\(\\s*(?:args)?\\s*\\)|args)\\s*=>/);\n```\n\nYour `toNumberList` function should have an `args` parameter.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(\\(\\s*args\\s*\\)|args)\\s*=>/);\n```\n\nYour `toNumberList` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(\\(\\s*args\\s*\\)|args)\\s*=>\\s*\\{/);\n```\n\nYour `toNumberList` function should return the result of calling the `.split()` method of `args`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(/);\n```\n\nYou should split `args` on the `\",\"` character.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)/);\n```\n\nYou should chain the `.map()` method to the `.split()` method.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(/);\n```\n\nYou should pass a reference to `parseFloat` as the callback to `.map()`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?/);\n```"
    },
    {
      "title": "Step 85",
      "description": "Declare an `apply` function that takes a `fn` and `args` parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare an `apply` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*(?:var|let|const)\\s+apply\\s*=/);\n```\n\nYou should use `const` to declare your `apply` variable.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=/);\n```\n\nYour `apply` variable should be assigned an arrow function.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(/);\n```\n\nYour `apply` function should have `fn` as its first parameter.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn/);\n```\n\nYour `apply` function should have `args` as its second parameter.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)/);\n```\n\nYour `apply` function should be empty.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 86",
      "description": "The `fn` parameter will be passed the name of a function, such as `\"SUM\"`. Update `apply` to implicitly return the function from your `spreadsheetFunctions` object using the `fn` variable as the key for the object access.\n\nRemember that `fn` might not contain a lowercase string, so you'll need to convert it to a lowercase string.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => {}\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `apply` function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*\\{/);\n```\n\nYour `apply` function should access the `spreadsheetFunctions` object.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions/);\n```\n\nYour `apply` function should access the property of the `spreadsheetFunctions` object that matches the `fn` value.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn/);\n```\n\nYour `apply` function should call the `.toLowerCase()` method on `fn` in the property access.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]/);\n```"
    },
    {
      "title": "Step 87",
      "description": "Your `apply` function is returning the spreadsheet function, but not actually applying it. Update `apply` to call the function. Pass in the result of calling `toNumberList` with `args` as an argument.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()];\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `apply` function should call the `spreadsheetFunctions[fn.toLowerCase()]` function.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(/);\n```\n\nYou should pass a `toNumberList()` call to your `spreadsheetFunctions[fn.toLowerCase()]` call.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(/);\n```\n\nYou should pass `args` to your `toNumberList()` call.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)/);\n```"
    },
    {
      "title": "Step 88",
      "description": "Now your `applyFunction` needs to return a result. Return the result of calling the `.replace()` method on `str2`. Pass your `functionCall` regex and an empty callback.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `applyFunction` function should return the result of calling the `.replace()` method on `str2`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(/);\n```\n\nYou should pass `functionCall` as the first argument to your `.replace()` call.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall/);\n```\n\nYou should pass an empty arrow function as the second argument to your `.replace()` call.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*\\)\\s*=>\\s*\\{\\s*\\}/);\n```"
    },
    {
      "title": "Step 89",
      "description": "Update the callback function to take `match`, `fn`, and `args` as parameters. It should implicitly return the result of checking whether `spreadsheetFunctions` has its own property of `fn`.\n\nRemember to make `fn` lower case.\n\nTo check if a property on a given object exists or not, you can use the <dfn>hasOwnProperty()</dfn> method. \n\nThe `hasOwnProperty()` method returns `true` or `false` depending on if the property is found on the object or not.\n\nHere is an example of how to use the `hasOwnProperty()` method:\n\n```js\nconst developerObj = {\n  name: 'John',\n  age: 34,\n}\n\ndeveloperObj.hasOwnProperty('name'); // true\ndeveloperObj.hasOwnProperty('salary'); // false\n```",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, () => {})\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your callback function should have `match` as the first parameter.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match/);\n```\n\nYour callback function should have `fn` as the second parameter.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn/);\n```\n\nYour callback function should have `args` as the third parameter.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>/);\n```\n\nYour callback function should use an implicit return.\n\n```js\nassert.notMatch(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*\\{/);\n```\n\nYour callback function should return the result of calling the `.hasOwnProperty()` method on the `spreadsheetFunctions` object.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\.hasOwnProperty\\(/);\n```\n\nYou should pass `fn` to the .`hasOwnProperty()` method.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\.hasOwnProperty\\(\\s*fn/);\n```\n\nYou should call the `.toLowerCase()` method on `fn`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\.hasOwnProperty\\(\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\)/);\n```"
    },
    {
      "title": "Step 90",
      "description": "Use the ternary operator to turn your `.hasOwnProperty()` call into the condition. If the object has the property, return the result of calling `apply` with `fn` and `args` as arguments. Otherwise, return `match`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\n--fcc-editable-region--\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) );\n}\n--fcc-editable-region--\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your callback function should use ternary syntax.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\.hasOwnProperty\\(\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\)\\s*\\?/);\n```\n\nIf the ternary condition is true, your callback function should return the result of calling `apply()`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\s*\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\s*\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\.hasOwnProperty\\(\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\)\\s*\\?\\s*apply\\(/);\n```\n\nYou should pass `fn` as the first argument to your `apply()` call.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\.hasOwnProperty\\(\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\)\\s*\\?\\s*apply\\(\\s*fn/);\n```\n\nYou should pass `args` as the second argument to your `apply()` call.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\.hasOwnProperty\\(\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\)\\s*\\?\\s*apply\\(\\s*fn\\s*,\\s*args\\s*\\)/);\n```\n\nIf the ternary is false, you should return `match`.\n\n```js\nassert.match(code, /const\\s+applyFunction\\s*=\\s*(?:\\(\\s*str\\s*\\)|str)\\s*=>\\s*\\{\\s*const\\s+noHigh\\s*=\\s*highPrecedence\\(\\s*str\\s*\\)\\s*;?\\s*const\\s+infix\\s*=\\s*\\/\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\(\\[(?:\\+-|-\\+)\\]\\)\\(\\[(?:\\\\d\\.|\\.\\\\d)\\]\\+\\)\\/\\s*;?\\s*const\\s+str2\\s*=\\s*infixEval\\(\\s*noHigh\\s*,\\s*infix\\s*\\)\\s*;?\\s*const\\s+functionCall\\s*=\\s*\\/\\(\\[a-z0-9\\]\\*\\)\\\\\\(\\(\\[0-9\\., \\]\\*\\)\\\\\\)\\(\\?!\\.\\*\\\\\\(\\)\\/i\\s*;?\\s*const\\s+toNumberList\\s*=\\s*(?:\\(\\s*args\\s*\\)|args)\\s*=>\\s*args\\.split\\(\\s*('|\"|`),\\1\\s*\\)\\.map\\(\\s*parseFloat\\s*\\)\\s*;?\\s*const\\s+apply\\s*=\\s*\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\s*\\[\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\]\\s*\\(\\s*toNumberList\\(\\s*args\\s*\\)\\s*\\)\\s*;?\\s*return\\s+str2\\.replace\\(\\s*functionCall\\s*,\\s*\\(\\s*match\\s*,\\s*fn\\s*,\\s*args\\s*\\)\\s*=>\\s*spreadsheetFunctions\\.hasOwnProperty\\(\\s*fn\\.toLowerCase\\(\\s*\\)\\s*\\)\\s*\\?\\s*apply\\(\\s*fn\\s*,\\s*args\\s*\\)\\s*:\\s*match/);\n```"
    },
    {
      "title": "Step 91",
      "description": "Now you can start applying your function parser to your `evalFormula` logic. Declare a `functionExpanded` variable, and assign it the result of calling `applyFunction` with your `cellExpanded` string.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should declare a `functionExpanded` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*/);\n```\n\nYou should use `const` to declare your `functionExpanded` variable.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+functionExpanded\\s*=\\s*/);\n```\n\nYou should assign the `functionExpanded` variable the result of calling your `applyFunction` function.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(/);\n```\n\nYou should pass `cellExpanded` to your `applyFunction` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(\\s*cellExpanded\\s*\\)\\s*;?/);\n```"
    },
    {
      "title": "Step 92",
      "description": "Like you did with your `highPrecedence()` function, your `evalFormula()` function needs to ensure it has evaluated and replaced everything.\n\nUse a ternary to check if `functionExpanded` is equal to the original string `x`. If it is, return `functionExpanded`, otherwise return the result of calling `evalFormula()` again with `functionExpanded` and `cells` as arguments.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\n--fcc-editable-region--\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n\n}\n--fcc-editable-region--\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your `evalFormula` function should use the `return` keyword.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(\\s*cellExpanded\\s*\\)\\s*;?\\s*return/);\n```\n\nYour `return` statement should check if `functionExpanded` is equal to `x`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(\\s*cellExpanded\\s*\\)\\s*;?\\s*return\\s+(?:functionExpanded\\s*===\\s*x|x\\s*===\\s*functionExpanded)/);\n```\n\nYour `return` statement should use a ternary operator.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(\\s*cellExpanded\\s*\\)\\s*;?\\s*return\\s+(?:functionExpanded\\s*===\\s*x|x\\s*===\\s*functionExpanded)\\s*\\?/);\n```\n\nIf the ternary condition is true, your `evalFormula()` should return `functionExpanded`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(\\s*cellExpanded\\s*\\)\\s*;?\\s*return\\s+(?:functionExpanded\\s*===\\s*x|x\\s*===\\s*functionExpanded)\\s*\\?\\s*functionExpanded/);\n```\n\nIf the ternary condition is false, your `evalFormula()` should return the result of calling `evalFormula()`.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(\\s*cellExpanded\\s*\\)\\s*;?\\s*return\\s+(?:functionExpanded\\s*===\\s*x|x\\s*===\\s*functionExpanded)\\s*\\?\\s*functionExpanded\\s*:\\s*evalFormula\\(/);\n```\n\nYou should pass `functionExpanded` as the first argument to your `evalFormula()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(\\s*cellExpanded\\s*\\)\\s*;?\\s*return\\s+(?:functionExpanded\\s*===\\s*x|x\\s*===\\s*functionExpanded)\\s*\\?\\s*functionExpanded\\s*:\\s*evalFormula\\(\\s*functionExpanded/);\n```\n\nYou should pass `cells` as the second argument to your `evalFormula()` call.\n\n```js\nassert.match(code, /const\\s+evalFormula\\s*=\\s*\\(\\s*x\\s*,\\s*cells\\s*\\)\\s*=>\\s*{\\s*const\\s+idToText\\s*=\\s*(\\(\\s*id\\s*\\)|id)\\s*=>\\s*cells\\.find\\(\\s*(\\(\\s*cell\\s*\\)|cell)\\s*=>\\s*(?:cell\\.id\\s*===\\s*id|id\\s*===\\s*cell\\.id)\\s*\\)\\.value\\s*;?\\s*const\\s+rangeRegex\\s*=\\s*\\/\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\):\\(\\[A-J\\]\\)\\(\\[1-9\\]\\[0-9\\]\\?\\)\\/(gi|ig)\\s*;?\\s*const\\s+rangeFromString\\s*=\\s*\\(\\s*num1\\s*,\\s*num2\\s*\\)\\s*=>\\s*range\\(\\s*parseInt\\(\\s*num1\\s*\\)\\s*,\\s*parseInt\\(\\s*num2\\s*\\)\\s*\\)\\s*;?\\s*const\\s+elemValue\\s*=\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*(\\(\\s*character\\s*\\)|character)\\s*=>\\s*idToText\\(\\s*character\\s*\\+\\s*num\\s*\\)\\s*;?\\s*const\\s+addCharacters\\s*=\\s*(\\(\\s*character1\\s*\\)|character1)\\s*=>\\s*(\\(\\s*character2\\s*\\)|character2)\\s*=>\\s*(\\(\\s*num\\s*\\)|num)\\s*=>\\s*charRange\\(\\s*character1\\s*,\\s*character2\\s*\\)\\.map\\(\\s*elemValue\\(\\s*num\\s*\\)\\s*\\)\\s*;?\\s*const\\s+rangeExpanded\\s*=\\s*x\\.replace\\(\\s*rangeRegex\\s*,\\s*\\(\\s*_match\\s*,\\s*char1\\s*,\\s*num1\\s*,\\s*char2\\s*,\\s*num2\\s*\\)\\s*=>\\s*rangeFromString\\(\\s*num1\\s*,\\s*num2\\s*\\)\\.map\\(\\s*addCharacters\\s*\\(\\s*char1\\s*\\)\\(\\s*char2\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*const\\s+cellRegex\\s*=\\s*\\/\\[A-J\\]\\[1-9\\]\\[0-9\\]\\?\\/(gi|ig)\\s*;?\\s*const\\s+cellExpanded\\s*=\\s*rangeExpanded\\.replace\\(\\s*cellRegex\\s*,\\s*(\\(\\s*match\\s*\\)|match)\\s*=>\\s*idToText\\(\\s*match\\.toUpperCase\\(\\s*\\)\\s*\\)\\s*\\)\\s*;?\\s*(?:const|let|var)\\s+functionExpanded\\s*=\\s*applyFunction\\(\\s*cellExpanded\\s*\\)\\s*;?\\s*return\\s+(?:functionExpanded\\s*===\\s*x|x\\s*===\\s*functionExpanded)\\s*\\?\\s*functionExpanded\\s*:\\s*evalFormula\\(\\s*functionExpanded\\s*,\\s*cells\\s*\\)\\s*;?/);\n```"
    },
    {
      "title": "Step 93",
      "description": "Now your `update()` function can actually evaluate formulas. Remember that you wrote the `if` condition to check that a function was called.\n\nInside your `if` statement, set the `value` of the `element` to be the result of your `evalFormula()` function. Do not pass any arguments yet.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should update the `value` property of `element` in your `if` block.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value/);\n```\n\nYou should assign the `value` property the result of calling your `evalFormula()` function.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(/);\n```\n\nYou should not pass any arguments to your `evalFormula()` call.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(\\s*\\)/);\n```"
    },
    {
      "title": "Step 94",
      "description": "The first argument for your `evalFormula` call needs to be the contents of the cell (which you stored in `value`). However, the contents start with an `=` character to trigger the function, so you need to pass the substring of `value` starting at index `1`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula();\n  }\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should pass `value` as the first argument to your `evalFormula()` call.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(\\s*value/);\n```\n\nYou should call the `.slice()` method on the `value` argument.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(\\s*value\\.(?:slice|substring)\\(/);\n```\n\nYou should pass the number `1` as the argument to your `.slice()` call.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(\\s*value\\.(?:slice|substring)\\(\\s*1\\s*\\)\\s*\\)\\s*;?/);\n```"
    },
    {
      "title": "Step 95",
      "description": "You can quickly get all cells from your page by getting the `#container` element by its `id` and accessing the `children` property of the result. Pass that to your `evalFormula()` call as the second parameter.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1));\n  }\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "For the second parameter of your `evalFormula()` call, you should call the `.getElementById()` method of the `document` object.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(\\s*value\\.slice\\(\\s*1\\s*\\)\\s*,\\s*document\\.getElementById\\(/);\n```\n\nYou should pass `container` as the argument to your `.getElementById()` call.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(\\s*value\\.slice\\(\\s*1\\s*\\)\\s*,\\s*document\\.getElementById\\(\\s*('|\"|`)container\\9\\s*\\)/);\n```\n\nYou should access the `children` property of the result of your `.getElementById()` call.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(\\s*value\\.slice\\(\\s*1\\s*\\)\\s*,\\s*document\\.getElementById\\(\\s*('|\"|`)container\\9\\s*\\)\\.children\\s*\\)\\s*;?/);\n```"
    },
    {
      "title": "Step 96",
      "description": "Unfortunately, that `children` property is returning a collection of elements, which is array-like but not an array. Wrap your second argument in `Array.from()` to convert it to an array.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\n--fcc-editable-region--\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), document.getElementById(\"container\").children);\n  }\n}\n--fcc-editable-region--"
        }
      ],
      "testCode": "You should wrap your `document.getElementById('container').children` in `Array.from()`.\n\n```js\nassert.match(code, /const\\s+update\\s*=\\s*(?:\\(\\s*event\\s*\\)|event)\\s*=>\\s*\\{\\s*const\\s+element\\s*=\\s*event\\.target\\s*;?\\s*const\\s+value\\s*=\\s*element\\.value\\.replace\\(\\s*\\/\\\\s\\/g\\s*,\\s*('|\"|`)\\1\\s*\\)\\s*;?\\s*if\\s*\\(\\s*(!value\\.includes\\(\\s*element\\.id\\s*\\)\\s*&&\\s*(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\3|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\4|value\\.startsWith\\(\\s*('|\"|`)=\\5\\s*\\))|(?:value\\s*\\[\\s*0\\s*\\]\\s*===\\s*('|\"|`)=\\6|value\\.charAt\\(\\s*0\\s*\\)\\s*===\\s*('|\"|`)=\\7|value\\.startsWith\\(\\s*('|\"|`)=\\8\\s*\\))\\s*\\|\\|\\s*!value\\.includes\\(\\s*element\\.id\\s*\\))\\s*\\)\\s*\\{\\s*element\\.value\\s*=\\s*evalFormula\\(\\s*value\\.slice\\(\\s*1\\s*\\)\\s*,\\s*Array\\.from\\(\\s*document\\.getElementById\\(\\s*('|\"|`)container\\9\\s*\\)\\.children\\s*\\)\\s*\\)\\s*;?/);\n```"
    },
    {
      "title": "Step 97",
      "description": "Your spreadsheet is now functional. However, you don't have support for very many formulas.\n\nAdd an `even` property to your `spreadsheetFunctions`. It should take a `nums` parameter, and return the result of filtering the `nums` array to only include even numbers. Use a reference to your `isEven` function to help.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median,\n\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have an `even` property.\n\n```js\nassert.property(spreadsheetFunctions, \"even\");\n```\n\nYour `even` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.even);\n```\n\nYour `even` function should take a `nums` parameter.\n\n```js\nassert.match(code, /even\\s*:\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>/)\n```\n\nYour `even` function should use an implicit return.\n\n```js\nassert.notMatch(code, /even\\s*:\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*\\{/)\n```\n\nYour `even` function should return the result of calling the `.filter()` method on `nums`.\n\n```js\nassert.match(code, /even\\s*:\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*nums\\s*\\.\\s*filter/)\n```\n\nYou should pass a reference to your `isEven()` function as the callback for the `.filter()` method.\n\n```js\nassert.match(code, /even\\s*:\\s*(\\(\\s*nums\\s*\\)|nums)\\s*=>\\s*nums\\s*\\.\\s*filter\\s*\\(\\s*isEven\\s*\\)/)\n```\n\nYour `even` function should return an array of even numbers.\n\n```js\nassert.deepEqual(spreadsheetFunctions.even([1, 2, 3, 4, 5, 6]), [2, 4, 6]);\n```"
    },
    {
      "title": "Step 98",
      "description": "Add a `firsttwo` property which takes a `nums` parameter and returns the first two elements of the `nums` array in order. Then add a `lasttwo` property which returns the last two elements of the `nums` array in order.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median,\n  even: nums => nums.filter(isEven),\n\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have a `firsttwo` property.\n\n```js\nassert.property(spreadsheetFunctions, \"firsttwo\");\n```\n\nYour `firsttwo` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.firsttwo);\n```\n\nYour `firsttwo` function should return the first two numbers of the array.\n\n```js\nassert.deepEqual(spreadsheetFunctions.firsttwo([1, 2, 3, 4, 5, 6]), [1, 2]);\n```\n\nYour `spreadsheetFunctions` object should have a `lasttwo` property.\n\n```js\nassert.property(spreadsheetFunctions, \"lasttwo\");\n```\n\nYour `lasttwo` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.lasttwo);\n```\n\nYour `lasttwo` function should return the last two numbers of the array.\n\n```js\nassert.deepEqual(spreadsheetFunctions.lasttwo([1, 2, 3, 4, 5, 6]), [5, 6]);\n```"
    },
    {
      "title": "Step 99",
      "description": "Add a `has2` property which returns whether the `nums` array has `2` in the values, and an `increment` property which returns `nums` with every value incremented by one.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median,\n  even: nums => nums.filter(isEven),\n  firsttwo: nums => nums.slice(0, 2),\n  lasttwo: nums => nums.slice(-2),\n\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have a `has2` property.\n\n```js\nassert.property(spreadsheetFunctions, \"has2\");\n```\n\nYour `has2` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.has2);\n```\n\nYour `has2` function should return `true` if the array has `2` in it.\n\n```js\nassert.isTrue(spreadsheetFunctions.has2([1, 2, 3]));\n```\n\nYour `has2` function should return `false` if the array does not have `2` in it.\n\n```js\nassert.isFalse(spreadsheetFunctions.has2([1, 3, 4]));\n```\n\nYour `spreadsheetFunctions` object should have an `increment` property.\n\n```js\nassert.property(spreadsheetFunctions, \"increment\");\n```\n\nYour `increment` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.increment);\n```\n\nYour `increment` function should return an array of numbers incremented by one.\n\n```js\nassert.deepEqual(spreadsheetFunctions.increment([1, 2, 3]), [2, 3, 4]);\n```"
    },
    {
      "title": "Step 100",
      "description": "Add a `someeven` property to your `spreadsheetFunctions` - use the `.some()` method to check if any element in the array is even.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median,\n  even: nums => nums.filter(isEven),\n\n  firsttwo: nums => nums.slice(0, 2),\n  lasttwo: nums => nums.slice(-2),\n  has2: nums => nums.includes(2),\n  increment: nums => nums.map(num => num + 1),\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have a `someeven` property.\n\n```js\nassert.property(spreadsheetFunctions, \"someeven\");\n```\n\nYour `someeven` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.someeven);\n```\n\nYour `someeven` function should return `true` if some of the elements in the array are even.\n\n```js\nassert.isTrue(spreadsheetFunctions.someeven([1, 2, 3]));\n```\n\nYour `someeven` function should return `false` if none of the elements in the array are even.\n\n```js\nassert.isFalse(spreadsheetFunctions.someeven([1, 3, 5]));\n```"
    },
    {
      "title": "Step 102",
      "description": "Create a `random` property. This property should use the first two numbers from an array to generate a random whole number. The range for this number starts at the first number (inclusive) of the two and ends just before the sum of these two numbers. Use the `Math.floor()` and `Math.random()` methods for the calculation.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median,\n  even: nums => nums.filter(isEven),\n  someeven: nums => nums.some(isEven),\n  everyeven: nums => nums.every(isEven),\n  firsttwo: nums => nums.slice(0, 2),\n  lasttwo: nums => nums.slice(-2),\n  has2: nums => nums.includes(2),\n  increment: nums => nums.map(num => num + 1),\n\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have a `random` property.\n\n```js\nassert.property(spreadsheetFunctions, \"random\");\n```\n\nYour `random` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.random);\n```\n\nYour `random` function should return a random number between the first two numbers in the array.\n\n```js\nassert.isAtLeast(spreadsheetFunctions.random([1, 2, 3]), 1);\nassert.isAtMost(spreadsheetFunctions.random([1, 2, 3]), 2);\n```\n\nYour `random` function should return a whole number (integer).\n\n```js\nconst result = spreadsheetFunctions.random([1, 10]);\nassert.equal(result, Math.floor(result));\n```"
    },
    {
      "title": "Step 103",
      "description": "Add a `range` property which generates a range from the first number in `nums` to the second number in `nums`. Remember that you have a `range` function you can reuse here.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median,\n  even: nums => nums.filter(isEven),\n  someeven: nums => nums.some(isEven),\n  everyeven: nums => nums.every(isEven),\n  firsttwo: nums => nums.slice(0, 2),\n  lasttwo: nums => nums.slice(-2),\n  has2: nums => nums.includes(2),\n  increment: nums => nums.map(num => num + 1),\n  random: ([x, y]) => Math.floor(Math.random() * y + x),\n\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have a `range` property.\n\n```js\nassert.property(spreadsheetFunctions, \"range\");\n```\n\nYour `range` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.range);\n```\n\nYour `range` function should return an array of consecutive numbers from the first number in the argument to the second number in the argument.\n\n```js\nassert.deepEqual(spreadsheetFunctions.range([1, 5, 10]), [1, 2, 3, 4, 5]);\n```"
    },
    {
      "title": "Step 104",
      "description": "The last function has a few approaches to implement, and you are free to choose whichever approach you would like.\n\nAdd a `nodupes` property which returns `nums` with all duplicate values removed. For example, `[2, 1, 2, 5, 3, 2, 7]` should return `[2, 1, 5, 3, 7]`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median,\n  even: nums => nums.filter(isEven),\n  someeven: nums => nums.some(isEven),\n  everyeven: nums => nums.every(isEven),\n  firsttwo: nums => nums.slice(0, 2),\n  lasttwo: nums => nums.slice(-2),\n  has2: nums => nums.includes(2),\n  increment: nums => nums.map(num => num + 1),\n  random: ([x, y]) => Math.floor(Math.random() * y + x),\n  range: nums => range(...nums),\n\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have a `nodupes` property.\n\n```js\nassert.property(spreadsheetFunctions, \"nodupes\");\n```\n\nYour `nodupes` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.nodupes);\n```\n\nYour `nodupes` function should remove all duplicate values from the array.\n\n```js\nassert.deepEqual(spreadsheetFunctions.nodupes([2, 1, 2, 5, 3, 2, 7]), [2, 1, 5, 3, 7]);\nassert.deepEqual(spreadsheetFunctions.nodupes([1, 2, 3]), [1, 2, 3]);\n```"
    },
    {
      "title": "Step 105",
      "description": "Finally, to handle potential edge cases, add an empty string property (you will need to use quotes) which is a function that takes a single argument and returns that argument.\n\nWith that, your spreadsheet project is now complete. You are welcome to experiment with adding support for even more functions.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  \n  sum,\n  average,\n  median,\n  even: nums => nums.filter(isEven),\n  someeven: nums => nums.some(isEven),\n  everyeven: nums => nums.every(isEven),\n  firsttwo: nums => nums.slice(0, 2),\n  lasttwo: nums => nums.slice(-2),\n  has2: nums => nums.includes(2),\n  increment: nums => nums.map(num => num + 1),\n  random: ([x, y]) => Math.floor(Math.random() * y + x),\n  range: nums => range(...nums),\n  nodupes: nums => [...new Set(nums).values()]\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have an empty string property.\n\n```js\nassert.property(spreadsheetFunctions, \"\");\n```\n\nYour empty string property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions[\"\"]);\n```\n\nYour empty string property function should return the argument.\n\n```js\nassert.deepEqual(spreadsheetFunctions[\"\"]([1,2,3]), [1,2,3]);\n```"
    },
    {
      "title": "Step 101",
      "description": "Arrays have an `.every()` method. Like the `.some()` method, `.every()` accepts a callback function which should take an element of the array as the argument. The `.every()` method will return `true` if the callback function returns `true` for all elements in the array.\n\nHere is an example of a `.every()` method call to check if all elements in the array are uppercase letters.\n\n```js\nconst arr = [\"A\", \"b\", \"C\"];\narr.every(letter => letter === letter.toUpperCase());\n```\n\nAdd an `everyeven` property to your `spreadsheetFunctions` - use the `.every()` method to check whether all array elements are even.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  const str2 = infixEval(str, regex);\n  return str === str2 ? str : highPrecedence(str2);\n}\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\n--fcc-editable-region--\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median,\n  even: nums => nums.filter(isEven),\n  someeven: nums => nums.some(isEven),\n\n  firsttwo: nums => nums.slice(0, 2),\n  lasttwo: nums => nums.slice(-2),\n  has2: nums => nums.includes(2),\n  increment: nums => nums.map(num => num + 1),\n}\n--fcc-editable-region--\n\nconst applyFunction = str => {\n  const noHigh = highPrecedence(str);\n  const infix = /([\\d.]+)([+-])([\\d.]+)/;\n  const str2 = infixEval(noHigh, infix);\n  const functionCall = /([a-z0-9]*)\\(([0-9., ]*)\\)(?!.*\\()/i;\n  const toNumberList = args => args.split(\",\").map(parseFloat);\n  const apply = (fn, args) => spreadsheetFunctions[fn.toLowerCase()](toNumberList(args));\n  return str2.replace(functionCall, (match, fn, args) => spreadsheetFunctions.hasOwnProperty(fn.toLowerCase()) ? apply(fn, args) : match);\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n  const functionExpanded = applyFunction(cellExpanded);\n  return functionExpanded === x ? functionExpanded : evalFormula(functionExpanded, cells);\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n    element.value = evalFormula(value.slice(1), Array.from(document.getElementById(\"container\").children));\n  }\n}"
        }
      ],
      "testCode": "Your `spreadsheetFunctions` object should have an `everyeven` property.\n\n```js\nassert.property(spreadsheetFunctions, \"everyeven\");\n```\n\nYour `everyeven` property should be a function.\n\n```js\nassert.isFunction(spreadsheetFunctions.everyeven);\n```\n\nYour `everyeven` function should return `true` if every element in the array is even.\n\n```js\nassert.isTrue(spreadsheetFunctions.everyeven([2, 4, 6]));\n```\n\nYour `everyeven` function should return `false` if some of the elements in the array are not even.\n\n```js\nassert.isFalse(spreadsheetFunctions.everyeven([1, 2, 3]));\n```"
    },
    {
      "title": "Step 18",
      "description": "In earlier projects you learned about the `setAttribute` method. Another way to update an attribute in JavaScript is to use the following syntax:\n\n```js\nel.attribute = value;\n```\n\nThe property names for hyphenated HTML attribute values, such as `aria-label`, follow camel case, becoming `ariaLabel`.\n\n```js\nel.ariaLabel = \"Aria Label Value\";\n```\n\nSet the `aria-label` attribute for the `input` element to the same value as the `id` attribute.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n     createLabel(number);\n--fcc-editable-region--\n    letters.forEach(letter => {\n     const input = document.createElement(\"input\");\n     input.type = \"text\";\n     input.id = letter + number;\n \n    })   \n--fcc-editable-region--\n  })\n}"
        }
      ],
      "testCode": "You should have an `input.ariaLabel`.\n\n```js\nassert.match(code, /input\\.ariaLabel\\s*=/);\n```\n\n\nYou should give `input.ariaLabel` the same value as `input.id`.\n\n```js\nassert.match(code, /input\\.ariaLabel\\s*=\\s*((letter\\s*\\+\\s*number)|(input.id))/);\n```"
    },
    {
      "title": "Step 75",
      "description": "You should use `console.log()` to print the result of calling the `highPrecedence` function with the string `\"5*3\"`.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\n--fcc-editable-region--\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  return regex.test(str);\n}\n\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "You should call `console.log()`.\n\n```js\n\nassert.match(code, /console\\.log\\(/);\n\n```\n\nYou should call your `highPrecedence` function.\n\n```js\n\nassert.match(code, /console\\.log\\(highPrecedence\\(/); \n\n\n```\n\nPass `5*3` as the argument\n\n```js\n\nassert.match(code, /console\\.log\\(highPrecedence\\([\"']5\\*3[\"']\\)\\);?/);\n\n```"
    },
    {
      "title": "Step 76",
      "description": "Remove both the `console.log()` with your `highPrecedence` call, and the `return` statement from your `highPrecedence` function.",
      "files": [
        {
          "name": "index.html",
          "language": "html",
          "content": "<!DOCTYPE html>\n<html lang=\"en\">\n  <head>\n    <meta charset=\"utf-8\" />\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1\" />\n    <link rel=\"stylesheet\" href=\"./styles.css\" />\n    <title>Functional Programming Spreadsheet</title>\n  </head>\n  <body>\n    <div id=\"container\">\n      <div></div>\n    </div>\n    <script src=\"./script.js\"></script>\n  </body>\n</html>"
        },
        {
          "name": "styles.css",
          "language": "css",
          "content": "#container {\n  display: grid;\n  grid-template-columns: 50px repeat(10, 200px);\n  grid-template-rows: repeat(11, 30px);\n}\n\n.label {\n  background-color: lightgray;\n  text-align: center;\n  vertical-align: middle;\n  line-height: 30px;\n}"
        },
        {
          "name": "script.js",
          "language": "js",
          "content": "const infixToFunction = {\n  \"+\": (x, y) => x + y,\n  \"-\": (x, y) => x - y,\n  \"*\": (x, y) => x * y,\n  \"/\": (x, y) => x / y,\n}\n\nconst infixEval = (str, regex) => str.replace(regex, (_match, arg1, operator, arg2) => infixToFunction[operator](parseFloat(arg1), parseFloat(arg2)));\n\n--fcc-editable-region--\nconst highPrecedence = str => {\n  const regex = /([\\d.]+)([*\\/])([\\d.]+)/;\n  return regex.test(str);\n}\nconsole.log(highPrecedence(\"5*3\"));\n--fcc-editable-region--\n\nconst isEven = num => num % 2 === 0;\nconst sum = nums => nums.reduce((acc, el) => acc + el, 0);\nconst average = nums => sum(nums) / nums.length;\n\nconst median = nums => {\n  const sorted = nums.slice().sort((a, b) => a - b);\n  const length = sorted.length;\n  const middle = length / 2 - 1;\n  return isEven(length)\n    ? average([sorted[middle], sorted[middle + 1]])\n    : sorted[Math.ceil(middle)];\n}\n\nconst spreadsheetFunctions = {\n  sum,\n  average,\n  median\n}\n\nconst range = (start, end) => Array(end - start + 1).fill(start).map((element, index) => element + index);\nconst charRange = (start, end) => range(start.charCodeAt(0), end.charCodeAt(0)).map(code => String.fromCharCode(code));\n\nconst evalFormula = (x, cells) => {\n  const idToText = id => cells.find(cell => cell.id === id).value;\n  const rangeRegex = /([A-J])([1-9][0-9]?):([A-J])([1-9][0-9]?)/gi;\n  const rangeFromString = (num1, num2) => range(parseInt(num1), parseInt(num2));\n  const elemValue = num => character => idToText(character + num);\n  const addCharacters = character1 => character2 => num => charRange(character1, character2).map(elemValue(num));\n  const rangeExpanded = x.replace(rangeRegex, (_match, char1, num1, char2, num2) => rangeFromString(num1, num2).map(addCharacters(char1)(char2)));\n  const cellRegex = /[A-J][1-9][0-9]?/gi;\n  const cellExpanded = rangeExpanded.replace(cellRegex, match => idToText(match.toUpperCase()));\n}\n\nwindow.onload = () => {\n  const container = document.getElementById(\"container\");\n  const createLabel = (name) => {\n    const label = document.createElement(\"div\");\n    label.className = \"label\";\n    label.textContent = name;\n    container.appendChild(label);\n  }\n  const letters = charRange(\"A\", \"J\");\n  letters.forEach(createLabel);\n  range(1, 99).forEach(number => {\n    createLabel(number);\n    letters.forEach(letter => {\n      const input = document.createElement(\"input\");\n      input.type = \"text\";\n      input.id = letter + number;\n      input.ariaLabel = letter + number;\n      input.onchange = update;\n      container.appendChild(input);\n    })\n  })\n}\n\nconst update = event => {\n  const element = event.target;\n  const value = element.value.replace(/\\s/g, \"\");\n  if (!value.includes(element.id) && value.startsWith('=')) {\n\n  }\n}"
        }
      ],
      "testCode": "Your code should not log the result of `highPrecedence(\"5*3\")`.\n\n```js\n\nassert.notMatch(code, /console\\.log\\(highPrecedence\\(\"5\\*3\"\\)\\)/);\n\n```\n\nYour `highPrecedence` function should not return a value.\n\n```js\n\nassert.isUndefined(highPrecedence(\"5*3\"));\n\n```"
    }
  ]
}