{
  "section": {
    "id": "10-coding-interview-prep",
    "name": "10-coding-interview-prep"
  },
  "challenges": [
    {
      "id": "a3f503de51cf954ede28891d",
      "title": "Find the Symmetric Difference",
      "challengeType": 1,
      "dashedName": "find-the-symmetric-difference",
      "description": "The mathematical term <dfn>symmetric difference</dfn> (`△` or `⊕`) of two sets is the set of elements which are in either of the two sets but not in both. For example, for sets `A = {1, 2, 3}` and `B = {2, 3, 4}`, `A △ B = {1, 4}`.\n\nSymmetric difference is a binary operation, which means it operates on only two elements. So to evaluate an expression involving symmetric differences among *three* elements (`A △ B △ C`), you must complete one operation at a time. Thus, for sets `A` and `B` above, and `C = {2, 3}`, `A △ B △ C = (A △ B) △ C = {1, 4} △ {2, 3} = {1, 2, 3, 4}`.",
      "instructions": "Create a function that takes two or more arrays and returns an array of their symmetric difference. The returned array must contain only unique values (*no duplicates*).",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sym(args) {\n  return args;\n}\n\nsym([1, 2, 3], [5, 2, 1, 4]);"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sym() {\n  var arrays = [].slice.call(arguments);\n  return arrays.reduce(function (symDiff, arr) {\n    return symDiff.concat(arr).filter(function (val, idx, theArr) {\n      return theArr.indexOf(val) === idx\n        && (symDiff.indexOf(val) === -1 || arr.indexOf(val) === -1);\n    });\n  });\n}\nsym([1, 2, 3], [5, 2, 1, 4]);"
        }
      ],
      "tests": [
        {
          "text": "`sym([1, 2, 3], [5, 2, 1, 4])` should return `[3, 4, 5]`.",
          "testCode": "assert.sameMembers(sym([1, 2, 3], [5, 2, 1, 4]), [3, 4, 5]);"
        },
        {
          "text": "`sym([1, 2, 3], [5, 2, 1, 4])` should contain only three elements.",
          "testCode": "assert.equal(sym([1, 2, 3], [5, 2, 1, 4]).length, 3);"
        },
        {
          "text": "`sym([1, 2, 3, 3], [5, 2, 1, 4])` should return `[3, 4, 5]`.",
          "testCode": "assert.sameMembers(sym([1, 2, 3, 3], [5, 2, 1, 4]), [3, 4, 5]);"
        },
        {
          "text": "`sym([1, 2, 3, 3], [5, 2, 1, 4])` should contain only three elements.",
          "testCode": "assert.equal(sym([1, 2, 3, 3], [5, 2, 1, 4]).length, 3);"
        },
        {
          "text": "`sym([1, 2, 3], [5, 2, 1, 4, 5])` should return `[3, 4, 5]`.",
          "testCode": "assert.sameMembers(sym([1, 2, 3], [5, 2, 1, 4, 5]), [3, 4, 5]);"
        },
        {
          "text": "`sym([1, 2, 3], [5, 2, 1, 4, 5])` should contain only three elements.",
          "testCode": "assert.equal(sym([1, 2, 3], [5, 2, 1, 4, 5]).length, 3);"
        },
        {
          "text": "`sym([1, 2, 5], [2, 3, 5], [3, 4, 5])` should return `[1, 4, 5]`.",
          "testCode": "assert.sameMembers(sym([1, 2, 5], [2, 3, 5], [3, 4, 5]), [1, 4, 5]);"
        },
        {
          "text": "`sym([1, 2, 5], [2, 3, 5], [3, 4, 5])` should contain only three elements.",
          "testCode": "assert.equal(sym([1, 2, 5], [2, 3, 5], [3, 4, 5]).length, 3);"
        },
        {
          "text": "`sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])` should return `[1, 4, 5]`.",
          "testCode": "assert.sameMembers(sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]), [1, 4, 5]);"
        },
        {
          "text": "`sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5])` should contain only three elements.",
          "testCode": "assert.equal(sym([1, 1, 2, 5], [2, 2, 3, 5], [3, 4, 5, 5]).length, 3);"
        },
        {
          "text": "`sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3])` should return `[2, 3, 4, 6, 7]`.",
          "testCode": "assert.sameMembers(\n  sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3]),\n  [2, 3, 4, 6, 7]\n);"
        },
        {
          "text": "`sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3])` should contain only five elements.",
          "testCode": "assert.equal(\n  sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3]).length,\n  5\n);"
        },
        {
          "text": "`sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1])` should return `[1, 2, 4, 5, 6, 7, 8, 9]`.",
          "testCode": "assert.sameMembers(\n  sym(\n    [3, 3, 3, 2, 5],\n    [2, 1, 5, 7],\n    [3, 4, 6, 6],\n    [1, 2, 3],\n    [5, 3, 9, 8],\n    [1]\n  ),\n  [1, 2, 4, 5, 6, 7, 8, 9]\n);"
        },
        {
          "text": "`sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1])` should contain only eight elements.",
          "testCode": "assert.equal(\n  sym([3, 3, 3, 2, 5], [2, 1, 5, 7], [3, 4, 6, 6], [1, 2, 3], [5, 3, 9, 8], [1])\n    .length,\n  8\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301611,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\find-the-symmetric-difference.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "61abc7ebf3029b56226de5b6",
      "title": "Implement Binary Search",
      "challengeType": 1,
      "dashedName": "implement-binary-search",
      "description": "Binary search is an **O(log(n))** efficiency algorithm for searching a sorted array to find an element. It operates using the following steps:\n\n1. Find the middle `value` of a sorted array. If `value == target` return `true` (The value has been found and the search is complete).\n1. If middle `value < target`, search right half of array in next compare.\n1. If middle `value > target`, search left half of array in next compare.\n1. If after searching the whole array the value is not present, return `false` (The array has been searched and the value is not in the array).\n\nAs you can see, you are successively halving an array, which gives you the log(n) efficiency. For this challenge, we want you to show your work - how you got to the target value... the path you took!",
      "instructions": "Write a function `binarySearch` that implements the binary search algorithm on an array, returning the path you took (each middle value comparison) to find the target in an array.\n\nThe function takes a sorted array of integers and a target value as input. It returns an array containing (in-order) the middle value you found at each halving of the original array until you found the target value. The target value should be the last element of the returned array. If the value is not found, return the string `Value Not Found`.\n\nFor example, `binarySearch([1,2,3,4,5,6,7], 5)` would return `[4,6,5]`.\n\nFor this challenge, when halving, you MUST use `Math.floor()` when doing division: `Math.floor(x/2)`. This will give a consistent, testable path.\n\n**Note:** The following array will be used in tests:\n\n```js\nconst testArray = [\n  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n  23, 49, 70\n];\n```",
      "boilerplate": [
        {
          "language": "js",
          "code": "function binarySearch(searchList, value) {\n  let arrayPath = [];\n  return arrayPath;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "let binarySearch = (searchList, value) => {\n  let arrayPath = [];\n\n  // set initial L - M - R\n  let left = 0;\n  let right = searchList.length - 1;\n  let middle = Math.floor(right / 2);\n\n  // if first comparison finds value\n  if (searchList[middle] == value) {\n    arrayPath.push(searchList[middle]);\n    return arrayPath;\n  }\n\n  while (searchList[middle] !== value) {\n    // add to output array\n    arrayPath.push(searchList[middle]);\n\n    // not found\n    if (right < left) {\n      return 'Value Not Found';\n    }\n    // value is in left or right portion of array\n    // update L - M - R\n    if (searchList[middle] > value) {\n      right = middle - 1;\n      middle = left + Math.floor((right - left) / 2);\n    } else {\n      left = middle + 1;\n      middle = left + Math.floor((right - left) / 2);\n    }\n\n    // if found update output array and exit\n    if (searchList[middle] == value) {\n      arrayPath.push(searchList[middle]);\n\n      break;\n    }\n  }\n  return arrayPath;\n};"
        }
      ],
      "tests": [
        {
          "text": "`binarySearch` should be a function.",
          "testCode": "assert.isFunction(binarySearch);"
        },
        {
          "text": "`binarySearch(testArray, 0)` should return `[13, 5, 2, 0]`.",
          "testCode": "const _testArray = [\n  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n  23, 49, 70\n];\nassert.deepEqual(binarySearch(_testArray, 0), [13, 5, 2, 0]);"
        },
        {
          "text": "`binarySearch(testArray, 1)` should return `[13, 5, 2, 0, 1]`.",
          "testCode": "const _testArray = [\n  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n  23, 49, 70\n];\nassert.deepEqual(binarySearch(_testArray, 1), [13, 5, 2, 0, 1]);"
        },
        {
          "text": "`binarySearch(testArray, 2)` should return `[13, 5, 2]`.",
          "testCode": "const _testArray = [\n  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n  23, 49, 70\n];\nassert.deepEqual(binarySearch(_testArray, 2), [13, 5, 2]);"
        },
        {
          "text": "`binarySearch(testArray, 6)` should return the string `Value Not Found`.",
          "testCode": "const _testArray = [\n  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n  23, 49, 70\n];\nassert.strictEqual(binarySearch(_testArray, 6), 'Value Not Found');"
        },
        {
          "text": "`binarySearch(testArray, 11)` should return `[13, 5, 10, 11]`.",
          "testCode": "const _testArray = [\n  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n  23, 49, 70\n];\nassert.deepEqual(binarySearch(_testArray, 11), [13, 5, 10, 11])"
        },
        {
          "text": "`binarySearch(testArray, 13)` should return `[13]`.",
          "testCode": "const _testArray = [\n  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n  23, 49, 70\n];\nassert.deepEqual(binarySearch(_testArray, 13), [13]);"
        },
        {
          "text": "`binarySearch(testArray, 70)` should return `[13, 19, 22, 49, 70]`.",
          "testCode": "const _testArray = [\n  0, 1, 2, 3, 4, 5, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22,\n  23, 49, 70\n];\nassert.deepEqual(binarySearch(_testArray, 70), [13, 19, 22, 49, 70]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 487618,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\implement-binary-search.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "8d5123c8c441eddfaeb5bdef",
      "title": "Implement Bubble Sort",
      "challengeType": 1,
      "dashedName": "implement-bubble-sort",
      "description": "This is the first of several challenges on sorting algorithms. Given an array of unsorted items, we want to be able to return a sorted array. We will see several different methods to do this and learn some tradeoffs between these different approaches. While most modern languages have built-in sorting methods for operations like this, it is still important to understand some of the common basic approaches and learn how they can be implemented.\n\nHere we will see bubble sort. The bubble sort method starts at the beginning of an unsorted array and 'bubbles up' unsorted values towards the end, iterating through the array until it is completely sorted. It does this by comparing adjacent items and swapping them if they are out of order. The method continues looping through the array until no swaps occur at which point the array is sorted.\n\nThis method requires multiple iterations through the array and for average and worst cases has quadratic time complexity. While simple, it is usually impractical in most situations.\n\n**Instructions:** Write a function `bubbleSort` which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function bubbleSort(array) {\n  // Only change code below this line\n  return array;\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function bubbleSort(array) {\n  for (let i = 0; i < array.length; i++) {\n    let swapped = false;\n    for (let j = 1; j < array.length; j++) {\n      if (array[j - 1] > array[j]) {\n        let temp = array[j-1];\n        array[j-1] =  array[j];\n        array[j] = temp;\n        swapped = true;\n      }\n    }\n    if (swapped === false) {\n      break;\n    }\n  }\n  return array;\n}"
        }
      ],
      "tests": [
        {
          "text": "`bubbleSort` should be a function.",
          "testCode": "assert.isFunction(bubbleSort);"
        },
        {
          "text": "`bubbleSort` should return a sorted array (least to greatest).",
          "testCode": "function isSorted(a){\n  for(let i = 0; i < a.length - 1; i++)\n    if(a[i] > a[i + 1])\n      return false;\n  return true;\n}\nassert.isTrue(\n  isSorted(\n    bubbleSort([\n      1,\n      4,\n      2,\n      8,\n      345,\n      123,\n      43,\n      32,\n      5643,\n      63,\n      123,\n      43,\n      2,\n      55,\n      1,\n      234,\n      92\n    ])\n  )\n);"
        },
        {
          "text": "`bubbleSort([1,4,2,8,345,123,43,32,5643,63,123,43,2,55,1,234,92])` should return an array that is unchanged except for order.",
          "testCode": "assert.sameMembers(\n  bubbleSort([\n    1,\n    4,\n    2,\n    8,\n    345,\n    123,\n    43,\n    32,\n    5643,\n    63,\n    123,\n    43,\n    2,\n    55,\n    1,\n    234,\n    92\n  ]),\n  [1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]\n);"
        },
        {
          "text": "`bubbleSort` should not use the built-in `.sort()` method.",
          "testCode": "function isBuiltInSortUsed(){\n  let sortUsed = false;\n  const temp = Array.prototype.sort;\n  Array.prototype.sort = () => sortUsed = true;\n  try {\n    bubbleSort([0, 1]);\n  } finally {\n    Array.prototype.sort = temp;\n  }\n  return sortUsed;\n}\nassert.isFalse(isBuiltInSortUsed());"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301612,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\implement-bubble-sort.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "587d8259367417b2b2512c86",
      "title": "Implement Insertion Sort",
      "challengeType": 1,
      "dashedName": "implement-insertion-sort",
      "description": "The next sorting method we'll look at is insertion sort. This method works by building up a sorted array at the beginning of the list. It begins the sorted array with the first element. Then it inspects the next element and swaps it backwards into the sorted array until it is in sorted position. It continues iterating through the list and swapping new items backwards into the sorted portion until it reaches the end. This algorithm has quadratic time complexity in the average and worst cases.\n\n**Instructions:** Write a function `insertionSort` which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function insertionSort(array) {\n  // Only change code below this line\n  return array;\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function insertionSort (array) {\n  for (let currentIndex = 0; currentIndex < array.length; currentIndex++) {\n    let current = array[currentIndex];\n    let j = currentIndex - 1;\n    while (j > -1 && array[j] > current) {\n      array[j + 1] = array[j];\n      j--;\n    }\n    array[j + 1] = current;\n  }\n  return array;\n}"
        }
      ],
      "tests": [
        {
          "text": "`insertionSort` should be a function.",
          "testCode": "assert.isFunction(insertionSort);"
        },
        {
          "text": "`insertionSort` should return a sorted array (least to greatest).",
          "testCode": "function isSorted(a){\n  for(let i = 0; i < a.length - 1; i++)\n    if(a[i] > a[i + 1])\n      return false;\n  return true;\n}\nassert.isTrue(\n  isSorted(\n    insertionSort([\n      1,\n      4,\n      2,\n      8,\n      345,\n      123,\n      43,\n      32,\n      5643,\n      63,\n      123,\n      43,\n      2,\n      55,\n      1,\n      234,\n      92\n    ])\n  )\n);"
        },
        {
          "text": "`insertionSort([1,4,2,8,345,123,43,32,5643,63,123,43,2,55,1,234,92])` should return an array that is unchanged except for order.",
          "testCode": "assert.sameMembers(\n  insertionSort([\n    1,\n    4,\n    2,\n    8,\n    345,\n    123,\n    43,\n    32,\n    5643,\n    63,\n    123,\n    43,\n    2,\n    55,\n    1,\n    234,\n    92\n  ]),\n  [1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]\n);"
        },
        {
          "text": "`insertionSort([5, 4, 33, 2, 8])` should return `[2, 4, 5, 8, 33]`.",
          "testCode": "assert.deepEqual(insertionSort([5, 4, 33, 2, 8]), [2, 4, 5, 8, 33])"
        },
        {
          "text": "`insertionSort` should not use the built-in `.sort()` method.",
          "testCode": "function isBuiltInSortUsed(){\n  let sortUsed = false;\n  const temp = Array.prototype.sort;\n  Array.prototype.sort = () => sortUsed = true;\n  try {\n    insertionSort([0, 1]);\n  } finally {\n    Array.prototype.sort = temp;\n  }\n  return sortUsed;\n}\nassert.isFalse(isBuiltInSortUsed());"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301613,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\implement-insertion-sort.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "587d825c367417b2b2512c8f",
      "title": "Implement Merge Sort",
      "challengeType": 1,
      "dashedName": "implement-merge-sort",
      "description": "Another common intermediate sorting algorithm is merge sort. Like quick sort, merge sort also uses a divide-and-conquer, recursive methodology to sort an array. It takes advantage of the fact that it is relatively easy to sort two arrays as long as each is sorted in the first place. But we'll start with only one array as input, so how do we get to two sorted arrays from that? Well, we can recursively divide the original input in two until we reach the base case of an array with one item. A single-item array is naturally sorted, so then we can start combining. This combination will unwind the recursive calls that split the original array, eventually producing a final sorted array of all the elements. The steps of merge sort, then, are:\n\n**1)** Recursively split the input array in half until a sub-array with only one element is produced.\n\n**2)** Merge each sorted sub-array together to produce the final sorted array.\n\nMerge sort is an efficient sorting method, with time complexity of *O(nlog(n))*. This algorithm is popular because it is performant and relatively easy to implement.\n\nAs an aside, this will be the last sorting algorithm we cover here. However, later in the section on tree data structures we will describe heap sort, another efficient sorting method that requires a binary heap in its implementation.\n\n**Instructions:** Write a function `mergeSort` which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest. A good way to implement this is to write one function, for instance `merge`, which is responsible for merging two sorted arrays, and another function, for instance `mergeSort`, which is responsible for the recursion that produces single-item arrays to feed into merge. Good luck!",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function mergeSort(array) {\n  // Only change code below this line\n  return array;\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function mergeSort(array) {\n  if (array.length === 1) {\n    return array;\n  } else {\n    const splitIndex = Math.floor(array.length / 2);\n    return merge(\n      mergeSort(array.slice(0, splitIndex)),\n      mergeSort(array.slice(splitIndex))\n    );\n  }\n\n  // Merge two sorted arrays\n  function merge(array1, array2) {\n    let merged = [];\n    while (array1.length && array2.length) {\n      if (array1[0] < array2[0]) {\n        merged.push(array1.shift());\n      } else if (array1[0] > array2[0]) {\n        merged.push(array2.shift());\n      } else {\n        merged.push(array1.shift(), array2.shift());\n      }\n    }\n\n    // After looping ends, one array is empty, and other array contains only\n    // values greater than all values in `merged`\n    return [...merged, ...array1, ...array2];\n  }\n}\n\nmergeSort([1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]);"
        }
      ],
      "tests": [
        {
          "text": "`mergeSort` should be a function.",
          "testCode": "assert.isFunction(mergeSort);"
        },
        {
          "text": "`mergeSort` should return a sorted array (least to greatest).",
          "testCode": "function isSorted(a){\n  for(let i = 0; i < a.length - 1; i++)\n    if(a[i] > a[i + 1])\n      return false;\n  return true;\n}\nassert.isTrue(\n  isSorted(\n    mergeSort([\n      1,\n      4,\n      2,\n      8,\n      345,\n      123,\n      43,\n      32,\n      5643,\n      63,\n      123,\n      43,\n      2,\n      55,\n      1,\n      234,\n      92\n    ])\n  )\n);"
        },
        {
          "text": "`mergeSort([1,4,2,8,345,123,43,32,5643,63,123,43,2,55,1,234,92])` should return an array that is unchanged except for order.",
          "testCode": "assert.sameMembers(\n  mergeSort([\n    1,\n    4,\n    2,\n    8,\n    345,\n    123,\n    43,\n    32,\n    5643,\n    63,\n    123,\n    43,\n    2,\n    55,\n    1,\n    234,\n    92\n  ]),\n  [1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]\n);"
        },
        {
          "text": "`mergeSort` should not use the built-in `.sort()` method.",
          "testCode": "function isBuiltInSortUsed(){\n  let sortUsed = false;\n  const temp = Array.prototype.sort;\n  Array.prototype.sort = () => sortUsed = true;\n  try {\n    mergeSort([0, 1]);\n  } finally {\n    Array.prototype.sort = temp;\n  }\n  return sortUsed;\n}\nassert.isFalse(isBuiltInSortUsed());"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301614,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\implement-merge-sort.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "587d825a367417b2b2512c89",
      "title": "Implement Quick Sort",
      "challengeType": 1,
      "dashedName": "implement-quick-sort",
      "description": "Here we will move on to an intermediate sorting algorithm: quick sort. Quick sort is an efficient, recursive divide-and-conquer approach to sorting an array. In this method, a pivot value is chosen in the original array. The array is then partitioned into two subarrays of values less than and greater than the pivot value. We then combine the result of recursively calling the quick sort algorithm on both sub-arrays. This continues until the base case of an empty or single-item array is reached, which we return. The unwinding of the recursive calls return us the sorted array.\n\nQuick sort is a very efficient sorting method, providing *O(nlog(n))* performance on average. It is also relatively easy to implement. These attributes make it a popular and useful sorting method.\n\n**Instructions:** Write a function `quickSort` which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest. While the choice of the pivot value is important, any pivot will do for our purposes here. For simplicity, the first or last element could be used.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function quickSort(array) {\n  // Only change code below this line\n  return array;\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function quickSort(array) {\n  if (array.length === 0) {\n    return [];\n  } else {\n    const pivotValue = array[0];\n\n    // Sort elements into three piles\n    let lesser = [];\n    let equal = [];\n    let greater = [];\n    for (let e of array) {\n      if (e < pivotValue) {\n        lesser.push(e);\n      } else if (e > pivotValue) {\n        greater.push(e);\n      } else {\n        equal.push(e);\n      }\n    }\n\n    return [...quickSort(lesser), ...equal, ...quickSort(greater)];\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`quickSort` should be a function.",
          "testCode": "assert(typeof quickSort == 'function');"
        },
        {
          "text": "`quickSort` should return a sorted array (least to greatest).",
          "testCode": "function isSorted(a){\n  for(let i = 0; i < a.length - 1; i++)\n    if(a[i] > a[i + 1])\n      return false;\n  return true;\n}\nassert.isTrue(\n  isSorted(\n    quickSort([\n      1,\n      4,\n      2,\n      8,\n      345,\n      123,\n      43,\n      32,\n      5643,\n      63,\n      123,\n      43,\n      2,\n      55,\n      1,\n      234,\n      92\n    ])\n  )\n);"
        },
        {
          "text": "`quickSort([1,4,2,8,345,123,43,32,5643,63,123,43,2,55,1,234,92])` should return an array that is unchanged except for order.",
          "testCode": "assert.sameMembers(\n  quickSort([\n    1,\n    4,\n    2,\n    8,\n    345,\n    123,\n    43,\n    32,\n    5643,\n    63,\n    123,\n    43,\n    2,\n    55,\n    1,\n    234,\n    92\n  ]),\n  [1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]\n);"
        },
        {
          "text": "`quickSort` should not use the built-in `.sort()` method.",
          "testCode": "function isBuiltInSortUsed(){\n  let sortUsed = false;\n  const temp = Array.prototype.sort;\n  Array.prototype.sort = () => sortUsed = true;\n  try {\n    quickSort([0, 1]);\n  } finally {\n    Array.prototype.sort = temp;\n  }\n  return sortUsed;\n}\nassert.isFalse(isBuiltInSortUsed());"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301615,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\implement-quick-sort.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "587d8259367417b2b2512c85",
      "title": "Implement Selection Sort",
      "challengeType": 1,
      "dashedName": "implement-selection-sort",
      "description": "Here we will implement selection sort. Selection sort works by selecting the minimum value in a list and swapping it with the first value in the list. It then starts at the second position, selects the smallest value in the remaining list, and swaps it with the second element. It continues iterating through the list and swapping elements until it reaches the end of the list. Now the list is sorted. Selection sort has quadratic time complexity in all cases.\n\n**Instructions**: Write a function `selectionSort` which takes an array of integers as input and returns an array of these integers in sorted order from least to greatest.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function selectionSort(array) {\n  // Only change code below this line\n  return array;\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function selectionSort(array) {\n  for (let i = 0; i < array.length-1; i++) {\n    let minimumIndex = i;\n    for (let j = i+1; j < array.length; j++){\n      if (array[j] < array[minimumIndex]) {\n        minimumIndex = j;\n      }\n    }\n    let value = array[minimumIndex];\n    array[minimumIndex] = array[i];\n    array[i] = value;\n  }\n    return array;\n}"
        }
      ],
      "tests": [
        {
          "text": "`selectionSort` should be a function.",
          "testCode": "assert.isFunction(selectionSort);"
        },
        {
          "text": "`selectionSort` should return a sorted array (least to greatest).\n\n```js\nfunction isSorted(a){\n  for(let i = 0; i < a.length - 1; i++)\n    if(a[i] > a[i + 1])\n      return false;\n  return true;\n}\n\nassert.isTrue(\n  isSorted(\n    selectionSort([\n      1,\n      4,\n      2,\n      8,\n      345,\n      123,\n      43,\n      32,\n      5643,\n      63,\n      123,\n      43,\n      2,\n      55,\n      1,\n      234,\n      92\n    ])\n  )\n);\n```\n\n`selectionSort([1,4,2,8,345,123,43,32,5643,63,123,43,2,55,1,234,92])` should return an array that is unchanged except for order.",
          "testCode": "assert.sameMembers(\n  selectionSort([\n    1,\n    4,\n    2,\n    8,\n    345,\n    123,\n    43,\n    32,\n    5643,\n    63,\n    123,\n    43,\n    2,\n    55,\n    1,\n    234,\n    92\n  ]),\n  [1, 4, 2, 8, 345, 123, 43, 32, 5643, 63, 123, 43, 2, 55, 1, 234, 92]\n);"
        },
        {
          "text": "`selectionSort` should not use the built-in `.sort()` method.",
          "testCode": "function isBuiltInSortUsed(){\n  let sortUsed = false;\n  const temp = Array.prototype.sort;\n  Array.prototype.sort = () => sortUsed = true;\n  try {\n    selectionSort([0, 1]);\n  } finally {\n    Array.prototype.sort = temp;\n  }\n  return sortUsed;\n}\nassert.isFalse(isBuiltInSortUsed());"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301616,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\implement-selection-sort.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "a56138aff60341a09ed6c480",
      "title": "Inventory Update",
      "challengeType": 1,
      "dashedName": "inventory-update",
      "description": "Compare and update the inventory stored in a 2D array against a second 2D array of a fresh delivery. Update the current existing inventory item quantities (in `arr1`). If an item cannot be found, add the new item and quantity into the inventory array. The returned inventory array should be in alphabetical order by item.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function updateInventory(arr1, arr2) {\n    return arr1;\n}\n\n// Example inventory lists\nvar curInv = [\n    [21, \"Bowling Ball\"],\n    [2, \"Dirty Sock\"],\n    [1, \"Hair Pin\"],\n    [5, \"Microphone\"]\n];\n\nvar newInv = [\n    [2, \"Hair Pin\"],\n    [3, \"Half-Eaten Apple\"],\n    [67, \"Bowling Ball\"],\n    [7, \"Toothpaste\"]\n];\n\nupdateInventory(curInv, newInv);"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function updateInventory(arr1, arr2) {\n  arr2.forEach(function(item) {\n    createOrUpdate(arr1, item);\n  });\n  // All inventory must be accounted for or you're fired!\n  return arr1;\n}\n\nfunction createOrUpdate(arr1, item) {\n  var index = -1;\n  while (++index < arr1.length) {\n    if (arr1[index][1] === item[1]) {\n      arr1[index][0] += item[0];\n      return;\n    }\n    if (arr1[index][1] > item[1]) {\n      break;\n    }\n  }\n  arr1.splice(index, 0, item);\n}\n\n// Example inventory lists\nvar curInv = [\n    [21, 'Bowling Ball'],\n    [2, 'Dirty Sock'],\n    [1, 'Hair Pin'],\n    [5, 'Microphone']\n];\n\nvar newInv = [\n    [2, 'Hair Pin'],\n    [3, 'Half-Eaten Apple'],\n    [67, 'Bowling Ball'],\n    [7, 'Toothpaste']\n];\n\nupdateInventory(curInv, newInv);"
        }
      ],
      "tests": [
        {
          "text": "The function `updateInventory` should return an array.",
          "testCode": "assert.isArray(\n  updateInventory(\n    [\n      [21, 'Bowling Ball'],\n      [2, 'Dirty Sock'],\n      [1, 'Hair Pin'],\n      [5, 'Microphone']\n    ],\n    [\n      [2, 'Hair Pin'],\n      [3, 'Half-Eaten Apple'],\n      [67, 'Bowling Ball'],\n      [7, 'Toothpaste']\n    ]\n  )\n);"
        },
        {
          "text": "`updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]])` should return an array with a length of 6.",
          "testCode": "assert.equal(\n  updateInventory(\n    [\n      [21, 'Bowling Ball'],\n      [2, 'Dirty Sock'],\n      [1, 'Hair Pin'],\n      [5, 'Microphone']\n    ],\n    [\n      [2, 'Hair Pin'],\n      [3, 'Half-Eaten Apple'],\n      [67, 'Bowling Ball'],\n      [7, 'Toothpaste']\n    ]\n  ).length,\n  6\n);"
        },
        {
          "text": "`updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]])` should return `[[88, \"Bowling Ball\"], [2, \"Dirty Sock\"], [3, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [5, \"Microphone\"], [7, \"Toothpaste\"]]`.",
          "testCode": "assert.deepEqual(\n  updateInventory(\n    [\n      [21, 'Bowling Ball'],\n      [2, 'Dirty Sock'],\n      [1, 'Hair Pin'],\n      [5, 'Microphone']\n    ],\n    [\n      [2, 'Hair Pin'],\n      [3, 'Half-Eaten Apple'],\n      [67, 'Bowling Ball'],\n      [7, 'Toothpaste']\n    ]\n  ),\n  [\n    [88, 'Bowling Ball'],\n    [2, 'Dirty Sock'],\n    [3, 'Hair Pin'],\n    [3, 'Half-Eaten Apple'],\n    [5, 'Microphone'],\n    [7, 'Toothpaste']\n  ]\n);"
        },
        {
          "text": "`updateInventory([[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]], [])` should return `[[21, \"Bowling Ball\"], [2, \"Dirty Sock\"], [1, \"Hair Pin\"], [5, \"Microphone\"]]`.",
          "testCode": "assert.deepEqual(\n  updateInventory(\n    [\n      [21, 'Bowling Ball'],\n      [2, 'Dirty Sock'],\n      [1, 'Hair Pin'],\n      [5, 'Microphone']\n    ],\n    []\n  ),\n  [\n    [21, 'Bowling Ball'],\n    [2, 'Dirty Sock'],\n    [1, 'Hair Pin'],\n    [5, 'Microphone']\n  ]\n);"
        },
        {
          "text": "`updateInventory([], [[2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [67, \"Bowling Ball\"], [7, \"Toothpaste\"]])` should return `[[67, \"Bowling Ball\"], [2, \"Hair Pin\"], [3, \"Half-Eaten Apple\"], [7, \"Toothpaste\"]]`.",
          "testCode": "assert.deepEqual(\n  updateInventory(\n    [],\n    [\n      [2, 'Hair Pin'],\n      [3, 'Half-Eaten Apple'],\n      [67, 'Bowling Ball'],\n      [7, 'Toothpaste']\n    ]\n  ),\n  [\n    [67, 'Bowling Ball'],\n    [2, 'Hair Pin'],\n    [3, 'Half-Eaten Apple'],\n    [7, 'Toothpaste']\n  ]\n);"
        },
        {
          "text": "`updateInventory([[0, \"Bowling Ball\"], [0, \"Dirty Sock\"], [0, \"Hair Pin\"], [0, \"Microphone\"]], [[1, \"Hair Pin\"], [1, \"Half-Eaten Apple\"], [1, \"Bowling Ball\"], [1, \"Toothpaste\"]])` should return `[[1, \"Bowling Ball\"], [0, \"Dirty Sock\"], [1, \"Hair Pin\"], [1, \"Half-Eaten Apple\"], [0, \"Microphone\"], [1, \"Toothpaste\"]]`.",
          "testCode": "assert.deepEqual(\n  updateInventory(\n    [\n      [0, 'Bowling Ball'],\n      [0, 'Dirty Sock'],\n      [0, 'Hair Pin'],\n      [0, 'Microphone']\n    ],\n    [\n      [1, 'Hair Pin'],\n      [1, 'Half-Eaten Apple'],\n      [1, 'Bowling Ball'],\n      [1, 'Toothpaste']\n    ]\n  ),\n  [\n    [1, 'Bowling Ball'],\n    [0, 'Dirty Sock'],\n    [1, 'Hair Pin'],\n    [1, 'Half-Eaten Apple'],\n    [0, 'Microphone'],\n    [1, 'Toothpaste']\n  ]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 16019,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\inventory-update.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "a7bf700cd123b9a54eef01d5",
      "title": "No Repeats Please",
      "challengeType": 1,
      "dashedName": "no-repeats-please",
      "description": "Return the number of total permutations of the provided string that don't have repeated consecutive letters. Assume that all characters in the provided string are each unique.\n\nFor example, `aab` should return 2 because it has 6 total permutations (`aab`, `aab`, `aba`, `aba`, `baa`, `baa`), but only 2 of them (`aba` and `aba`) don't have the same letter (in this case `a`) repeating.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function permAlone(str) {\n  return str;\n}\n\npermAlone('aab');"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function permAlone(str) {\n  return permuter(str).filter(function(perm) {\n    return !perm.match(/(.)\\1/g);\n  }).length;\n}\n\nfunction permuter(str) {\n  // http://staff.roguecc.edu/JMiller/JavaScript/permute.html\n  //permArr: Global array which holds the list of permutations\n  //usedChars: Global utility array which holds a list of \"currently-in-use\" characters\n  var permArr = [], usedChars = [];\n  function permute(input) {\n    //convert input into a char array (one element for each character)\n    var i, ch, chars = input.split(\"\");\n    for (i = 0; i < chars.length; i++) {\n      //get and remove character at index \"i\" from char array\n      ch = chars.splice(i, 1);\n      //add removed character to the end of used characters\n      usedChars.push(ch);\n      //when there are no more characters left in char array to add, add used chars to list of permutations\n      if (chars.length === 0) permArr[permArr.length] = usedChars.join(\"\");\n      //send characters (minus the removed one from above) from char array to be permuted\n      permute(chars.join(\"\"));\n      //add removed character back into char array in original position\n      chars.splice(i, 0, ch);\n      //remove the last character used off the end of used characters array\n      usedChars.pop();\n    }\n  }\n  permute(str);\n  return permArr;\n}\n\npermAlone('aab');"
        }
      ],
      "tests": [
        {
          "text": "`permAlone(\"aab\")` should return a number.",
          "testCode": "assert.isNumber(permAlone('aab'));"
        },
        {
          "text": "`permAlone(\"aab\")` should return 2.",
          "testCode": "assert.strictEqual(permAlone('aab'), 2);"
        },
        {
          "text": "`permAlone(\"aaa\")` should return 0.",
          "testCode": "assert.strictEqual(permAlone('aaa'), 0);"
        },
        {
          "text": "`permAlone(\"aabb\")` should return 8.",
          "testCode": "assert.strictEqual(permAlone('aabb'), 8);"
        },
        {
          "text": "`permAlone(\"abcdefa\")` should return 3600.",
          "testCode": "assert.strictEqual(permAlone('abcdefa'), 3600);"
        },
        {
          "text": "`permAlone(\"abfdefa\")` should return 2640.",
          "testCode": "assert.strictEqual(permAlone('abfdefa'), 2640);"
        },
        {
          "text": "`permAlone(\"zzzzzzzz\")` should return 0.",
          "testCode": "assert.strictEqual(permAlone('zzzzzzzz'), 0);"
        },
        {
          "text": "`permAlone(\"a\")` should return 1.",
          "testCode": "assert.strictEqual(permAlone('a'), 1);"
        },
        {
          "text": "`permAlone(\"aaab\")` should return 0.",
          "testCode": "assert.strictEqual(permAlone('aaab'), 0);"
        },
        {
          "text": "`permAlone(\"aaabb\")` should return 12.",
          "testCode": "assert.strictEqual(permAlone('aaabb'), 12);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 16037,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\no-repeats-please.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "a3f503de51cfab748ff001aa",
      "title": "Pairwise",
      "challengeType": 1,
      "dashedName": "pairwise",
      "description": "Given an array `arr`, find element pairs whose sum equal the second argument `arg` and return the sum of their indices.\n\nYou may use multiple pairs that have the same numeric elements but different indices. Each pair should use the lowest possible available indices. Once an element has been used it cannot be reused to pair with another element. For instance, `pairwise([1, 1, 2], 3)` creates a pair `[2, 1]` using the 1 at index 0 rather than the 1 at index 1, because 0+2 &lt; 1+2.\n\nFor example `pairwise([7, 9, 11, 13, 15], 20)` returns `6`. The pairs that sum to 20 are `[7, 13]` and `[9, 11]`. We can then write out the array with their indices and values.\n\n<div style='margin-left: 2em;'>\n\n| Index | 0 | 1 | 2  | 3  | 4  |\n| ----- | - | - | -- | -- | -- |\n| Value | 7 | 9 | 11 | 13 | 15 |\n\n</div>\n\nBelow we'll take their corresponding indices and add them.\n\n<div style='margin-left: 2em;'>\n\n7 + 13 = 20 → Indices 0 + 3 = 3  \n9 + 11 = 20 → Indices 1 + 2 = 3  \n3 + 3 = 6 → Return `6`\n\n</div>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function pairwise(arr, arg) {\n  return arg;\n}\n\npairwise([1,4,2,3,0,5], 7);"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function pairwise(arr, arg) {\n  var sum = 0;\n  arr.forEach(function(e, i, a) {\n    if (e != null) {\n      var diff = arg-e;\n      a[i] = null;\n      var dix = a.indexOf(diff);\n      if (dix !== -1) {\n        sum += dix;\n        sum += i;\n        a[dix] = null;\n      }\n    }\n  });\n  return sum;\n}\n\npairwise([1,4,2,3,0,5], 7);"
        }
      ],
      "tests": [
        {
          "text": "`pairwise([1, 4, 2, 3, 0, 5], 7)` should return 11.",
          "testCode": "assert.deepEqual(pairwise([1, 4, 2, 3, 0, 5], 7), 11);"
        },
        {
          "text": "`pairwise([1, 3, 2, 4], 4)` should return 1.",
          "testCode": "assert.deepEqual(pairwise([1, 3, 2, 4], 4), 1);"
        },
        {
          "text": "`pairwise([1, 1, 1], 2)` should return 1.",
          "testCode": "assert.deepEqual(pairwise([1, 1, 1], 2), 1);"
        },
        {
          "text": "`pairwise([0, 0, 0, 0, 1, 1], 1)` should return 10.",
          "testCode": "assert.deepEqual(pairwise([0, 0, 0, 0, 1, 1], 1), 10);"
        },
        {
          "text": "`pairwise([], 100)` should return 0.",
          "testCode": "assert.deepEqual(pairwise([], 100), 0);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301617,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\algorithms\\pairwise.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "algorithms",
        "name": "Algorithms"
      }
    },
    {
      "id": "587d8257367417b2b2512c7b",
      "title": "Add a New Element to a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "add-a-new-element-to-a-binary-search-tree",
      "description": "This series of challenges will introduce the tree data structure. Trees are an important and versatile data structure in computer science. Of course, their name comes from the fact that when visualized they look much like the trees we are familiar with in the natural world. A tree data structure begins with one node, typically referred to as the root, and from here branches out to additional nodes, each of which may have more child nodes, and so on and so forth. The data structure is usually visualized with the root node at the top; you can think of it as a natural tree flipped upside down.\n\nFirst, let's describe some common terminology we will encounter with trees. The root node is the top of the tree. Data points in the tree are called nodes. Nodes with branches leading to other nodes are referred to as the parent of the node the branch leads to (the child). Other more complicated familial terms apply as you might expect. A subtree refers to all the descendants of a particular node, branches may be referred to as edges, and leaf nodes are nodes at the end of the tree that have no children. Finally, note that trees are inherently recursive data structures. That is, any children of a node are parents of their own subtree, and so on. The recursive nature of trees is important to understand when designing algorithms for common tree operations.\n\nTo begin, we will discuss a particular type of tree, the binary tree. In fact, we will actually discuss a particular binary tree, a binary search tree. Let's describe what this means. While the tree data structure can have any number of branches at a single node, a binary tree can only have two branches for every node. Furthermore, a binary search tree is ordered with respect to the child subtrees, such that the value of each node in the left subtree is less than or equal to the value of the parent node, and the value of each node in the right subtree is greater than or equal to the value of the parent node. It's very helpful to visualize this relationship in order to understand it better:\n\n<div style='width: 100%; display: flex; justify-content: center; align-items: center;'><img alt=\"an example of a binary search tree\" style='width: 100%; max-width: 350px; background-color: var(--gray-05);' src='https://user-images.githubusercontent.com/18563015/32136009-1e665d98-bbd6-11e7-9133-63184f9f9182.png'></div>\n\nNow this ordered relationship is very easy to see. Note that every value to the left of 8, the root node, is less than 8, and every value to the right is greater than 8. Also notice that this relationship applies to each of the subtrees as well. For example, the first left child is a subtree. 3 is the parent node, and it has exactly two child nodes — by the rules governing binary search trees, we know without even looking that the left child of this node (and any of its children) will be less than 3, and the right child (and any of its children) will be greater than 3 (but also less than the structure's root value), and so on.\n\nBinary search trees are very common and useful data structures because they provide logarithmic time in the average case for several common operations such as lookup, insertion, and deletion.",
      "instructions": "We'll start simple. We've defined the skeleton of a binary search tree structure here in addition to a function to create nodes for our tree. Observe that each node may have a left and right value. These will be assigned child subtrees if they exist. In our binary search tree, you will create a method to add new values to the tree. The method should be called `add` and it should accept an integer value to add to the tree. Take care to maintain the invariant of a binary search tree: the value in each left child should be less than or equal to the parent value, and the value in each right child should be greater than or equal to the parent value. Here, let's make it so our tree cannot hold duplicate values. If we try to add a value that already exists, the method should return `null`. Otherwise, if the addition is successful, `undefined` should be returned.\n\n**Hint:** trees are naturally recursive data structures!",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  this.add = function(element) {\n    let current = this.root;\n    if (!current) {\n      this.root = new Node(element);\n      return;\n    } else {\n      const searchTree = function(current) {\n        if (current.value > element) {\n          if (current.left) {\n            return searchTree(current.left);\n          } else {\n            current.left = new Node(element);\n            return;\n          }\n        } else if (current.value < element) {\n          if (current.right) {\n            return searchTree(current.right);\n          } else {\n            current.right = new Node(element);\n            return;\n          }\n        } else {\n          return null;\n        }\n      };\n      return searchTree(current);\n    }\n  };\n}"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `add`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.add == 'function';\n  })()\n);"
        },
        {
          "text": "The add method should add elements according to the binary search tree rules.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.add !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(1);\n    test.add(1);\n    test.add(7);\n    test.add(87);\n    test.add(34);\n    test.add(45);\n    test.add(73);\n    test.add(8);\n    const expectedResult = [1, 4, 7, 8, 34, 45, 73, 87];\n    const result = test.inOrder();\n    return expectedResult.toString() === result.toString();\n  })()\n);"
        },
        {
          "text": "Adding an element that already exists should return `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.add !== 'function') {\n      return false;\n    }\n    test.add(4);\n    return test.add(4) == null;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301618,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\add-a-new-element-to-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    inOrder() {\n      if (!this.root) {\n        return null;\n      }\n      var result = new Array();\n      function traverseInOrder(node) {\n        node.left && traverseInOrder(node.left);\n        result.push(node.value);\n        node.right && traverseInOrder(node.right);\n      }\n      traverseInOrder(this.root);\n      return result;\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8252367417b2b2512c67",
      "title": "Add Elements at a Specific Index in a Linked List",
      "challengeType": 1,
      "dashedName": "add-elements-at-a-specific-index-in-a-linked-list",
      "description": "Let's create a addAt(index,element) method that adds an element at a given index. Just like how we remove elements at a given index, we need to keep track of the currentIndex as we traverse the linked list. When the currentIndex matches the given index, we would need to reassign the previous node's next property to reference the new added node. And the new node should reference the next node in the currentIndex. Returning to the conga line example, a new person wants to join the line, but he wants to join in the middle. You are in the middle of the line, so you take your hands off of the person ahead of you. The new person walks over and puts his hands on the person you once had hands on, and you now have your hands on the new person.",
      "instructions": "Create an `addAt(index,element)` method that adds an element at a given index. Return false if an element could not be added. **Note:** Remember to check if the given index is a negative or is longer than the length of the linked list.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function(element) {\n    this.element = element;\n    this.next = null;\n  };\n\n  this.size = function() {\n    return length;\n  };\n\n  this.head = function() {\n    return head;\n  };\n\n  this.add = function(element) {\n    var node = new Node(element);\n    if (head === null) {\n      head = node;\n    } else {\n      var currentNode = head;\n\n      while (currentNode.next) {\n        currentNode = currentNode.next;\n      }\n\n      currentNode.next = node;\n    }\n    length++;\n  };\n\n  // Only change code below this line\n\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function(element){\n    this.element = element;\n    this.next = null;\n  };\n\n  this.size = function(){\n    return length;\n  };\n\n  this.head = function(){\n    return head;\n  };\n\n  this.add = function(element){\n    var node = new Node(element);\n    if (head === null){\n        head = node;\n    } else {\n      var currentNode = head;\n\n      while (currentNode.next) {\n        currentNode = currentNode.next;\n      }\n\n      currentNode.next = node;\n    }\n    length++;\n  };\n  this.addAt = function (index, element) {\n    if (index > length || index < 0) {\n      return false;\n    }\n    var newNode = new Node(element);\n    var currentNode = head;\n    if (index === 0) {\n      head = newNode;\n    } else {\n      var previousNode = null;\n      var i = 0;\n      while (currentNode && i < index) {\n        previousNode = currentNode;\n        currentNode = currentNode.next;\n        i++;\n      }\n      previousNode.next = newNode;\n    }\n    newNode.next = currentNode;\n    length++;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `addAt` method should reassign `head` to the new node when the given index is 0.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.addAt(0, 'fish');\n    return test.head().element === 'fish' && test.head().next.element === 'cat';\n  })()\n);"
        },
        {
          "text": "Your `addAt` method should increase the length of the linked list by one for each new node added to the linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.addAt(0, 'cat');\n    return test.size() === 3;\n  })()\n);"
        },
        {
          "text": "Your `addAt` method should return `false` if a node was unable to be added.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    return test.addAt(4, 'cat') === false;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301619,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\add-elements-at-a-specific-index-in-a-linked-list.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8256367417b2b2512c77",
      "title": "Adjacency List",
      "challengeType": 1,
      "dashedName": "adjacency-list",
      "description": "Graphs can be represented in different ways. Here we describe one way, which is called an <dfn>adjacency list</dfn>. An adjacency list is essentially a bulleted list where the left side is the node and the right side lists all the other nodes it's connected to. Below is a representation of an adjacency list.\n\n<blockquote>Node1: Node2, Node3<br>Node2: Node1<br>Node3: Node1</blockquote>\n\nAbove is an undirected graph because `Node1` is connected to `Node2` and `Node3`, and that information is consistent with the connections `Node2` and `Node3` show. An adjacency list for a directed graph would mean each row of the list shows direction. If the above was directed, then `Node2: Node1` would mean there the directed edge is pointing from `Node2` towards `Node1`. We can represent the undirected graph above as an adjacency list by putting it within a JavaScript object.\n\n```js\nvar undirectedG = {\n  Node1: [\"Node2\", \"Node3\"],\n  Node2: [\"Node1\"],\n  Node3: [\"Node1\"]\n};\n```\n\nThis can also be more simply represented as an array where the nodes just have numbers rather than string labels.\n\n```js\nvar undirectedGArr = [\n  [1, 2], // Node1\n  [0],    // Node2\n  [0]     // Node3\n];\n```",
      "instructions": "Create a social network as an undirected graph with 4 nodes/people named `James`, `Jill`, `Jenny`, and `Jeff`. There are edges/relationships between James and Jeff, Jill and Jenny, and Jeff and Jenny.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var undirectedAdjList = {};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var undirectedAdjList = {\n  James: ['Jeff'],\n  Jill: ['Jenny'],\n  Jenny: ['Jill', 'Jeff'],\n  Jeff: ['James', 'Jenny']\n};"
        }
      ],
      "tests": [
        {
          "text": "`undirectedAdjList` should only contain four nodes.",
          "testCode": "assert(Object.keys(undirectedAdjList).length === 4);"
        },
        {
          "text": "There should be an edge between `Jeff` and `James`.",
          "testCode": "assert(\n  undirectedAdjList.James.indexOf('Jeff') !== -1 &&\n    undirectedAdjList.Jeff.indexOf('James') !== -1\n);"
        },
        {
          "text": "There should be an edge between `Jill` and `Jenny`.",
          "testCode": "assert(\n  undirectedAdjList.Jill.indexOf('Jenny') !== -1 &&\n    undirectedAdjList.Jenny.indexOf('Jill') !== -1\n);"
        },
        {
          "text": "There should be an edge between `Jeff` and `Jenny`.",
          "testCode": "assert(\n  undirectedAdjList.Jeff.indexOf('Jenny') !== -1 &&\n    undirectedAdjList.Jenny.indexOf('Jeff') !== -1\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301620,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\adjacency-list.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8256367417b2b2512c78",
      "title": "Adjacency Matrix",
      "challengeType": 1,
      "dashedName": "adjacency-matrix",
      "description": "Another way to represent a graph is to put it in an <dfn>adjacency matrix</dfn>. An <dfn>adjacency matrix</dfn> is a two-dimensional (2D) array where each nested array has the same number of elements as the outer array. In other words, it is a matrix or grid of numbers, where the numbers represent the edges.\n\n**Note**: The numbers to the top and left of the matrix are just labels for the nodes. Inside the matrix, ones mean there exists an edge between the vertices (nodes) representing the row and column. Finally, zeros mean there is no edge or relationship.\n\n<pre>\n    1 2 3\n  \\------\n1 | 0 1 1\n2 | 1 0 0\n3 | 1 0 0\n</pre>\n\nAbove is a very simple, undirected graph where you have three nodes, where the first node is connected to the second and third node. Below is a JavaScript implementation of the same thing.\n\n```js\nvar adjMat = [\n  [0, 1, 1],\n  [1, 0, 0],\n  [1, 0, 0]\n];\n```\n\nUnlike an adjacency list, each \"row\" of the matrix has to have the same number of elements as nodes in the graph. Here we have a three by three matrix, which means we have three nodes in our graph. A directed graph would look similar. Below is a graph where the first node has an edge pointing toward the second node, and then the second node has an edge pointing to the third node.\n\n```js\nvar adjMatDirected = [\n  [0, 1, 0],\n  [0, 0, 1],\n  [0, 0, 0]\n];\n```\n\nGraphs can also have <dfn>weights</dfn> on their edges. So far, we have <dfn>unweighted</dfn> edges where just the presence and lack of edge is binary (`0` or `1`). You can have different weights depending on your application.",
      "instructions": "Create an adjacency matrix of an undirected graph with five nodes. This matrix should be in a multi-dimensional array. These five nodes have relationships between the first and fourth node, the first and third node, the third and fifth node, and the fourth and fifth node. All edge weights are one.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var adjMatUndirected = [];"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var adjMatUndirected = [\n  [0, 0, 1, 1, 0],\n  [0, 0, 0, 0, 0],\n  [1, 0, 0, 0, 1],\n  [1, 0, 0, 0, 1],\n  [0, 0, 1, 1, 0]\n];"
        }
      ],
      "tests": [
        {
          "text": "`undirectedAdjList` should only contain five nodes.",
          "testCode": "assert(\n  adjMatUndirected.length === 5 &&\n    adjMatUndirected\n      .map(function (x) {\n        return x.length === 5;\n      })\n      .reduce(function (a, b) {\n        return a && b;\n      })\n);"
        },
        {
          "text": "There should be an edge between the first and fourth node.",
          "testCode": "assert(adjMatUndirected[0][3] === 1 && adjMatUndirected[3][0] === 1);"
        },
        {
          "text": "There should be an edge between the first and third node.",
          "testCode": "assert(adjMatUndirected[0][2] === 1 && adjMatUndirected[2][0] === 1);"
        },
        {
          "text": "There should be an edge between the third and fifth node.",
          "testCode": "assert(adjMatUndirected[2][4] === 1 && adjMatUndirected[4][2] === 1);"
        },
        {
          "text": "There should be an edge between the fourth and fifth node.",
          "testCode": "assert(adjMatUndirected[3][4] === 1 && adjMatUndirected[4][3] === 1);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301621,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\adjacency-matrix.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825c367417b2b2512c90",
      "title": "Breadth-First Search",
      "challengeType": 1,
      "dashedName": "breadth-first-search",
      "description": "So far, we've learned different ways of creating representations of graphs. What now? One natural question to have is what are the distances between any two nodes in the graph? Enter <dfn>graph traversal algorithms</dfn>.\n\n<dfn>Traversal algorithms</dfn> are algorithms to traverse or visit nodes in a graph. One type of traversal algorithm is the breadth-first search algorithm.\n\nThis algorithm starts at one node and visits all its neighbors that are one edge away. It then goes on to visit each of their neighbors and so on until all nodes have been reached.\n\nAn important data structure that will help implement the breadth-first search algorithm is the queue. This is an array where you can add elements to one end and remove elements from the other end. This is also known as a <dfn>FIFO</dfn> or <dfn>First-In-First-Out</dfn> data structure.\n\nVisually, this is what the algorithm is doing:\n<img alt=\"animation showing the breadth first search algorithm\" src='https://cdn.freecodecamp.org/curriculum/coding-interview-prep/breadth-first-search.gif'>\n\nThe grey shading represents a node getting added into the queue and the black shading represents a node getting removed from the queue. See how every time a node gets removed from the queue (node turns black), all their neighbors get added into the queue (node turns grey).\n\nTo implement this algorithm, you'll need to input a graph structure and a node you want to start at.\n\nFirst, you'll want to be aware of the distances from, or number of edges away from, the start node. You'll want to start all your distances with some large number, like `Infinity`. This prevents counting issues for when a node may not be reachable from your start node. Next, you'll want to go from the start node to its neighbors. These neighbors are one edge away and at this point you should add one unit of distance to the distances you're keeping track of.",
      "instructions": "Write a function `bfs()` that takes an adjacency matrix graph (a two-dimensional array) and a node label root as parameters. The node label will just be the integer value of the node between `0` and `n - 1`, where `n` is the total number of nodes in the graph.\n\nYour function will output a JavaScript object key-value pairs with the node and its distance from the root. If the node could not be reached, it should have a distance of `Infinity`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function bfs(graph, root) {\n  var nodesLen = {};\n\n  return nodesLen;\n};\n\nvar exBFSGraph = [\n  [0, 1, 0, 0],\n  [1, 0, 1, 0],\n  [0, 1, 0, 1],\n  [0, 0, 1, 0]\n];\nconsole.log(bfs(exBFSGraph, 3));"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function bfs(graph, root) {\n  var nodesLen = {};\n  // Set all distances to infinity\n  for (var i = 0; i < graph.length; i++) {\n    nodesLen[i] = Infinity;\n  }\n  nodesLen[root] = 0; // ...except root node\n  var queue = [root]; // Keep track of nodes to visit\n  var current; // Current node traversing\n  // Keep on going until no more nodes to traverse\n  while (queue.length !== 0) {\n    current = queue.shift();\n    // Get adjacent nodes from current node\n    var curConnected = graph[current]; // Get layer of edges from current\n    var neighborIdx = []; // List of nodes with edges\n    var idx = curConnected.indexOf(1); // Get first edge connection\n    while (idx !== -1) {\n      neighborIdx.push(idx); // Add to list of neighbors\n      idx = curConnected.indexOf(1, idx + 1); // Keep on searching\n    }\n    // Loop through neighbors and get lengths\n    for (var j = 0; j < neighborIdx.length; j++) {\n      // Increment distance for nodes traversed\n      if (nodesLen[neighborIdx[j]] === Infinity) {\n        nodesLen[neighborIdx[j]] = nodesLen[current] + 1;\n        queue.push(neighborIdx[j]); // Add new neighbors to queue\n      }\n    }\n  }\n  return nodesLen;\n}"
        }
      ],
      "tests": [
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` with a start node of `1` should return `{0: 1, 1: 0, 2: 1, 3: 2}`",
          "testCode": "var graph = [\n  [0, 1, 0, 0],\n  [1, 0, 1, 0],\n  [0, 1, 0, 1],\n  [0, 0, 1, 0]\n];\nvar results = bfs(graph, 1);\nassert.deepEqual(results, { 0: 1, 1: 0, 2: 1, 3: 2 });"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]` with a start node of `1` should return `{0: 1, 1: 0, 2: 1, 3: Infinity}`",
          "testCode": "var graph = [\n  [0, 1, 0, 0],\n  [1, 0, 1, 0],\n  [0, 1, 0, 0],\n  [0, 0, 0, 0]\n];\nvar results = bfs(graph, 1);\n assert.deepEqual(results, { 0: 1, 1: 0, 2: 1, 3: Infinity });"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` with a start node of `0` should return `{0: 0, 1: 1, 2: 2, 3: 3}`",
          "testCode": "var graph = [\n  [0, 1, 0, 0],\n  [1, 0, 1, 0],\n  [0, 1, 0, 1],\n  [0, 0, 1, 0]\n];\nvar results = bfs(graph, 0);\n assert.deepEqual(results, { 0: 0, 1: 1, 2: 2, 3: 3 });"
        },
        {
          "text": "The input graph `[[0, 1], [1, 0]]` with a start node of `0` should return `{0: 0, 1: 1}`",
          "testCode": "var graph = [\n  [0, 1],\n  [1, 0]\n];\nvar results = bfs(graph, 0);\nassert.deepEqual(results, { 0: 0, 1: 1 });"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301622,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\breadth-first-search.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8257367417b2b2512c7c",
      "title": "Check if an Element is Present in a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "check-if-an-element-is-present-in-a-binary-search-tree",
      "description": "Now that we have a general sense of what a binary search tree is let's talk about it in a little more detail. Binary search trees provide logarithmic time for the common operations of lookup, insertion, and deletion in the average case, and linear time in the worst case. Why is this? Each of those basic operations requires us to find an item in the tree (or in the case of insertion to find where it should go) and because of the tree structure at each parent node we are branching left or right and effectively excluding half the size of the remaining tree. This makes the search proportional to the logarithm of the number of nodes in the tree, which creates logarithmic time for these operations in the average case. Ok, but what about the worst case? Well, consider constructing a tree from the following values, adding them left to right: `10`, `12`, `17`, `25`. Following our rules for a binary search tree, we will add `12` to the right of `10`, `17` to the right of this, and `25` to the right of this. Now our tree resembles a linked list and traversing it to find `25` would require us to traverse all the items in linear fashion. Hence, linear time in the worst case. The problem here is that the tree is unbalanced. We'll look a little more into what this means in the following challenges.",
      "instructions": "In this challenge, we will create a utility for our tree. Write a method `isPresent` which takes an integer value as input and returns a boolean value for the presence or absence of that value in the binary search tree.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  this.isPresent = function (value) {\n    var current = this.root\n    while (current) {\n      if (value === current.value) {\n        return true;\n      }\n      current = value < current.value ? current.left : current.right;\n    }\n    return false;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `isPresent`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.isPresent == 'function';\n  })()\n);"
        },
        {
          "text": "The `isPresent` method should correctly check for the presence or absence of elements added to the tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.isPresent !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(7);\n    test.add(411);\n    test.add(452);\n    return (\n      test.isPresent(452) &&\n      test.isPresent(411) &&\n      test.isPresent(7) &&\n      !test.isPresent(100)\n    );\n  })()\n);"
        },
        {
          "text": "`isPresent` should handle cases where the tree is empty.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.isPresent !== 'function') {\n      return false;\n    }\n    return test.isPresent(5) == false;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301623,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\check-if-an-element-is-present-in-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        function searchTree(node) {\n          if (value < node.value) {\n            if (node.left == null) {\n              node.left = new Node(value);\n              return;\n            } else if (node.left != null) {\n              return searchTree(node.left);\n            }\n          } else if (value > node.value) {\n            if (node.right == null) {\n              node.right = new Node(value);\n              return;\n            } else if (node.right != null) {\n              return searchTree(node.right);\n            }\n          } else {\n            return null;\n          }\n        }\n        return searchTree(node);\n      }\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "5cc0c1b32479e176caf3b422",
      "title": "Check if Tree is Binary Search Tree",
      "challengeType": 1,
      "dashedName": "check-if-tree-is-binary-search-tree",
      "description": "Since you already know what a binary search tree is, this challenge will establish how it is you can tell that a tree is a binary search tree or not.\n\nThe main distinction of a binary search tree is that the nodes are ordered in an organized fashion. Nodes have at most 2 child nodes (placed to the right and/or left) based on if the child node's value is greater than or equal to (right) or less than (left) the parent node.",
      "instructions": "In this challenge, you will create a utility for your tree. Write a JavaScript method `isBinarySearchTree` which takes a tree as an input and returns a boolean value for whether the tree is a binary search tree or not. Use recursion whenever possible.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n}\nfunction isBinarySearchTree(tree) {\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n}\nfunction isBinarySearchTree(tree) {\n  if (tree.root == null) {\n    return null;\n  } else {\n    let isBST = true;\n    function checkTree(node) {\n      if (node.left != null) {\n        const left = node.left;\n        if (left.value >= node.value) {\n          isBST = false;\n        } else {\n          checkTree(left);\n        }\n      }\n      if (node.right != null) {\n        const right = node.right;\n        if (right.value < node.value) {\n          isBST = false;\n        } else {\n          checkTree(right);\n        }\n      }\n    }\n    checkTree(tree.root);\n    return isBST;\n  }\n};"
        }
      ],
      "tests": [
        {
          "text": "Your Binary Search Tree should return true when checked with `isBinarySearchTree()`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    test.push(1);\n    test.push(5);\n    test.push(3);\n    test.push(2);\n    test.push(4);\n    return isBinarySearchTree(test) == true;\n  })()\n);"
        },
        {
          "text": "`isBinarySearchTree()` should return false when checked with a tree that is not a binary search tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    test.push(1);\n    test.root.left = new Node(1);\n    return isBinarySearchTree(test) == false;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301624,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\check-if-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype.push = function(val) {\n  var root = this.root;\n\n  if (!root) {\n    this.root = new Node(val);\n    return;\n  }\n\n  var currentNode = root;\n  var newNode = new Node(val);\n\n  while (currentNode) {\n    if (val < currentNode.value) {\n      if (!currentNode.left) {\n        currentNode.left = newNode;\n        break;\n      } else {\n        currentNode = currentNode.left;\n      }\n    } else {\n      if (!currentNode.right) {\n        currentNode.right = newNode;\n        break;\n      } else {\n        currentNode = currentNode.right;\n      }\n    }\n  }\n};"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8255367417b2b2512c75",
      "title": "Create a Circular Queue",
      "challengeType": 1,
      "dashedName": "create-a-circular-queue",
      "description": "In this challenge you will be creating a Circular Queue. A circular queue is a queue that writes to the end of a collection then begins overwriting itself at the beginning of the collection. This type of data structure is useful in certain situations. For example, a circular queue can be used for streaming media. Once the queue is full, new media data will overwrite old data.\n\nA good way to illustrate this concept is with an array of length `5`:\n\n```js\n[null, null, null, null, null]\n ^Read @ 0\n ^Write @ 0\n```\n\nHere the read and write are both at position `0`. Now the queue gets 3 new records `a`, `b`, and `c`. Our queue now looks like:\n\n```js\n[a, b, c, null, null]\n ^Read @ 0\n          ^Write @ 3\n```\n\nAs the read head reads, it can remove values or keep them:\n\n```js\n[null, null, null, null, null]\n                   ^Read @ 3\n                   ^Write @ 3\n```\n\nNow we write the values `d`, `e`, and `f` to the queue. Once the write reaches the end of the array it loops back to the beginning:\n\n```js\n[f, null, null, d, e]\n                ^Read @ 3\n    ^Write @ 1\n```\n\nThis approach requires a constant amount of memory but allows files of a much larger size to be processed.",
      "instructions": "In this challenge we will implement a circular queue. The circular queue should provide `enqueue` and `dequeue` methods which allow you to read from and write to the queue. The class itself should also accept an integer argument which you can use to specify the size of the queue when created. We've written the starting version of this class for you in the code editor.\n\nWhen you enqueue items to the queue, the write pointer should advance forward and loop back to the beginning once it reaches the end of the queue. The `enqueue` method should return the item you enqueued if it is successful; otherwise it will return `null`.\n\nLikewise, the read pointer should advance forward as you dequeue items. When you dequeue an item, that item should be returned. If you cannot dequeue an item, you should return `null`.\n\nThe write pointer should not be allowed to move past the read pointer (our class won't let you overwrite data you haven't read yet) and the read pointer should not be able to advance past data you have written.",
      "boilerplate": [
        {
          "language": "js",
          "code": "class CircularQueue {\n  constructor(size) {\n\n    this.queue = [];\n    this.read = 0;\n    this.write = 0;\n    this.max = size - 1;\n\n    while (size > 0) {\n      this.queue.push(null);\n      size--;\n    }\n  }\n\n  print() {\n    return this.queue;\n  }\n\n  enqueue(item) {\n    // Only change code below this line\n\n    // Only change code above this line\n  }\n\n  dequeue() {\n    // Only change code below this line\n\n    // Only change code above this line\n  }\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "class CircularQueue {\n  constructor(size) {\n    this.queue = [];\n    this.read = 0;\n    this.write = 0;\n    this.max = size - 1;\n\n    while (size > 0) {\n      this.queue.push(null);\n      size--;\n    }\n  }\n\n  print() {\n    return this.queue;\n  }\n\n  enqueue(item) {\n    // Only change code below this line\n    console.log(this.write, this.max);\n    if (this.queue[this.write] === null) {\n      this.queue[this.write++] = item;\n\n      if (this.write > this.max) {\n        this.write = 0;\n      }\n      return item;\n    }\n    return null;\n    // Only change code above this line\n  }\n\n  dequeue() {\n    // Only change code below this line\n    if (this.queue[this.read] !== null) {\n      let item = this.queue[this.read];\n      this.queue[this.read++] = null;\n      if (this.read > this.max) {\n        this.read = 0;\n      }\n      return item;\n    }\n    return null;\n    // Only change code above this line\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "The `enqueue` method should add items to the circular queue.",
          "testCode": "assert(\n  (function () {\n    var test = new CircularQueue(3);\n    test.enqueue(17);\n    test.enqueue(32);\n    test.enqueue(591);\n    var print = test.print();\n    return print[0] === 17 && print[1] === 32 && print[2] === 591;\n  })()\n);"
        },
        {
          "text": "You should not enqueue items past the read pointer.",
          "testCode": "assert(\n  (function () {\n    var test = new CircularQueue(3);\n    test.enqueue(17);\n    test.enqueue(32);\n    test.enqueue(591);\n    test.enqueue(13);\n    test.enqueue(25);\n    test.enqueue(59);\n    var print = test.print();\n    return print[0] === 17 && print[1] === 32 && print[2] === 591;\n  })()\n);"
        },
        {
          "text": "The `dequeue` method should dequeue items from the queue.",
          "testCode": "assert(\n  (function () {\n    var test = new CircularQueue(3);\n    test.enqueue(17);\n    test.enqueue(32);\n    test.enqueue(591);\n    return (\n      test.dequeue() === 17 && test.dequeue() === 32 && test.dequeue() === 591\n    );\n  })()\n);"
        },
        {
          "text": "After an item is dequeued, its position in the queue should be reset to `null`.",
          "testCode": "assert(\n  (function () {\n    var test = new CircularQueue(3);\n    test.enqueue(17);\n    test.enqueue(32);\n    test.enqueue(672);\n    test.dequeue();\n    test.dequeue();\n    var print = test.print();\n    return print[0] === null && print[1] === null && print[2] === 672;\n  })()\n);"
        },
        {
          "text": "Trying to dequeue past the write pointer should return `null` and does not advance the write pointer.",
          "testCode": "assert(\n  (function () {\n    var test = new CircularQueue(3);\n    test.enqueue(17);\n    test.enqueue(32);\n    test.enqueue(591);\n    return (\n      test.dequeue() === 17 &&\n      test.dequeue() === 32 &&\n      test.dequeue() === 591 &&\n      test.dequeue() === null &&\n      test.dequeue() === null &&\n      test.dequeue() === null &&\n      test.dequeue() === null &&\n      test.enqueue(100) === 100 &&\n      test.dequeue() === 100\n    );\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301625,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-circular-queue.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825a367417b2b2512c87",
      "title": "Create a Doubly Linked List",
      "challengeType": 1,
      "dashedName": "create-a-doubly-linked-list",
      "description": "All of the linked lists we've created so far are singly linked lists. Here, we'll create a <dfn>doubly linked list</dfn>. As the name implies, nodes in a doubly linked list have references to the next and previous node in the list.\n\nThis allows us to traverse the list in both directions but it also requires more memory to be used because every node must contain an additional reference to the previous node in the list.",
      "instructions": "We've provided a `Node` object and started our `DoublyLinkedList`. Let's add two methods to our doubly linked list called `add` and `remove`. The `add` method should add the given element to the list while the `remove` method should remove all occurrences of a given element in the list.\n\nBe careful to handle any possible edge cases when writing these methods, such as deletions for the first or last element. Also, removing any item on an empty list should return `null`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var Node = function(data, prev) {\n  this.data = data;\n  this.prev = prev;\n  this.next = null;\n};\nvar DoublyLinkedList = function() {\n  this.head = null;\n  this.tail = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "The `DoublyLinkedList` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The `DoublyLinkedList` should have a method called `add`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    if (test.add == undefined) {\n      return false;\n    }\n    return typeof test.add == 'function';\n  })()\n);"
        },
        {
          "text": "The `DoublyLinkedList` should have a method called `remove`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    if (test.remove == undefined) {\n      return false;\n    }\n    return typeof test.remove == 'function';\n  })()\n);"
        },
        {
          "text": "Removing an item from an empty list should return `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    return test.remove(100) == null;\n  })()\n);"
        },
        {
          "text": "The `add` method should add items to the list.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    test.add(5);\n    test.add(6);\n    test.add(723);\n    return test.print().join('') == '56723';\n  })()\n);"
        },
        {
          "text": "Each node should keep track of the previous node.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    test.add(50);\n    test.add(68);\n    test.add(73);\n    return test.printReverse().join('') == '736850';\n  })()\n);"
        },
        {
          "text": "The first item should be removable from the list.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    test.add(25);\n    test.add(35);\n    test.add(60);\n    test.remove(25);\n    return test.print().join('') == '3560';\n  })()\n);"
        },
        {
          "text": "The last item should be removable from the list.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    test.add(25);\n    test.add(35);\n    test.add(60);\n    test.remove(60);\n    return test.print().join('') == '2535';\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301626,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-doubly-linked-list.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "DoublyLinkedList.prototype = Object.assign(\n  DoublyLinkedList.prototype,\n  {\n  \n  print() {\n    if (this.head == null) {\n      return null;\n    } else {\n      var result = new Array();\n      var node = this.head;\n      while (node.next != null) {\n        result.push(node.data);\n        node = node.next;\n      };\n      result.push(node.data);\n      return result;\n    };\n  },\n  printReverse() {\n    if (this.tail == null) {\n      return null;\n    } else {\n      var result = new Array();\n      var node = this.tail;\n      while (node.prev != null) {\n        result.push(node.data);\n        node = node.prev;\n      };\n      result.push(node.data);\n      return result;\n    };\n  }\n});"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825b367417b2b2512c8e",
      "title": "Create a Hash Table",
      "challengeType": 1,
      "dashedName": "create-a-hash-table",
      "description": "In this challenge we will learn about hash tables. A Hash table is used to implement associative arrays, or mappings of key-value pairs, like the objects and Maps we have just been studying. A JavaScript object could be implemented as a hash table, for instance (its actual implementation will depend on the environment it's running in). The way a hash table works is that it takes a key input and hashes this key in a deterministic way to some numerical value. This numerical value is then used as the actual key the associated value is stored by. Then, if you try to access the same key again, the hashing function will process the key, return the same numerical result, which will then be used to look up the associated value. This provides very efficient O(1) lookup time on average.\n\nHash tables can be implemented as arrays with hash functions producing array indices within a specified range. In this method, the choice of the array size is important, as is the hashing function. For instance, what if the hashing function produces the same value for two different keys? This is called a collision. One way to handle collisions is to just store both key-value pairs at that index. Then, upon lookup of either, you would have to iterate through the bucket of items to find the key you are looking for. A good hashing function will minimize collisions to maintain efficient search time.\n\nHere, we won't be concerned with the details of hashing or hash table implementation, we will just try to get a general sense of how they work.",
      "instructions": "Let's create the basic functionality of a hash table. We've created a naive hashing function for you to use. You can pass a string value to the function `hash` and it will return a hashed value you can use as a key for storage. Store items based on this hashed value in the `this.collection` object. Create these three methods: `add`, `remove`, and `lookup`. The first should accept a key value pair to add to the hash table. The second should remove a key-value pair when passed a key. The third should accept a key and return the associated value or `null` if the key is not present.\n\nBe sure to write your code to account for collisions!\n\n**Note:** The `remove` method tests won't pass until the `add` and `lookup` methods are correctly implemented.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var called = 0;\nvar hash = string => {\n  called++;\n  var hashed = 0;\n  for (var i = 0; i < string.length; i++) {\n    hashed += string.charCodeAt(i);\n  }\n  return hashed;\n};\nvar HashTable = function() {\n  this.collection = {};\n  // Only change code below this line\n  \n  // Only change code above this line\n};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var called = 0;\nvar hash = (string) => {\n  called++;\n  var hash = 0;\n  for (var i = 0; i < string.length; i++) { hash += string.charCodeAt(i); }\n  return hash;\n};\nvar HashTable = function() {\n  this.collection = {};\n  // Only change code below this line\n\n  this.add = function(key, val) {\n    var theHash = hash(key);\n    if (!this.collection.hasOwnProperty(theHash)) {\n      this.collection[theHash] = {};\n    }\n    this.collection[theHash][key] = val;\n  }\n\n  this.remove = function(key) {\n    var theHash = hash(key);\n    var hashedObj = this.collection[theHash];\n    if (hashedObj.hasOwnProperty(key)) {\n      delete hashedObj[key];\n    }\n    if (!Object.keys(hashedObj).length) {\n      delete this.collection[theHash];\n    }\n  }\n\n  this.lookup = function(key) {\n    var theHash = hash(key);\n    if (this.collection.hasOwnProperty(theHash)) {\n      return this.collection[theHash][key];\n    }\n    return null\n  }\n  // Only change code above this line\n};"
        }
      ],
      "tests": [
        {
          "text": "The `hash` function should be valid.\n\n```js\nlet calls = 0;\nconst ourHash = string => {\n  calls++;\n  let hashCode = 0;\n  for (let i = 0; i < string.length; i++) {\n    hashCode += string.charCodeAt(i);\n  }\n  return hashCode;\n};\n\nassert.strictEqual(hash('yek'),ourHash('yek'));\n\nassert.strictEqual(hash('key'),ourHash('key'));\nassert.strictEqual(hash('key1'),ourHash('key1'));\nassert.strictEqual(hash('key2'),ourHash('key2'));\nassert.strictEqual(hash('key3'),ourHash('key3'));\n\nassert.strictEqual(hash('1key'),ourHash('1key'));\nassert.strictEqual(hash('ke1y'),ourHash('ke1y'));\nassert.strictEqual(hash('altKey'),ourHash('altKey'));\n\nassert.strictEqual(called,calls); \n```\n\nThe `HashTable` data structure should exist.",
          "testCode": "assert.isDefined(HashTable); \nlet newHashTable = new HashTable(); \nassert.isObject(newHashTable);"
        },
        {
          "text": "The `HashTable` should have an `add` method.",
          "testCode": "let newHashTable = new HashTable(); \nassert.isFunction(newHashTable.add);"
        },
        {
          "text": "The `HashTable` should have a `lookup` method.",
          "testCode": "let newHashTable = new HashTable(); \nassert.isFunction(newHashTable.lookup);"
        },
        {
          "text": "The `HashTable` should have a `remove` method.",
          "testCode": "let newHashTable = new HashTable(); \nassert.isFunction(newHashTable.remove);"
        },
        {
          "text": "The `add` method should add key value pairs and the `lookup` method should return the values associated with a given key.",
          "testCode": "let newHashTable = new HashTable(); \nnewHashTable.add('key','value');\nassert.strictEqual(newHashTable.lookup('key'),'value');"
        },
        {
          "text": "The `remove` method should accept a key as input and should remove the associated key value pair.",
          "testCode": "let hashValue = hash('key');\nlet newHashTable = new HashTable(); \nnewHashTable.add('key','value');\nnewHashTable.remove('key'); \nassert.notProperty(newHashTable.collection,hashValue);"
        },
        {
          "text": "The `remove` method should only remove the correct key value pair.\n\n```js\nlet newHashTable = new HashTable(); \nlet hashValue = hash('key');\nnewHashTable.add('key','value');\nnewHashTable.add('yek','value');\nnewHashTable.add('altKey','value');\nnewHashTable.remove('yek');\n\nassert.notExists(newHashTable.lookup('yek'));\nassert.exists(newHashTable.lookup('altKey'));\nassert.exists(newHashTable.lookup('key'));\n\nnewHashTable.remove('key');\n\nassert.notProperty(newHashTable.collection,hashValue); \nassert.exists(newHashTable.lookup('altKey'));\n\n```\n\nItems should be added using the hash function.",
          "testCode": "let newHashTable = new HashTable(); \ncalled = 0;\nnewHashTable.add('key1', 'value1')\nnewHashTable.add('key2', 'value2');\nnewHashTable.add('key3', 'value3');\nassert.strictEqual(called,3);"
        },
        {
          "text": "The hash table should handle collisions.",
          "testCode": "let newHashTable = new HashTable(); \ncalled = 0;\nnewHashTable.add('key1','value1');\nnewHashTable.add('1key', 'value2'); \nnewHashTable.add('ke1y', 'value3'); \nassert.strictEqual(newHashTable.lookup('key1'),'value1');\nassert.strictEqual(newHashTable.lookup('1key'),'value2');\nassert.strictEqual(newHashTable.lookup('ke1y'),'value3');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301627,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-hash-table.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8251367417b2b2512c62",
      "title": "Create a Linked List Class",
      "challengeType": 1,
      "dashedName": "create-a-linked-list-class",
      "description": "Let's create a `linked list` class. Every linked list should start out with a few basic properties: a `head` (the first item in your list) and a `length` (number of items in your list). Sometimes you'll see implementations of linked lists that incorporate a `tail` for the last element of the list, but for now we'll just stick with these two. Whenever we add an element to the linked list, our `length` property should be incremented by one.\n\nWe'll want to have a way to add items to our linked list, so the first method we'll want to create is the `add` method.\n\nIf our list is empty, adding an element to our linked list is straightforward enough: we just wrap that element in a `Node` class, and we assign that node to the `head` of our linked list.\n\nBut what if our list already has one or more members? How do we add an element to the list? Recall that each node in a linked list has a `next` property. To add a node to the list, find the last node in the list, and point that last node's `next` property at our new node. (Hint: you know you've reached the end of a linked list when a node's `next` property is `null`.)",
      "instructions": "Write an add method that assigns the first node you push to the linked list to the `head`; after that, whenever adding a node, every node should be referenced by the previous node's `next` property.\n\nNote\n\nYour list's `length` should increase by one every time an element is added to the linked list.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function(element){\n    this.element = element;\n    this.next = null;\n  };\n\n  this.head = function(){\n    return head;\n  };\n\n  this.size = function(){\n    return length;\n  };\n\n  this.add = function(element){\n    // Only change code below this line\n\n    // Only change code above this line\n  };\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function LinkedList() { \n  var length = 0; \n  var head = null; \n\n  var Node = function(element){\n    this.element = element; \n    this.next = null; \n  }; \n\n  this.head = function(){\n    return head;\n  };\n\n  this.size = function(){\n    return length;\n  };\n\n  this.add = function(element){\n    // Only change code below this line\n    if (head == null) {\n      head = new Node(element);\n    } \n    else {\n      let currentNode = head;\n      while (currentNode.next != null) {\n        // currentNode.next will be last node of linked list after loop\n        currentNode = currentNode.next;\n      }\n      currentNode.next = new Node(element);\n    }\n    length++;\n    // Only change code above this line\n  };\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `LinkedList` class should have a `add` method.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    return typeof test.add === 'function';\n  })()\n);"
        },
        {
          "text": "Your `LinkedList` class should assign `head` to the first node added.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    return test.head().element === 'cat';\n  })()\n);"
        },
        {
          "text": "The previous `node` in your `LinkedList` class should have reference to the newest node created.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('fish');\n    return test.head().next.element === 'dog' && test.head().next.next.element === 'fish';\n  })()\n);"
        },
        {
          "text": "The  `size` of your `LinkedList` class should equal the amount of nodes in the linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    return test.size() === 2;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301628,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-linked-list-class.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "8d5823c8c441eddfaeb5bdef",
      "title": "Create a Map Data Structure",
      "challengeType": 1,
      "dashedName": "create-a-map-data-structure",
      "description": "The next few challenges will cover maps and hash tables. Maps are data structures that store key-value pairs. In JavaScript, these are available to us as objects. Maps provide rapid lookup of stored items based on key values and are very common and useful data structures.",
      "instructions": "Let's get some practice creating our own map. Because JavaScript objects provide a much more efficient map structure than anything we could write here, this is intended primarily as a learning exercise. However, JavaScript objects only provide us with certain operations. What if we wanted to define custom operations? Use the `Map` object provided here as a wrapper around a JavaScript `object`. Create the following methods and operations on the Map object:\n\n<ul>\n<li><code>add</code> accepts a <code>key, value</code> pair to add to the map.</li>\n<li><code>remove</code> accepts a key and removes the associated <code>key, value</code> pair</li>\n<li><code>get</code> accepts a <code>key</code> and returns the stored <code>value</code></li>\n<li><code>has</code> accepts a <code>key</code> and returns <dfn>true</dfn> if the key exists or <dfn>false</dfn> if it doesn't.</li>\n<li><code>values</code> returns an array of all the values in the map</li>\n<li><code>size</code> returns the number of items in the map</li>\n<li><code>clear</code> empties the map</li>\n</ul>",
      "boilerplate": [
        {
          "language": "js",
          "code": "var Map = function() {\n  this.collection = {};\n  // Only change code below this line\n  \n  // Only change code above this line\n};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var Map = function() {\n    this.collection = {};\n    // Only change code below this line\n\n    this.add = function(key,value) {\n      this.collection[key] = value;\n    }\n\n    this.remove = function(key) {\n      delete this.collection[key];\n    }\n\n    this.get = function(key) {\n      return this.collection[key];\n    }\n\n    this.has = function(key) {\n      return this.collection.hasOwnProperty(key)\n    }\n\n    this.values = function() {\n      return Object.values(this.collection);\n    }\n\n    this.size = function() {\n      return Object.keys(this.collection).length;\n    }\n\n    this.clear = function() {\n      for(let item of Object.keys(this.collection)) {\n        delete this.collection[item];\n      }\n    }\n    // Only change code above this line\n};"
        }
      ],
      "tests": [
        {
          "text": "The `Map` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof Map !== 'undefined') {\n      test = new Map();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The `Map` object should have the following methods: `add`, `remove`, `get`, `has`, `values`, `clear`, and `size`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof Map !== 'undefined') {\n      test = new Map();\n    }\n    return (\n      typeof test.add == 'function' &&\n      typeof test.remove == 'function' &&\n      typeof test.get == 'function' &&\n      typeof test.has == 'function' &&\n      typeof test.values == 'function' &&\n      typeof test.clear == 'function' &&\n      typeof test.size == 'function'\n    );\n  })()\n);"
        },
        {
          "text": "The `add` method should add items to the map.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof Map !== 'undefined') {\n      test = new Map();\n    }\n    test.add(5, 6);\n    test.add(2, 3);\n    test.add(2, 5);\n    return test.size() == 2;\n  })()\n);"
        },
        {
          "text": "The `has` method should return `true` for added items and `false` for absent items.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof Map !== 'undefined') {\n      test = new Map();\n    }\n    test.add('test', 'value');\n    return test.has('test') && !test.has('false');\n  })()\n);"
        },
        {
          "text": "The `get` method should accept keys as input and should return the associated values.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof Map !== 'undefined') {\n      test = new Map();\n    }\n    test.add('abc', 'def');\n    return test.get('abc') == 'def';\n  })()\n);"
        },
        {
          "text": "The `values` method should return all the values stored in the map as strings in an array.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof Map !== 'undefined') {\n      test = new Map();\n    }\n    test.add('a', 'b');\n    test.add('c', 'd');\n    test.add('e', 'f');\n    var vals = test.values();\n    return (\n      vals.indexOf('b') != -1 &&\n      vals.indexOf('d') != -1 &&\n      vals.indexOf('f') != -1\n    );\n  })()\n);"
        },
        {
          "text": "The `clear` method should empty the map and the `size` method should return the number of items present in the map.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof Map !== 'undefined') {\n      test = new Map();\n    }\n    test.add('b', 'b');\n    test.add('c', 'd');\n    test.remove('asdfas');\n    var init = test.size();\n    test.clear();\n    return init == 2 && test.size() == 0;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301629,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-map-data-structure.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8255367417b2b2512c74",
      "title": "Create a Priority Queue Class",
      "challengeType": 1,
      "dashedName": "create-a-priority-queue-class",
      "description": "In this challenge you will be creating a Priority Queue. A Priority Queue is a special type of Queue in which items may have additional information which specifies their priority. This could be simply represented with an integer. Item priority will override placement order in determining the sequence items are dequeued. If an item with a higher priority is enqueued after items with lower priority, the higher priority item will be dequeued before all the others.\n\nFor instance, let’s imagine we have a priority queue with three items:\n\n```js\n[['kitten', 2], ['dog', 2], ['rabbit', 2]]\n```\n\nHere the second value (an integer) represents item priority. If we enqueue `['human', 1]` with a priority of `1` (assuming lower priorities are given precedence) it would then be the first item to be dequeued. The collection would look like this:\n\n```js\n[['human', 1], ['kitten', 2], ['dog', 2], ['rabbit', 2]]\n```\n\nWe’ve started writing a `PriorityQueue` in the code editor. You will need to add an `enqueue` method for adding items with a priority, a `dequeue` method for removing and returning items, a `size` method to return the number of items in the queue, a `front` method to return the element at the front of the queue, and finally an `isEmpty` method that will return `true` if the queue is empty or `false` if it is not.\n\nThe `enqueue` should accept items with the format shown above (`['human', 1]`) where `1` represents the priority. `dequeue` and `front` should return only the item's name, not its priority.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function PriorityQueue () {\n  this.collection = [];\n  this.printCollection = function() {\n    console.log(this.collection);\n  };\n  // Only change code below this line\n\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function PriorityQueue() {\n  this.collection = [];\n  this.printCollection = function () {\n    console.log(this.collection);\n  };\n  // Only change code below this line\n  this.enqueue = function (newitem) {\n    if (this.isEmpty()) {\n      return this.collection.push(newitem);\n    }\n\n    this.collection = this.collection.reverse();\n    var found_index = this.collection.findIndex(function (item) {\n      return newitem[1] >= item[1];\n    });\n    if (found_index === -1) {\n      this.collection.push(newitem);\n    } else {\n      this.collection.splice(found_index, 0, newitem);\n    }\n    this.collection = this.collection.reverse();\n  };\n  this.dequeue = function () {\n    if (!this.isEmpty()) {\n      return this.collection.shift()[0];\n    } else {\n      return \"The queue is empty.\";\n    }\n  };\n  this.size = function () {\n    return this.collection.length;\n  };\n  this.front = function () {\n    return this.collection[0][0];\n  };\n  this.isEmpty = function () {\n    return this.size() > 0 ? false : true;\n  };\n  // Only change code above this line\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `PriorityQueue` class should have a `enqueue` method.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    return typeof test.enqueue === 'function';\n  })()\n);"
        },
        {
          "text": "Your `PriorityQueue` class should have a `dequeue` method.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    return typeof test.dequeue === 'function';\n  })()\n);"
        },
        {
          "text": "Your `PriorityQueue` class should have a `size` method.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    return typeof test.size === 'function';\n  })()\n);"
        },
        {
          "text": "Your `PriorityQueue` class should have a `front` method.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    return typeof test.front === 'function';\n  })()\n);"
        },
        {
          "text": "Your `PriorityQueue` class should have an `isEmpty` method.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    return typeof test.isEmpty === 'function';\n  })()\n);"
        },
        {
          "text": "Your `PriorityQueue` class should correctly keep track of the current number of items using the `size` method as items are enqueued and dequeued.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    test.enqueue(['David Brown', 2]);\n    test.enqueue(['Jon Snow', 1]);\n    var size1 = test.size();\n    test.dequeue();\n    var size2 = test.size();\n    test.enqueue(['A', 3]);\n    test.enqueue(['B', 3]);\n    test.enqueue(['C', 3]);\n    return size1 === 2 && size2 === 1 && test.size() === 4;\n  })()\n);"
        },
        {
          "text": "The `front` method should return the correct item at the front of the queue as items are enqueued and dequeued.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    test.enqueue(['David Brown', 2]);\n    var front1 = test.front();\n    test.enqueue(['Jon Snow', 1]);\n    var front2 = test.front();\n    test.dequeue();\n    test.enqueue(['A', 3]);\n    var front3 = test.front();\n    test.enqueue(['B', 3]);\n    test.enqueue(['C', 3]);\n    test.dequeue();\n    var front4 = test.front();\n    return (\n      front1 === 'David Brown' &&\n      front2 === 'Jon Snow' &&\n      front3 === 'David Brown' &&\n      front4 === 'A'\n    );\n  })()\n);"
        },
        {
          "text": "The `isEmpty` method should return `true` when the queue is empty.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    test.enqueue(['A', 1]);\n    test.enqueue(['B', 1]);\n    test.dequeue();\n    var first = test.isEmpty();\n    test.dequeue();\n    return !first && test.isEmpty();\n  })()\n);"
        },
        {
          "text": "The priority queue should return items with a higher priority before items with a lower priority and return items in first-in-first-out order otherwise.",
          "testCode": "assert(\n  (function () {\n    var test = new PriorityQueue();\n    test.enqueue(['A', 5]);\n    test.enqueue(['B', 5]);\n    test.enqueue(['C', 5]);\n    test.enqueue(['D', 3]);\n    test.enqueue(['E', 1]);\n    test.enqueue(['F', 7]);\n    var result = [];\n    result.push(test.dequeue());\n    result.push(test.dequeue());\n    result.push(test.dequeue());\n    result.push(test.dequeue());\n    result.push(test.dequeue());\n    result.push(test.dequeue());\n    return result.join('') === 'EDABCF';\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301630,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-priority-queue-class.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8250367417b2b2512c60",
      "title": "Create a Queue Class",
      "challengeType": 1,
      "dashedName": "create-a-queue-class",
      "description": "Like stacks, queues are a collection of elements. But unlike stacks, queues follow the FIFO (First-In First-Out) principle. Elements added to a queue are pushed to the tail, or the end, of the queue, and only the element at the front of the queue is allowed to be removed.\n\nWe could use an array to represent a queue, but just like stacks, we want to limit the amount of control we have over our queues.\n\nThe two main methods of a queue class is the enqueue and the dequeue method. The enqueue method pushes an element to the tail of the queue, and the dequeue method removes and returns the element at the front of the queue. Other useful methods are the front, size, and isEmpty methods.",
      "instructions": "Write an `enqueue` method that pushes an element to the tail of the queue, a `dequeue` method that removes and returns the front element, a `front` method that lets us see the front element, a `size` method that shows the length, and an `isEmpty` method to check if the queue is empty.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function Queue() {\n  var collection = [];\n  this.print = function() {\n    console.log(collection);\n  };\n  // Only change code below this line\n\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function Queue () { \n    var collection = [];\n    this.print = function() {\n        console.log(collection);\n    };\n    // Only change code below this line\n    this.enqueue = function(item) {\n        collection.push(item);\n    }\n\n    this.dequeue = function() {\n        return collection.shift();\n    }\n\n    this.front = function() {\n        return collection[0];\n    }\n\n    this.size = function(){\n        return collection.length;\n    }\n\n    this.isEmpty = function() {\n        return collection.length === 0 ? true : false;\n    }\n    // Only change code above this line\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `Queue` class should have a `enqueue` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    return typeof test.enqueue === 'function';\n  })()\n);"
        },
        {
          "text": "Your `Queue` class should have a `dequeue` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    return typeof test.dequeue === 'function';\n  })()\n);"
        },
        {
          "text": "Your `Queue` class should have a `front` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    return typeof test.front === 'function';\n  })()\n);"
        },
        {
          "text": "Your `Queue` class should have a `size` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    return typeof test.size === 'function';\n  })()\n);"
        },
        {
          "text": "Your `Queue` class should have an `isEmpty` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    return typeof test.isEmpty === 'function';\n  })()\n);"
        },
        {
          "text": "The `dequeue` method should remove and return the front element of the queue",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    test.enqueue('Smith');\n    test.enqueue('John');\n    return test.dequeue() === 'Smith';\n  })()\n);"
        },
        {
          "text": "The `front` method should return value of the front element of the queue",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    test.enqueue('Smith');\n    test.enqueue('John');\n    return test.front() === 'Smith';\n  })()\n);"
        },
        {
          "text": "The `size` method should return the length of the queue",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    test.enqueue('Smith');\n    return test.size() === 1;\n  })()\n);"
        },
        {
          "text": "The `isEmpty` method should return `false` if there are elements in the queue",
          "testCode": "assert(\n  (function () {\n    var test = new Queue();\n    test.enqueue('Smith');\n    return !test.isEmpty();\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301631,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-queue-class.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "8d1323c8c441eddfaeb5bdef",
      "title": "Create a Set Class",
      "challengeType": 1,
      "dashedName": "create-a-set-class",
      "description": "In this exercise we are going to create a class named `Set` to emulate an abstract data structure called \"set\". A set is like an array, but it cannot contain duplicate values. The typical use for a set is to simply check for the presence of an item. We can see how the ES6 `Set` object works in the example below:\n\n```js\nconst set1 = new Set([1, 2, 3, 5, 5, 2, 0]);\nconsole.log(set1);\n// output: {1, 2, 3, 5, 0}\nconsole.log(set1.has(1));\n// output: true\nconsole.log(set1.has(6));\n// output: false\n```\n\nFirst, we will create an add method that adds a value to our set collection as long as the value does not already exist in the set. Then we will create a remove method that removes a value from the set collection if it already exists. And finally, we will create a size method that returns the number of elements inside the set collection.",
      "instructions": "Create an `add` method that adds a unique value to the set collection and returns `true` if the value was successfully added and `false` otherwise.\n\nCreate a `remove` method that accepts a value and checks if it exists in the set. If it does, then this method should remove it from the set collection, and return `true`. Otherwise, it should return `false`. Create a `size` method that returns the size of the set collection.",
      "boilerplate": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    // Dictionary will hold the items of our set\n    this.dictionary = {};\n    this.length = 0;\n  }\n\n  // This method will check for the presence of an element and return true or false\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n\n  // This method will return all the values in the set\n  values() {\n    return Object.values(this.dictionary);\n  }\n\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    this.dictionary = {};\n    this.length = 0;\n  }\n\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n\n  values() {\n    return Object.values(this.dictionary);\n  }\n\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = element;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n\n  size() {\n    return this.length;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `Set` class should have an `add` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    return typeof test.add === 'function';\n  })()\n);"
        },
        {
          "text": "Your `add` method should not add duplicate values.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    test.add('a');\n    test.add('b');\n    test.add('a');\n    var vals = test.values();\n    return vals[0] === 'a' && vals[1] === 'b' && vals.length === 2;\n  })()\n);"
        },
        {
          "text": "Your `add` method should return `true` when a value has been successfully added.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    var result = test.add('a');\n    return result != undefined && result === true;\n  })()\n);"
        },
        {
          "text": "Your `add` method should return `false` when a duplicate value is added.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    test.add('a');\n    var result = test.add('a');\n    return result != undefined && result === false;\n  })()\n);"
        },
        {
          "text": "Your `Set` class should have a `remove` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    return typeof test.remove === 'function';\n  })()\n);"
        },
        {
          "text": "Your `remove` method should only remove items that are present in the set.",
          "testCode": "assert.deepEqual(\n  (function () {\n    var test = new Set();\n    test.add('a');\n    test.add('b');\n    test.remove('c');\n    return test.values();\n  })(),\n  ['a', 'b']\n);"
        },
        {
          "text": "Your `remove` method should remove the given item from the set.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    test.add('a');\n    test.add('b');\n    test.remove('a');\n    var vals = test.values();\n    return vals[0] === 'b' && vals.length === 1;\n  })()\n);"
        },
        {
          "text": "Your `Set` class should have a `size` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    return typeof test.size === 'function';\n  })()\n);"
        },
        {
          "text": "The `size` method should return the number of elements in the collection.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    test.add('a');\n    test.add('b');\n    test.remove('a');\n    return test.size() === 1;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301632,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-set-class.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8250367417b2b2512c5f",
      "title": "Create a Stack Class",
      "challengeType": 1,
      "dashedName": "create-a-stack-class",
      "description": "In the last section, we talked about what a stack is and how we can use an array to represent a stack. In this section, we will be creating our own stack class. Although you can use arrays to create stacks, sometimes it is best to limit the amount of control we have with our stacks. Apart from the `push` and `pop` method, stacks have other useful methods. Let's add a `peek`, `isEmpty`, and `clear` method to our stack class.",
      "instructions": "Write a `push` method that pushes an element to the top of the stack, a `pop` method that removes and returns the element on the top of the stack, a `peek` method that looks at the top element in the stack, an `isEmpty` method that checks if the stack is empty, and a `clear` method that removes all elements from the stack. Normally stacks don't have this, but we've added a `print` helper method that console logs the collection.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function Stack() {\n  var collection = [];\n  this.print = function() {\n    console.log(collection);\n  };\n  // Only change code below this line\n\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "class Stack {\n  constructor() {\n    this.collection = [];\n  }\n  print() {\n    console.log(this.collection);\n  }\n  push(val) {\n    this.collection.push(val);\n  }\n  pop() {\n    return this.collection.pop();\n  }\n  peek() {\n    return this.collection[this.collection.length - 1];\n  }\n  isEmpty() {\n    return this.collection.length === 0;\n  }\n  clear() {\n    return (this.collection.length = 0);\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `Stack` class should have a `push` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    return typeof test.push === 'function';\n  })()\n);"
        },
        {
          "text": "Your `Stack` class should have a `pop` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    return typeof test.pop === 'function';\n  })()\n);"
        },
        {
          "text": "Your `Stack` class should have a `peek` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    return typeof test.peek === 'function';\n  })()\n);"
        },
        {
          "text": "Your `Stack` class should have a `isEmpty` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    return typeof test.isEmpty === 'function';\n  })()\n);"
        },
        {
          "text": "Your `Stack` class should have a `clear` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    return typeof test.clear === 'function';\n  })()\n);"
        },
        {
          "text": "The `peek` method should return the top element of the stack",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    test.push('CS61');\n    test.push('CS50');\n    return test.peek() === 'CS50' && test.peek() === 'CS50';\n  })()\n);"
        },
        {
          "text": "The `pop` method should remove and return the top element of the stack",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    test.push('CS61');\n    test.push('CS50');\n    return test.pop() === 'CS50' && test.pop() === 'CS61';\n  })()\n);"
        },
        {
          "text": "The `isEmpty` method should return true if a stack does not contain any elements",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    return test.isEmpty();\n  })()\n);"
        },
        {
          "text": "The `clear` method should remove all element from the stack",
          "testCode": "assert(\n  (function () {\n    var test = new Stack();\n    test.push('CS61');\n    test.push('CS50');\n    test.clear();\n    return test.isEmpty();\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301633,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-stack-class.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8259367417b2b2512c84",
      "title": "Create a Trie Search Tree",
      "challengeType": 1,
      "dashedName": "create-a-trie-search-tree",
      "description": "Here we will move on from binary search trees and take a look at another type of tree structure called a trie. A trie is an ordered search tree commonly used to hold strings, or more generically associative arrays or dynamic datasets in which the keys are strings. They are very good at storing sets of data when many keys will have overlapping prefixes, for example, all the words in a dictionary. Unlike a binary tree, nodes are not associated with actual values. Instead, the path to a node represents a specific key. For instance, if we wanted to store the string code in a trie, we would have four nodes, one for each letter: c — o — d — e. Following that path through all these nodes will then create code as a string — that path is the key we stored. Then, if we wanted to add the string coding, it would share the first three nodes of code before branching away after the d. In this way, large datasets can be stored very compactly. In addition, search can be very quick because it is effectively limited to the length of the string you are storing. Furthermore, unlike binary trees a node can store any number of child nodes. As you might have guessed from the above example, some metadata is commonly stored at nodes that hold the end of a key so that on later traversals that key can still be retrieved. For instance, if we added codes in our example above we would need some way to know that the e in code represents the end of a key that was previously entered. Otherwise, this information would effectively be lost when we add codes.",
      "instructions": "Let's create a trie to store words. It will accept words through an `add` method and store these in a trie data structure. It will also allow us to query if a given string is a word with an `isWord` method, and retrieve all the words entered into the trie with a `print` method. `isWord` should return a boolean value and `print` should return an array of all these words as string values. In order for us to verify that this data structure is implemented correctly, we've provided a `Node` structure for each node in the tree. Each node will be an object with a `keys` property which is a JavaScript Map object. This will hold the individual letters that are valid keys of each node. We've also created an `end` property on the nodes that can be set to `true` if the node represents the termination of a word.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nvar Node = function() {\n  this.keys = new Map();\n  this.end = false;\n  this.setEnd = function() {\n    this.end = true;\n  };\n  this.isEnd = function() {\n    return this.end;\n  };\n};\nvar Trie = function() {\n  // Only change code below this line\n  \n  // Only change code above this line\n};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "The `Trie` should have an `add` method.",
          "testCode": "assert(\n  (function testTrie() {\n    var test = false;\n    if (typeof Trie !== 'undefined') {\n      test = new Trie();\n    } else {\n      return false;\n    }\n    return typeof test.add == 'function';\n  })()\n);"
        },
        {
          "text": "The `Trie` should have a `print` method.",
          "testCode": "assert(\n  (function testTrie() {\n    var test = false;\n    if (typeof Trie !== 'undefined') {\n      test = new Trie();\n    } else {\n      return false;\n    }\n    return typeof test.print == 'function';\n  })()\n);"
        },
        {
          "text": "The `Trie` should have an `isWord` method.",
          "testCode": "assert(\n  (function testTrie() {\n    var test = false;\n    if (typeof Trie !== 'undefined') {\n      test = new Trie();\n    } else {\n      return false;\n    }\n    return typeof test.isWord == 'function';\n  })()\n);"
        },
        {
          "text": "The `print` method should return all items added to the trie as strings in an array.",
          "testCode": "assert(\n  (function testTrie() {\n    var test = false;\n    if (typeof Trie !== 'undefined') {\n      test = new Trie();\n    } else {\n      return false;\n    }\n    test.add('jump');\n    test.add('jumps');\n    test.add('jumped');\n    test.add('house');\n    test.add('mouse');\n    var added = test.print();\n    return (\n      added.indexOf('jump') != -1 &&\n      added.indexOf('jumps') != -1 &&\n      added.indexOf('jumped') != -1 &&\n      added.indexOf('house') != -1 &&\n      added.indexOf('mouse') != -1 &&\n      added.length == 5\n    );\n  })()\n);"
        },
        {
          "text": "The `isWord` method should return `true` only for words added to the trie and `false` for all other words.",
          "testCode": "assert(\n  (function testTrie() {\n    var test = false;\n    if (typeof Trie !== 'undefined') {\n      test = new Trie();\n    } else {\n      return false;\n    }\n    test.add('hop');\n    test.add('hops');\n    test.add('hopped');\n    test.add('hoppy');\n    test.add('hope');\n    return (\n      test.isWord('hop') &&\n      !test.isWord('ho') &&\n      test.isWord('hopped') &&\n      !test.isWord('hopp') &&\n      test.isWord('hoppy') &&\n      !test.isWord('hoping')\n    );\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301634,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-a-trie-search-tree.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825b367417b2b2512c8d",
      "title": "Create an ES6 JavaScript Map",
      "challengeType": 1,
      "dashedName": "create-an-es6-javascript-map",
      "description": "The new version of JavaScript provides us with a built-in Map object which provides much of the functionality we wrote by hand in the last challenge. This Map object, although similar to regular JavaScript objects, provides some useful functionality that normal objects lack. For example, an ES6 Map tracks the insertion order of items that are added to it. Here is a more complete overview of its methods: \n\n- `.has(key)` returns true or false based on the presence of a key \n- `.get(key)` returns the value associated with a key \n- `.set(key, value)` sets a new key, value pair \n- `.delete(key)` removes a key, value pair \n- `.clear()` removes all key, value pairs \n- `.keys()` returns a new map iterator object that contains all the keys in insertion order \n- `.values()` returns a new map iterator object that contains all the values in insertion order \n- `.entries()` returns a new map iterator object that contains all the key, value pairs in insertion order",
      "instructions": "Define a JavaScript Map object and assign to it a variable called myMap. Add the key, value pair `freeCodeCamp`, `Awesome!` to it.",
      "boilerplate": [
        {
          "language": "js",
          "code": ""
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "const myMap = new Map();\n\nmyMap.set(\"freeCodeCamp\", \"Awesome!\");"
        }
      ],
      "tests": [
        {
          "text": "The `myMap` object should exist.",
          "testCode": "assert(typeof myMap === 'object');"
        },
        {
          "text": "`myMap` should contain the key value pair `freeCodeCamp`, `Awesome!`.",
          "testCode": "assert(myMap.get('freeCodeCamp') === 'Awesome!');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301635,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-an-es6-javascript-map.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8254367417b2b2512c70",
      "title": "Create and Add to Sets in ES6",
      "challengeType": 1,
      "dashedName": "create-and-add-to-sets-in-es6",
      "description": "Now that you have worked through ES5, you are going to perform something similar in ES6. This will be considerably easier. ES6 contains a built-in data structure `Set` so many of the operations you wrote by hand are now included for you. Let's take a look:\n\nTo create a new empty set:\n\n```js\nvar set = new Set();\n```\n\nYou can create a set with a value:\n\n```js\nvar set = new Set(1);\n```\n\nYou can create a set with an array:\n\n```js\nvar set = new Set([1, 2, 3]);\n```\n\nOnce you have created a set, you can add the values you wish using the `add` method:\n\n```js\nvar set = new Set([1, 2, 3]);\nset.add([4, 5, 6]);\n```\n\nAs a reminder, a set is a data structure that cannot contain duplicate values:\n\n```js\nvar set = new Set([1, 2, 3, 1, 2, 3]);\n// set contains [1, 2, 3] only\n```",
      "instructions": "For this exercise, return a set with the following values: `1, 2, 3, 'Taco', 'Cat', 'Awesome'`",
      "boilerplate": [
        {
          "language": "js",
          "code": "function checkSet() {\n  var set = new Set([1, 2, 3, 3, 2, 1, 2, 3, 1]);\n  // Only change code below this line\n\n  // Only change code above this line\n  console.log(Array.from(set));\n  return set;\n}\n\ncheckSet();"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function checkSet(){var set = new Set([1,2,3,'Taco','Cat','Awesome']);\nreturn set;}"
        }
      ],
      "tests": [
        {
          "text": "Your `Set` should only contain the values `1, 2, 3, Taco, Cat, Awesome`.",
          "testCode": "assert(\n  (function () {\n    var test = checkSet();\n    return (\n      test.size == 6 &&\n      test.has(1) &&\n      test.has(2) &&\n      test.has(3) &&\n      test.has('Taco') &&\n      test.has('Cat') &&\n      test.has('Awesome')\n    );\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301636,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\create-and-add-to-sets-in-es6.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8258367417b2b2512c80",
      "title": "Delete a Leaf Node in a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "delete-a-leaf-node-in-a-binary-search-tree",
      "description": "This is the first of three challenges where we will implement a more difficult operation in binary search trees: deletion. Deletion is difficult because removing nodes breaks links in the tree. These links must be carefully reestablished to ensure the binary tree structure is maintained. For some deletions, this means the tree must be rearranged. In general, you will encounter one of three cases when trying to delete a node: Leaf Node: The target to delete has zero children. One Child: The target to delete only has one child. Two Children: The target to delete has two child nodes. Removing a leaf node is easy, we simply remove it. Deleting a node with one child is also relatively easy, we simply remove it and link its parent to child of the node we deleted. Removing a node with two children is more difficult, however, because this creates two child nodes that need to be reconnected to the parent tree. We'll see how to deal with this case in the third challenge. Additionally, you need to be mindful of some edge cases when handling deletion. What if the tree is empty? What if the node to delete is the root node? What if there are only two elements in the tree? For now, let's handle the first case where we delete a leaf node.",
      "instructions": "Create a method on our binary tree called `remove`. We'll build the logic for our deletion operation in here. First, you'll want to create a function within remove that finds the node we are trying to delete in the current tree. If the node is not present in the tree, `remove` should return `null`. Now, if the target node is a leaf node with no children, then the parent reference to it should be set to `null`. This effectively deletes the node from the tree. To do this, you will have to keep track of the parent of the node we are trying to delete as well. It will also be useful to create a way to track the number of children the target node has, as this will determine which case our deletion falls under. We will handle the second and third cases in the next challenges. Good luck!",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\n\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `remove`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.remove == 'function';\n  })()\n);"
        },
        {
          "text": "Trying to remove an element from an empty tree should return `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    return test.remove(100) == null;\n  })()\n);"
        },
        {
          "text": "Trying to remove an element that does not exist should return `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(15);\n    test.add(30);\n    return test.remove(100) == null;\n  })()\n);"
        },
        {
          "text": "If the root node has no children, deleting it should set the root to `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(500);\n    test.remove(500);\n    return test.inorder() == null;\n  })()\n);"
        },
        {
          "text": "The `remove` method should remove leaf nodes from the tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(5);\n    test.add(3);\n    test.add(7);\n    test.add(6);\n    test.add(10);\n    test.add(12);\n    test.remove(3);\n    test.remove(12);\n    test.remove(10);\n    return test.inorder().join('') == '567';\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301637,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\delete-a-leaf-node-in-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        function searchTree(node) {\n          if (value < node.value) {\n            if (node.left == null) {\n              node.left = new Node(value);\n              return;\n            } else if (node.left != null) {\n              return searchTree(node.left);\n            }\n          } else if (value > node.value) {\n            if (node.right == null) {\n              node.right = new Node(value);\n              return;\n            } else if (node.right != null) {\n              return searchTree(node.right);\n            }\n          } else {\n            return null;\n          }\n        }\n        return searchTree(node);\n      }\n    },\n    inorder: function() {\n      if (this.root == null) {\n        return null;\n      } else {\n        var result = new Array();\n        function traverseInOrder(node) {\n          if (node.left != null) {\n            traverseInOrder(node.left);\n          }\n          result.push(node.value);\n          if (node.right != null) {\n            traverseInOrder(node.right);\n          }\n        }\n        traverseInOrder(this.root);\n        return result;\n      }\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8258367417b2b2512c81",
      "title": "Delete a Node with One Child in a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "delete-a-node-with-one-child-in-a-binary-search-tree",
      "description": "Now that we can delete leaf nodes let's move on to the second case: deleting a node with one child. For this case, say we have a tree with the following nodes 1 — 2 — 3 where 1 is the root. To delete 2, we simply need to make the right reference in 1 point to 3. More generally to delete a node with only one child, we make that node's parent reference the next node in the tree.",
      "instructions": "We've provided some code in our `remove` method that accomplishes the tasks from the last challenge. We find the target to delete and its parent and define the number of children the target node has. Let's add the next case here for target nodes with only one child. Here, we'll have to determine if the single child is a left or right branch in the tree and then set the correct reference in the parent to point to this node. In addition, let's account for the case where the target is the root node (this means the parent node will be `null`). Feel free to replace all the starter code with your own as long as it passes the tests.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\n\nfunction BinarySearchTree() {\n  this.root = null;\n  this.remove = function(value) {\n    if (this.root === null) {\n      return null;\n    }\n    var target;\n    var parent = null;\n    // Find the target value and its parent\n    (function findValue(node = this.root) {\n      if (value == node.value) {\n        target = node;\n      } else if (value < node.value && node.left !== null) {\n        parent = node;\n        return findValue(node.left);\n      } else if (value < node.value && node.left === null) {\n        return null;\n      } else if (value > node.value && node.right !== null) {\n        parent = node;\n        return findValue(node.right);\n      } else {\n        return null;\n      }\n    }.bind(this)());\n    if (target === null) {\n      return null;\n    }\n    // Count the children of the target to delete\n    var children =\n      (target.left !== null ? 1 : 0) + (target.right !== null ? 1 : 0);\n    // Case 1: Target has no children\n    if (children === 0) {\n      if (target == this.root) {\n        this.root = null;\n      } else {\n        if (parent.left == target) {\n          parent.left = null;\n        } else {\n          parent.right = null;\n        }\n      }\n    }\n    // Case 2: Target has one child\n    // Only change code below this line\n  };\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `remove`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.remove == 'function';\n  })()\n);"
        },
        {
          "text": "Trying to remove an element that does not exist should return `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    return test.remove(100) == null;\n  })()\n);"
        },
        {
          "text": "If the root node has no children, deleting it should set the root to `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(500);\n    test.remove(500);\n    return test.inorder() == null;\n  })()\n);"
        },
        {
          "text": "The `remove` method should remove leaf nodes from the tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(5);\n    test.add(3);\n    test.add(7);\n    test.add(6);\n    test.add(10);\n    test.add(12);\n    test.remove(3);\n    test.remove(12);\n    test.remove(10);\n    return test.inorder().join('') == '567';\n  })()\n);"
        },
        {
          "text": "The `remove` method should remove nodes with one child.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(1);\n    test.add(4);\n    test.add(3);\n    test.add(2);\n    test.add(6);\n    test.add(8);\n    test.remove(6);\n    test.remove(3);\n    return test.inorder().join('') == '1248';\n  })()\n);"
        },
        {
          "text": "Removing the root in a tree with two nodes should set the second to be the root.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(15);\n    test.add(27);\n    test.remove(15);\n    return test.inorder().join('') == '27';\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301638,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\delete-a-node-with-one-child-in-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        function searchTree(node) {\n          if (value < node.value) {\n            if (node.left == null) {\n              node.left = new Node(value);\n              return;\n            } else if (node.left != null) {\n              return searchTree(node.left);\n            }\n          } else if (value > node.value) {\n            if (node.right == null) {\n              node.right = new Node(value);\n              return;\n            } else if (node.right != null) {\n              return searchTree(node.right);\n            }\n          } else {\n            return null;\n          }\n        }\n        return searchTree(node);\n      }\n    },\n    inorder: function() {\n      if (this.root == null) {\n        return null;\n      } else {\n        var result = new Array();\n        function traverseInOrder(node) {\n          if (node.left != null) {\n            traverseInOrder(node.left);\n          }\n          result.push(node.value);\n          if (node.right != null) {\n            traverseInOrder(node.right);\n          }\n        }\n        traverseInOrder(this.root);\n        return result;\n      }\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8258367417b2b2512c82",
      "title": "Delete a Node with Two Children in a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "delete-a-node-with-two-children-in-a-binary-search-tree",
      "description": "Removing nodes that have two children is the hardest case to implement. Removing a node like this produces two subtrees that are no longer connected to the original tree structure. How can we reconnect them? One method is to find the smallest value in the right subtree of the target node and replace the target node with this value. Selecting the replacement in this way ensures that it is greater than every node in the left subtree it becomes the new parent of but also less than every node in the right subtree it becomes the new parent of. Once this replacement is made the replacement node must be removed from the right subtree. Even this operation is tricky because the replacement may be a leaf or it may itself be the parent of a right subtree. If it is a leaf we must remove its parent's reference to it. Otherwise, it must be the right child of the target. In this case, we must replace the target value with the replacement value and make the target reference the replacement's right child.",
      "instructions": "Let's finish our `remove` method by handling the third case. We've provided some code again for the first two cases. Add some code now to handle target nodes with two children. Any edge cases to be aware of? What if the tree has only three nodes? Once you are finished this will complete our deletion operation for binary search trees. Nice job, this is a pretty hard problem!",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\n\nfunction BinarySearchTree() {\n  this.root = null;\n  this.remove = function(value) {\n    if (this.root === null) {\n      return null;\n    }\n    var target;\n    var parent = null;\n    // Find the target value and its parent\n    (function findValue(node = this.root) {\n      if (value == node.value) {\n        target = node;\n      } else if (value < node.value && node.left !== null) {\n        parent = node;\n        return findValue(node.left);\n      } else if (value < node.value && node.left === null) {\n        return null;\n      } else if (value > node.value && node.right !== null) {\n        parent = node;\n        return findValue(node.right);\n      } else {\n        return null;\n      }\n    }.bind(this)());\n    if (target === null) {\n      return null;\n    }\n    // Count the children of the target to delete\n    var children =\n      (target.left !== null ? 1 : 0) + (target.right !== null ? 1 : 0);\n    // Case 1: Target has no children\n    if (children === 0) {\n      if (target == this.root) {\n        this.root = null;\n      } else {\n        if (parent.left == target) {\n          parent.left = null;\n        } else {\n          parent.right = null;\n        }\n      }\n    }\n    // Case 2: Target has one child\n    else if (children == 1) {\n      var newChild = target.left !== null ? target.left : target.right;\n      if (parent === null) {\n        target.value = newChild.value;\n        target.left = null;\n        target.right = null;\n      } else if (newChild.value < parent.value) {\n        parent.left = newChild;\n      } else {\n        parent.right = newChild;\n      }\n      target = null;\n    }\n    // Case 3: Target has two children\n    // Only change code below this line\n  };\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `remove`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.remove == 'function';\n  })()\n);"
        },
        {
          "text": "Trying to remove an element that does not exist should return `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.remove == 'function' ? test.remove(100) == null : false;\n  })()\n);"
        },
        {
          "text": "If the root node has no children, deleting it should set the root to `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    test.add(500);\n    test.remove(500);\n    return typeof test.remove == 'function' ? test.inorder() == null : false;\n  })()\n);"
        },
        {
          "text": "The `remove` method should remove leaf nodes from the tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    test.add(5);\n    test.add(3);\n    test.add(7);\n    test.add(6);\n    test.add(10);\n    test.add(12);\n    test.remove(3);\n    test.remove(12);\n    test.remove(10);\n    return typeof test.remove == 'function'\n      ? test.inorder().join('') == '567'\n      : false;\n  })()\n);"
        },
        {
          "text": "The `remove` method should remove nodes with one child.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(-1);\n    test.add(3);\n    test.add(7);\n    test.add(16);\n    test.remove(16);\n    test.remove(7);\n    test.remove(3);\n    return test.inorder().join('') == '-1';\n  })()\n);"
        },
        {
          "text": "Removing the root in a tree with two nodes should set the second to be the root.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(15);\n    test.add(27);\n    test.remove(15);\n    return test.inorder().join('') == '27';\n  })()\n);"
        },
        {
          "text": "The `remove` method should remove nodes with two children while maintaining the binary search tree structure.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(1);\n    test.add(4);\n    test.add(3);\n    test.add(7);\n    test.add(9);\n    test.add(11);\n    test.add(14);\n    test.add(15);\n    test.add(19);\n    test.add(50);\n    test.remove(9);\n    if (!test.isBinarySearchTree()) {\n      return false;\n    }\n    test.remove(11);\n    if (!test.isBinarySearchTree()) {\n      return false;\n    }\n    test.remove(14);\n    if (!test.isBinarySearchTree()) {\n      return false;\n    }\n    test.remove(19);\n    if (!test.isBinarySearchTree()) {\n      return false;\n    }\n    test.remove(3);\n    if (!test.isBinarySearchTree()) {\n      return false;\n    }\n    test.remove(50);\n    if (!test.isBinarySearchTree()) {\n      return false;\n    }\n    test.remove(15);\n    if (!test.isBinarySearchTree()) {\n      return false;\n    }\n    return test.inorder().join('') == '147';\n  })()\n);"
        },
        {
          "text": "The root should be removable on a tree of three nodes.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.remove !== 'function') {\n      return false;\n    }\n    test.add(100);\n    test.add(50);\n    test.add(300);\n    test.remove(100);\n    return test.inorder().join('') == 50300;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301639,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\delete-a-node-with-two-children-in-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        function searchTree(node) {\n          if (value < node.value) {\n            if (node.left == null) {\n              node.left = new Node(value);\n              return;\n            } else if (node.left != null) {\n              return searchTree(node.left);\n            }\n          } else if (value > node.value) {\n            if (node.right == null) {\n              node.right = new Node(value);\n              return;\n            } else if (node.right != null) {\n              return searchTree(node.right);\n            }\n          } else {\n            return null;\n          }\n        }\n        return searchTree(node);\n      }\n    },\n    inorder: function() {\n      if (this.root == null) {\n        return null;\n      } else {\n        var result = new Array();\n        function traverseInOrder(node) {\n          if (node.left != null) {\n            traverseInOrder(node.left);\n          }\n          result.push(node.value);\n          if (node.right != null) {\n            traverseInOrder(node.right);\n          }\n        }\n        traverseInOrder(this.root);\n        return result;\n      }\n    },\n    isBinarySearchTree() {\n      if (this.root == null) {\n        return null;\n      } else {\n        var check = true;\n        function checkTree(node) {\n          if (node.left != null) {\n            var left = node.left;\n            if (left.value > node.value) {\n              check = false;\n            } else {\n              checkTree(left);\n            }\n          }\n          if (node.right != null) {\n            var right = node.right;\n            if (right.value < node.value) {\n              check = false;\n            } else {\n              checkTree(right);\n            }\n          }\n        }\n        checkTree(this.root);\n        return check;\n      }\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825d367417b2b2512c96",
      "title": "Depth-First Search",
      "challengeType": 1,
      "dashedName": "depth-first-search",
      "description": "Similar to <dfn>breadth-first search</dfn>, here we will learn about another graph traversal algorithm called <dfn>depth-first search</dfn>.\n\nWhereas the breadth-first search searches incremental edge lengths away from the source node, <dfn>depth-first search</dfn> first goes down a path of edges as far as it can.\n\nOnce it reaches one end of a path, the search will backtrack to the last node with an un-visited edge path and continue searching.\n\nThe animation below shows how the algorithm works. The algorithm starts with the top node and visits the nodes in the numbered order.\n\n<img alt=\"animation showing the depth first search algorithm\" src='https://cdn.freecodecamp.org/curriculum/coding-interview-prep/depth-first-search.gif'>\n\nNotice how, unlike breadth-first search, every time a node is visited, it doesn't visit all of its neighbors. Instead, it first visits one of its neighbors and continues down that path until there are no more nodes to be visited on that path.\n\nTo implement this algorithm, you'll want to use a stack. A stack is an array where the last element added is the first to be removed. This is also known as a <dfn>Last-In-First-Out</dfn> data structure. A stack is helpful in depth-first search algorithms because, as we add neighbors to the stack, we want to visit the most recently added neighbors first and remove them from the stack.\n\nA simple output of this algorithm is a list of nodes which are reachable from a given node. Therefore, you'll also want to keep track of the nodes you visit.",
      "instructions": "Write a function `dfs()` that takes an undirected, adjacency matrix `graph` and a node label `root` as parameters. The node label will just be the numeric value of the node between `0` and `n - 1`, where `n` is the total number of nodes in the graph.\n\nYour function should output an array of all nodes reachable from `root`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function dfs(graph, root) {\n\n}\n\nvar exDFSGraph = [\n  [0, 1, 0, 0],\n  [1, 0, 1, 0],\n  [0, 1, 0, 1],\n  [0, 0, 1, 0]\n];\nconsole.log(dfs(exDFSGraph, 3));"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function dfs(graph, root) {\n    var stack = [];\n    var tempV;\n    var visited = [];\n    var tempVNeighbors = [];\n    stack.push(root);\n    while (stack.length > 0) {\n        tempV = stack.pop();\n        if (visited.indexOf(tempV) == -1) {\n            visited.push(tempV);\n            tempVNeighbors = graph[tempV];\n            for (var i = 0; i < tempVNeighbors.length; i++) {\n                if (tempVNeighbors[i] == 1) {\n                    stack.push(i);\n                }\n            }\n        }\n    }\n    return visited;\n}"
        }
      ],
      "tests": [
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` with a start node of `1` should return an array with `0`, `1`, `2`, and `3`.",
          "testCode": "assert.sameMembers(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 1, 0],\n      [0, 1, 0, 1],\n      [0, 0, 1, 0]\n    ];\n    return dfs(graph, 1);\n  })(),\n  [0, 1, 2, 3]\n);"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` with a start node of `3` should return an array with `3`, `2`, `1`, and `0`.",
          "testCode": "assert.sameMembers(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 1, 0],\n      [0, 1, 0, 1],\n      [0, 0, 1, 0]\n    ];\n    return dfs(graph, 3);\n  })(),\n  [3, 2, 1, 0]\n);"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 1], [0, 0, 1, 0]]` with a start node of `1` should return an array with four elements.",
          "testCode": "assert(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 1, 0],\n      [0, 1, 0, 1],\n      [0, 0, 1, 0]\n    ];\n    return dfs(graph, 1);\n  })().length === 4\n);"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]` with a start node of `3` should return an array with `3`.",
          "testCode": "assert.sameMembers(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 1, 0],\n      [0, 1, 0, 0],\n      [0, 0, 0, 0]\n    ];\n    return dfs(graph, 3);\n  })(),\n  [3]\n);"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 0]]` with a start node of `3` should return an array with one element.",
          "testCode": "assert(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 1, 0],\n      [0, 1, 0, 0],\n      [0, 0, 0, 0]\n    ];\n    return dfs(graph, 3);\n  })().length === 1\n);"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` with a start node of `3` should return an array with `2` and `3`.",
          "testCode": "assert.sameMembers(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 0, 0],\n      [0, 0, 0, 1],\n      [0, 0, 1, 0]\n    ];\n    return dfs(graph, 3);\n  })(),\n  [2, 3]\n);"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` with a start node of `3` should return an array with two elements.",
          "testCode": "assert(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 0, 0],\n      [0, 0, 0, 1],\n      [0, 0, 1, 0]\n    ];\n    return dfs(graph, 3);\n  })().length === 2\n);"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` with a start node of `0` should return an array with `0` and `1`.",
          "testCode": "assert.sameMembers(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 0, 0],\n      [0, 0, 0, 1],\n      [0, 0, 1, 0]\n    ];\n    return dfs(graph, 0);\n  })(),\n  [0, 1]\n);"
        },
        {
          "text": "The input graph `[[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1], [0, 0, 1, 0]]` with a start node of `0` should return an array with two elements.",
          "testCode": "assert(\n  (function () {\n    var graph = [\n      [0, 1, 0, 0],\n      [1, 0, 0, 0],\n      [0, 0, 0, 1],\n      [0, 0, 1, 0]\n    ];\n    return dfs(graph, 0);\n  })().length === 2\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301640,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\depth-first-search.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8257367417b2b2512c7d",
      "title": "Find the Minimum and Maximum Height of a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "find-the-minimum-and-maximum-height-of-a-binary-search-tree",
      "description": "In the last challenge we described a scenario in which a tree could become unbalanced. To understand the concept of balance, let's take a look at another tree property: height. Height in a tree represents the distance from the root node to any given leaf node. Different paths in a highly branched tree structure may have different heights, but for a given tree there will be a minimum and maximum height. If the tree is balanced, these values will differ at most by one. This means that in a balanced tree, all the leaf nodes exist within the same level, or if they are not within the same level they are at most one level apart.\n\nThe property of balance is important for trees because it is what determines the efficiency of tree operations. As we explained in the last challenge, we face worst case time complexity for heavily unbalanced trees. Self-balancing trees are commonly used to account for this issue in trees with dynamic data sets. Common examples of these include AVL trees, red-black trees, and B-trees. These trees all contain additional internal logic which re-balance the tree when insertions or deletions create a state of imbalance.\n\n**Note:** A similar property to height is depth, which refers to how far a given node is from the root node.",
      "instructions": "Write two methods for our binary tree: `findMinHeight` and `findMaxHeight`. These methods should return an integer value for the minimum and maximum height within a given binary tree, respectively. If the node is empty let's assign it a height of `-1` (that's the base case). Finally, add a third method `isBalanced` which returns `true` or `false` depending on whether the tree is balanced or not. You can use the first two methods you just wrote to determine this.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n  this.findMinHeight = function(root = this.root) {\n    // empty tree.\n    if (root === null) {\n      return -1;\n    }\n    // leaf node.\n    if (root.left === null && root.right === null) {\n      return 0;\n    }\n    if (root.left === null) {\n      return this.findMinHeight(root.right) + 1;\n    }\n    if (root.right === null) {\n      return this.findMinHeight(root.left) + 1;\n    }\n    const lHeight = this.findMinHeight(root.left);\n    const rHeight = this.findMinHeight(root.right);\n    return Math.min(lHeight, rHeight) + 1;\n  };\n  this.findMaxHeight = function(root = this.root) {\n    // empty tree.\n    if (root === null) {\n      return -1;\n    }\n    // leaf node.\n    if (root.left === null && root.right === null) {\n      return 0;\n    }\n    if (root.left === null) {\n      return this.findMaxHeight(root.right) + 1;\n    }\n    if (root.right === null) {\n      return this.findMaxHeight(root.left) + 1;\n    }\n    const lHeight = this.findMaxHeight(root.left);\n    const rHeight = this.findMaxHeight(root.right);\n    return Math.max(lHeight, rHeight) + 1;\n  };\n  this.isBalanced = function(root = this.root) {\n    if (root === null) {\n      return true;\n    }\n\n    if (root.left === null && root.right === null) {\n      return true;\n    }\n\n    if (root.left === null) {\n      return this.findMaxHeight(root.right) <= 0;\n    }\n\n    if (root.right === null) {\n      return this.findMaxHeight(root.left) <= 0;\n    }\n\n    const lHeight = this.findMaxHeight(root.left);\n    const rHeight = this.findMaxHeight(root.right);\n    if (Math.abs(lHeight - rHeight) > 1) {\n      return false;\n    }\n    return this.isBalanced(root.left) && this.isBalanced(root.right);\n  };\n}"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `findMinHeight`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.findMinHeight == 'function';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `findMaxHeight`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.findMaxHeight == 'function';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `isBalanced`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.isBalanced == 'function';\n  })()\n);"
        },
        {
          "text": "The `findMinHeight` method should return the minimum height of the tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.findMinHeight !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(1);\n    test.add(7);\n    test.add(87);\n    test.add(34);\n    test.add(45);\n    test.add(73);\n    test.add(8);\n    return test.findMinHeight() == 1;\n  })()\n);"
        },
        {
          "text": "The `findMaxHeight` method should return the maximum height of the tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.findMaxHeight !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(1);\n    test.add(7);\n    test.add(87);\n    test.add(34);\n    test.add(45);\n    test.add(73);\n    test.add(8);\n    return test.findMaxHeight() == 5;\n  })()\n);"
        },
        {
          "text": "An empty tree should return a height of `-1`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.findMaxHeight !== 'function') {\n      return false;\n    }\n    return test.findMaxHeight() == -1;\n  })()\n);"
        },
        {
          "text": "The `isBalanced` method should return `false` if the tree is an unbalanced binary search tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.isBalanced !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(1);\n    test.add(7);\n    test.add(87);\n    test.add(34);\n    test.add(45);\n    test.add(73);\n    test.add(8);\n    return test.isBalanced() === false;\n  })()\n);"
        },
        {
          "text": "The `isBalanced` method should return `true` if the tree is a balanced binary search tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.isBalanced !== 'function') {\n      return false;\n    }\n    test.add(10);\n    test.add(3);\n    test.add(22);\n    test.add(1);\n    test.add(4);\n    test.add(17);\n    test.add(32);\n    return test.isBalanced() === true;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301641,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\find-the-minimum-and-maximum-height-of-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      function searchTree(node) {\n        if (value < node.value) {\n          if (node.left == null) {\n            node.left = new Node(value);\n            return;\n          } else if (node.left != null) {\n            return searchTree(node.left);\n          }\n        } else if (value > node.value) {\n          if (node.right == null) {\n            node.right = new Node(value);\n            return;\n          } else if (node.right != null) {\n            return searchTree(node.right);\n          }\n        } else {\n          return null;\n        }\n      }\n\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        return searchTree(node);\n      }\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8256367417b2b2512c7a",
      "title": "Find the Minimum and Maximum Value in a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "find-the-minimum-and-maximum-value-in-a-binary-search-tree",
      "description": "In this challenge you will define two methods, `findMin` and `findMax`. These methods should return the minimum and maximum value held in the binary search tree (don't worry about adding values to the tree for now, we have added some in the background). If you get stuck, reflect on the invariant that must be true for binary search trees: each left subtree is less than or equal to its parent and each right subtree is greater than or equal to its parent. Let's also say that our tree can only store integer values. If the tree is empty, either method should return `null`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\n\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\n\nfunction BinarySearchTree() {\n  this.root = null;\n  this.findMin = function() {\n    // Empty tree.\n    if (!this.root) {\n      return null;\n    }\n    let currentNode = this.root;\n    while (currentNode.left) {\n      currentNode = currentNode.left;\n    }\n    return currentNode.value;\n  };\n  this.findMax = function() {\n    // Empty tree.\n    if (!this.root) {\n      return null;\n    }\n    let currentNode = this.root;\n    while (currentNode.right) {\n      currentNode = currentNode.right;\n    }\n    return currentNode.value;\n  };\n  this.add = function(value) {\n    // Empty tree.\n    if (!this.root) {\n      this.root = new Node(value);\n      return undefined;\n    }\n    return this.addNode(this.root, value);\n  };\n  this.addNode = function(node, value) {\n    // Check if value already exists.\n    if (node.value === value) return null;\n    if (value < node.value) {\n      if (node.left) {\n        return this.addNode(node.left, value);\n      } else {\n        node.left = new Node(value);\n        return undefined;\n      }\n    } else {\n      if (node.right) {\n        return this.addNode(node.right, value);\n      } else {\n        node.right = new Node(value);\n        return undefined;\n      }\n    }\n  };\n  this.isPresent = function(value) {\n    if (!this.root) {\n      return null;\n    }\n    return this.isNodePresent(this.root, value);\n  };\n  this.isNodePresent = function(node, value) {\n    if (node.value === value) return true;\n    if (value < node.value) {\n      return node.left ? this.isNodePresent(node.left, value) : false;\n    } else {\n      return node.right ? this.isNodePresent(node.right, value) : false;\n    }\n    return false;\n  };\n  this.findMinHeight = function() {\n    if (!this.root) {\n      return -1;\n    }\n    let heights = {};\n    let height = 0;\n    this.traverseTree(this.root, height, heights);\n    return Math.min(...Object.keys(heights));\n  };\n  this.findMaxHeight = function() {\n    if (!this.root) {\n      return -1;\n    }\n    let heights = {};\n    let height = 0;\n    this.traverseTree(this.root, height, heights);\n    return Math.max(...Object.keys(heights));\n  };\n  this.traverseTree = function(node, height, heights) {\n    if (node.left === null && node.right === null) {\n      return (heights[height] = true);\n    }\n    if (node.left) {\n      this.traverseTree(node.left, height + 1, heights);\n    }\n    if (node.right) {\n      this.traverseTree(node.right, height + 1, heights);\n    }\n  };\n  this.isBalanced = function() {\n    return this.findMaxHeight() > this.findMinHeight() + 1;\n  };\n  // DFS tree traversal.\n  this.inorder = function() {\n    if (!this.root) return null;\n    let result = [];\n\n    function traverseInOrder(node) {\n      if (node.left) traverseInOrder(node.left);\n      result.push(node.value);\n      if (node.right) traverseInOrder(node.right);\n    }\n    traverseInOrder(this.root);\n    return result;\n  };\n  this.preorder = function() {\n    if (!this.root) return null;\n    let result = [];\n\n    function traverseInOrder(node) {\n      result.push(node.value);\n      if (node.left) traverseInOrder(node.left);\n      if (node.right) traverseInOrder(node.right);\n    }\n    traverseInOrder(this.root);\n    return result;\n  };\n  this.postorder = function() {\n    if (!this.root) return null;\n    let result = [];\n\n    function traverseInOrder(node) {\n      if (node.left) traverseInOrder(node.left);\n      if (node.right) traverseInOrder(node.right);\n      result.push(node.value);\n    }\n    traverseInOrder(this.root);\n    return result;\n  };\n  // BFS tree traversal.\n  this.levelOrder = function() {\n    if (!this.root) return null;\n    let queue = [this.root];\n    let result = [];\n    while (queue.length) {\n      let node = queue.shift();\n      result.push(node.value);\n      if (node.left) queue.push(node.left);\n      if (node.right) queue.push(node.right);\n    }\n    return result;\n  };\n  this.reverseLevelOrder = function() {\n    if (!this.root) return null;\n    let queue = [this.root];\n    let result = [];\n    while (queue.length) {\n      let node = queue.shift();\n      result.push(node.value);\n      if (node.right) queue.push(node.right);\n      if (node.left) queue.push(node.left);\n    }\n    return result;\n  };\n  // Delete a leaf node.\n}\nlet bst = new BinarySearchTree();"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `findMin`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.findMin == 'function';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `findMax`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.findMax == 'function';\n  })()\n);"
        },
        {
          "text": "The `findMin` method should return the minimum value in the binary search tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.findMin !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(1);\n    test.add(7);\n    test.add(87);\n    test.add(34);\n    test.add(45);\n    test.add(73);\n    test.add(8);\n    return test.findMin() == 1;\n  })()\n);"
        },
        {
          "text": "The `findMax` method should return the maximum value in the binary search tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.findMax !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(1);\n    test.add(7);\n    test.add(87);\n    test.add(34);\n    test.add(45);\n    test.add(73);\n    test.add(8);\n    return test.findMax() == 87;\n  })()\n);"
        },
        {
          "text": "The `findMin` and `findMax` methods should return `null` for an empty tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.findMin !== 'function') {\n      return false;\n    }\n    if (typeof test.findMax !== 'function') {\n      return false;\n    }\n    return test.findMin() == null && test.findMax() == null;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301642,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\find-the-minimum-and-maximum-value-in-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      function searchTree(node) {\n        if (value < node.value) {\n          if (node.left == null) {\n            node.left = new Node(value);\n            return;\n          } else if (node.left != null) {\n            return searchTree(node.left);\n          }\n        } else if (value > node.value) {\n          if (node.right == null) {\n            node.right = new Node(value);\n            return;\n          } else if (node.right != null) {\n            return searchTree(node.right);\n          }\n        } else {\n          return null;\n        }\n      }\n\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        return searchTree(node);\n      }\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825b367417b2b2512c8c",
      "title": "Implement Heap Sort with a Min Heap",
      "challengeType": 1,
      "dashedName": "implement-heap-sort-with-a-min-heap",
      "description": "Now that we can add and remove elements let's see some of the applications heaps can be used for. Heaps are commonly used to implement priority queues because they always store an item of greatest or least value in first position. In addition, they are used to implement a sorting algorithm called heap sort. We'll see how to do this here. Heap sort uses a min heap, the reverse of a max heap. A min heap always stores the element of least value in the root position.\n\nHeap sort works by taking an unsorted array, adding each item in the array into a min heap, and then extracting every item out of the min heap into a new array. The min heap structure ensures that the new array will contain the original items in least to greatest order. This is one of the most efficient sorting algorithms with average and worst case performance of O(nlog(n)).",
      "instructions": "Let's implement heap sort with a min heap. Feel free to adapt your max heap code here. Create an object `MinHeap` with `insert`, `remove`, and `sort` methods. The `sort` method should return an array of all the elements in the min heap sorted from smallest to largest.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isSorted(a){\n  for(let i = 0; i < a.length - 1; i++)\n    if(a[i] > a[i + 1])\n      return false;\n  return true;\n}\n// Generate a randomly filled array\nfunction createRandomArray(size = 5){\n  let a = new Array(size);\n  for(let i = 0; i < size; i++)\n    a[i] = Math.floor(Math.random() * 100);\n  \n  return a;\n}\nconst array = createRandomArray(25);\n\nvar MinHeap = function() {\n  // Only change code below this line\n  \n  // Only change code above this line\n};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "The `MinHeap` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof MinHeap !== 'undefined') {\n      test = new MinHeap();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "`MinHeap` should have a method called `insert`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof MinHeap !== 'undefined') {\n      test = new MinHeap();\n    } else {\n      return false;\n    }\n    return typeof test.insert == 'function';\n  })()\n);"
        },
        {
          "text": "`MinHeap` should have a method called `remove`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof MinHeap !== 'undefined') {\n      test = new MinHeap();\n    } else {\n      return false;\n    }\n    return typeof test.remove == 'function';\n  })()\n);"
        },
        {
          "text": "`MinHeap` should have a method called `sort`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof MinHeap !== 'undefined') {\n      test = new MinHeap();\n    } else {\n      return false;\n    }\n    return typeof test.sort == 'function';\n  })()\n);"
        },
        {
          "text": "The `sort` method should return an array containing all items added to the min heap in sorted order.\n\n```js\nassert(\n  (() => {\n    if (typeof MinHeap === 'undefined') {\n      return false;\n    }\n\nconst heap = new MinHeap();\n    const arr = createRandomArray(25);\n\nfor (let i of arr) {\n      heap.insert(i);\n    }\n\nconst result = heap.sort();\n    arr.sort((a, b) => a - b);\n\nfor (let i = 0; i < arr.length; i++) {\n      if (arr[i] !== result[i]) {\n        return false;\n      }\n    }\n    return true;\n  })()\n);\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301643,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\implement-heap-sort-with-a-min-heap.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8256367417b2b2512c79",
      "title": "Incidence Matrix",
      "challengeType": 1,
      "dashedName": "incidence-matrix",
      "description": "Yet another way to represent a graph is to put it in an <dfn>incidence matrix.</dfn>\n\nAn <dfn>incidence matrix</dfn> is a two-dimensional (2D) array. Generally speaking, an incidence matrix relates two different classes of objects between its two dimensions. This kind of matrix is similar to an adjacency matrix. However, the rows and columns mean something else here.\n\nIn graphs, we have edges and nodes. These will be our \"two different classes of objects\". This matrix will have the rows be the nodes and columns be the edges. This means that we can have an uneven number of rows and columns.\n\nEach column will represent a unique edge. Also, each edge connects two nodes. To show that there is an edge between two nodes, you will put a 1 in the two rows of a particular column. Below is a 3 node graph with one edge between node 1 and node 3.\n\n<blockquote>    1<br>   ---<br>1 | 1<br>2 | 0<br>3 | 1</blockquote>\n\nHere is an example of an incidence matrix with 4 edges and 4 nodes. Remember, the columns are the edges and rows are the nodes themselves.\n\n<blockquote>    1 2 3 4<br>   --------<br>1 | 0 1 1 1<br>2 | 1 1 0 0<br>3 | 1 0 0 1<br>4 | 0 0 1 0</blockquote>\n\nBelow is a JavaScript implementation of the same thing.\n\n```js\nvar incMat = [\n  [0, 1, 1, 1],\n  [1, 1, 0, 0],\n  [1, 0, 0, 1],\n  [0, 0, 1, 0]\n];\n```\n\nTo make a directed graph, use `-1` for an edge leaving a particular node and `1` for an edge entering a node.\n\n```js\nvar incMatDirected = [\n  [ 0, -1,  1, -1],\n  [-1,  1,  0,  0],\n  [ 1,  0,  0,  1],\n  [ 0,  0, -1,  0]\n];\n```\n\nGraphs can also have <dfn>weights</dfn> on their edges. So far, we have <dfn>unweighted</dfn> edges where just the presence and lack of edge is binary (`0` or `1`). You can have different weights depending on your application. A different weight is represented as numbers greater than 1.",
      "instructions": "Create an incidence matrix of an undirected graph with five nodes and four edges. This matrix should be in a multi-dimensional array.\n\nThese five nodes have the following relationships. The first edge is between the first and second node. The second edge is between the second and third node. The third edge is between the third and fifth node. The fourth edge is between the fourth and second node. All edge weights are one and the edge order matters.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var incMatUndirected = [\n\n];"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var incMatUndirected = [[1, 0, 0, 0],[1, 1, 0, 1],[0, 1, 1, 0],[0, 0, 0, 1],[0, 0, 1, 0]];"
        }
      ],
      "tests": [
        {
          "text": "`incMatUndirected` should only contain five nodes.",
          "testCode": "assert(\n  incMatUndirected.length === 5 &&\n    incMatUndirected\n      .map(function (x) {\n        return x.length === 4;\n      })\n      .reduce(function (a, b) {\n        return a && b;\n      })\n);"
        },
        {
          "text": "There should be a first edge between the first and second node.",
          "testCode": "assert(incMatUndirected[0][0] === 1 && incMatUndirected[1][0] === 1);"
        },
        {
          "text": "There should be a second edge between the second and third node.",
          "testCode": "assert(incMatUndirected[1][1] === 1 && incMatUndirected[2][1] === 1);"
        },
        {
          "text": "There should be a third edge between the third and fifth node.",
          "testCode": "assert(incMatUndirected[2][2] === 1 && incMatUndirected[4][2] === 1);"
        },
        {
          "text": "There should be a fourth edge between the second and fourth node.",
          "testCode": "assert(incMatUndirected[1][3] === 1 && incMatUndirected[3][3] === 1);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301644,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\incidence-matrix.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825a367417b2b2512c8a",
      "title": "Insert an Element into a Max Heap",
      "challengeType": 1,
      "dashedName": "insert-an-element-into-a-max-heap",
      "description": "Now we will move on to another tree data structure, the binary heap. A binary heap is a partially ordered binary tree which satisfies the heap property. The heap property specifies a relationship between parent and child nodes. You may have a max heap, in which all parent nodes are greater than or equal to their child nodes, or a min heap, in which the reverse is true. Binary heaps are also complete binary trees. This means that all levels of the tree are fully filled and if the last level is partially filled it is filled from left to right.\n\nWhile binary heaps may be implemented as tree structures with nodes that contain left and right references, the partial ordering according to the heap property allows us to represent the heap with an array. The parent-children relationship is what we're interested in and with simple arithmetic we can compute the children of any parent and the parent of any child node.\n\nFor instance, consider this array representation of a binary min heap:\n\n```js\n[ 6, 22, 30, 37, 63, 48, 42, 76 ]\n```\n\nThe root node is the first element, `6`. Its children are `22` and `30`. If we look at the relationship between the array indices of these values, for index `i` the children are `2 * i + 1` and `2 * i + 2`. Similarly, the element at index `0` is the parent of these two children at indices `1` and `2`. More generally, we can find the parent of a node at any index with the following: `Math.floor((i - 1) / 2)`. These patterns will hold true as the binary tree grows to any size. Finally, we can make a slight adjustment to make this arithmetic even easier by skipping the first element in the array. Doing this creates the following relationship for any element at a given index `i`:\n\nExample array representation:\n\n```js\n[ null, 6, 22, 30, 37, 63, 48, 42, 76 ]\n```\n\nAn element's left child: `i * 2`\n\nAn element's right child: `i * 2 + 1`\n\nAn element's parent: `Math.floor(i / 2)`\n\nOnce you wrap your head around the math, using an array representation is very useful because node locations can be quickly determined with this arithmetic and memory usage is diminished because you don't need to maintain references to child nodes.",
      "instructions": "Instructions: Here we will create a max heap. Start by just creating an `insert` method which adds elements to our heap. During insertion, it is important to always maintain the heap property. For a max heap this means the root element should always have the greatest value in the tree and all parent nodes should be greater than their children. For an array implementation of a heap, this is typically accomplished in three steps:\n\n<ol>\n  <li>Add the new element to the end of the array.</li>\n  <li>If the element is larger than its parent, switch them.</li>\n  <li>Continue switching until the new element is either smaller than its parent or you reach the root of the tree.</li>\n</ol>\n\nFinally, add a `print` method which returns an array of all the items that have been added to the heap.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var MaxHeap = function() {\n  // Only change code below this line\n    \n  // Only change code above this line\n};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var MaxHeap = function() {\n    // Only change code below this line\n    this.heap = [];\n    this.parent = index => {\n      return Math.floor((index - 1) / 2);\n    }\n    this.insert = element => {\n      this.heap.push(element);\n      this.heapifyUp(this.heap.length - 1);\n    }\n    this.heapifyUp = index => {\n      let currentIndex = index,\n      parentIndex = this.parent(currentIndex);\n      while (currentIndex > 0 && this.heap[currentIndex] > this.heap[parentIndex]) {\n        this.swap(currentIndex, parentIndex);\n        currentIndex = parentIndex;\n        parentIndex = this.parent(parentIndex);\n      }\n    }\n    this.swap = (index1, index2) => {\n      [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\n    }\n    this.print = () => {\n      return this.heap;\n    }\n    // Only change code above this line\n};"
        }
      ],
      "tests": [
        {
          "text": "The `MaxHeap` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "`MaxHeap` should have a method called `insert`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    } else {\n      return false;\n    }\n    return typeof test.insert == 'function';\n  })()\n);"
        },
        {
          "text": "`MaxHeap` should have a method called `print`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    } else {\n      return false;\n    }\n    return typeof test.print == 'function';\n  })()\n);"
        },
        {
          "text": "The `insert` method should add elements according to the max heap property.\n\n```js\nassert(\n  (function () {\n    var test = false;\n    if (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    } else {\n      return false;\n    }\n    test.insert(50);\n    test.insert(100);\n    test.insert(700);\n    test.insert(32);\n    test.insert(51);\n    test.insert(800);\n    const result = test.print();\n    const solution = JSON.stringify([null,800,51,700,32,50,100]);\n    const solutionWithoutNull = JSON.stringify([800,51,700,32,50,100]);\n\nreturn (result.length == 6) ? (JSON.stringify(result) == solutionWithoutNull) : (JSON.stringify(result) == solution);\n  })()\n);\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301703,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\insert-an-element-into-a-max-heap.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8259367417b2b2512c83",
      "title": "Invert a Binary Tree",
      "challengeType": 1,
      "dashedName": "invert-a-binary-tree",
      "description": "Here will we create a function to invert a binary tree. Given a binary tree, we want to produce a new tree that is equivalently the mirror image of this tree. Running an inorder traversal on an inverted tree will explore the nodes in reverse order when compared to the inorder traversal of the original tree. Write a method to do this called `invert` on our binary tree. Calling this method should invert the current tree structure. Ideally, we would like to do this in-place in linear time. That is, we only visit each node once and we modify the existing tree structure as we go, without using any additional memory. Good luck!",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var displayTree = (tree) => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  this.invert = function(node = this.root) {\n    if (node) {\n      const temp = node.left;\n      node.left = node.right;\n      node.right = temp;\n      this.invert(node.left);\n      this.invert(node.right);\n    }\n    return node;\n  }\n    // Only change code above this line\n}"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `invert`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.invert == 'function';\n  })()\n);"
        },
        {
          "text": "The `invert` method should correctly invert the tree structure.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.invert !== 'function') {\n      return false;\n    }\n    test.add(4);\n    test.add(1);\n    test.add(7);\n    test.add(87);\n    test.add(34);\n    test.add(45);\n    test.add(73);\n    test.add(8);\n    test.invert();\n    return test.inorder().join('') == '877345348741';\n  })()\n);"
        },
        {
          "text": "Inverting an empty tree should return `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.invert !== 'function') {\n      return false;\n    }\n    return test.invert() == null;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301704,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\invert-a-binary-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      function searchTree(node) {\n        if (value < node.value) {\n          if (node.left == null) {\n            node.left = new Node(value);\n            return;\n          } else if (node.left != null) {\n            return searchTree(node.left)\n          };\n        } else if (value > node.value) {\n          if (node.right == null) {\n            node.right = new Node(value);\n            return;\n          } else if (node.right != null) {\n            return searchTree(node.right);\n          };\n        } else {\n          return null;\n        };\n      }\n\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        return searchTree(node);\n      };\n    },\n    inorder: function() {\n      if (this.root == null) {\n        return null;\n      } else {\n        var result = new Array();\n        function traverseInOrder(node) {\n          if (node.left != null) {\n            traverseInOrder(node.left);\n          };\n          result.push(node.value);\n          if (node.right != null) {\n            traverseInOrder(node.right);\n          };\n        }\n        traverseInOrder(this.root);\n        return result;\n      };\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8250367417b2b2512c5e",
      "title": "Learn how a Stack Works",
      "challengeType": 1,
      "dashedName": "learn-how-a-stack-works",
      "description": "You are probably familiar with stack of books on your table. You have likely used the undo feature of a text editor. You are also probably used to hitting the back button on your phone to go back to the previous view in your app.\n\nYou know what they all have in common? They all store the data in a way so that you can traverse backwards.\n\nThe topmost book in the stack was the one that was put there last. If you remove that book from your stack's top, you would expose the book that was put there before the last book and so on.\n\nIf you think about it, in all the above examples, you are getting <dfn>Last-In-First-Out</dfn> type of service. We will try to mimic this with our code.\n\nThis data storage scheme is called a <dfn>Stack</dfn>. In particular, we would have to implement the `push()` method that pushes JavaScript objects at the top of the stack; and `pop()` method, that removes the JavaScript object that's at the top of the stack at the current moment.",
      "instructions": "Here we have a stack of homework assignments represented as an array: `\"BIO12\"` is at the base, and `\"PSY44\"` is at the top of the stack.\n\nModify the given array and treat it like a `stack` using the JavaScript methods mentioned above. Remove the top element `\"PSY44\"` from the stack. Then add `\"CS50\"` to be the new top element of the stack.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var homeworkStack = [\"BIO12\",\"HIS80\",\"MAT122\",\"PSY44\"];\n// Only change code below this line"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "`homeworkStack` should only contain 4 elements.",
          "testCode": "assert(homeworkStack.length === 4);"
        },
        {
          "text": "The last element in `homeworkStack` should be `\"CS50\"`.",
          "testCode": "assert(homeworkStack[3] === 'CS50');"
        },
        {
          "text": "`homeworkStack` should not contain `\"PSY44\"`.",
          "testCode": "assert(homeworkStack.indexOf('PSY44') === -1);"
        },
        {
          "text": "The initial declaration of the `homeworkStack` should not be changed.",
          "testCode": "assert(\n  __helpers.removeJSComments(code).match(/=/g).length === 1 &&\n    /homeworkStack\\s*=\\s*\\[\"BIO12\"\\s*,\\s*\"HIS80\"\\s*,\\s*\"MAT122\"\\s*,\\s*\"PSY44\"\\]/.test(\n      __helpers.removeJSComments(code)\n    )\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301705,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\learn-how-a-stack-works.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8254367417b2b2512c6e",
      "title": "Perform a Difference on Two Sets of Data",
      "challengeType": 1,
      "dashedName": "perform-a-difference-on-two-sets-of-data",
      "description": "In this exercise we are going to perform a difference on 2 sets of data. We will create a method on our `Set` data structure called `difference`. A difference of sets should compare two sets and return the items present in the first set that are absent in the second. This method should take another `Set` as an argument and return the `difference` of the two sets.\n\nFor example, if `setA = ['a','b','c']` and `setB = ['a','b','d','e']`, then the difference of setA and setB is: `setA.difference(setB) = ['c']`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    // This will hold the set\n    this.dictionary = {};\n    this.length = 0;\n  }\n  // This method will check for the presence of an element and return true or false\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n  // This method will return all the values in the set\n  values() {\n    return Object.keys(this.dictionary);\n  }\n  // This method will add an element to the set\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = true;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n  // This method will remove an element from a set\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n  // This method will return the size of the set\n  size() {\n    return this.length;\n  }\n  // This is our union method \n  union(set) {\n    const newSet = new Set();\n    this.values().forEach(value => {\n      newSet.add(value);\n    })\n    set.values().forEach(value => {\n      newSet.add(value);\n    })\n\n    return newSet;\n  }\n  // This is our intersection method\n  intersection(set) {\n    const newSet = new Set();\n\n    let largeSet;\n    let smallSet;\n    if (this.dictionary.length > set.length) {\n      largeSet = this;\n      smallSet = set;\n    } else {\n      largeSet = set;\n      smallSet = this;\n    }\n\n    smallSet.values().forEach(value => {\n      if (largeSet.dictionary[value]) {\n        newSet.add(value);\n      }\n    })\n\n    return newSet;\n  }\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    this.dictionary = {};\n    this.length = 0;\n  }\n\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n\n  values() {\n    return Object.keys(this.dictionary);\n  }\n\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = true;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  union(set) {\n    const newSet = new Set();\n    this.values().forEach(value => {\n      newSet.add(value);\n    })\n    set.values().forEach(value => {\n      newSet.add(value);\n    })\n\n    return newSet;\n  }\n\n  intersection(set) {\n    const newSet = new Set();\n\n    let largeSet;\n    let smallSet;\n    if (this.dictionary.length > set.length) {\n      largeSet = this;\n      smallSet = set;\n    } else {\n      largeSet = set;\n      smallSet = this;\n    }\n\n    smallSet.values().forEach(value => {\n      if (largeSet.dictionary[value]) {\n        newSet.add(value);\n      }\n    })\n\n    return newSet;\n  }\n\n  difference(set) {\n    const newSet = new Set();\n\n    this.values().forEach(value => {\n      if (!set.dictionary[value]) {\n        newSet.add(value);\n      }\n    })\n\n    return newSet;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `Set` class should have a `difference` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    return typeof test.difference === 'function';\n  })()\n);"
        },
        {
          "text": "Your `difference` method should return the proper collection.\n\n```js\nvar setA = new Set();\nvar setB = new Set();\nsetA.add('a');\nsetA.add('b');\nsetA.add('c');\nsetB.add('c');\nsetB.add('d');\nvar differenceSetAB = setA.difference(setB);\n\nassert.equal(differenceSetAB.size(), 2)\nassert.deepEqual(differenceSetAB.values(), ['a', 'b'])\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301706,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\perform-a-difference-on-two-sets-of-data.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8254367417b2b2512c6f",
      "title": "Perform a Subset Check on Two Sets of Data",
      "challengeType": 1,
      "dashedName": "perform-a-subset-check-on-two-sets-of-data",
      "description": "In this exercise, we are going to perform a subset test on 2 sets of data. We will create a method on our `Set` data structure called `isSubsetOf`. This will compare the first set against the second, and if the first set is fully contained within the second, it will return `true`.\n\nFor example, if `setA = ['a','b']` and `setB = ['a','b','c','d']`, then `setA` is a subset of `setB`, so `setA.isSubsetOf(setB)` should return `true`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    // This will hold the set\n    this.dictionary = {};\n    this.length = 0;\n  }\n  // This method will check for the presence of an element and return true or false\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n  // This method will return all the values in the set\n  values() {\n    return Object.keys(this.dictionary);\n  }\n  // This method will add an element to the set\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = true;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n  // This method will remove an element from a set\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n  // This method will return the size of the set\n  size() {\n    return this.length;\n  }\n  // This is our union method \n  union(set) {\n    const newSet = new Set();\n    this.values().forEach(value => {\n      newSet.add(value);\n    })\n    set.values().forEach(value => {\n      newSet.add(value);\n    })\n\n    return newSet;\n  }\n  // This is our intersection method\n  intersection(set) {\n    const newSet = new Set();\n\n    let largeSet;\n    let smallSet;\n    if (this.dictionary.length > set.length) {\n      largeSet = this;\n      smallSet = set;\n    } else {\n      largeSet = set;\n      smallSet = this;\n    }\n\n    smallSet.values().forEach(value => {\n      if (largeSet.dictionary[value]) {\n        newSet.add(value);\n      }\n    })\n\n    return newSet;\n  }\n\n  difference(set) {\n    const newSet = new Set();\n\n    this.values().forEach(value => {\n      if (!set.dictionary[value]) {\n        newSet.add(value);\n      }\n    })\n\n    return newSet;\n  }\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    this.dictionary = {};\n    this.length = 0;\n  }\n\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n\n  values() {\n    return Object.keys(this.dictionary);\n  }\n\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = true;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  union(set) {\n    const newSet = new Set();\n    this.values().forEach(value => {\n      newSet.add(value);\n    })\n    set.values().forEach(value => {\n      newSet.add(value);\n    })\n\n    return newSet;\n  }\n\n  intersection(set) {\n    const newSet = new Set();\n\n    let largeSet;\n    let smallSet;\n    if (this.dictionary.length > set.length) {\n      largeSet = this;\n      smallSet = set;\n    } else {\n      largeSet = set;\n      smallSet = this;\n    }\n\n    smallSet.values().forEach(value => {\n      if (largeSet.dictionary[value]) {\n        newSet.add(value);\n      }\n    })\n\n    return newSet;\n  }  \n\n  difference(set) {\n    const newSet = new Set();\n\n    this.values().forEach(value => {\n      if (!set.dictionary[value]) {\n        newSet.add(value);\n      }\n    })\n\n    return newSet;\n  }\n\n  isSubsetOf(set) {\n    for(const value of this.values()){\n      if(!set.dictionary[value]) return false;\n    }\n    return true\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `Set` class should have a `isSubsetOf` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    return typeof test.isSubsetOf === 'function';\n  })()\n);"
        },
        {
          "text": "The first `Set` should be contained in the second `Set`.",
          "testCode": "assert(\n  (function () {\n    var setA = new Set();\n    var setB = new Set();\n    setA.add('a');\n    setB.add('b');\n    setB.add('c');\n    setB.add('a');\n    setB.add('d');\n    var aIsSubsetOfB = setA.isSubsetOf(setB);\n    return aIsSubsetOfB === true;\n  })()\n);"
        },
        {
          "text": "`['a', 'b'].isSubsetOf(['a', 'b', 'c', 'd'])` should return `true`.",
          "testCode": "assert(\n  (function () {\n    var setA = new Set();\n    var setB = new Set();\n    setA.add('a');\n    setA.add('b');\n    setB.add('a');\n    setB.add('b');\n    setB.add('c');\n    setB.add('d');\n    var aIsSubsetOfB = setA.isSubsetOf(setB);\n    return aIsSubsetOfB === true;\n  })()\n);"
        },
        {
          "text": "`['a', 'b', 'c'].isSubsetOf(['a', 'b'])` should return `false`.",
          "testCode": "assert(\n  (function () {\n    var setA = new Set();\n    var setB = new Set();\n    setA.add('a');\n    setA.add('b');\n    setA.add('c');\n    setB.add('a');\n    setB.add('b');\n    var aIsSubsetOfB = setA.isSubsetOf(setB);\n    return aIsSubsetOfB === false;\n  })()\n);"
        },
        {
          "text": "`[].isSubsetOf([])` should return `true`.",
          "testCode": "assert(\n  (function () {\n    var setA = new Set();\n    var setB = new Set();\n    var aIsSubsetOfB = setA.isSubsetOf(setB);\n    return aIsSubsetOfB === true;\n  })()\n);"
        },
        {
          "text": "`['a', 'b'].isSubsetOf(['c', 'd'])` should return `false`.",
          "testCode": "assert(\n  (function () {\n    var setA = new Set();\n    var setB = new Set();\n    setA.add('a');\n    setA.add('b');\n    setB.add('c');\n    setB.add('d');\n    var aIsSubsetOfB = setA.isSubsetOf(setB);\n    return aIsSubsetOfB === false;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301707,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\perform-a-subset-check-on-two-sets-of-data.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8253367417b2b2512c6c",
      "title": "Perform a Union on Two Sets",
      "challengeType": 1,
      "dashedName": "perform-a-union-on-two-sets",
      "description": "In this exercise we are going to perform a union on two sets of data. We will create a method on our `Set` data structure called `union`. This method should take another `Set` as an argument and return the `union` of the two sets, excluding any duplicate values.\n\nFor example, if `setA = ['a','b','c']` and `setB = ['a','b','d','e']`, then the union of setA and setB is: `setA.union(setB) = ['a', 'b', 'c', 'd', 'e']`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    // This will hold the set\n    this.dictionary = {};\n    this.length = 0;\n  }\n  // This method will check for the presence of an element and return true or false\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n  // This method will return all the values in the set\n  values() {\n    return Object.values(this.dictionary);\n  }\n  // This method will add an element to the set\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = element;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n  // This method will remove an element from a set\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n  // This method will return the size of the set\n  size() {\n    return this.length;\n  }\n  // Only change code below this line\n\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    this.dictionary = {};\n    this.length = 0;\n  }\n\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n\n  values() {\n    return Object.values(this.dictionary);\n  }\n\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = element;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  union(set) {\n    const newSet = new Set();\n    this.values().forEach(value => {\n      newSet.add(value);\n    })\n    set.values().forEach(value => {\n      newSet.add(value);\n    })\n\n    return newSet;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `Set` class should have a `union` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    return typeof test.union === 'function';\n  })()\n);"
        },
        {
          "text": "The union of a `Set` containing values `[\"a\", \"b\", \"c\"]` and a `Set` containing values `[\"c\", \"d\"]` should return a new `Set` containing values `[\"a\", \"b\", \"c\", \"d\"]`.",
          "testCode": "assert(\n  (function () {\n    var setA = new Set();\n    var setB = new Set();\n    setA.add('a');\n    setA.add('b');\n    setA.add('c');\n    setB.add('c');\n    setB.add('d');\n    var unionSetAB = setA.union(setB);\n    var final = unionSetAB.values();\n    return (\n      final.indexOf('a') !== -1 &&\n      final.indexOf('b') !== -1 &&\n      final.indexOf('c') !== -1 &&\n      final.indexOf('d') !== -1 &&\n      final.length === 4\n    );\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301708,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\perform-a-union-on-two-sets.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8253367417b2b2512c6d",
      "title": "Perform an Intersection on Two Sets of Data",
      "challengeType": 1,
      "dashedName": "perform-an-intersection-on-two-sets-of-data",
      "description": "In this exercise we are going to perform an intersection on 2 sets of data. We will create a method on our `Set` data structure called `intersection`. An intersection of sets represents all values that are common to two or more sets. This method should take another `Set` as an argument and return the `intersection` of the two sets.\n\nFor example, if `setA = ['a','b','c']` and `setB = ['a','b','d','e']`, then the intersection of setA and setB is: `setA.intersection(setB) = ['a', 'b']`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    // This will hold the set\n    this.dictionary = {};\n    this.length = 0;\n  }\n  // This method will check for the presence of an element and return true or false\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n  // This method will return all the values in the set\n  values() {\n    return Object.keys(this.dictionary);\n  }\n  // This method will add an element to the set\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = true;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n  // This method will remove an element from a set\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n  // This method will return the size of the set\n  size() {\n    return this.length;\n  }\n  // This is our union method \n  union(set) {\n    const newSet = new Set();\n    this.values().forEach(value => {\n      newSet.add(value);\n    })\n    set.values().forEach(value => {\n      newSet.add(value);\n    })\n\n    return newSet;\n  }\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "class Set {\n  constructor() {\n    this.dictionary = {};\n    this.length = 0;\n  }\n\n  has(element) {\n    return this.dictionary[element] !== undefined;\n  }\n\n  values() {\n    return Object.keys(this.dictionary);\n  }\n\n  add(element) {\n    if (!this.has(element)) {\n      this.dictionary[element] = true;\n      this.length++;\n      return true;\n    }\n\n    return false;\n  }\n\n  remove(element) {\n    if (this.has(element)) {\n      delete this.dictionary[element];\n      this.length--;\n      return true;\n    }\n\n    return false;\n  }\n\n  size() {\n    return this.length;\n  }\n\n  union(set) {\n    const newSet = new Set();\n    this.values().forEach(value => {\n      newSet.add(value);\n    })\n    set.values().forEach(value => {\n      newSet.add(value);\n    })\n\n    return newSet;\n  }\n\n  intersection(set) {\n    const newSet = new Set();\n\n    let largeSet;\n    let smallSet;\n    if (this.dictionary.length > set.length) {\n      largeSet = this;\n      smallSet = set;\n    } else {\n      largeSet = set;\n      smallSet = this;\n    }\n\n    smallSet.values().forEach(value => {\n      if (largeSet.dictionary[value]) {\n        newSet.add(value);\n      }\n    })\n\n    return newSet;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `Set` class should have a `intersection` method.",
          "testCode": "assert(\n  (function () {\n    var test = new Set();\n    return typeof test.intersection === 'function';\n  })()\n);"
        },
        {
          "text": "The proper collection should be returned.",
          "testCode": "assert(\n  (function () {\n    var setA = new Set();\n    var setB = new Set();\n    setA.add('a');\n    setA.add('b');\n    setA.add('c');\n    setB.add('c');\n    setB.add('d');\n    var intersectionSetAB = setA.intersection(setB);\n    return (\n      intersectionSetAB.size() === 1 && intersectionSetAB.values()[0] === 'c'\n    );\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301709,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\perform-an-intersection-on-two-sets-of-data.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825b367417b2b2512c8b",
      "title": "Remove an Element from a Max Heap",
      "challengeType": 1,
      "dashedName": "remove-an-element-from-a-max-heap",
      "description": "Now that we can add elements to our heap let's see how we can remove elements. Removing and inserting elements both require similar logic. In a max heap you will usually want to remove the greatest value, so this involves simply extracting it from the root of our tree. This will break the heap property of our tree, so we must reestablish it in some way. Typically, for a max heap this is done in the following way:\n\n<ol>\n  <li>Move the last element in the heap into the root position.</li>\n  <li>If either child of the root is greater than it, swap the root with the child of greater value.</li>\n  <li>Continue swapping until the parent is greater than both children or you reach the last level in the tree.</li>\n</ol>",
      "instructions": "Instructions: Add a method to our max heap called `remove`. This method should return the greatest value that has been added to our max heap and remove it from the heap. It should also reorder the heap so the heap property is maintained. After removing an element, the next greatest element remaining in the heap should become the root.",
      "boilerplate": [
        {
          "language": "js",
          "code": "const MaxHeap = function () {\n  this.heap = [];\n  this.parent = index => {\n    return Math.floor((index - 1) / 2);\n  }\n  this.insert = element => {\n    this.heap.push(element);\n    this.heapifyUp(this.heap.length - 1);\n  }\n  this.heapifyUp = index => {\n    let currentIndex = index,\n    parentIndex = this.parent(currentIndex);\n    while (currentIndex > 0 && this.heap[currentIndex] > this.heap[parentIndex]) {\n      this.swap(currentIndex, parentIndex);\n      currentIndex = parentIndex;\n      parentIndex = this.parent(parentIndex);\n    }\n  }\n  this.swap = (index1, index2) => {\n    [this.heap[index1], this.heap[index2]] = [this.heap[index2], this.heap[index1]];\n  }\n  this.print = () => {\n    return this.heap;\n  }\n  // Only change code below this line\n\n  // Only change code above this line\n};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "The `MaxHeap` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    let test = false;\n    if (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "`MaxHeap` should have a method called `print`.",
          "testCode": "assert(\n  (function () {\n    let test = false;\n    if (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    } else {\n      return false;\n    }\n    return typeof test.print == 'function';\n  })()\n);"
        },
        {
          "text": "`MaxHeap` should have a method called `insert`.",
          "testCode": "assert(\n  (function () {\n    let test = false;\n    if (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    } else {\n      return false;\n    }\n    return typeof test.insert == 'function';\n  })()\n);"
        },
        {
          "text": "`MaxHeap` should have a method called `remove`.",
          "testCode": "assert(\n  (function () {\n    let test = false;\n    if (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    } else {\n      return false;\n    }\n    return typeof test.remove == 'function';\n  })()\n);"
        },
        {
          "text": "The `remove` method should remove the greatest element from the max heap while maintaining the max heap property.\n\n```js\nfunction isHeap(arr, i, n) {\n    if( arr[i] < arr[2 * i + 1] || arr[i] < arr[2 * i + 2] ){\n        return false;\n    }\n    if (i > (n - 1) / 2) {\n        return true;\n    }\n    if (isHeap(arr, 2 * i + 1, n) && isHeap(arr, 2 * i + 2, n)) {\n        return true;\n    }\n    return false;\n}\n\nassert(\n  (function () {\n    let test = false;\n\nif (typeof MaxHeap !== 'undefined') {\n      test = new MaxHeap();\n    } else {\n      return false;\n    }\n\nlet max = Infinity;\n    const [result, vals] = [[], [9, 3, 5, 2, 15, 3, 7, 12, 7, 10, 90]];\n\nvals.forEach((val) => test.insert(val));\n\nfor (let i = 0; i < vals.length; i++) {\n      const curHeap = test.print();\n      const arr = curHeap[0] === null ? curHeap.slice(1) : curHeap;\n\nif (!isHeap(arr, 0, arr.length - 1)) {\n        return false;\n      }\n\nconst removed = test.remove();\n      if (!vals.includes(removed)) return false;\n      if (removed > max) return false\n      max = removed;\n      result.push(removed);\n    }\n\nfor (let i = 0; i < vals.length; i++) {\n      if (!result.includes(vals[i])) {\n        return false;\n      }\n    }\n\nreturn true;\n  })()\n);\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301710,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\remove-an-element-from-a-max-heap.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8251367417b2b2512c65",
      "title": "Remove Elements from a Linked List by Index",
      "challengeType": 1,
      "dashedName": "remove-elements-from-a-linked-list-by-index",
      "description": "Before we move on to another data structure, let's get a couple of last bits of practice with linked lists.\n\nLet's write a `removeAt` method that removes the `element` at a given `index`. The method should be called `removeAt(index)`. To remove an `element` at a certain `index`, we'll need to keep a running count of each node as we move along the linked list.\n\nA common technique used to iterate through the elements of a linked list involves a <dfn>'runner'</dfn>, or sentinel, that 'points' at the nodes that your code is comparing. In our case, starting at the `head` of our list, we start with a `currentIndex` variable that starts at `0`. The `currentIndex` should increment by one for each node we pass.\n\nJust like our `remove(element)` method, which <a href=\"/learn/coding-interview-prep/data-structures/remove-elements-from-a-linked-list\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">we covered in a previous lesson</a>, we need to be careful not to orphan the rest of our list when we remove the node in our `removeAt(index)` method. We keep our nodes contiguous by making sure that the node that has reference to the removed node has a reference to the next node.",
      "instructions": "Write a `removeAt(index)` method that removes and returns a node at a given `index`. The method should return `null` if the given `index` is either negative, or greater than or equal to the `length` of the linked list.\n\n**Note:** Remember to keep count of the `currentIndex`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function(element){\n    this.element = element;\n    this.next = null;\n  };\n\n  this.size = function(){\n    return length;\n  };\n\n  this.head = function(){\n    return head;\n  };\n\n  this.add = function(element){\n    var node = new Node(element);\n    if(head === null){\n      head = node;\n    } else {\n      var currentNode = head;\n\n      while(currentNode.next){\n        currentNode  = currentNode.next;\n      }\n\n      currentNode.next = node;\n    }\n\n    length++;\n  };\n\n  // Only change code below this line\n\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function (element) {\n    this.element = element;\n    this.next = null;\n  };\n\n  this.size = function () {\n    return length;\n  };\n\n  this.head = function () {\n    return head;\n  };\n\n  this.add = function (element) {\n    var node = new Node(element);\n    if (head === null) {\n      head = node;\n    } else {\n      var currentNode = head;\n\n      while (currentNode.next) {\n        currentNode = currentNode.next;\n      }\n\n      currentNode.next = node;\n    }\n\n    length++;\n  };\n\n  this.removeAt = function (index) {\n    var currentNode = head;\n    var previous = head;\n    var count = 0;\n    if (index >= length || index < 0) {\n      return null;\n    }\n    if (index === 0) {\n      var removed = head.element;\n      head = currentNode.next;\n    } else {\n      while (count < index) {\n        previous = currentNode;\n        currentNode = currentNode.next;\n        count++;\n      }\n      var removed = previous.next.element;\n      previous.next = currentNode.next;\n    }\n    length--;\n    return removed;\n  };\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `LinkedList` class should have a `removeAt` method.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    return typeof test.removeAt === 'function';\n  })()\n);"
        },
        {
          "text": "Your `removeAt` method should reduce the `length` of the linked list by one.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    test.removeAt(1);\n    return test.size() === 2;\n  })()\n);"
        },
        {
          "text": "Your `removeAt` method should remove the element at the specified index from the linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    test.add('bird');\n    test.removeAt(1);\n    return (\n      JSON.stringify(test.head()) ===\n      '{\"element\":\"cat\",\"next\":{\"element\":\"kitten\",\"next\":{\"element\":\"bird\",\"next\":null}}}'\n    );\n  })()\n);"
        },
        {
          "text": "When only one element is present in the linked list, your `removeAt` method should remove and return the element at specified index, and reduce the length of the linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    var removedItem = test.removeAt(0);\n    return test.head() === null && test.size() === 0 && removedItem === 'cat';\n  })()\n);"
        },
        {
          "text": "Your `removeAt` method should return the element of the removed node.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    return test.removeAt(1) === 'dog';\n  })()\n);"
        },
        {
          "text": "Your `removeAt` method should return `null` and the linked list should not change if the given index is less than `0`.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    var removedItem = test.removeAt(-1);\n    return (\n      removedItem === null &&\n      JSON.stringify(test.head()) ===\n        '{\"element\":\"cat\",\"next\":{\"element\":\"dog\",\"next\":{\"element\":\"kitten\",\"next\":null}}}'\n    );\n  })()\n);"
        },
        {
          "text": "Your `removeAt` method should return `null` and the linked list should not change if the given index is greater than or equal to the `length` of the list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    var removedItem = test.removeAt(3);\n    return (\n      removedItem === null &&\n      JSON.stringify(test.head()) ===\n        '{\"element\":\"cat\",\"next\":{\"element\":\"dog\",\"next\":{\"element\":\"kitten\",\"next\":null}}}'\n    );\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301711,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\remove-elements-from-a-linked-list-by-index.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8251367417b2b2512c63",
      "title": "Remove Elements from a Linked List",
      "challengeType": 1,
      "dashedName": "remove-elements-from-a-linked-list",
      "description": "The next important method that any implementation of a linked list will need is a `remove` method. This method should take the element we want to remove as an argument, and then search the list to find and remove the node that contains that element.\n\nWhenever we remove a node from a linked list, it's important that we don't accidentally orphan the rest of the list in doing so. Recall that every node's `next` property points to the node that follows it in the list. If we're removing the middle element, say, we'll want to make sure that we have a connection from that element's previous node's `next` property to the middle element's `next` property (which is the next node in the list!)\n\nThis might sound really confusing, so let's return to the conga line example so we have a good conceptual model. Picture yourself in a conga line, and the person directly in front of you leaves the line. The person who just left the line no longer has her hands on anyone in line--and you no longer have your hands on the person that left. You step forward and put your hands on next person you see.\n\nIf the element we wish to remove is the `head` element, we reassign the `head` to the second node of the linked list.",
      "instructions": "Write a `remove` method that takes an element and removes it from the linked list.\n\n**Note:** The `length` of the list should decrease by one every time an element is removed from the linked list.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function(element){\n    this.element = element;\n    this.next = null;\n  };\n\n  this.size = function(){\n    return length;\n  };\n\n  this.head = function(){\n    return head;\n  };\n\n  this.add = function(element){\n    var node = new Node(element);\n    if(head === null){\n        head = node;\n    } else {\n      var currentNode = head;\n\n      while(currentNode.next){\n        currentNode  = currentNode.next;\n      }\n\n      currentNode.next = node;\n    }\n\n    length++;\n  };\n\n  this.remove = function(element){\n    // Only change code below this line\n\n    // Only change code above this line\n  };\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function(element){\n    this.element = element;\n    this.next = null;\n  };\n\n  this.size = function(){\n    return length;\n  };\n\n  this.head = function(){\n    return head;\n  };\n\n  this.add = function(element){\n    var node = new Node(element);\n    if(head === null){\n        head = node;\n    } else {\n        var currentNode = head;\n\n        while(currentNode.next){\n            currentNode  = currentNode.next;\n        }\n\n        currentNode.next = node;\n    }\n\n    length++;\n  };\n\n  this.remove = function(element){\n    if (head === null) {\n      return;\n    }\n    var previous;\n    var currentNode = head;\n\n    while (currentNode.next !== null && currentNode.element !== element) {\n      previous = currentNode;\n      currentNode = currentNode.next;\n    }\n    \n    if (currentNode.next === null && currentNode.element !== element) {\n      return;\n    }\n    else if (previous) {\n      previous.next = currentNode.next;\n    } else {\n      head = currentNode.next;\n    }\n\n    length--;\n  };\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `LinkedList` class should have a `remove` method.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    return typeof test.remove === 'function';\n  })()\n);"
        },
        {
          "text": "Your `remove` method should reassign `head` to the second node when the first node is removed.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.remove('cat');\n    return test.head().element === 'dog';\n  })()\n);"
        },
        {
          "text": "Your `remove` method should decrease the `length` of the linked list by one for every node removed.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('hamster');\n    test.remove('cat');\n    test.remove('fish');\n    return test.size() === 2;\n  })()\n);"
        },
        {
          "text": "Your `remove` method should reassign the reference of the previous node of the removed node to the removed node's `next` reference.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('snake');\n    test.add('kitten');\n    test.remove('snake');\n    return test.head().next.next.element === 'kitten';\n  })()\n);"
        },
        {
          "text": "Your `remove` method should not change the linked list if the element does not exist in the linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    test.remove('elephant');\n    return (\n      JSON.stringify(test.head()) ===\n      '{\"element\":\"cat\",\"next\":{\"element\":\"dog\",\"next\":{\"element\":\"kitten\",\"next\":null}}}'\n    );\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301712,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\remove-elements-from-a-linked-list.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8254367417b2b2512c71",
      "title": "Remove items from a set in ES6",
      "challengeType": 1,
      "dashedName": "remove-items-from-a-set-in-es6",
      "description": "Let's practice removing items from an ES6 Set using the `delete` method.\n\nFirst, create an ES6 Set:\n\n```js\nvar set = new Set([1,2,3]);\n```\n\nNow remove an item from your Set with the `delete` method.\n\n```js\nset.delete(1);\nconsole.log([...set]) // should return [ 2, 3 ]\n```",
      "instructions": "Now, create a set with the integers 1, 2, 3, 4, & 5.\n\nRemove the values 2 and 5, and then return the set.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function checkSet(){\n  // Only change code below this line\n  var set = null;\n\n  // Only change code above this line\n  return set;   \n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function checkSet(){\nvar set = new Set([1,2,3,4,5]);\nset.delete(2);\nset.delete(5);\nreturn set;}"
        }
      ],
      "tests": [
        {
          "text": "Your Set should contain the values 1, 3, & 4",
          "testCode": "assert(\n  (function () {\n    var test = checkSet();\n    return test.has(1) && test.has(3) && test.has(4) && test.size === 3;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301713,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\remove-items-from-a-set-in-es6.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d825a367417b2b2512c88",
      "title": "Reverse a Doubly Linked List",
      "challengeType": 1,
      "dashedName": "reverse-a-doubly-linked-list",
      "description": "Let's create one more method for our doubly linked list called reverse which reverses the list in place. Once the method is executed the head should point to the previous tail and the tail should point to the previous head. Now, if we traverse the list from head to tail we should meet the nodes in a reverse order compared to the original list. Trying to reverse an empty list should return null.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "var Node = function(data, prev) {\n  this.data = data;\n  this.prev = prev;\n  this.next = null;\n};\nvar DoublyLinkedList = function() {\n  this.head = null;\n  this.tail = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n};"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var Node = function(data, prev) {\n    this.data = data;\n    this.prev = prev;\n    this.next = null;\n  };\n  var DoublyLinkedList = function() {\n    this.head = null;\n    this.tail = null;\n\n    this.reverse = function() {\n      if (!this.head || !this.head.next) {\n        return this.head\n      }\n\n      let tail;\n      let temp;\n      let current = this.head;\n      while(current !== null) {\n        if(!tail) tail = current;\n        temp = current.prev;\n        current.prev = current.next;\n        current.next = temp;\n        current = current.prev;\n      }\n\n      this.head = temp.prev;\n      this.tail = tail\n    }\n  };"
        }
      ],
      "tests": [
        {
          "text": "The `DoublyLinkedList` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The `DoublyLinkedList` should have a method called `reverse`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    if (test.reverse == undefined) {\n      return false;\n    }\n    return typeof test.reverse == 'function';\n  })()\n);"
        },
        {
          "text": "Reversing an empty list should return `null`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    return test.reverse() == null;\n  })()\n);"
        },
        {
          "text": "The `reverse` method should reverse the list.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    test.add(58);\n    test.add(61);\n    test.add(32);\n    test.add(95);\n    test.add(41);\n    test.reverse();\n    return test.print().join('') == '4195326158';\n  })()\n);"
        },
        {
          "text": "The `next` and `previous` references should be correctly maintained when a list is reversed.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof DoublyLinkedList !== 'undefined') {\n      test = new DoublyLinkedList();\n    }\n    test.add(11);\n    test.add(22);\n    test.add(33);\n    test.add(44);\n    test.add(55);\n    test.reverse();\n    return test.printReverse().join('') == '1122334455';\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301714,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\reverse-a-doubly-linked-list.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "DoublyLinkedList.prototype = Object.assign(\n  DoublyLinkedList.prototype,\n  {\n    add(data) {\n      if (this.head == null) {\n        this.head = new Node(data, null);\n        this.tail = this.head;\n      } else {\n        var node = this.head;\n        var prev = null;\n        while (node.next != null) {\n          prev = node;\n          node = node.next;\n        };\n        var newNode = new Node(data, node);\n        node.next = newNode;\n        this.tail = newNode;\n      };\n    },\n    print() {\n      if (this.head == null) {\n        return null;\n      } else {\n        var result = new Array();\n        var node = this.head;\n        while (node.next != null) {\n          result.push(node.data);\n          node = node.next;\n        };\n        result.push(node.data);\n        return result;\n      };\n    },\n    printReverse() {\n      if (this.tail == null) {\n        return null;\n      } else {\n        var result = new Array();\n        var node = this.tail;\n        while (node.prev != null) {\n          result.push(node.data);\n          node = node.prev;\n        };\n        result.push(node.data);\n        return result;\n      };\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8251367417b2b2512c64",
      "title": "Search within a Linked List",
      "challengeType": 1,
      "dashedName": "search-within-a-linked-list",
      "description": "Let's add a few more useful methods to our linked list class. Wouldn't it be useful if we could tell if our list was empty or not, as with our `Stack` and `Queue` classes?\n\nWe should also be able to find specific elements in our linked list. Traversing through data structures is something you'll want to get a lot of practice with! Let's create an `indexOf` method that takes an `element` as an argument, and returns that element's `index` in the linked list. If the element is not found in the linked list, return `-1`.\n\nLet's also implement a method that does the opposite: an `elementAt` method that takes an `index` as an argument and returns the `element` at the given `index`. If no `element` is found, return `undefined`.",
      "instructions": "Write an `isEmpty` method that checks if the linked list is empty, an `indexOf` method that returns the `index` of a given element, and an `elementAt` that returns an `element` at a given `index`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function(element){\n    this.element = element;\n    this.next = null;\n  };\n\n  this.size = function() {\n    return length;\n  };\n\n  this.head = function(){\n    return head;\n  };\n\n  this.add = function(element){\n    var node = new Node(element);\n    if(head === null){\n        head = node;\n    } else {\n      var currentNode = head;\n\n      while(currentNode.next){\n        currentNode = currentNode.next;\n      }\n\n      currentNode.next = node;\n    }\n\n    length++;\n  };\n\n  this.remove = function(element){\n    var currentNode = head;\n    var previousNode;\n    if(currentNode.element === element){\n      head = currentNode.next;\n    } else {\n      while(currentNode.element !== element) {\n        previousNode = currentNode;\n        currentNode = currentNode.next;\n      }\n\n      previousNode.next = currentNode.next;\n    }\n\n    length --;\n  };\n\n  // Only change code below this line\n\n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function LinkedList() {\n  var length = 0;\n  var head = null;\n\n  var Node = function(element){\n    this.element = element;\n    this.next = null;\n  };\n\n  this.size = function() {\n    return length;\n  };\n\n  this.head = function(){\n    return head;\n  };\n\n  this.add = function(element){\n    var node = new Node(element);\n    if(head === null){\n        head = node;\n    } else {\n        var currentNode = head;\n\n        while(currentNode.next){\n            currentNode  = currentNode.next;\n        }\n\n        currentNode.next = node;\n    }\n\n    length++;\n  };\n\n  this.remove = function(element){\n    var currentNode = head;\n    var previousNode;\n    if(currentNode.element === element){\n        head = currentNode.next;\n    } else {\n        while(currentNode.element !== element) {\n            previousNode = currentNode;\n            currentNode = currentNode.next;\n        }\n\n        previousNode.next = currentNode.next;\n    }\n\n    length --;\n  };\n\n  this.indexOf = function(element) {\n    if (head === null) return -1\n\n    let current = head;\n    let index = 0;\n\n    while (current.element !== element && current.next !== null) {\n      current = current.next;\n      index++\n    }\n\n    if (current.element !== element && current.next === null) {\n      return -1\n    }\n\n    return index;\n  }\n\n  this.elementAt = function(index) {\n    if (head === null) return undefined;\n\n    let current = head;\n    let currentIndex = 0;\n\n    while (currentIndex !== index && current.next !== null) {\n      current = current.next;\n      currentIndex++\n    }\n\n    if (currentIndex !== index && current.next === null) {\n      return undefined;\n    }\n\n    return current.element;\n  }\n\n  this.isEmpty = function() {\n    return length === 0;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "Your `LinkedList` class should have an `isEmpty` method.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    return typeof test.isEmpty === 'function';\n  })()\n);"
        },
        {
          "text": "Your `isEmpty` method should return `false` when there is at least one element in linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    return test.isEmpty() === false;\n  })()\n);"
        },
        {
          "text": "Your `isEmpty` method should return `true` when there are no elements in linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    return test.isEmpty() === true;\n  })()\n);"
        },
        {
          "text": "Your `LinkedList` class should have an `indexOf` method.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    return typeof test.indexOf === 'function';\n  })()\n);"
        },
        {
          "text": "Your `indexOf` method should return the index of a given element found in linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    return test.indexOf('cat') === 0;\n  })()\n);"
        },
        {
          "text": "Your `indexOf` method should return `-1` if the given element is not found in linked list",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    return test.indexOf('pony') === -1;\n  })()\n);"
        },
        {
          "text": "Your `LinkedList` class should have an `elementAt` method.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    return typeof test.elementAt === 'function';\n  })()\n);"
        },
        {
          "text": "Your `elementAt` method should return the element found at a given index in linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    return test.elementAt(1) === 'dog';\n  })()\n);"
        },
        {
          "text": "Your `elementAt` method should return `undefined` if the given element is not found at a given index in linked list.",
          "testCode": "assert(\n  (function () {\n    var test = new LinkedList();\n    test.add('cat');\n    test.add('dog');\n    test.add('kitten');\n    return test.elementAt(5) === undefined;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301715,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\search-within-a-linked-list.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8253367417b2b2512c6a",
      "title": "Typed Arrays",
      "challengeType": 1,
      "dashedName": "typed-arrays",
      "description": "Arrays are JavaScript objects that can hold a lot of different elements.\n\n```js\nvar complexArr = [1, 5, \"2\", \"Word\", {\"name\": \"James\"}];\n```\n\nBasically what happens in the background is that your browser will automatically give the right amount of memory space for that array. It will also change as needed if you add or remove data.\n\nHowever, in the world of high performance and different element types, sometimes you need to be more specific on how much memory is given to an array.\n\n<dfn>Typed arrays</dfn> are the answer to this problem. You are now able to say how much memory you want to give an array. Below is a basic overview of the different types of arrays available and the size in bytes for each element in that array.\n\n<table><tbody><tr><th>Type</th><th>Each element size in bytes</th></tr><tr><td><code>Int8Array</code></td><td>1</td></tr><tr><td><code>Uint8Array</code></td><td>1</td></tr><tr><td><code>Uint8ClampedArray</code></td><td>1</td></tr><tr><td><code>Int16Array</code></td><td>2</td></tr><tr><td><code>Uint16Array</code></td><td>2</td></tr><tr><td><code>Int32Array</code></td><td>4</td></tr><tr><td><code>Uint32Array</code></td><td>4</td></tr><tr><td><code>Float32Array</code></td><td>4</td></tr><tr><td><code>Float64Array</code></td><td>8</td></tr></tbody></table>\n\nThere are two ways in creating these kind of arrays. One way is to create it directly. Below is how to create a 3 length `Int16Array`.\n\n```js\nvar i8 = new Int16Array(3);\nconsole.log(i8);\n// Returns [0, 0, 0]\n```\n\nYou can also create a <dfn>buffer</dfn> to assign how much data (in bytes) you want the array to take up. **Note**  \nTo create typed arrays using buffers, you need to assign the number of bytes to be a multiple of the bytes listed above.\n\n```js\n// Create same Int16Array array differently\nvar byteSize = 6; // Needs to be multiple of 2\nvar buffer = new ArrayBuffer(byteSize);\nvar i8View = new Int16Array(buffer);\nbuffer.byteLength; // Returns 6\ni8View.byteLength; // Returns 6\nconsole.log(i8View); // Returns [0, 0, 0]\n```\n\n<dfn>Buffers</dfn> are general purpose objects that just carry data. You cannot access them normally. To access them, you need to first create a <dfn>view</dfn>.\n\n```js\ni8View[0] = 42;\nconsole.log(i8View); // Returns [42, 0, 0]\n```\n\n**Note**  \nTyped arrays do not have some of the methods traditional arrays have such as `.pop()` or `.push()`. Typed arrays also fail `Array.isArray()` that checks if something is an array. Although simpler, this can be an advantage for less-sophisticated JavaScript engines to implement them.",
      "instructions": "First create a `buffer` that is 64-bytes. Then create a `Int32Array` typed array with a view of it called `i32View`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var buffer;\nvar i32View;"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var buffer = new ArrayBuffer(64);\nvar i32View = new Int32Array(buffer);"
        }
      ],
      "tests": [
        {
          "text": "Your `buffer` should be 64 bytes large.",
          "testCode": "assert(buffer.byteLength === 64);"
        },
        {
          "text": "Your `i32View` view of your buffer should be 64 bytes large.",
          "testCode": "assert(i32View.byteLength === 64);"
        },
        {
          "text": "Your `i32View` view of your buffer should be 16 elements long.",
          "testCode": "assert(i32View.length === 16);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301716,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\typed-arrays.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8255367417b2b2512c72",
      "title": "Use .has and .size on an ES6 Set",
      "challengeType": 1,
      "dashedName": "use--has-and--size-on-an-es6-set",
      "description": "Let's look at the .has and .size methods available on the ES6 Set object.\n\nFirst, create an ES6 Set\n\n```js\nvar set = new Set([1,2,3]);\n```\n\nThe .has method will check if the value is contained within the set.\n\n```js\nvar hasTwo = set.has(2);\n```\n\nThe .size method will return an integer representing the size of the Set\n\n```js\nvar howBig = set.size;\n```",
      "instructions": "In this exercise we will pass an array and a value to the checkSet() function. Your function should create an ES6 set from the array argument. Find if the set contains the value argument. Find the size of the set. And return those two values in an array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function checkSet(arrToBeSet, checkValue){\n\n   // Only change code below this line\n\n   // Only change code above this line\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function checkSet(arrToBeSet, checkValue){\nvar set = new Set(arrToBeSet);\nvar result = [\nset.has(checkValue),\nset.size\n];\nreturn result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`checkSet([4, 5, 6], 3)` should return [ false, 3 ]",
          "testCode": "var test = checkSet([4, 5, 6], 3);\nassert.deepEqual(test, [false, 3]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301717,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\use-.has-and-.size-on-an-es6-set.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8258367417b2b2512c7f",
      "title": "Use Breadth First Search in a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "use-breadth-first-search-in-a-binary-search-tree",
      "description": "Here we will introduce another tree traversal method: breadth-first search. In contrast to the depth-first search methods from the last challenge, breadth-first search explores all the nodes in a given level within a tree before continuing on to the next level. Typically, queues are utilized as helper data structures in the design of breadth-first search algorithms.\n\nIn this method, we start by adding the root node to a queue. Then we begin a loop where we dequeue the first item in the queue, add it to a new array, and then inspect both its child subtrees. If its children are not null, they are each enqueued. This process continues until the queue is empty.",
      "instructions": "Let's create a breadth-first search method in our tree called `levelOrder`. This method should return an array containing the values of all the tree nodes, explored in a breadth-first manner. Be sure to return the values in the array, not the nodes themselves. A level should be traversed from left to right. Next, let's write a similar method called `reverseLevelOrder` which performs the same search but in the reverse direction (right to left) at each level.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  this.levelOrder = (root = this.root) => {\n    if(!root) return null;\n    let queue = [root];\n    let results = [];\n    while(queue.length > 0) {\n      let node = queue.shift();\n      results.push(node.value);\n      if(node.left) queue.push(node.left);\n      if(node.right) queue.push(node.right);\n    }\n    return results;\n  }\n\n  this.reverseLevelOrder = (root = this.root) => {\n    if(!root) return null;\n    let queue = [root];\n    let results = [] ;\n    while ( queue.length > 0) {\n      let node = queue.shift();\n      results.push(node.value);\n      if(node.right) queue.push(node.right);\n      if(node.left ) queue.push(node.left);\n    }\n    return results;\n  }\n  // Only change code above this line\n}"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `levelOrder`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.levelOrder == 'function';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `reverseLevelOrder`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.reverseLevelOrder == 'function';\n  })()\n);"
        },
        {
          "text": "The `levelOrder` method should return an array of the tree node values explored in level order.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.levelOrder !== 'function') {\n      return false;\n    }\n    test.add(7);\n    test.add(1);\n    test.add(9);\n    test.add(0);\n    test.add(3);\n    test.add(8);\n    test.add(10);\n    test.add(2);\n    test.add(5);\n    test.add(4);\n    test.add(6);\n    return test.levelOrder().join('') == '719038102546';\n  })()\n);"
        },
        {
          "text": "The `reverseLevelOrder` method should return an array of the tree node values explored in reverse level order.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.reverseLevelOrder !== 'function') {\n      return false;\n    }\n    test.add(7);\n    test.add(1);\n    test.add(9);\n    test.add(0);\n    test.add(3);\n    test.add(8);\n    test.add(10);\n    test.add(2);\n    test.add(5);\n    test.add(4);\n    test.add(6);\n    return test.reverseLevelOrder().join('') == '791108305264';\n  })()\n);"
        },
        {
          "text": "The `levelOrder` method should return `null` for an empty tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.levelOrder !== 'function') {\n      return false;\n    }\n    return test.levelOrder() == null;\n  })()\n);"
        },
        {
          "text": "The `reverseLevelOrder` method should return `null` for an empty tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.reverseLevelOrder !== 'function') {\n      return false;\n    }\n    return test.reverseLevelOrder() == null;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301718,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\use-breadth-first-search-in-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      function searchTree(node) {\n        if (value < node.value) {\n          if (node.left == null) {\n            node.left = new Node(value);\n            return;\n          } else if (node.left != null) {\n            return searchTree(node.left);\n          }\n        } else if (value > node.value) {\n          if (node.right == null) {\n            node.right = new Node(value);\n            return;\n          } else if (node.right != null) {\n            return searchTree(node.right);\n          }\n        } else {\n          return null;\n        }\n      }\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        return searchTree(node);\n      }\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8257367417b2b2512c7e",
      "title": "Use Depth First Search in a Binary Search Tree",
      "challengeType": 1,
      "dashedName": "use-depth-first-search-in-a-binary-search-tree",
      "description": "We know how to search a binary search tree for a specific value. But what if we just want to explore the entire tree? Or what if we don't have an ordered tree and we need to just search for a value? Here we will introduce some tree traversal methods which can be used to explore tree data structures. First up is depth-first search. In depth-first search, a given subtree is explored as deeply as possible before the search continues on to another subtree. There are three ways this can be done: In-order: Begin the search at the left-most node and end at the right-most node. Pre-order: Explore all the roots before the leaves. Post-order: Explore all the leaves before the roots. As you may guess, you may choose different search methods depending on what type of data your tree is storing and what you are looking for. For a binary search tree, an inorder traversal returns the nodes in sorted order.",
      "instructions": "Here we will create these three search methods on our binary search tree. Depth-first search is an inherently recursive operation which continues to explore further subtrees so long as child nodes are present. Once you understand this basic concept, you can simply rearrange the order in which you explore the nodes and subtrees to produce any of the three searches above. For example, in post-order search we would want to recurse all the way to a leaf node before we begin to return any of the nodes themselves, whereas in pre-order search we would want to return the nodes first, and then continue recursing down the tree. Define `inorder`, `preorder`, and `postorder` methods on our tree. Each of these methods should return an array of items which represent the tree traversal. Be sure to return the integer values at each node in the array, not the nodes themselves. Finally, return `null` if the tree is empty.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  // Only change code below this line\n  \n  // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var displayTree = tree => console.log(JSON.stringify(tree, null, 2));\nfunction Node(value) {\n  this.value = value;\n  this.left = null;\n  this.right = null;\n}\nfunction BinarySearchTree() {\n  this.root = null;\n  this.result = [];\n\n  this.inorder = function(node) {\n    if (!node) node = this.root;\n    if (!node) return null;\n\n    if (node.left) this.inorder(node.left);\n    this.result.push(node.value);\n    if (node.right) this.inorder(node.right);\n    return this.result;\n  };\n  this.preorder = function(node) {\n    if (!node) node = this.root;\n    if (!node) return null;\n\n    this.result.push(node.value);\n    if (node.left) this.preorder(node.left);\n    if (node.right) this.preorder(node.right);\n    return this.result;\n  };\n  this.postorder = function(node) {\n    if (!node) node = this.root;\n    if (!node) return null;\n\n    if (node.left) this.postorder(node.left);\n    if (node.right) this.postorder(node.right);\n    this.result.push(node.value);\n\n    return this.result;\n  };\n}"
        }
      ],
      "tests": [
        {
          "text": "The `BinarySearchTree` data structure should exist.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    }\n    return typeof test == 'object';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `inorder`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.inorder == 'function';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `preorder`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.preorder == 'function';\n  })()\n);"
        },
        {
          "text": "The binary search tree should have a method called `postorder`.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    return typeof test.postorder == 'function';\n  })()\n);"
        },
        {
          "text": "The `inorder` method should return an array of the node values that result from an inorder traversal.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.inorder !== 'function') {\n      return false;\n    }\n    test.add(7);\n    test.add(1);\n    test.add(9);\n    test.add(0);\n    test.add(3);\n    test.add(8);\n    test.add(10);\n    test.add(2);\n    test.add(5);\n    test.add(4);\n    test.add(6);\n    return test.inorder().join('') == '012345678910';\n  })()\n);"
        },
        {
          "text": "The `preorder` method should return an array of the node values that result from a preorder traversal.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.preorder !== 'function') {\n      return false;\n    }\n    test.add(7);\n    test.add(1);\n    test.add(9);\n    test.add(0);\n    test.add(3);\n    test.add(8);\n    test.add(10);\n    test.add(2);\n    test.add(5);\n    test.add(4);\n    test.add(6);\n    return test.preorder().join('') == '710325469810';\n  })()\n);"
        },
        {
          "text": "The `postorder` method should return an array of the node values that result from a postorder traversal.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.postorder !== 'function') {\n      return false;\n    }\n    test.add(7);\n    test.add(1);\n    test.add(9);\n    test.add(0);\n    test.add(3);\n    test.add(8);\n    test.add(10);\n    test.add(2);\n    test.add(5);\n    test.add(4);\n    test.add(6);\n    return test.postorder().join('') == '024653181097';\n  })()\n);"
        },
        {
          "text": "The `inorder` method should return `null` for an empty tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.inorder !== 'function') {\n      return false;\n    }\n    return test.inorder() == null;\n  })()\n);"
        },
        {
          "text": "The `preorder` method should return `null` for an empty tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.preorder !== 'function') {\n      return false;\n    }\n    return test.preorder() == null;\n  })()\n);"
        },
        {
          "text": "The `postorder` method should return `null` for an empty tree.",
          "testCode": "assert(\n  (function () {\n    var test = false;\n    if (typeof BinarySearchTree !== 'undefined') {\n      test = new BinarySearchTree();\n    } else {\n      return false;\n    }\n    if (typeof test.postorder !== 'function') {\n      return false;\n    }\n    return test.postorder() == null;\n  })()\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301719,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\use-depth-first-search-in-a-binary-search-tree.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "BinarySearchTree.prototype = Object.assign(\n  BinarySearchTree.prototype,\n  {\n    add: function(value) {\n      function searchTree(node) {\n        if (value < node.value) {\n          if (node.left == null) {\n            node.left = new Node(value);\n            return;\n          } else if (node.left != null) {\n            return searchTree(node.left);\n          }\n        } else if (value > node.value) {\n          if (node.right == null) {\n            node.right = new Node(value);\n            return;\n          } else if (node.right != null) {\n            return searchTree(node.right);\n          }\n        } else {\n          return null;\n        }\n      }\n\n      var node = this.root;\n      if (node == null) {\n        this.root = new Node(value);\n        return;\n      } else {\n        return searchTree(node);\n      }\n    }\n  }\n);"
          }
        ]
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8255367417b2b2512c73",
      "title": "Use Spread and Notes for ES5 Set() Integration",
      "challengeType": 1,
      "dashedName": "use-spread-and-notes-for-es5-set-integration",
      "description": "Do you remember the ES6 spread operator `...`?\n\n`...` can take iterable objects in ES6 and turn them into arrays.\n\nLet's create a Set, and check out the spread function.\n\n```js\nvar set = new Set([1,2,3]);\nvar setToArr = [...set]\nconsole.log(setToArr) // returns [ 1, 2, 3 ]\n```",
      "instructions": "In this exercise we will pass a set object to the `checkSet` function. It should return an array containing the values of the Set.\n\nNow you've successfully learned how to use the ES6 `Set()` object, good job!",
      "boilerplate": [
        {
          "language": "js",
          "code": "function checkSet(set){\n   // Only change code below this line\n\n   // Only change code above this line\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function checkSet(set){\nreturn [...set];}"
        }
      ],
      "tests": [
        {
          "text": "`checkSet(new Set([1,2,3,4,5,6,7])` should return `[1, 2, 3, 4, 5, 6, 7]`.",
          "testCode": "var test = checkSet(new Set([1, 2, 3, 4, 5, 6, 7]));\nassert.deepEqual(test, [1, 2, 3, 4, 5, 6, 7]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301720,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\use-spread-and-notes-for-es5-set-integration.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "587d8251367417b2b2512c61",
      "title": "Work with Nodes in a Linked List",
      "challengeType": 1,
      "dashedName": "work-with-nodes-in-a-linked-list",
      "description": "Another common data structure you'll run into in computer science is the <dfn>linked list</dfn>. A linked list is a linear collection of data elements, called 'nodes', each of which points to the next. Each <dfn>node</dfn> in a linked list contains two key pieces of information: the `element` itself, and a reference to the next `node`.\n\nImagine that you are in a conga line. You have your hands on the next person in the line, and the person behind you has their hands on you. You can see the person straight ahead of you, but they are blocking the view of the other people ahead in line. A node is just like a person in a conga line: they know who they are and they can only see the next person in line, but they are not aware of the other people ahead or behind them.",
      "instructions": "In our code editor, we've created two nodes, `Kitten` and `Puppy`, and we've manually connected the `Kitten` node to the `Puppy` node.\n\nCreate a `Cat` and `Dog` node and manually add them to the line.",
      "boilerplate": [
        {
          "language": "js",
          "code": "var Node = function(element) {\n  this.element = element;\n  this.next = null;\n};\nvar Kitten = new Node('Kitten');\nvar Puppy = new Node('Puppy');\n\nKitten.next = Puppy;\n// Only change code below this line"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [
        {
          "text": "Your `Puppy` node should have a reference to a `Cat` node.",
          "testCode": "assert(Puppy.next.element === 'Cat');"
        },
        {
          "text": "Your `Cat` node should have a reference to a `Dog` node.",
          "testCode": "assert(Cat.next.element === 'Dog');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 301721,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\data-structures\\work-with-nodes-in-a-linked-list.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "data-structures",
        "name": "Data Structures"
      }
    },
    {
      "id": "bd7156d8c242eddfaeb5bd13",
      "title": "Build a freeCodeCamp Forum Homepage",
      "challengeType": 3,
      "dashedName": "build-a-freecodecamp-forum-homepage",
      "description": "**Objective:** Build an app that is functionally similar to this: <https://codepen.io/freeCodeCamp/full/JqdoMV>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can see a list of the most recent posts on the freeCodeCamp forum.\n\n**User Story:** For each topic, I can see the title and a list of links to users who have recently posted in it.\n\n**User Story:** I can see the number of replies and views that each topic has had, and a timestamp of when the topic was last active.\n\n**Hint:** To get the 30 most recent forum posts: <https://forum-proxy.freecodecamp.rocks/latest>.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302349,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-camper-leaderboard.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "5a5d02bd919fcf9ca8cf46cb",
      "title": "Build a Light-Bright App",
      "challengeType": 3,
      "dashedName": "build-a-light-bright-app",
      "description": "**Objective:** Build an app that is functionally similar to this: <https://codepen.io/freeCodeCamp/full/eyLYXE>.\n\n**Rule #1:** Don't look at the example project's code. Figure it out for yourself.\n\n**Rule #2:** Fulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can click or drag the mouse cursor to color the circles.\n\n**User Story:** I can double-click on a colored circle to remove the color.\n\n**User Story:** I can click on a colored circle to change its color.\n\n**User Story:** I should get a circle of different color on each click.\n\n**User Story:** I can click on the 'Reset' button to remove the recent color.\n\n**User Story:** I can click on the 'Reset All' button to remove all the colors from the circles.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302350,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-light-bright-app.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c443eddfaeb5bdff",
      "title": "Build a Nightlife Coordination App",
      "challengeType": 4,
      "dashedName": "build-a-nightlife-coordination-app",
      "description": "Build a full stack JavaScript app that is functionally similar to this: <a href=\"https://yoyo44.herokuapp.com/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://yoyo44.herokuapp.com/</a>. Use a site builder of your choice to complete the project.\n\nHere are the specific user stories you should implement for this project:\n\n**User Story:** As an unauthenticated user, you can view all bars in your area.\n\n**User Story:** As an authenticated user, you can add yourself to a bar to indicate you are going there tonight.\n\n**User Story:** As an authenticated user, you can remove yourself from a bar if you no longer want to go there.\n\n**User Story:** As an unauthenticated user, when you login you should not have to search again.\n\n**Hint:** Try using the Yelp API to find venues in the cities your users search for. If you use Yelp's API, be sure to mention so in your app.\n\nWhen you are done, make sure a working demo of your project is hosted somewhere public. Then submit the URL to it in the Solution Link field. Optionally, also submit a link to your project's source code in the GitHub Link field.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302351,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-nightlife-coordination-app.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c443eddfaeb5bdee",
      "title": "Build a Pinterest Clone",
      "challengeType": 4,
      "dashedName": "build-a-pinterest-clone",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://build-a-pinterest-clone.freecodecamp.rocks/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://build-a-pinterest-clone.freecodecamp.rocks/</a>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** As an unauthenticated user, I can login with GitHub.\n\n**User Story:** As an authenticated user, I can link to images.\n\n**User Story:** As an authenticated user, I can delete images that I've linked to.\n\n**User Story:** As an authenticated user, I can see a Pinterest-style wall of all the images I've linked to.\n\n**User Story:** As an unauthenticated user, I can browse other users' walls of images.\n\n**User Story:** As an authenticated user, if I upload an image that is broken, it will be replaced by a placeholder image. (can use jQuery broken image detection)\n\n**Hint:** Masonry.js is a library that allows for Pinterest-style image grids.\n\nOnce you've finished implementing these user stories, enter the URL to your live app and, optionally, your GitHub repository. Then click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302352,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-pinterest-clone.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "5a4b7fcdb66f799f199e11db",
      "title": "Build a Pong Game",
      "challengeType": 3,
      "dashedName": "build-a-pong-game",
      "description": "**Objective:** Build an app that is functionally similar to this: <https://codepen.io/satyamdev/full/pdMmBp>.\n\n**Rule #1:** Don't look at the example project's code. Figure it out for yourself.\n\n**Rule #2:** Fulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can control a paddle.\n\n**User Story:** The computer can control the other paddle.\n\n**User Story:** The computer's paddle is unbeatable. It should never miss the ball.\n\n**User Story:** The game keeps track of the player and computer's score.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302353,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-pong-game.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7155d8c242eddfaeb5bd13",
      "title": "Build a Recipe Box",
      "challengeType": 3,
      "dashedName": "build-a-recipe-box",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://codepen.io/freeCodeCamp/full/dNVazZ/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://codepen.io/freeCodeCamp/full/dNVazZ/</a>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can create recipes that have names and ingredients.\n\n**User Story:** I can see an index view where the names of all the recipes are visible.\n\n**User Story:** I can click into any of those recipes to view it.\n\n**User Story:** I can edit these recipes.\n\n**User Story:** I can delete these recipes.\n\n**User Story:** All new recipes I add are saved in my browser's local storage. If I refresh the page, these recipes will still be there.\n\n**Hint:** You should prefix your local storage keys on CodePen, i.e. `_username_recipes`\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302354,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-recipe-box.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7153d8c242eddfaeb5bd13",
      "title": "Build a Roguelike Dungeon Crawler Game",
      "challengeType": 3,
      "dashedName": "build-a-roguelike-dungeon-crawler-game",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://codepen.io/freeCodeCamp/full/apLXEJ/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://codepen.io/freeCodeCamp/full/apLXEJ/</a>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I have health, a level, and a weapon. I can pick up a better weapon. I can pick up health items.\n\n**User Story:** All the items and enemies on the map are arranged at random.\n\n**User Story:** I can move throughout a map, discovering items.\n\n**User Story:** I can move anywhere within the map's boundaries, but I can't move through an enemy until I've beaten it.\n\n**User Story:** Much of the map is hidden. When I take a step, all spaces that are within a certain number of spaces from me are revealed.\n\n**User Story:** When I beat an enemy, the enemy goes away and I get XP, which eventually increases my level.\n\n**User Story:** When I fight an enemy, we take turns damaging each other until one of us loses. I do damage based off of my level and my weapon. The enemy does damage based off of its level. Damage is somewhat random within a range.\n\n**User Story:** When I find and beat the boss, I win.\n\n**User Story:** The game should be challenging, but theoretically winnable.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302355,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-roguelike-dungeon-crawler-game.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c442eddfaeb5bd1c",
      "title": "Build a Memory Light Game",
      "challengeType": 3,
      "dashedName": "build-a-memory-light-game",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://codepen.io/freeCodeCamp/full/obYBjE\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://codepen.io/freeCodeCamp/full/obYBjE</a>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I am presented with a random series of button presses.\n\n**User Story:** Each time I input a series of button presses correctly, I see the same series of button presses but with an additional step.\n\n**User Story:** I hear a sound that corresponds to each button both when the series of button presses plays, and when I personally press a button.\n\n**User Story:** If I press the wrong button, I am notified that I have done so, and that series of button presses starts again to remind me of the pattern so I can try again.\n\n**User Story:** I can see how many steps are in the current series of button presses.\n\n**User Story:** If I want to restart, I can hit a button to do so, and the game will return to a single step.\n\n**User Story:** I can play in strict mode where if I get a button press wrong, it notifies me that I have done so, and the game restarts at a new random series of button presses.\n\n**User Story:** I can win the game by getting a series of 20 steps correct. I am notified of my victory, then the game starts over.\n\n**Hint:** Here are mp3s you can use for each button:\n\n- `https://cdn.freecodecamp.org/curriculum/take-home-projects/memory-light-game/sound-1.mp3`\n- `https://cdn.freecodecamp.org/curriculum/take-home-projects/memory-light-game/sound-2.mp3`\n- `https://cdn.freecodecamp.org/curriculum/take-home-projects/memory-light-game/sound-3.mp3`\n- `https://cdn.freecodecamp.org/curriculum/take-home-projects/memory-light-game/sound-4.mp3`\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302357,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-simon-game.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c442eedfaeb5bd1c",
      "title": "Build a Tic Tac Toe Game",
      "challengeType": 3,
      "dashedName": "build-a-tic-tac-toe-game",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://codepen.io/freeCodeCamp/full/KzXQgy/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://codepen.io/freeCodeCamp/full/KzXQgy/</a>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can play a game of Tic Tac Toe with the computer.\n\n**User Story:** My game will reset as soon as it's over so I can play again.\n\n**User Story:** I can choose whether I want to play as X or O.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302358,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-tic-tac-toe-game.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c443eddfaeb5bdef",
      "title": "Build a Voting App",
      "challengeType": 4,
      "dashedName": "build-a-voting-app",
      "description": "Build a full stack JavaScript app that is functionally similar to this: <a href=\"https://voting-app.freecodecamp.rocks/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://voting-app.freecodecamp.rocks/</a>. Use a site builder of your choice to complete the project.\n\nHere are the specific user stories you should implement for this project:\n\n**User Story:** As an authenticated user, you can keep my polls and come back later to access them.\n\n**User Story:** As an authenticated user, you can share my polls with my friends.\n\n**User Story:** As an authenticated user, you can see the aggregate results of my polls.\n\n**User Story:** As an authenticated user, you can delete polls that I decide I don't want anymore.\n\n**User Story:** As an authenticated user, you can create a poll with any number of possible items.\n\n**User Story:** As an unauthenticated or authenticated user, you can see and vote on everyone's polls.\n\n**User Story:** As an unauthenticated or authenticated user, you can see the results of polls in chart form. (This could be implemented using Chart.js or Google Charts.)\n\n**User Story:** As an authenticated user, if you don't like the options on a poll, you can create a new option.\n\nWhen you are done, make sure a working demo of your project is hosted somewhere public. Then submit the URL to it in the Solution Link field. Optionally, also submit a link to your project's source code in the GitHub Link field.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302359,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-voting-app.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c442eddfaeb5bd19",
      "title": "Build a Wikipedia Viewer",
      "challengeType": 3,
      "dashedName": "build-a-wikipedia-viewer",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://codepen.io/freeCodeCamp/full/wGqEga/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://codepen.io/freeCodeCamp/full/wGqEga/</a>.\n\nThe MediaWiki software powers Wikipedia, and it helps you collect and organize knowledge and make it available to people.\n\nUsing the MediaWiki API, replicate the search function and random article function, similar to the example app above. You can use Wikipedia as your data source.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can search Wikipedia entries in a search box and see the resulting Wikipedia entries.\n\n**User Story:** I can click a button to see a random Wikipedia entry.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302360,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-a-wikipedia-viewer.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c443edefaeb5bdee",
      "title": "Build an Image Search Abstraction Layer",
      "challengeType": 4,
      "dashedName": "build-an-image-search-abstraction-layer",
      "description": "Build a full stack JavaScript app that allows you to search for images like this: <a href=\"https://image-search-abstraction-layer.freecodecamp.rocks/query/lolcats%20funny?page=10\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://image-search-abstraction-layer.freecodecamp.rocks/query/lolcats%20funny?page=10</a> and browse recent search queries like this: <a href=\"https://image-search-abstraction-layer.freecodecamp.rocks/recent/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://image-search-abstraction-layer.freecodecamp.rocks/recent/</a>. Use a site builder of your choice to complete the project.\n\nHere are the specific user stories you should implement for this project:\n\n**User Story:** You can get the image URLs, description and page URLs for a set of images relating to a given search string.\n\n**User Story:** You can paginate through the responses by adding a `?page=2` parameter to the URL.\n\n**User Story:** You can get a list of the most recently submitted search strings.\n\nWhen you are done, make sure a working demo of your project is hosted somewhere public. Then submit the URL to it in the Solution Link field. Optionally, also submit a link to your project's source code in the GitHub Link field.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302361,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-an-image-search-abstraction-layer.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7154d8c242eddfaeb5bd13",
      "title": "Build the Game of Life",
      "challengeType": 3,
      "dashedName": "build-the-game-of-life",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://codepen.io/freeCodeCamp/full/BpwMZv/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://codepen.io/freeCodeCamp/full/BpwMZv/</a>.\n\nThe Game of Life is a cellular automaton devised by the British mathematician John Horton Conway. It is a <em>zero-player game</em>, meaning that its evolution is determined by its initial state, requiring no further input. One interacts with the Game of Life by creating an initial configuration and observing how it evolves.\n\nThe universe of the Game of Life is an infinite, two-dimensional orthogonal grid of square cells, each of which is in one of two possible states, populated and unpopulated. Every cell interacts with its eight neighbors, which are the cells that are horizontally, vertically, or diagonally adjacent.\n\nAt each step in time, the following transitions occur:\n\n- Any live cell with fewer than two live neighbors dies, as if by underpopulation.\n- Any live cell with two or three live neighbors lives on to the next generation.\n- Any live cell with more than three live neighbors dies, as if by overpopulation.\n- Any dead cell with exactly three live neighbors becomes a live cell, as if by reproduction.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** When I first arrive at the game, it will randomly generate a board and start playing.\n\n**User Story:** I can start and stop the board.\n\n**User Story:** I can set up the board.\n\n**User Story:** I can clear the board.\n\n**User Story:** When I press start, the game will play out.\n\n**User Story:** Each time the board changes, I can see how many generations have gone by.\n\nWhen you are finished, include a link to your project and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302362,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\build-the-game-of-life.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c443eddfaeb5bd0e",
      "title": "Chart the Stock Market",
      "challengeType": 4,
      "dashedName": "chart-the-stock-market",
      "description": "Build a full stack JavaScript app that is functionally similar to this: <a href=\"https://chart-the-stock-market.freecodecamp.rocks/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://chart-the-stock-market.freecodecamp.rocks/</a>. Use a site builder of your choice to complete the project.\n\nHere are the specific user stories you should implement for this project:\n\n**User Story:** You can view a graph displaying the recent trend lines for each added stock.\n\n**User Story:** You can add new stocks by their symbol name.\n\n**User Story:** You can remove stocks.\n\n**User Story:** You can see changes in real-time when any other user adds or removes a stock. For this you will need to use Web Sockets.\n\nWhen you are done, make sure a working demo of your project is hosted somewhere public. Then submit the URL to it in the Solution Link field. Optionally, also submit a link to your project's source code in the GitHub Link field.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302363,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\chart-the-stock-market.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c443eddfaeb5bd0f",
      "title": "Manage a Book Trading Club",
      "challengeType": 4,
      "dashedName": "manage-a-book-trading-club",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://manage-a-book-trading-club.freecodecamp.rocks/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://manage-a-book-trading-club.freecodecamp.rocks/</a>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can view all books posted by every user.\n\n**User Story:** I can add a new book.\n\n**User Story:** I can update my settings to store my full name, city, and state.\n\n**User Story:** I can propose a trade and wait for the other user to accept the trade.\n\nOnce you've finished implementing these user stories, enter the URL to your live app and, optionally, your GitHub repository. Then click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302364,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\manage-a-book-trading-club.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7108d8c242eddfaeb5bd13",
      "title": "Map Data Across the Globe",
      "challengeType": 3,
      "dashedName": "map-data-across-the-globe",
      "description": "**Objective:** Build an app that is functionally similar to this: <https://codepen.io/freeCodeCamp/full/mVEJag>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can see where all Meteorites landed on a world map.\n\n**User Story:** I can tell the relative size of the meteorite, just by looking at the way it's represented on the map.\n\n**User Story:** I can mouse over the meteorite's data point for additional data.\n\n**Hint:** Here's a dataset you can use to build this: <https://raw.githubusercontent.com/freeCodeCamp/ProjectReferenceData/master/meteorite-strike-data.json>\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302365,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\map-data-across-the-globe.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7150d8c442eddfafb5bd1c",
      "title": "P2P Video Chat Application",
      "challengeType": 4,
      "dashedName": "p2p-video-chat-application",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://p2p-video-chat-application.freecodecamp.rocks/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://p2p-video-chat-application.freecodecamp.rocks/</a>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** Upon arriving, the browser will prompt me to access my camera and microphone.\n\n**User Story:** After I give it permission, I am prompted to type in a room name.\n\n**User Story:** Once I type in the room name, a room will be created if no room of that name existed before.\n\n**User Story:** A friend of mine can subsequently go to the same website, type in the same room I entered, and join the same room, then enter into a video chat with me.\n\n**User Story:** If I type in a room name, and there are already two people in that room, I get a notification that the room is full.\n\n**User Story:** Anyone can create or join any room. And there can be any number of rooms, but all of them must have unique names.\n\n**User Story:** I can choose to not permit the site to access my microphone and webcam. If I choose not to do this, or if some other driver problem occurs, I see an error message saying these are required.\n\n**User Story:** When I choose to cancel the room name input step, or if I type in no name, or just spaces, it should again ask me again to type in a valid room name.\n\n**User Story:** If one of the two people in the room get disconnected, they can reconnect to the same room and continue chatting.\n\nOnce you've finished implementing these user stories, enter the URL to your live app and, optionally, your GitHub repository. Then click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302366,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\p2p-video-chat-application.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7198d8c242eddfaeb5bd13",
      "title": "Show National Contiguity with a Force Directed Graph",
      "challengeType": 3,
      "dashedName": "show-national-contiguity-with-a-force-directed-graph",
      "description": "**Objective:** Build an app that is functionally similar to this: <https://codepen.io/freeCodeCamp/full/XWEONRz>.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can see a Force-directed Graph that shows which countries share borders.\n\n**User Story:** I can see each country's flag on its node.\n\n**Hint:** Here's a dataset you can use to build this: <https://raw.githubusercontent.com/DealPete/forceDirected/master/countries.json>\n\n**Hint:** You can create a spritesheet of national flags at <https://www.flag-sprites.com>.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302367,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\show-national-contiguity-with-a-force-directed-graph.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c442eddfaeb5bd10",
      "title": "Show the Local Weather",
      "challengeType": 3,
      "dashedName": "show-the-local-weather",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://codepen.io/freeCodeCamp/full/bELRjV\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://codepen.io/freeCodeCamp/full/bELRjV</a>.\n\n**Rule #1:** Don't look at the example project's code. Figure it out for yourself.\n\n**Rule #2:** Fulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can see the weather in my current location.\n\n**User Story:** I can see a different icon or background image (e.g. snowy mountain, hot desert) depending on the weather.\n\n**User Story:** I can push a button to toggle between Fahrenheit and Celsius.\n\n**Note:** Many internet browsers now require an HTTP Secure (`https://`) connection to obtain a user's locale via HTML5 Geolocation. For this reason, we recommend using HTML5 Geolocation to get user location and then use the freeCodeCamp Weather API <a href=\"https://weather-proxy.freecodecamp.rocks/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://weather-proxy.freecodecamp.rocks/</a> which uses an HTTP Secure connection for the weather. Also, be sure to connect to <a href=\"https://codepen.io\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">CodePen.io</a> via `https://`.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302368,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\show-the-local-weather.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    },
    {
      "id": "bd7158d8c442eddfaeb5bd1f",
      "title": "Use the Twitch JSON API",
      "challengeType": 3,
      "dashedName": "use-the-twitch-json-api",
      "description": "**Objective:** Build an app that is functionally similar to this: <a href=\"https://codepen.io/freeCodeCamp/full/Myvqmo/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://codepen.io/freeCodeCamp/full/Myvqmo/</a>.\n\nThe Twitch API is a RESTful API that lets developers build creative integrations for the broader Twitch community.\n\nFulfill the below user stories and get all of the tests to pass. Use whichever libraries or APIs you need. Give it your own personal style.\n\n**User Story:** I can see whether freeCodeCamp is currently streaming on Twitch.tv.\n\n**User Story:** I can click the status output and be sent directly to the freeCodeCamp's Twitch.tv channel.\n\n**User Story:** If a Twitch user is currently streaming, I can see additional details about what they are streaming.\n\n**Hint:** Here's an array of the Twitch.tv usernames of people who regularly stream: `[\"ESL_SC2\", \"OgamingSC2\", \"cretetion\", \"freecodecamp\", \"storbeck\", \"habathcx\", \"RobotCaleb\", \"noobs2ninjas\"]`\n\n**UPDATE:** Due to a change in conditions on API usage, Twitch.tv requires an API key, but we've built a workaround. Use <a href=\"https://twitch-proxy.freecodecamp.rocks/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">https://twitch-proxy.freecodecamp.rocks/</a> instead of Twitch's API base URL and you'll still be able to get account information, without needing to sign up for an API key.\n\nWhen you are finished, include a link to your project on CodePen and click the \"I've completed this challenge\" button.\n\nYou can get feedback on your project by sharing it on the <a href=\"https://forum.freecodecamp.org/c/project-feedback/409\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">freeCodeCamp forum</a>.",
      "instructions": "",
      "boilerplate": [],
      "solution": [
        {
          "language": "js",
          "code": "// solution required"
        }
      ],
      "tests": [],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 19541,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\10-coding-interview-prep\\take-home-projects\\use-the-twitch-json-api.md"
      },
      "section": {
        "id": "10-coding-interview-prep",
        "name": "10-coding-interview-prep"
      },
      "lesson": {
        "id": "take-home-projects",
        "name": "Take Home Projects"
      }
    }
  ],
  "metadata": {
    "total_challenges": 76,
    "challenges_with_content": 76
  }
}