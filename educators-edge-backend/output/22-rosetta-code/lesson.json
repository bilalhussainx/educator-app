{
  "section": {
    "id": "22-rosetta-code",
    "name": "22-rosetta-code"
  },
  "challenges": [
    {
      "id": "594810f028c0303b75339acb",
      "title": "100 doors",
      "challengeType": 1,
      "dashedName": "100-doors",
      "description": "There are 100 doors in a row that are all initially closed. You make 100 passes by the doors. The first time through, visit every door and 'toggle' the door (if the door is closed, open it; if it is open, close it). The second time, only visit every 2nd door (i.e., door #2, #4, #6, ...) and toggle it. The third time, visit every 3rd door (i.e., door #3, #6, #9, ...), etc., until you only visit the 100th door.",
      "instructions": "Implement a function to determine the state of the doors after the last pass. Return the final result in an array, with only the door number included in the array if it is open.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function getFinalOpenedDoors(numDoors) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function getFinalOpenedDoors(numDoors) {\n  // this is the final pattern (always squares).\n  // thus, the most efficient solution simply returns an array of squares up to numDoors).\n  const finalState = [];\n  let i = 1;\n  while (Math.pow(i, 2) <= numDoors) {\n    finalState.push(Math.pow(i, 2));\n    i++;\n  }\n  return finalState;\n}"
        }
      ],
      "tests": [
        {
          "text": "`getFinalOpenedDoors` should be a function.",
          "testCode": "assert(typeof getFinalOpenedDoors === 'function');"
        },
        {
          "text": "`getFinalOpenedDoors` should return an array.",
          "testCode": "assert(Array.isArray(getFinalOpenedDoors(100)));"
        },
        {
          "text": "`getFinalOpenedDoors` should produce the correct result.",
          "testCode": "assert.deepEqual(getFinalOpenedDoors(100), solution);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302217,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\100-doors.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const solution = [1, 4, 9, 16, 25, 36, 49, 64, 81, 100];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5951e88f64ebf159166a1176",
      "title": "24 game",
      "challengeType": 1,
      "dashedName": "24-game",
      "description": "The 24 Game tests a person's mental arithmetic.\n\nThe aim of the game is to arrange four numbers in a way that when evaluated, the result is 24",
      "instructions": "Implement a function that takes a string of four digits as its argument, with each digit from 1 to 9 (inclusive) with repetitions allowed, and returns an arithmetic expression that evaluates to the number 24. If no such solution exists, return \"no solution exists\".\n\n**Rules:**\n<ul>\n  <li> Only the following operators/functions are allowed: multiplication, division, addition, subtraction. </li>\n  <li> Division should use floating point or rational arithmetic, etc, to preserve remainders. </li>\n  <li> Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong). </li>\n  <li> The order of the digits when given does not have to be preserved. </li>\n</ul>\n\n| Example input                 | Example output            |\n| ----------------------------- | ------------------------- |\n| <code>solve24(\"4878\");</code> | <code>(7-8/8)\\*4</code>   |\n| <code>solve24(\"1234\");</code> | <code>3\\*1\\*4\\*2</code>   |\n| <code>solve24(\"6789\");</code> | <code>(6\\*8)/(9-7)</code> |\n| <code>solve24(\"1127\");</code> | <code>(1+7)\\*(2+1)</code> |",
      "boilerplate": [
        {
          "language": "js",
          "code": "function solve24 (numStr) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function solve24(numStr) {\n  const digitsArr = numStr.split('');\n  const answers = [];\n\n  const digitPermutations = [];\n  const operatorPermutations = [];\n\n  function generateDigitPermutations (digits, permutations = []) {\n    if (digits.length === 0) {\n      digitPermutations.push(permutations);\n    }\n    else {\n      for (let i = 0; i < digits.length; i++) {\n        const curr = digits.slice();\n        const next = curr.splice(i, 1);\n        generateDigitPermutations(curr.slice(), permutations.concat(next));\n      }\n    }\n  }\n\n  function generateOperatorPermutations (permutations = []) {\n    const operators = ['+', '-', '*', '/'];\n    if (permutations.length === 3) {\n      operatorPermutations.push(permutations);\n    }\n    else {\n      for (let i = 0; i < operators.length; i++) {\n        const curr = permutations.slice();\n        curr.push(operators[i]);\n        generateOperatorPermutations(curr);\n      }\n    }\n  }\n\n  generateDigitPermutations(digitsArr);\n  generateOperatorPermutations();\n\n  interleave();\n\n  return answers[0];\n\n  function interleave () {\n    for (let i = 0; i < digitPermutations.length; i++) {\n      for (let j = 0; j < operatorPermutations.length; j++) {\n        const d = digitPermutations[i];\n        const o = operatorPermutations[j];\n        const perm = [\n          `${d[0]}${o[0]}${d[1]}${o[1]}${d[2]}${o[2]}${d[3]}`,\n          `(${d[0]}${o[0]}${d[1]})${o[1]}${d[2]}${o[2]}${d[3]}`,\n          `${d[0]}${o[0]}(${d[1]}${o[1]}${d[2]})${o[2]}${d[3]}`,\n          `${d[0]}${o[0]}${d[1]}${o[1]}(${d[2]}${o[2]}${d[3]})`,\n          `${d[0]}${o[0]}(${d[1]}${o[1]}${d[2]}${o[2]}${d[3]})`,\n          `(${d[0]}${o[0]}${d[1]}${o[1]}${d[2]})${o[2]}${d[3]}`,\n          `(${d[0]}${o[0]}${d[1]})${o[1]}(${d[2]}${o[2]}${d[3]})`\n        ];\n\n        perm.forEach(combination => {\n          const res = eval(combination);\n\n          if (res === 24) {\n            return answers.push(combination);\n          }\n        });\n      }\n    }\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`solve24` should be a function.",
          "testCode": "assert(typeof solve24 === 'function');"
        },
        {
          "text": "`solve24(\"4878\")` should return `(7-8/8)*4`, `4*(7-8/8)`, or a similar valid string",
          "testCode": "assert(isValidSolution_(solve24(testCases_[0])));"
        },
        {
          "text": "`solve24(\"1234\")` should return `1*2*3*4` or a similar valid string",
          "testCode": "assert(isValidSolution_(solve24(testCases_[1])));"
        },
        {
          "text": "`solve24(\"6789\")` should return `(6*8)/(9-7)`, `(8*6)/(9-7)`, or a similar valid string",
          "testCode": "assert(isValidSolution_(solve24(testCases_[2])));"
        },
        {
          "text": "`solve24(\"1127\")` should return `(1+7)*(1+2)` or a similar valid string",
          "testCode": "assert(isValidSolution_(solve24(testCases_[3])));"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302218,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\24-game.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases_ = [\n  '4878',\n  '1234',\n  '6789',\n  '1127'\n];\n\nconst OPERATORS_ = {\n  \"+\": (a, b) => a + b,\n  \"-\": (a, b) => a - b,\n  \"*\": (a, b) => a * b,\n  \"/\": (a, b) => a / b,\n}\n\nconst PRECEDENCE_ = {\n  \"+\": 1,\n  \"-\": 1,\n  \"*\": 2,\n  \"/\": 2,\n}\n\nfunction evaluate_(expression) {\n  expression = expression.replace('/\\s+/g', '');\n  const stack = [];\n  let postfix = \"\";\n\n  // Convert from infix to postfix\n  let head = 0;\n  while (head < expression.length) {\n    let c = expression[head];\n    switch (c) {\n      case \"(\":\n        stack.push(c);\n        break;\n      case \")\":\n        let last = stack.pop();\n        while (last !== \"(\") {\n          postfix += last;\n          last = stack.pop();\n        }\n        break;\n      case \"+\":\n      case \"-\":\n      case \"*\":\n      case \"/\":\n        while (stack.length &&\n               PRECEDENCE_[c] <= PRECEDENCE_[stack[stack.length-1]]) {\n          postfix += stack.pop();\n        }\n        stack.push(c);\n        break;\n      case \"0\":\n      case \"1\":\n      case \"2\":\n      case \"3\":\n      case \"4\":\n      case \"5\":\n      case \"6\":\n      case \"7\":\n      case \"8\":\n      case \"9\":\n        postfix += c;\n        break;\n      default:\n        return false;\n    }\n    head++;\n  }\n\n  // Clear out stack\n  while (stack.length) {\n    postfix += stack.pop();\n  }\n\n  // Evaluate postfix\n  for (let c of postfix) {\n    switch (c) {\n      case \"+\":\n      case \"-\":\n      case \"*\":\n      case \"/\":\n        const b = +stack.pop();\n        const a = +stack.pop();\n        stack.push(OPERATORS_[c](a, b));\n        break;\n      default:\n        stack.push(c);\n    }\n  }\n  return stack.pop();\n}\n\n// Check solution validity\nfunction isValidSolution_(userSolution) {\n  return evaluate_(userSolution) === 24;\n}"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5949b579404977fbaefcd736",
      "title": "9 billion names of God the integer",
      "challengeType": 1,
      "dashedName": "9-billion-names-of-god-the-integer",
      "description": "This task is a variation of the short story by Arthur C. Clarke.\n\n(Solvers should be aware of the consequences of completing this task.)\n\nIn detail, to specify what is meant by a \"name\":\n\n<ul>\n  <li>The integer 1 has 1 name \"1\".</li>\n  <li>The integer 2 has 2 names \"1+1\" and \"2\".</li>\n  <li>The integer 3 has 3 names \"1+1+1\", \"2+1\",  and \"3\".</li>\n  <li>The integer 4 has 5 names \"1+1+1+1\", \"2+1+1\", \"2+2\", \"3+1\", \"4\".</li>\n  <li>The integer 5 has 7 names \"1+1+1+1+1\", \"2+1+1+1\", \"2+2+1\", \"3+1+1\", \"3+2\", \"4+1\", \"5\".</li>\n</ul>\n\nThis can be visualized in the following form:\n\n<pre>          1\n        1   1\n      1   1   1\n    1   2   1   1\n  1   2   2   1   1\n1   3   3   2   1   1\n</pre>\n\nWhere row $n$ corresponds to integer $n$, and each column $C$ in row $m$ from left to right corresponds to the number of names beginning with $C$.\n\nOptionally note that the sum of the $n$-th row $P(n)$ is the integer partition function.",
      "instructions": "Implement a function that returns the sum of the $n$-th row.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function numberOfNames(num) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function numberOfNames(num) {\n  const cache = [\n    [1]\n  ];\n  for (let l = cache.length; l < num + 1; l++) {\n    let Aa;\n    let Mi;\n    const r = [0];\n    for (let x = 1; x < l + 1; x++) {\n      r.push(r[r.length - 1] + (Aa = cache[l - x < 0 ? cache.length - (l - x) : l - x])[(Mi = Math.min(x, l - x)) < 0 ? Aa.length - Mi : Mi]);\n    }\n    cache.push(r);\n  }\n  return cache[num][cache[num].length - 1];\n}"
        }
      ],
      "tests": [
        {
          "text": "`numberOfNames` should be function.",
          "testCode": "assert(typeof numberOfNames === 'function');"
        },
        {
          "text": "`numberOfNames(5)` should equal 7.",
          "testCode": "assert.equal(numberOfNames(5), 7);"
        },
        {
          "text": "`numberOfNames(12)` should equal 77.",
          "testCode": "assert.equal(numberOfNames(12), 77);"
        },
        {
          "text": "`numberOfNames(18)` should equal 385.",
          "testCode": "assert.equal(numberOfNames(18), 385);"
        },
        {
          "text": "`numberOfNames(23)` should equal 1255.",
          "testCode": "assert.equal(numberOfNames(23), 1255);"
        },
        {
          "text": "`numberOfNames(42)` should equal 53174.",
          "testCode": "assert.equal(numberOfNames(42), 53174);"
        },
        {
          "text": "`numberOfNames(123)` should equal 2552338241.",
          "testCode": "assert.equal(numberOfNames(123), 2552338241);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302219,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\9-billion-names-of-god-the-integer.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339acc",
      "title": "ABC Problem",
      "challengeType": 1,
      "dashedName": "abc-problem",
      "description": "You are given a collection of ABC blocks (e.g., childhood alphabet blocks). There are 20 blocks with two letters on each block. A complete alphabet is guaranteed amongst all sides of the blocks. The sample collection of blocks:\n\n<pre>(B O)\n(X K)\n(D Q)\n(C P)\n(N A)\n(G T)\n(R E)\n(T G)\n(Q D)\n(F S)\n(J W)\n(H U)\n(V I)\n(A N)\n(O B)\n(E R)\n(F S)\n(L Y)\n(P C)\n(Z M)\n</pre>",
      "instructions": "Implement a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks.\n\nSome rules to keep in mind:\n\n<ul>\n  <li>Once a letter on a block is used, that block cannot be used again.</li>\n  <li>The function should be case-insensitive.</li>\n</ul>",
      "boilerplate": [
        {
          "language": "js",
          "code": "function canMakeWord(word) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function canMakeWord(word) {\n  const characters = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM';\n  const blocks = characters.split(' ').map(pair => pair.split(''));\n\n  const letters = [...word.toUpperCase()];\n  let length = letters.length;\n  const copy = new Set(blocks);\n\n  letters.forEach(letter => {\n    for (let block of copy) {\n      const index = block.indexOf(letter);\n\n      if (index !== -1) {\n        length--;\n        copy.delete(block);\n        break;\n      }\n    }\n  });\n  return !length;\n}"
        }
      ],
      "tests": [
        {
          "text": "`canMakeWord` should be a function.",
          "testCode": "assert(typeof canMakeWord === 'function');"
        },
        {
          "text": "`canMakeWord` should return a boolean.",
          "testCode": "assert(typeof canMakeWord('hi') === 'boolean');"
        },
        {
          "text": "`canMakeWord(\"bark\")` should return true.",
          "testCode": "assert(canMakeWord(words[0]));"
        },
        {
          "text": "`canMakeWord(\"BooK\")` should return false.",
          "testCode": "assert(!canMakeWord(words[1]));"
        },
        {
          "text": "`canMakeWord(\"TReAT\")` should return true.",
          "testCode": "assert(canMakeWord(words[2]));"
        },
        {
          "text": "`canMakeWord(\"COMMON\")` should return false.",
          "testCode": "assert(!canMakeWord(words[3]));"
        },
        {
          "text": "`canMakeWord(\"squAD\")` should return true.",
          "testCode": "assert(canMakeWord(words[4]));"
        },
        {
          "text": "`canMakeWord(\"conFUSE\")` should return true.",
          "testCode": "assert(canMakeWord(words[5]));"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302220,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\abc-problem.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const words = ['bark', 'BooK', 'TReAT', 'COMMON', 'squAD', 'conFUSE'];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339acd",
      "title": "Abundant, deficient and perfect number classifications",
      "challengeType": 1,
      "dashedName": "abundant-deficient-and-perfect-number-classifications",
      "description": "These define three classifications of positive integers based on their proper divisors.\n\nLet $P(n)$ be the sum of the proper divisors of `n` where proper divisors are all positive integers `n` other than `n` itself.\n\nIf `P(n) < n` then `n` is classed as `deficient`\n\nIf `P(n) === n` then `n` is classed as `perfect`\n\nIf `P(n) > n` then `n` is classed as `abundant`\n\n**Example**: `6` has proper divisors of `1`, `2`, and `3`. `1 + 2 + 3 = 6`, so `6` is classed as a perfect number.",
      "instructions": "Implement a function that calculates how many of the integers from `1` to `num` (inclusive) are in each of the three classes. Output the result as an array in the following format `[deficient, perfect, abundant]`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function getDPA(num) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function getDPA(num) {\n  const dpa = [1, 0, 0];\n  for (let n = 2; n <= num; n += 1) {\n    let ds = 1;\n    const e = Math.sqrt(n);\n    for (let d = 2; d < e; d += 1) {\n      if (n % d === 0) {\n        ds += d + (n / d);\n      }\n    }\n    if (n % e === 0) {\n      ds += e;\n    }\n    dpa[ds < n ? 0 : ds === n ? 1 : 2] += 1;\n  }\n  return dpa;\n}"
        }
      ],
      "tests": [
        {
          "text": "`getDPA` should be a function.",
          "testCode": "assert(typeof getDPA === 'function');"
        },
        {
          "text": "`getDPA(5000)` should return an array.",
          "testCode": "assert(Array.isArray(getDPA(5000)));"
        },
        {
          "text": "`getDPA(5000)` return array should have a length of `3`.",
          "testCode": "assert(getDPA(5000).length === 3);"
        },
        {
          "text": "`getDPA(5000)` should return `[3758, 3, 1239]`.",
          "testCode": "assert.deepEqual(getDPA(5000), [3758, 3, 1239]);"
        },
        {
          "text": "`getDPA(10000)` should return `[7508, 4, 2488]`.",
          "testCode": "assert.deepEqual(getDPA(10000), [7508, 4, 2488]);"
        },
        {
          "text": "`getDPA(20000)` should return `[15043, 4, 4953]`.",
          "testCode": "assert.deepEqual(getDPA(20000), [15043, 4, 4953]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302221,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\abundant-deficient-and-perfect-number-classifications.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ace",
      "title": "Accumulator factory",
      "challengeType": 1,
      "dashedName": "accumulator-factory",
      "description": "A problem posed by Paul Graham is that of creating a function that takes a single (numeric) argument and which returns another function that is an accumulator. The returned accumulator function in turn also takes a single numeric argument, and returns the sum of all the numeric values passed in so far to that accumulator (including the initial value passed when the accumulator was created).",
      "instructions": "Create a function that takes a number $n$ and generates accumulator functions that return the sum of every number ever passed to them.\n\n**Rules:**\n\nDo not use global variables.\n\n**Hint:**\n\nClosures save outer state.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function accumulator(sum) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function accumulator(sum) {\n  return function(n) {\n    return sum += n;\n  };\n}"
        }
      ],
      "tests": [
        {
          "text": "`accumulator` should be a function.",
          "testCode": "assert(typeof accumulator === 'function');"
        },
        {
          "text": "`accumulator(0)` should return a function.",
          "testCode": "assert(typeof accumulator(0) === 'function');"
        },
        {
          "text": "`accumulator(0)(2)` should return a number.",
          "testCode": "assert(typeof accumulator(0)(2) === 'number');"
        },
        {
          "text": "Passing in the values 3, -4, 1.5, and 5 should return 5.5.",
          "testCode": "assert(testFn(5) === 5.5);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302222,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\accumulator-factory.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testFn = typeof accumulator(3) === 'function' && accumulator(3);\nif (testFn) {\n  testFn(-4);\n  testFn(1.5);\n}"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339acf",
      "title": "Ackermann function",
      "challengeType": 1,
      "dashedName": "ackermann-function",
      "description": "The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree.\n\nThe Ackermann function is usually defined as follows:\n\n$A(m, n) = \\\\begin{cases} n+1 & \\\\mbox{if } m = 0 \\\\\\\\ A(m-1, 1) & \\\\mbox{if } m > 0 \\\\mbox{ and } n = 0 \\\\\\\\ A(m-1, A(m, n-1)) & \\\\mbox{if } m > 0 \\\\mbox{ and } n > 0. \\\\end{cases}$\n\nIts arguments are never negative and it always terminates.",
      "instructions": "Write a function which returns the value of $A(m, n)$. Arbitrary precision is preferred (since the function grows so quickly), but not required.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function ack(m, n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function ack(m, n) {\n  return m === 0 ? n + 1 : ack(m - 1, n === 0 ? 1 : ack(m, n - 1));\n}"
        }
      ],
      "tests": [
        {
          "text": "`ack` should be a function.",
          "testCode": "assert(typeof ack === 'function');"
        },
        {
          "text": "`ack(0, 0)` should return 1.",
          "testCode": "assert(ack(0, 0) === 1);"
        },
        {
          "text": "`ack(1, 1)` should return 3.",
          "testCode": "assert(ack(1, 1) === 3);"
        },
        {
          "text": "`ack(2, 5)` should return 13.",
          "testCode": "assert(ack(2, 5) === 13);"
        },
        {
          "text": "`ack(3, 3)` should return 61.",
          "testCode": "assert(ack(3, 3) === 61);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302223,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\ackermann-function.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad0",
      "title": "Align columns",
      "challengeType": 1,
      "dashedName": "align-columns",
      "description": "Given an array of many lines, where fields within a line are delineated by a single `$` character, write a program that aligns each column of fields by ensuring that words in each column are separated by at least one space. Further, allow for each word in a column to be either left justified, right justified, or center justified within its column.",
      "instructions": "Use the following text to test your programs:\n\n```js\nconst testText = [\n  'Given$a$text$file$of$many$lines',\n  'where$fields$within$a$line$',\n  'are$delineated$by$a$single$\"dollar\"$character',\n  'write$a$program',\n  'that$aligns$each$column$of$fields',\n  'by$ensuring$that$words$in$each$',\n  'column$are$separated$by$at$least$one$space.',\n  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',\n  'justified,$right$justified',\n  'or$center$justified$within$its$column.'\n];\n```\n\n**Note that:**\n\n- The example input texts lines may, or may not, have trailing dollar characters.\n- All columns should share the same alignment.\n- Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.\n- Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal. Lines in it should be joined using new line character (`\\n`).\n- The minimum space between columns should be computed from the text and not hard-coded.\n- It is not a requirement to add separating characters between or around columns.\n\nFor example, one of the lines from the `testText`, after justifying to the right, left and center respectively:\n\n```js\n'    column        are separated     by     at    least       one space.\\n'\n'column     are        separated by     at     least    one       space.\\n'\n'  column      are     separated   by     at    least      one    space.\\n'\n```",
      "boilerplate": [
        {
          "language": "js",
          "code": "function formatText(input, justification) {\n\n}\n\nconst testText = [\n  'Given$a$text$file$of$many$lines',\n  'where$fields$within$a$line$',\n  'are$delineated$by$a$single$\"dollar\"$character',\n  'write$a$program',\n  'that$aligns$each$column$of$fields$',\n  'by$ensuring$that$words$in$each$',\n  'column$are$separated$by$at$least$one$space.',\n  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',\n  'justified,$right$justified',\n  'or$center$justified$within$its$column.'\n];"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "String.prototype.repeat = function (n) { return new Array(1 + parseInt(n)).join(this); };\n\nfunction formatText(input, justification) {\n  let x, y, max, cols = 0, diff, left, right;\n  for (x = 0; x < input.length; x++) {\n    input[x] = input[x].split('$');\n    if (input[x].length > cols) {\n      cols = input[x].length;\n    }\n  }\n  for (x = 0; x < cols; x++) {\n    max = 0;\n    for (y = 0; y < input.length; y++) {\n      if (input[y][x] && max < input[y][x].length) {\n        max = input[y][x].length;\n      }\n    }\n    for (y = 0; y < input.length; y++) {\n      if (input[y][x]) {\n        diff = (max - input[y][x].length) / 2;\n        left = ' '.repeat(Math.floor(diff));\n        right = ' '.repeat(Math.ceil(diff));\n        if (justification === 'left') {\n          right += left; left = '';\n        }\n        if (justification === 'right') {\n          left += right; right = '';\n        }\n        input[y][x] = left + input[y][x] + right;\n      }\n    }\n  }\n  for (x = 0; x < input.length; x++) {\n    input[x] = input[x].join(' ');\n  }\n  input = input.join('\\n');\n  return input;\n}"
        }
      ],
      "tests": [
        {
          "text": "`formatText` should be a function.",
          "testCode": "assert(typeof formatText === 'function');"
        },
        {
          "text": "`formatText(testText, 'right')` should produce text with columns justified to the right.",
          "testCode": "assert.strictEqual(formatText(_testText, 'right'), rightAligned);"
        },
        {
          "text": "`formatText(testText, 'left')` should produce text with columns justified to the left.",
          "testCode": "assert.strictEqual(formatText(_testText, 'left'), leftAligned);"
        },
        {
          "text": "`formatText(testText, 'center')` should produce text with columns justified to the center.",
          "testCode": "assert.strictEqual(formatText(_testText, 'center'), centerAligned);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302224,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\align-columns.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const _testText = [\n  'Given$a$text$file$of$many$lines',\n  'where$fields$within$a$line$',\n  'are$delineated$by$a$single$\"dollar\"$character',\n  'write$a$program',\n  'that$aligns$each$column$of$fields$',\n  'by$ensuring$that$words$in$each$',\n  'column$are$separated$by$at$least$one$space.',\n  'Further,$allow$for$each$word$in$a$column$to$be$either$left$',\n  'justified,$right$justified',\n  'or$center$justified$within$its$column.'\n];\n\nconst rightAligned = '     Given          a      text   file     of     many     lines\\n' +\n'     where     fields    within      a   line \\n' +\n'       are delineated        by      a single \"dollar\" character\\n' +\n'     write          a   program\\n' +\n'      that     aligns      each column     of   fields \\n' +\n'        by   ensuring      that  words     in     each \\n' +\n'    column        are separated     by     at    least       one space.\\n' +\n'  Further,      allow       for   each   word       in         a column to be either left \\n' +\n'justified,      right justified\\n' +\n'        or     center justified within    its  column.';\n\nconst leftAligned = 'Given      a          text      file   of     many     lines    \\n' +\n'where      fields     within    a      line   \\n' +\n'are        delineated by        a      single \"dollar\" character\\n' +\n'write      a          program  \\n' +\n'that       aligns     each      column of     fields   \\n' +\n'by         ensuring   that      words  in     each     \\n' +\n'column     are        separated by     at     least    one       space.\\n' +\n'Further,   allow      for       each   word   in       a         column to be either left \\n' +\n'justified, right      justified\\n' +\n'or         center     justified within its    column. ';\n\nconst centerAligned = '  Given        a        text     file    of     many     lines  \\n' +\n'  where      fields    within     a     line  \\n' +\n'   are     delineated    by       a    single \\\"dollar\\\" character\\n' +\n'  write        a       program \\n' +\n'   that      aligns     each    column   of    fields  \\n' +\n'    by      ensuring    that    words    in     each   \\n' +\n'  column      are     separated   by     at    least      one    space.\\n' +\n' Further,    allow       for     each   word     in        a     column to be either left \\n' +\n'justified,   right    justified\\n' +\n'    or       center   justified within  its   column. ';"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5949b579404977fbaefcd737",
      "title": "Amicable pairs",
      "challengeType": 1,
      "dashedName": "amicable-pairs",
      "description": "Two integers $N$ and $M$ are said to be amicable pairs if $N \\\\neq M$ and the sum of the proper divisors of $N$ ($\\\\mathrm{sum}(\\\\mathrm{propDivs}(N))$) $= M$ as well as $\\\\mathrm{sum}(\\\\mathrm{propDivs}(M)) = N$.\n\n**Example:**\n\n**1184** and **1210** are an amicable pair, with proper divisors:\n\n<ul>\n  <li>1, 2, 4, 8, 16, 32, 37, 74, 148, 296, 592 and</li>\n  <li>1, 2, 5, 10, 11, 22, 55, 110, 121, 242, 605 respectively.</li>\n</ul>\n\nThe sum of the divisors for the first value, **1184**, is **1210** and the sum of the divisors for the second value, **1210**, is **1184**.",
      "instructions": "Calculate and show here the Amicable pairs below 20,000 (there are eight).",
      "boilerplate": [
        {
          "language": "js",
          "code": "function amicablePairsUpTo(maxNum) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// amicablePairsUpTo :: Int -> [(Int, Int)]\nfunction amicablePairsUpTo(maxNum) {\n  return range(1, maxNum)\n    .map(x => properDivisors(x)\n      .reduce((a, b) => a + b, 0))\n    .reduce((a, m, i, lst) => {\n      const n = i + 1;\n\n      return (m > n) && lst[m - 1] === n ?\n        a.concat([\n          [n, m]\n        ]) : a;\n    }, []);\n}\n\n// properDivisors :: Int -> [Int]\nfunction properDivisors(n) {\n  if (n < 2) return [];\n\n  const rRoot = Math.sqrt(n);\n  const intRoot = Math.floor(rRoot);\n  const blnPerfectSquare = rRoot === intRoot;\n  const lows = range(1, intRoot)\n  .filter(x => (n % x) === 0);\n\n  return lows.concat(lows.slice(1)\n    .map(x => n / x)\n    .reverse()\n    .slice(blnPerfectSquare | 0));\n}\n\n// Int -> Int -> Maybe Int -> [Int]\nfunction range(m, n, step) {\n  const d = (step || 1) * (n >= m ? 1 : -1);\n\n  return Array.from({\n    length: Math.floor((n - m) / d) + 1\n  }, (_, i) => m + (i * d));\n}"
        }
      ],
      "tests": [
        {
          "text": "`amicablePairsUpTo` should be a function.",
          "testCode": "assert(typeof amicablePairsUpTo === 'function');"
        },
        {
          "text": "`amicablePairsUpTo(300)` should return `[[220,284]]`.",
          "testCode": "assert.deepEqual(amicablePairsUpTo(300), answer300);"
        },
        {
          "text": "`amicablePairsUpTo(3000)` should return `[[220,284],[1184,1210],[2620,2924]]`.",
          "testCode": "assert.deepEqual(amicablePairsUpTo(3000), answer3000);"
        },
        {
          "text": "`amicablePairsUpTo(20000)` should return `[[220,284],[1184,1210],[2620,2924],[5020,5564],[6232,6368],[10744,10856],[12285,14595],[17296,18416]]`.",
          "testCode": "assert.deepEqual(amicablePairsUpTo(20000), answer20000);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302225,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\amicable-pairs.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const answer300 = [[220, 284]];\nconst answer3000 = [\n  [220, 284],\n  [1184, 1210],\n  [2620, 2924]\n];\nconst answer20000 = [\n  [220, 284],\n  [1184, 1210],\n  [2620, 2924],\n  [5020, 5564],\n  [6232, 6368],\n  [10744, 10856],\n  [12285, 14595],\n  [17296, 18416]\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594d8d0ab97724821379b1e6",
      "title": "Averages/Mode",
      "challengeType": 1,
      "dashedName": "averagesmode",
      "description": "Write a function `mode` to find the value that appears most in an array.\n\nThe case where the collection is empty may be ignored. Care must be taken to handle the case where the mode is non-unique.\n\nIf it is not appropriate or possible to support a general collection, use a vector (array), if possible. If it is not appropriate or possible to support an unspecified value type, use integers.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function mode(arr) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function mode(arr) {\n  const counter = {};\n  let result = [];\n  let max = 0;\n  // for (const i in arr) {\n  arr.forEach(el => {\n    if (!(el in counter)) {\n      counter[el] = 0;\n    }\n    counter[el]++;\n\n    if (counter[el] === max) {\n      result.push(el);\n    }\n    else if (counter[el] > max) {\n      max = counter[el];\n      result = [el];\n    }\n  });\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`mode` should be a function.",
          "testCode": "assert(typeof mode === 'function');"
        },
        {
          "text": "`mode([1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17])` should equal `[6]`",
          "testCode": "assert.deepEqual(mode(arr1), [6]);"
        },
        {
          "text": "`mode([1, 2, 4, 4, 1])` should equal `[1, 4]`.",
          "testCode": "assert.deepEqual(mode(arr2).sort(), [1, 4]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302226,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\averages-mode.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const arr1 = [1, 3, 6, 6, 6, 6, 7, 7, 12, 12, 17];\nconst arr2 = [1, 2, 4, 4, 1];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594d966a1467eb84194f0086",
      "title": "Averages/Pythagorean means",
      "challengeType": 1,
      "dashedName": "averagespythagorean-means",
      "description": "Compute all three of the <a href=\"https://en.wikipedia.org/wiki/Pythagorean_means\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Pythagorean means</a> of the set of integers $1$ through $10$ (inclusive).\n\nShow that $A(x_1,\\\\ldots,x_n) \\\\geq G(x_1,\\\\ldots,x_n) \\\\geq H(x_1,\\\\ldots,x_n)$ for this set of positive integers.\n\n<ul>\n  <li>The most common of the three means, the <a class='rosetta__link--rosetta' href='https://rosettacode.org/wiki/Averages/Arithmetic mean' title='Averages/Arithmetic mean' target='_blank'>arithmetic mean</a>, is the sum of the list divided by its length:<br>\n  <big>$ A(x_1, \\ldots, x_n) = \\frac{x_1 + \\cdots + x_n}{n}$</big></li>\n  <li>The <a class='rosetta__link--wiki' href='https://en.wikipedia.org/wiki/Geometric mean' title='wp: Geometric mean' target='_blank'>geometric mean</a> is the $n$th root of the product of the list:<br>\n  <big>$ G(x_1, \\ldots, x_n) = \\sqrt[n]{x_1 \\cdots x_n} $</big></li>\n  <li>The <a class='rosetta__link--wiki' href='https://en.wikipedia.org/wiki/Harmonic mean' title='wp: Harmonic mean' target='_blank'>harmonic mean</a> is $n$ divided by the sum of the reciprocal of each item in the list:<br>\n  <big>$ H(x_1, \\ldots, x_n) = \\frac{n}{\\frac{1}{x_1} + \\cdots + \\frac{1}{x_n}} $</big></li>\n</ul>",
      "instructions": "When writing your function, assume the input is an ordered array of all-inclusive numbers.\n\nFor the answer, please output an object in the following format:\n\n```js\n{\n  values: {\n    Arithmetic: 5.5,\n    Geometric: 4.528728688116765,\n    Harmonic: 3.414171521474055\n  },\n  test: 'is A >= G >= H ? yes'\n}\n```",
      "boilerplate": [
        {
          "language": "js",
          "code": "function pythagoreanMeans(rangeArr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function pythagoreanMeans(rangeArr) {\n  // arithmeticMean :: [Number] -> Number\n  const arithmeticMean = xs =>\n    foldl((sum, n) => sum + n, 0, xs) / length(xs);\n\n  // geometricMean :: [Number] -> Number\n  const geometricMean = xs =>\n    raise(foldl((product, x) => product * x, 1, xs), 1 / length(xs));\n\n  // harmonicMean :: [Number] -> Number\n  const harmonicMean = xs =>\n    length(xs) / foldl((invSum, n) => invSum + (1 / n), 0, xs);\n\n  // GENERIC FUNCTIONS ------------------------------------------------------\n\n  // A list of functions applied to a list of arguments\n  // <*> :: [(a -> b)] -> [a] -> [b]\n  const ap = (fs, xs) => //\n    Array.prototype.concat(...fs.map(f => //\n      Array.prototype.concat(...xs.map(x => [f(x)]))));\n\n  // foldl :: (b -> a -> b) -> b -> [a] -> b\n  const foldl = (f, a, xs) => xs.reduce(f, a);\n\n  // length :: [a] -> Int\n  const length = xs => xs.length;\n\n  // mapFromList :: [(k, v)] -> Dictionary\n  const mapFromList = kvs =>\n    foldl((a, [k, v]) =>\n      (a[(typeof k === 'string' && k)] = v, a), {}, kvs);\n\n  // raise :: Num -> Int -> Num\n  const raise = (n, e) => Math.pow(n, e);\n/*\n  // show :: a -> String\n  // show :: a -> Int -> String\n  const show = (...x) =>\n    JSON.stringify.apply(\n      null, x.length > 1 ? [x[0], null, x[1]] : x\n    );\n*/\n  // zip :: [a] -> [b] -> [(a,b)]\n  const zip = (xs, ys) =>\n    xs.slice(0, Math.min(xs.length, ys.length))\n      .map((x, i) => [x, ys[i]]);\n\n  // TEST -------------------------------------------------------------------\n  // mean :: Dictionary\n  const mean = mapFromList(zip(\n    ['Arithmetic', 'Geometric', 'Harmonic'],\n    ap([arithmeticMean, geometricMean, harmonicMean], [\n      rangeArr\n    ])\n  ));\n\n  return {\n    values: mean,\n    test: `is A >= G >= H ? ${mean.Arithmetic >= mean.Geometric &&\n      mean.Geometric >= mean.Harmonic ? 'yes' : 'no'}`\n  };\n}"
        }
      ],
      "tests": [
        {
          "text": "`pythagoreanMeans` should be a function.",
          "testCode": "assert(typeof pythagoreanMeans === 'function');"
        },
        {
          "text": "`pythagoreanMeans([1, 2, ..., 10])` should equal the same output above.",
          "testCode": "assert.deepEqual(pythagoreanMeans(range1), answer1);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302227,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\averages-pythagorean-means.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const range1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst answer1 = {\n  values: {\n    Arithmetic: 5.5,\n    Geometric: 4.528728688116765,\n    Harmonic: 3.414171521474055\n  },\n  test: 'is A >= G >= H ? yes'\n};"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594da033de4190850b893874",
      "title": "Averages/Root mean square",
      "challengeType": 1,
      "dashedName": "averagesroot-mean-square",
      "description": "Compute the Root Mean Square (RMS) of the numbers 1 through 10 inclusive.\n\nThe <abbr title=\"Root mean square\">RMS</abbr> is calculated by taking the square root of the mean of the squares of the numbers, given by the equation:\n\n$$x\\_{\\\\mathrm{rms}} = \\\\sqrt {{{x_1}^2 + {x_2}^2 + \\\\cdots + {x_n}^2} \\\\over n}. $$",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function rms(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function rms(arr) {\n  const sumOfSquares = arr.reduce((s, x) => s + x * x, 0);\n  return Math.sqrt(sumOfSquares / arr.length);\n}"
        }
      ],
      "tests": [
        {
          "text": "`rms` should be a function.",
          "testCode": "assert(typeof rms === 'function');"
        },
        {
          "text": "`rms([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])` should equal `6.2048368229954285`.",
          "testCode": "assert.equal(rms(arr1), answer1);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302228,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\averages-root-mean-square.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const arr1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\nconst answer1 = 6.2048368229954285;"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594db4d0dedb4c06a2a4cefd",
      "title": "Babbage problem",
      "challengeType": 1,
      "dashedName": "babbage-problem",
      "description": "Charles Babbage, looking ahead to the sorts of problems his Analytical Engine would be able to solve, gave this example:\n\n<blockquote>\n  What is the smallest positive integer whose square ends in the digits 269,696?\n  <footer style='margin-left: 2em;'>Babbage, letter to Lord Bowden, 1837; see Hollingdale and Tootill, <i>Electronic Computers</i>, second edition, 1970, p. 125.</footer>\n</blockquote>\n\nHe thought the answer might be 99,736, whose square is 9,947,269,696; but he couldn't be certain.\n\nThe task is to find out if Babbage had the right answer.",
      "instructions": "Implement a function to return the lowest integer that satisfies the Babbage problem. If Babbage was right, return Babbage's number.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function babbage(babbageNum, endDigits) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function babbage(babbageAns, endDigits) {\n  const babbageNum = Math.pow(babbageAns, 2);\n  const babbageStartDigits = parseInt(babbageNum.toString().replace('269696', ''));\n  let answer = 99736;\n\n  // count down from this answer and save any sqrt int result. return lowest one\n  for (let i = babbageStartDigits; i >= 0; i--) {\n    const num = parseInt(i.toString().concat('269696'));\n    const result = Math.sqrt(num);\n    if (result === Math.floor(Math.sqrt(num))) {\n      answer = result;\n    }\n  }\n\n  return answer;\n}"
        }
      ],
      "tests": [
        {
          "text": "`babbage` should be a function.",
          "testCode": "assert(typeof babbage === 'function');"
        },
        {
          "text": "`babbage(99736, 269696)` should not return 99736 (there is a smaller answer).",
          "testCode": "assert.equal(babbage(babbageAns, endDigits), answer);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302229,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\babbage-problem.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const babbageAns = 99736;\nconst endDigits = 269696;\nconst answer = 25264;"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594dc6c729e5700999302b45",
      "title": "Balanced brackets",
      "challengeType": 1,
      "dashedName": "balanced-brackets",
      "description": "Determine whether a generated string of brackets is balanced; that is, whether it consists entirely of pairs of opening/closing brackets (in that order), none of which mis-nest.\n\n**Examples:**\n| Input                     | Output |\n| ------------------------- | ------ |\n| <code>\\[]</code>          | true   |\n| <code>]\\[</code>          | false  |\n| <code>[][]</code>         | true   |\n| <code>]\\[]</code>         | false  |\n| <code>\\[]]\\[\\[]</code>    | false  |\n| <code>\\[\\[\\[\\[]]]]</code> | true   |",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isBalanced(str) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isBalanced(str) {\n  if (str === '') return true;\n  let a = str;\n  let b;\n  do {\n    b = a;\n    a = a.replace(/\\[\\]/g, '');\n  } while (a !== b);\n  return !a;\n}"
        }
      ],
      "tests": [
        {
          "text": "`isBalanced` should be a function.",
          "testCode": "assert(typeof isBalanced === 'function');"
        },
        {
          "text": "`isBalanced(\"[]\")` should return true.",
          "testCode": "assert(isBalanced(testCases[0]));"
        },
        {
          "text": "`isBalanced(\"]][[[][][][]][\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[1]));"
        },
        {
          "text": "`isBalanced(\"[][[[[][][[[]]]]]]\")` should return true.",
          "testCode": "assert(isBalanced(testCases[2]));"
        },
        {
          "text": "`isBalanced(\"][\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[3]));"
        },
        {
          "text": "`isBalanced(\"[[[]]]][[]\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[4]));"
        },
        {
          "text": "`isBalanced(\"][[]\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[5]));"
        },
        {
          "text": "`isBalanced(\"][[][]][[[]]\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[6]));"
        },
        {
          "text": "`isBalanced(\"[[][]]][\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[7]));"
        },
        {
          "text": "`isBalanced(\"[[[]]][[]]]][][[\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[8]));"
        },
        {
          "text": "`isBalanced(\"[]][[]]][[[[][]]\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[9]));"
        },
        {
          "text": "`isBalanced(\"][]][[][\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[10]));"
        },
        {
          "text": "`isBalanced(\"[[]][[][]]\")` should return true.",
          "testCode": "assert(isBalanced(testCases[11]));"
        },
        {
          "text": "`isBalanced(\"[[]]\")` should return true.",
          "testCode": "assert(isBalanced(testCases[12]));"
        },
        {
          "text": "`isBalanced(\"]][]][[]][[[\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[13]));"
        },
        {
          "text": "`isBalanced(\"][]][][[\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[14]));"
        },
        {
          "text": "`isBalanced(\"][][\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[15]));"
        },
        {
          "text": "`isBalanced(\"[]]]\")` should return false.",
          "testCode": "assert(!isBalanced(testCases[16]));"
        },
        {
          "text": "`isBalanced(\"\")` should return true.",
          "testCode": "assert(isBalanced(testCases[17]));"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302230,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\balanced-brackets.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases = [\n  '[]',\n  ']][[[][][][]][',\n  '[][[[[][][[[]]]]]]',\n  '][',\n  '[[[]]]][[]',\n  '][[]',\n  '][[][]][[[]]',\n  '[[][]]][',\n  '[[[]]][[]]]][][[',\n  '[]][[]]][[[[][]]',\n  '][]][[][',\n  '[[]][[][]]',\n  '[[]]',\n  ']][]][[]][[[',\n  '][]][][[',\n  '][][',\n  '[]]]',\n  ''\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5951815dd895584b06884620",
      "title": "Circles of given radius through two points",
      "challengeType": 1,
      "dashedName": "circles-of-given-radius-through-two-points",
      "description": "Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points.\n\n**Exceptions:**\n\n<ul>\n  <li>A radius of zero should be treated as never describing circles (except in the case where the points are coincident).</li>\n  <li>If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless the radius is equal to zero as well which then collapses the circles to a point.</li>\n  <li>If the points form a diameter then return a single circle.</li>\n  <li>If the points are too far apart then no circles can be drawn.</li>\n</ul>",
      "instructions": "Implement a function that takes two points and a radius and returns the two circles through those points. For each resulting circle, provide the coordinates for the center of each circle rounded to four decimal digits. Return each coordinate as an array, and coordinates as an array of arrays.\n\n**For edge cases, return the following:**\n\n<ul>\n  <li>If points are on the diameter, return one point. If the radius is also zero however, return <code>\"Radius Zero\"</code>.</li>\n  <li>If points are coincident, return <code>\"Coincident point. Infinite solutions\"</code>.</li>\n  <li>If points are farther apart than the diameter, return <code>\"No intersection. Points further apart than circle diameter\"</code>.</li>\n</ul>\n\n**Sample inputs:**\n\n<pre>      p1                p2           r\n0.1234, 0.9876    0.8765, 0.2345    2.0\n0.0000, 2.0000    0.0000, 0.0000    1.0\n0.1234, 0.9876    0.1234, 0.9876    2.0\n0.1234, 0.9876    0.8765, 0.2345    0.5\n0.1234, 0.9876    0.1234, 0.9876    0.0\n</pre>",
      "boilerplate": [
        {
          "language": "js",
          "code": "function getCircles(...args) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "const hDist = (p1, p2) => Math.hypot(...p1.map((e, i) => e - p2[i])) / 2;\nconst pAng = (p1, p2) => Math.atan(p1.map((e, i) => e - p2[i]).reduce((p, c) => c / p, 1));\nconst solveF = (p, r) => t => [parseFloat((r * Math.cos(t) + p[0]).toFixed(4)), parseFloat((r * Math.sin(t) + p[1]).toFixed(4))];\nconst diamPoints = (p1, p2) => p1.map((e, i) => parseFloat((e + (p2[i] - e) / 2).toFixed(4)));\n\nfunction getCircles(...args) {\n  const [p1, p2, s] = args;\n  const solve = solveF(p1, s);\n  const halfDist = hDist(p1, p2);\n\n  let msg = [];\n  switch (Math.sign(s - halfDist)) {\n    case 0:\n      msg = s ? diamPoints(p1, p2) :\n        'Radius Zero';\n      break;\n    case 1:\n      if (!halfDist) {\n        msg = 'Coincident point. Infinite solutions';\n      }\n      else {\n        const theta = pAng(p1, p2);\n        const theta2 = Math.acos(halfDist / s);\n        [1, -1].map(e => solve(theta + e * theta2)).forEach(\n          e => msg.push(e));\n      }\n      break;\n    case -1:\n      msg = 'No intersection. Points further apart than circle diameter';\n      break;\n    default:\n      msg = 'Reached the default';\n  }\n  return msg;\n}"
        }
      ],
      "tests": [
        {
          "text": "`getCircles` should be a function.",
          "testCode": "assert(typeof getCircles === 'function');"
        },
        {
          "text": "`getCircles([0.1234, 0.9876], [0.8765, 0.2345], 2.0)` should return `[[1.8631, 1.9742], [-0.8632, -0.7521]]`.",
          "testCode": "assert.deepEqual(getCircles(...testCases[0]), answers[0]);"
        },
        {
          "text": "`getCircles([0.0000, 2.0000], [0.0000, 0.0000], 1.0)` should return `[0, 1]`",
          "testCode": "assert.deepEqual(getCircles(...testCases[1]), answers[1]);"
        },
        {
          "text": "`getCircles([0.1234, 0.9876], [0.1234, 0.9876], 2.0)` should return `Coincident point. Infinite solutions`",
          "testCode": "assert.deepEqual(getCircles(...testCases[2]), answers[2]);"
        },
        {
          "text": "`getCircles([0.1234, 0.9876], [0.8765, 0.2345], 0.5)` should return `No intersection. Points further apart than circle diameter`",
          "testCode": "assert.deepEqual(getCircles(...testCases[3]), answers[3]);"
        },
        {
          "text": "`getCircles([0.1234, 0.9876], [0.1234, 0.9876], 0.0)` should return `Radius Zero`",
          "testCode": "assert.deepEqual(getCircles(...testCases[4]), answers[4]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302231,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\circles-of-given-radius-through-two-points.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases = [\n  [[0.1234, 0.9876], [0.8765, 0.2345], 2.0],\n  [[0.0000, 2.0000], [0.0000, 0.0000], 1.0],\n  [[0.1234, 0.9876], [0.1234, 0.9876], 2.0],\n  [[0.1234, 0.9876], [0.8765, 0.2345], 0.5],\n  [[0.1234, 0.9876], [0.1234, 0.9876], 0.0]\n];\nconst answers = [\n  [[1.8631, 1.9742], [-0.8632, -0.7521]],\n  [0, 1],\n  'Coincident point. Infinite solutions',\n  'No intersection. Points further apart than circle diameter',\n  'Radius Zero'\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5951a53863c8a34f02bf1bdc",
      "title": "Closest-pair problem",
      "challengeType": 1,
      "dashedName": "closest-pair-problem",
      "description": "Provide a function to find the closest two points among a set of given points in two dimensions.\n\nThe straightforward solution is a $O(n^2)$ algorithm (which we can call *brute-force algorithm*); the pseudo-code (using indexes) could be simply:\n\n<pre><strong>bruteForceClosestPair</strong> of P(1), P(2), ... P(N)\n<strong>if</strong> N &#x3C; 2 <strong>then</strong>\n  <strong>return</strong> ∞\n<strong>else</strong>\n  minDistance ← |P(1) - P(2)|\n  minPoints ← { P(1), P(2) }\n  <strong>foreach</strong> i ∈ [1, N-1]\n    <strong>foreach</strong> j ∈ [i+1, N]\n      <strong>if</strong> |P(i) - P(j)| &#x3C; minDistance <strong>then</strong>\n        minDistance ← |P(i) - P(j)|\n        minPoints ← { P(i), P(j) }\n      <strong>endif</strong>\n    <strong>endfor</strong>\n  <strong>endfor</strong>\n  <strong>return</strong> minDistance, minPoints\n<strong>endif</strong>\n</pre>\n\nA better algorithm is based on the recursive divide and conquer approach, which is $O(n\\log n)$ a pseudo-code could be:\n\n<pre><strong>closestPair</strong> of (xP, yP)\n  where xP is P(1) .. P(N) sorted by x coordinate, and\n  yP is P(1) .. P(N) sorted by y coordinate (ascending order)\n<strong>if</strong> N ≤ 3 <strong>then</strong>\n  <strong>return</strong> closest points of xP using brute-force algorithm\n<strong>else</strong>\n  xL ← points of xP from 1 to ⌈N/2⌉\n  xR ← points of xP from ⌈N/2⌉+1 to N\n  xm ← xP(⌈N/2⌉)<sub>x</sub>\n  yL ← { p ∈ yP : p<sub>x</sub> ≤ xm }\n  yR ← { p ∈ yP : p<sub>x</sub> > xm }\n  (dL, pairL) ← closestPair of (xL, yL)\n  (dR, pairR) ← closestPair of (xR, yR)\n  (dmin, pairMin) ← (dR, pairR)\n  <strong>if</strong> dL &#x3C; dR <strong>then</strong>\n    (dmin, pairMin) ← (dL, pairL)\n  <strong>endif</strong>\n  yS ← { p ∈ yP : |xm - p<sub>x</sub>| &#x3C; dmin }\n  nS ← number of points in yS\n  (closest, closestPair) ← (dmin, pairMin)\n  <strong>for</strong> i <strong>from</strong> 1 <strong>to</strong> nS - 1\n    k ← i + 1\n    <strong>while</strong> k ≤ nS <strong>and</strong> yS(k)<sub>y</sub> - yS(i)<sub>y</sub> &#x3C; dmin\n      <strong>if</strong> |yS(k) - yS(i)| &#x3C; closest <strong>then</strong>\n        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})\n      <strong>endif</strong>\n      k ← k + 1\n    <strong>endwhile</strong>\n  <strong>endfor</strong>\n  <strong>return</strong> closest, closestPair\n<strong>endif</strong>\n</pre>\n\nFor the input, expect the argument to be an array of `Point` objects with `x` and `y` members set to numbers. Return an object containing the key:value pairs for `distance` and `pair` (the pair of two closest points).\n\nFor example `getClosestPair` with input array `points`:\n\n```js\nconst points = [\n  new Point(1, 2),\n  new Point(3, 3),\n  new Point(2, 2)\n];\n```\n\nWould return:\n\n```js\n{\n  distance: 1,\n  pair: [\n    {\n      x: 1,\n      y: 2\n    },\n    {\n      x: 2,\n      y: 2\n    }\n  ]\n}\n```\n\n**Note:** Sort the `pair` array by their `x` values in incrementing order.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "const Point = function(x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function() {\n  return this.x;\n};\nPoint.prototype.getY = function() {\n  return this.y;\n};\n\nfunction getClosestPair(pointsArr) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "const Point = function(x, y) {\n  this.x = x;\n  this.y = y;\n};\nPoint.prototype.getX = function() {\n  return this.x;\n};\nPoint.prototype.getY = function() {\n  return this.y;\n};\n\nconst mergeSort = function mergeSort(points, comp) {\n    if(points.length < 2) return points;\n\n    var n = points.length,\n        i = 0,\n        j = 0,\n        leftN = Math.floor(n / 2),\n        rightN = leftN;\n\n    var leftPart = mergeSort( points.slice(0, leftN), comp),\n        rightPart = mergeSort( points.slice(rightN), comp );\n\n    var sortedPart = [];\n\n    while((i < leftPart.length) && (j < rightPart.length)) {\n        if(comp(leftPart[i], rightPart[j]) < 0) {\n            sortedPart.push(leftPart[i]);\n            i += 1;\n        }\n        else {\n            sortedPart.push(rightPart[j]);\n            j += 1;\n        }\n    }\n    while(i < leftPart.length) {\n        sortedPart.push(leftPart[i]);\n        i += 1;\n    }\n    while(j < rightPart.length) {\n        sortedPart.push(rightPart[j]);\n        j += 1;\n    }\n    return sortedPart;\n};\n\nconst closestPair = function _closestPair(Px, Py) {\n    if(Px.length < 2) return { distance: Infinity, pair: [ new Point(0, 0), new Point(0, 0) ] };\n    if(Px.length < 3) {\n        //find euclid distance\n        var d = Math.sqrt( Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2) );\n        return {\n            distance: d,\n            pair: [ Px[0], Px[1] ]\n        };\n    }\n\n    var n = Px.length,\n        leftN = Math.floor(n / 2),\n        rightN = leftN;\n\n    var Xl = Px.slice(0, leftN),\n        Xr = Px.slice(rightN),\n        Xm = Xl[leftN - 1],\n        Yl = [],\n        Yr = [];\n    //separate Py\n    for(var i = 0; i < Py.length; i += 1) {\n        if(Py[i].x <= Xm.x)\n            Yl.push(Py[i]);\n        else\n            Yr.push(Py[i]);\n    }\n\n    var dLeft = _closestPair(Xl, Yl),\n        dRight = _closestPair(Xr, Yr);\n\n    var minDelta = dLeft.distance,\n        closestPair = dLeft.pair;\n    if(dLeft.distance > dRight.distance) {\n        minDelta = dRight.distance;\n        closestPair = dRight.pair;\n    }\n\n    //filter points around Xm within delta (minDelta)\n    var closeY = [];\n    for(i = 0; i < Py.length; i += 1) {\n        if(Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);\n    }\n    //find min within delta. 8 steps max\n    for(i = 0; i < closeY.length; i += 1) {\n        for(var j = i + 1; j < Math.min( (i + 8), closeY.length ); j += 1) {\n            var d = Math.sqrt( Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2) );\n            if(d < minDelta) {\n                minDelta = d;\n                closestPair = [ closeY[i], closeY[j] ]\n            }\n        }\n    }\n\n    return {\n        distance: minDelta,\n        pair: closestPair.sort((pointA, pointB) => pointA.x - pointB.x)\n    };\n};\n\nfunction getClosestPair(points) {\n  const sortX = function(a, b) { return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0); }\n  const sortY = function(a, b) { return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0); }\n\n  const Px = mergeSort(points, sortX);\n  const Py = mergeSort(points, sortY);\n\n  return closestPair(Px, Py);\n}"
        }
      ],
      "tests": [
        {
          "text": "`getClosestPair` should be a function.",
          "testCode": "assert(typeof getClosestPair === 'function');"
        },
        {
          "text": "`getClosestPair(points1).distance` should be `0.0894096443343775`.",
          "testCode": "assert.equal(getClosestPair(points1).distance, answer1.distance);"
        },
        {
          "text": "`getClosestPair(points1).pair` should be `[ { x: 7.46489, y: 4.6268 }, { x: 7.46911, y: 4.71611 } ]`.",
          "testCode": "assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points1))).pair,\n  answer1.pair\n);"
        },
        {
          "text": "`getClosestPair(points2).distance` should be `65.06919393998976`.",
          "testCode": "assert.equal(getClosestPair(points2).distance, answer2.distance);"
        },
        {
          "text": "`getClosestPair(points2).pair` should be `[ { x: 37134, y: 1963 }, { x: 37181, y: 2008 } ]`.",
          "testCode": "assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points2))).pair,\n  answer2.pair\n);"
        },
        {
          "text": "`getClosestPair(points3).distance` should be `6754.625082119658`.",
          "testCode": "assert.equal(getClosestPair(points3).distance, answer3.distance);"
        },
        {
          "text": "`getClosestPair(points3).pair` should be `[ { x: 46817, y: 64975 }, { x: 48953, y: 58567 } ]`.",
          "testCode": "assert.deepEqual(\n  JSON.parse(JSON.stringify(getClosestPair(points3))).pair,\n  answer3.pair\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302232,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\closest-pair-problem.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const points1 = [\n    new Point(0.748501, 4.09624),\n    new Point(3.00302, 5.26164),\n    new Point(3.61878,  9.52232),\n    new Point(7.46911,  4.71611),\n    new Point(5.7819,   2.69367),\n    new Point(2.34709,  8.74782),\n    new Point(2.87169,  5.97774),\n    new Point(6.33101,  0.463131),\n    new Point(7.46489,  4.6268),\n    new Point(1.45428,  0.087596)\n];\n\nconst answer1 = {\n  distance: 0.0894096443343775,\n  pair: [\n    {\n      x: 7.46489,\n      y: 4.6268\n    },\n    {\n      x: 7.46911,\n      y: 4.71611\n    }\n  ]\n};\n\nconst points2 = [\n  new Point(37100, 13118),\n  new Point(37134, 1963),\n  new Point(37181, 2008),\n  new Point(37276, 21611),\n  new Point(37307, 9320)\n];\n\nconst answer2 = {\n  distance: 65.06919393998976,\n  pair: [\n    {\n      x: 37134,\n      y: 1963\n    },\n    {\n      x: 37181,\n      y: 2008\n    }\n  ]\n};\n\nconst points3 = [\n  new Point(16910, 54699),\n  new Point(14773, 61107),\n  new Point(95547, 45344),\n  new Point(95951, 17573),\n  new Point(5824, 41072),\n  new Point(8769, 52562),\n  new Point(21182, 41881),\n  new Point(53226, 45749),\n  new Point(68180, 887),\n  new Point(29322, 44017),\n  new Point(46817, 64975),\n  new Point(10501, 483),\n  new Point(57094, 60703),\n  new Point(23318, 35472),\n  new Point(72452, 88070),\n  new Point(67775, 28659),\n  new Point(19450, 20518),\n  new Point(17314, 26927),\n  new Point(98088, 11164),\n  new Point(25050, 56835),\n  new Point(8364, 6892),\n  new Point(37868, 18382),\n  new Point(23723, 7701),\n  new Point(55767, 11569),\n  new Point(70721, 66707),\n  new Point(31863, 9837),\n  new Point(49358, 30795),\n  new Point(13041, 39744),\n  new Point(59635, 26523),\n  new Point(25859, 1292),\n  new Point(1551, 53890),\n  new Point(70316, 94479),\n  new Point(48549, 86338),\n  new Point(46413, 92747),\n  new Point(27186, 50426),\n  new Point(27591, 22655),\n  new Point(10905, 46153),\n  new Point(40408, 84202),\n  new Point(52821, 73520),\n  new Point(84865, 77388),\n  new Point(99819, 32527),\n  new Point(34404, 75657),\n  new Point(78457, 96615),\n  new Point(42140, 5564),\n  new Point(62175, 92342),\n  new Point(54958, 67112),\n  new Point(4092, 19709),\n  new Point(99415, 60298),\n  new Point(51090, 52158),\n  new Point(48953, 58567)\n];\n\nconst answer3 = {\n  distance: 6754.625082119658,\n  pair: [\n    {\n      x: 46817,\n      y: 64975\n    },\n    {\n      x: 48953,\n      y: 58567\n    }\n  ]\n}"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5958469238c0d8d2632f46db",
      "title": "Combinations",
      "challengeType": 1,
      "dashedName": "combinations",
      "description": "Given non-negative integers `m` and `n`, generate all size `m` combinations of the integers from `0` (zero) to `n-1` in sorted order (each combination is sorted and the entire table is sorted).\n\n**Example:**\n\n`3` comb `5` is:\n\n<pre>0 1 2\n0 1 3\n0 1 4\n0 2 3\n0 2 4\n0 3 4\n1 2 3\n1 2 4\n1 3 4\n2 3 4\n</pre>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function combinations(m, n) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function combinations(m, n) {\n  const nArr = [...Array(n).keys()];\n\n  return (function generateCombinations (size, numArr) {\n    const ret = [];\n\n    for (let i = 0; i < numArr.length; i++) {\n      if (size === 1) {\n        ret.push([numArr[i]]);\n      }\n      else {\n        const sub = generateCombinations(size - 1, numArr.slice(i + 1, numArr.length));\n        for (let subI = 0; subI < sub.length; subI++) {\n          const next = sub[subI];\n          next.unshift(numArr[i]);\n          ret.push(next);\n        }\n      }\n    }\n    return ret;\n  }(m, nArr));\n}"
        }
      ],
      "tests": [
        {
          "text": "`combinations` should be a function.",
          "testCode": "assert(typeof combinations === 'function');"
        },
        {
          "text": "`combinations(3, 5)` should return `[[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]]`.",
          "testCode": "assert.deepEqual(combinations(testInput1[0], testInput1[1]), testOutput1);"
        },
        {
          "text": "`combinations(4, 6)` should return `[[0,1,2,3], [0,1,2,4], [0,1,2,5], [0,1,3,4], [0,1,3,5], [0,1,4,5], [0,2,3,4], [0,2,3,5], [0,2,4,5], [0,3,4,5], [1,2,3,4], [1,2,3,5], [1,2,4,5], [1,3,4,5], [2,3,4,5]]`",
          "testCode": "assert.deepEqual(combinations(testInput2[0], testInput2[1]), testOutput2);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302233,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\combinations.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testInput1 = [3, 5];\nconst testOutput1 = [[0, 1, 2], [0, 1, 3], [0, 1, 4], [0, 2, 3], [0, 2, 4], [0, 3, 4], [1, 2, 3], [1, 2, 4], [1, 3, 4], [2, 3, 4]];\n\nconst testInput2 = [4, 6];\nconst testOutput2 = [[0, 1, 2, 3], [0, 1, 2, 4], [0, 1, 2, 5], [0, 1, 3, 4], [0, 1, 3, 5], [0, 1, 4, 5], [0, 2, 3, 4], [0, 2, 3, 5], [0, 2, 4, 5], [0, 3, 4, 5], [1, 2, 3, 4], [1, 2, 3, 5], [1, 2, 4, 5], [1, 3, 4, 5], [2, 3, 4, 5]];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "596e414344c3b2872167f0fe",
      "title": "Comma quibbling",
      "challengeType": 1,
      "dashedName": "comma-quibbling",
      "description": "<a href=\"https://rosettacode.org/wiki/Comma_quibbling\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Comma quibbling</a> is a task originally set by Eric Lippert in his blog.",
      "instructions": "Write a function to generate a string output which is the concatenation of input words from a list/sequence where:\n\n<ol>\n  <li>An input of no words produces the output string of just the two brace characters (<code>\"{}\"</code>)</li>\n  <li>An input of just one word, e.g. <code>[\"ABC\"]</code>, produces the output string of the word inside the two braces, e.g. <code>\"{ABC}\"</code></li>\n  <li>An input of two words, e.g. <code>[\"ABC\", \"DEF\"]</code>, produces the output string of the two words inside the two braces with the words separated by the string <code>\" and \"</code>, e.g. <code>\"{ABC and DEF}\"</code></li>\n  <li>An input of three or more words, e.g. <code>[\"ABC\", \"DEF\", \"G\", \"H\"]</code>, produces the output string of all but the last word separated by <code>\", \"</code> with the last word separated by <code>\" and \"</code> and all within braces; e.g. <code>\"{ABC, DEF, G and H}\"</code></li>\n</ol>\n\nTest your function with the following series of inputs showing your output here on this page:\n\n<ul>\n  <li>[] # (No input words).</li>\n  <li>[\"ABC\"]</li>\n  <li>[\"ABC\", \"DEF\"]</li>\n  <li>[\"ABC\", \"DEF\", \"G\", \"H\"]</li>\n</ul>\n\n**Note:** Assume words are non-empty strings of uppercase characters for this task.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function quibble(words) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function quibble(words) {\n  return \"{\" +\n    words.slice(0, words.length - 1).join(\", \") +\n   (words.length > 1 ? \" and \" : \"\") +\n   (words[words.length - 1] || '') +\n  \"}\";\n}"
        }
      ],
      "tests": [
        {
          "text": "`quibble` should be a function.",
          "testCode": "assert(typeof quibble === 'function');"
        },
        {
          "text": "`quibble([\"ABC\"])` should return a string.",
          "testCode": "assert(typeof quibble(['ABC']) === 'string');"
        },
        {
          "text": "`quibble([])` should return \"{}\".",
          "testCode": "assert.equal(quibble(testCases[0]), results[0]);"
        },
        {
          "text": "`quibble([\"ABC\"])` should return `\"{ABC}\"`.",
          "testCode": "assert.equal(quibble(testCases[1]), results[1]);"
        },
        {
          "text": "`quibble([\"ABC\", \"DEF\"])` should return `\"{ABC and DEF}\"`.",
          "testCode": "assert.equal(quibble(testCases[2]), results[2]);"
        },
        {
          "text": "`quibble([\"ABC\", \"DEF\", \"G\", \"H\"])` should return `\"{ABC, DEF, G and H}\"`.",
          "testCode": "assert.equal(quibble(testCases[3]), results[3]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302234,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\comma-quibbling.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases = [[], [\"ABC\"], [\"ABC\", \"DEF\"], [\"ABC\", \"DEF\", \"G\", \"H\"]];\nconst results = [\"{}\", \"{ABC}\", \"{ABC and DEF}\", \"{ABC, DEF, G and H}\"];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "596e457071c35c882915b3e4",
      "title": "Compare a list of strings",
      "challengeType": 1,
      "dashedName": "compare-a-list-of-strings",
      "description": "A list is an ordered set of values that may contain duplicates. Here is an example:\n\n```js\nconst list = [['AA',  'BB', 'CC'], ['AA', 'ACB', 'AA'], [], ['AA']];\n````\n\nGiven a list of arbitrarily many strings, implement a function for each of the following conditions:\n\n<ul>\n  <li>test if they are all lexically equal</li>\n  <li>test if every string is lexically less than the one after it  (i.e. whether the list is in strict ascending order)</li>\n</ul>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function allEqual(arr) {\n\n  return true;\n}\n\nfunction azSorted(arr) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function allEqual(a) {\n  let out = true;\n  let i = 0;\n  while (++i < a.length) {\n    out = out && (a[i - 1] === a[i]);\n  } return out;\n}\n\nfunction azSorted(a) {\n  let out = true;\n  let i = 0;\n  while (++i < a.length) {\n    out = out && (a[i - 1] < a[i]);\n  } return out;\n}"
        }
      ],
      "tests": [
        {
          "text": "`allEqual` should be a function.",
          "testCode": "assert(typeof allEqual === 'function');"
        },
        {
          "text": "`azSorted` should be a function.",
          "testCode": "assert(typeof azSorted === 'function');"
        },
        {
          "text": "`allEqual([\"AA\", \"AA\", \"AA\", \"AA\"])` should return true.",
          "testCode": "assert(allEqual(testCases[0]));"
        },
        {
          "text": "`azSorted([\"AA\", \"AA\", \"AA\", \"AA\"])` should return false.",
          "testCode": "assert(!azSorted(testCases[0]));"
        },
        {
          "text": "`allEqual([\"AA\", \"ACB\", \"BB\", \"CC\"])` should return false.",
          "testCode": "assert(!allEqual(testCases[1]));"
        },
        {
          "text": "`azSorted([\"AA\", \"ACB\", \"BB\", \"CC\"])` should return true.",
          "testCode": "assert(azSorted(testCases[1]));"
        },
        {
          "text": "`allEqual([])` should return true.",
          "testCode": "assert(allEqual(testCases[2]));"
        },
        {
          "text": "`azSorted([])` should return true.",
          "testCode": "assert(azSorted(testCases[2]));"
        },
        {
          "text": "`allEqual([\"AA\"])` should return true.",
          "testCode": "assert(allEqual(testCases[3]));"
        },
        {
          "text": "`azSorted([\"AA\"])` should return true.",
          "testCode": "assert(azSorted(testCases[3]));"
        },
        {
          "text": "`allEqual([\"BB\", \"AA\"])` should return false.",
          "testCode": "assert(!allEqual(testCases[4]));"
        },
        {
          "text": "`azSorted([\"BB\", \"AA\"])` should return false.",
          "testCode": "assert(!azSorted(testCases[4]));"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302235,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\compare-a-list-of-strings.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases = [['AA', 'AA', 'AA', 'AA'], ['AA', 'ACB', 'BB', 'CC'], [], ['AA'], ['BB', 'AA']];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "596fd036dc1ab896c5db98b1",
      "title": "Convert seconds to compound duration",
      "challengeType": 1,
      "dashedName": "convert-seconds-to-compound-duration",
      "description": "Implement a function which:\n\n<ul>\n  <li>takes a positive integer representing a duration in seconds as input (e.g., <code>100</code>), and</li>\n  <li>returns a string which shows the same duration decomposed into weeks, days, hours, minutes, and seconds as detailed below (e.g., <code>1 min, 40 sec</code>).</li>\n</ul>\n\nDemonstrate that it passes the following three test-cases:\n\n<div style='font-size:115%; font-weight: bold;'>Test Cases</div>\n\n| Input number | Output number                         |\n| ------------ | ------------------------------------- |\n| 7259         | <code>2 hr, 59 sec</code>             |\n| 86400        | <code>1 d</code>                      |\n| 6000000      | <code>9 wk, 6 d, 10 hr, 40 min</code> |\n\n<div style=\"font-size:115%; font-weight: bold;\">Details</div>\n<ul>\n  <li>\n    The following five units should be used:\n\n| Unit   | Suffix used in Output | Conversion            |\n| ------ | --------------------- | --------------------- |\n| week   | <code>wk</code>       | 1 week = 7 days       |\n| day    | <code>d</code>        | 1 day = 24 hours      |\n| hour   | <code>hr</code>       | 1 hour = 60 minutes   |\n| minute | <code>min</code>      | 1 minute = 60 seconds |\n| second | <code>sec</code>      | ---                   |\n\n  </li>\n  <li>\n    However, <strong>only</strong> include quantities with non-zero values in the output (e.g., return <code>1 d</code> and not <code>0 wk, 1 d, 0 hr, 0 min, 0 sec</code>).\n  </li>\n  <li>\n    Give larger units precedence over smaller ones as much as possible (e.g., return <code>2 min, 10 sec</code> and not <code>1 min, 70 sec</code> or <code>130 sec</code>).\n  </li>\n  <li>\n    Mimic the formatting shown in the test-cases (quantities sorted from largest unit to smallest and separated by comma+space; value and unit of each quantity separated by space).\n  </li>\n</ul>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function convertSeconds(sec) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function convertSeconds(sec) {\n  const localNames = ['wk', 'd', 'hr', 'min', 'sec'];\n  // compoundDuration :: [String] -> Int -> String\n  const compoundDuration = (labels, intSeconds) =>\n    weekParts(intSeconds)\n    .map((v, i) => [v, labels[i]])\n    .reduce((a, x) =>\n      a.concat(x[0] ? [`${x[0]} ${x[1] || '?'}`] : []), []\n    )\n    .join(', ');\n\n    // weekParts :: Int -> [Int]\n  const weekParts = intSeconds => [0, 7, 24, 60, 60]\n    .reduceRight((a, x) => {\n      const r = a.rem;\n      const mod = x !== 0 ? r % x : r;\n\n      return {\n        rem: (r - mod) / (x || 1),\n        parts: [mod].concat(a.parts)\n      };\n    }, {\n      rem: intSeconds,\n      parts: []\n    })\n    .parts;\n\n  return compoundDuration(localNames, sec);\n}"
        }
      ],
      "tests": [
        {
          "text": "`convertSeconds` should be a function.",
          "testCode": "assert(typeof convertSeconds === 'function');"
        },
        {
          "text": "`convertSeconds(7259)` should return `2 hr, 59 sec`.",
          "testCode": "assert.equal(convertSeconds(testCases[0]), results[0]);"
        },
        {
          "text": "`convertSeconds(86400)` should return `1 d`.",
          "testCode": "assert.equal(convertSeconds(testCases[1]), results[1]);"
        },
        {
          "text": "`convertSeconds(6000000)` should return `9 wk, 6 d, 10 hr, 40 min`.",
          "testCode": "assert.equal(convertSeconds(testCases[2]), results[2]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302236,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\convert-seconds-to-compound-duration.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases = [7259, 86400, 6000000];\nconst results = ['2 hr, 59 sec', '1 d', '9 wk, 6 d, 10 hr, 40 min'];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "596fda99c69f779975a1b67d",
      "title": "Count occurrences of a substring",
      "challengeType": 1,
      "dashedName": "count-occurrences-of-a-substring",
      "description": "Create a function, or show a built-in function, to count the number of non-overlapping occurrences of a substring inside a string.\n\nThe function should take two arguments:\n\n<ul>\n  <li>the first argument being the string to search, and</li>\n  <li>the second a substring to be searched for.</li>\n</ul>\n\nIt should return an integer count.\n\nThe matching should yield the highest number of non-overlapping matches.\n\nIn general, this essentially means matching from left-to-right or right-to-left.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function countSubstring(str, subStr) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function countSubstring(str, subStr) {\n  const escapedSubStr = subStr.replace(/[.+*?^$[\\]{}()|/]/g, '\\\\$&');\n  const matches = str.match(new RegExp(escapedSubStr, 'g'));\n  return matches ? matches.length : 0;\n}"
        }
      ],
      "tests": [
        {
          "text": "`countSubstring` should be a function.",
          "testCode": "assert(typeof countSubstring === 'function');"
        },
        {
          "text": "`countSubstring(\"the three truths\", \"th\")` should return `3`.",
          "testCode": "assert.equal(countSubstring(testCases[0], searchString[0]), results[0]);"
        },
        {
          "text": "`countSubstring(\"ababababab\", \"abab\")` should return `2`.",
          "testCode": "assert.equal(countSubstring(testCases[1], searchString[1]), results[1]);"
        },
        {
          "text": "`countSubstring(\"abaabba*bbaba*bbab\", \"a*b\")` should return `2`.",
          "testCode": "assert.equal(countSubstring(testCases[2], searchString[2]), results[2]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302237,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\count-occurrences-of-a-substring.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases = ['the three truths', 'ababababab', 'abaabba*bbaba*bbab'];\nconst searchString = ['th', 'abab', 'a*b'];\nconst results = [3, 2, 2];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59713bd26bdeb8a594fb9413",
      "title": "Count the coins",
      "challengeType": 1,
      "dashedName": "count-the-coins",
      "description": "There are four types of common coins in US currency:\n\n<ul>\n  <li>quarters (25 cents)</li>\n  <li>dimes (10 cents)</li>\n  <li>nickels (5 cents), and</li>\n  <li>pennies (1 cent)</li>\n</ul>\n\n<p>There are six ways to make change for 15 cents:</p>\n\n<ul>\n  <li>A dime and a nickel</li>\n  <li>A dime and 5 pennies</li>\n  <li>3 nickels</li>\n  <li>2 nickels and 5 pennies</li>\n  <li>A nickel and 10 pennies</li>\n  <li>15 pennies</li>\n</ul>",
      "instructions": "Implement a function to determine how many ways there are to make change for a given input, `cents`, that represents an amount of US pennies using these common coins.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function countCoins(cents) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function countCoins(cents) {\n  const operands = [1, 5, 10, 25];\n  const targetsLength = cents + 1;\n  const operandsLength = operands.length;\n  const t = [1];\n\n  for (let a = 0; a < operandsLength; a++) {\n    for (let b = 1; b < targetsLength; b++) {\n      // initialise undefined target\n      t[b] = t[b] ? t[b] : 0;\n\n      // accumulate target + operand ways\n      t[b] += (b < operands[a]) ? 0 : t[b - operands[a]];\n    }\n  }\n\n  return t[targetsLength - 1];\n}"
        }
      ],
      "tests": [
        {
          "text": "`countCoins` should be a function.",
          "testCode": "assert(typeof countCoins === 'function');"
        },
        {
          "text": "`countCoins(15)` should return `6`.",
          "testCode": "assert.equal(countCoins(15), 6);"
        },
        {
          "text": "`countCoins(85)` should return `163`.",
          "testCode": "assert.equal(countCoins(85), 163);"
        },
        {
          "text": "`countCoins(100)` should return `242`.",
          "testCode": "assert.equal(countCoins(100), 242);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302238,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\count-the-coins.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59713da0a428c1a62d7db430",
      "title": "Cramer's rule",
      "challengeType": 1,
      "dashedName": "cramers-rule",
      "description": "<a href=\"https://rosettacode.org/wiki/Cramer%27s_rule\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Cramer's rule</a> is a formula for solving a system of linear equations by using the determinants of matrices formed from subsets of the coefficients and right hand side values.\n\nThe determinant of a matrix with 2 rows and two columns is given by:\n\n$\\begin{aligned}|A|={\\begin{vmatrix}a&b\\\\\\c&d\\end{vmatrix}}=ad-bc.\\end{aligned}$\n\nGiven a system of linear equations:\n\n$\\\\left\\\\{\\\\begin{matrix}a_1x + b_1y + c_1z&= {\\\\color{red}d_1}\\\\\\\\a_2x + b_2y + c_2z&= {\\\\color{red}d_2}\\\\\\\\a_3x + b_3y + c_3z&= {\\\\color{red}d_3}\\\\end{matrix}\\\\right.$\n\nwhich in matrix format is\n\n$\\\\begin{bmatrix} a_1 & b_1 & c_1 \\\\\\\\ a_2 & b_2 & c_2 \\\\\\\\ a_3 & b_3 & c_3 \\\\end{bmatrix}\\\\begin{bmatrix} x \\\\\\\\ y \\\\\\\\ z \\\\end{bmatrix}=\\\\begin{bmatrix} {\\\\color{red}d_1} \\\\\\\\ {\\\\color{red}d_2} \\\\\\\\ {\\\\color{red}d_3} \\\\end{bmatrix}.$\n\nThen the values of $x, y$ and $z$ can be found as follows:\n\n$x = \\\\frac{\\\\begin{vmatrix} {\\\\color{red}d_1} & b_1 & c_1 \\\\\\\\ {\\\\color{red}d_2} & b_2 & c_2 \\\\\\\\ {\\\\color{red}d_3} & b_3 & c_3 \\\\end{vmatrix} } { \\\\begin{vmatrix} a_1 & b_1 & c_1 \\\\\\\\ a_2 & b_2 & c_2 \\\\\\\\ a_3 & b_3 & c_3 \\\\end{vmatrix}}, \\\\quad y = \\\\frac {\\\\begin{vmatrix} a_1 & {\\\\color{red}d_1} & c_1 \\\\\\\\ a_2 & {\\\\color{red}d_2} & c_2 \\\\\\\\ a_3 & {\\\\color{red}d_3} & c_3 \\\\end{vmatrix}} {\\\\begin{vmatrix} a_1 & b_1 & c_1 \\\\\\\\ a_2 & b_2 & c_2 \\\\\\\\ a_3 & b_3 & c_3 \\\\end{vmatrix}}, \\\\text{ and }z = \\\\frac { \\\\begin{vmatrix} a_1 & b_1 & {\\\\color{red}d_1} \\\\\\\\ a_2 & b_2 & {\\\\color{red}d_2} \\\\\\\\ a_3 & b_3 & {\\\\color{red}d_3} \\\\end{vmatrix}} {\\\\begin{vmatrix} a_1 & b_1 & c_1 \\\\\\\\ a_2 & b_2 & c_2 \\\\\\\\ a_3 & b_3 & c_3 \\\\end{vmatrix} }.$",
      "instructions": "Given the following system of equations:\n\n$\\\\begin{cases} 2w-x+5y+z=-3 \\\\\\\\ 3w+2x+2y-6z=-32 \\\\\\\\ w+3x+3y-z=-47 \\\\\\\\ 5w-2x-3y+3z=49 \\\\\\\\ \\\\end{cases}$\n\nsolve for $w$, $x$, $y$ and $z$, using Cramer's rule.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function cramersRule(matrix, freeTerms) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "/**\n * Compute Cramer's Rule\n * @param  {array} matrix    x,y,z, etc. terms\n * @param  {array} freeTerms\n * @return {array}           solution for x,y,z, etc.\n */\nfunction cramersRule(matrix, freeTerms) {\n  const det = detr(matrix);\n  const returnArray = [];\n  let i;\n\n  for (i = 0; i < matrix[0].length; i++) {\n    const tmpMatrix = insertInTerms(matrix, freeTerms, i);\n    returnArray.push(detr(tmpMatrix) / det);\n  }\n  return returnArray;\n}\n\n/**\n * Inserts single dimensional array into\n * @param  {array} matrix multidimensional array to have ins inserted into\n * @param  {array} ins single dimensional array to be inserted vertically into matrix\n * @param  {array} at  zero based offset for ins to be inserted into matrix\n * @return {array}     New multidimensional array with ins replacing the at column in matrix\n */\nfunction insertInTerms(matrix, ins, at) {\n  const tmpMatrix = clone(matrix);\n  let i;\n  for (i = 0; i < matrix.length; i++) {\n    tmpMatrix[i][at] = ins[i];\n  }\n  return tmpMatrix;\n}\n/**\n * Compute the determinate of a matrix.  No protection, assumes square matrix\n * function borrowed, and adapted from MIT Licensed numericjs library (www.numericjs.com)\n * @param  {array} m Input Matrix (multidimensional array)\n * @return {number}   result rounded to 2 decimal\n */\nfunction detr(m) {\n  let ret = 1;\n  let j;\n  let k;\n  const A = clone(m);\n  const n = m[0].length;\n  let alpha;\n\n  for (j = 0; j < n - 1; j++) {\n    k = j;\n    for (let i = j + 1; i < n; i++) { if (Math.abs(A[i][j]) > Math.abs(A[k][j])) { k = i; } }\n    if (k !== j) {\n      const temp = A[k]; A[k] = A[j]; A[j] = temp;\n      ret *= -1;\n    }\n    const Aj = A[j];\n    for (let i = j + 1; i < n; i++) {\n      const Ai = A[i];\n      alpha = Ai[j] / Aj[j];\n      for (k = j + 1; k < n - 1; k += 2) {\n        const k1 = k + 1;\n        Ai[k] -= Aj[k] * alpha;\n        Ai[k1] -= Aj[k1] * alpha;\n      }\n      if (k !== n) { Ai[k] -= Aj[k] * alpha; }\n    }\n    if (Aj[j] === 0) { return 0; }\n    ret *= Aj[j];\n  }\n  return Math.round(ret * A[j][j] * 100) / 100;\n}\n\n/**\n * Clone two dimensional Array using ECMAScript 5 map function and EcmaScript 3 slice\n * @param  {array} m Input matrix (multidimensional array) to clone\n * @return {array}   New matrix copy\n */\nfunction clone(m) {\n  return m.map(a => a.slice());\n}"
        }
      ],
      "tests": [
        {
          "text": "`cramersRule` should be a function.",
          "testCode": "assert(typeof cramersRule === 'function');"
        },
        {
          "text": "`cramersRule([[2, -1, 5, 1], [3, 2, 2, -6], [1, 3, 3, -1], [5, -2, -3, 3]], [-3, -32, -47, 49])` should return `[2, -12, -4, 1]`.",
          "testCode": "assert.deepEqual(cramersRule(matrices[0], freeTerms[0]), answers[0]);"
        },
        {
          "text": "`cramersRule([[3, 1, 1], [2, 2, 5], [1, -3, -4]], [3, -1, 2])` should return `[1, 1, -1]`.",
          "testCode": "assert.deepEqual(cramersRule(matrices[1], freeTerms[1]), answers[1]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302239,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\cramers-rule.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const matrices = [\n  [\n    [2, -1, 5, 1],\n    [3, 2, 2, -6],\n    [1, 3, 3, -1],\n    [5, -2, -3, 3]\n  ],\n  [\n    [3, 1, 1],\n    [2, 2, 5],\n    [1, -3, -4]\n  ]\n];\nconst freeTerms = [[-3, -32, -47, 49], [3, -1, 2]];\n\nconst answers = [[2, -12, -4, 1], [1, 1, -1]];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e03",
      "title": "Cumulative standard deviation",
      "challengeType": 1,
      "dashedName": "cumulative-standard-deviation",
      "description": "Suppose that the entire population of interest is eight students in a particular class. For a finite set of numbers, the population standard deviation is found by taking the square root of the average of the squared deviations of the values subtracted from their average value. The marks of a class of eight students (that is, a statistical population) are the following eight values:\n\n$2, 4, 4, 4, 5, 5, 7, 9$\n\nThese eight data points have the mean (average) of 5:\n\n$$\\mu ={\\frac {2+4+4+4+5+5+7+9}{8}}={\\frac {40}{8}}=5$$\n\nFirst, calculate the deviations of each data point from the mean, and square the result of each:\n\n| Deviations of each data|  Square the result  |\n| ---------------------- | --------------------|\n| $(2-5)^{2}=(-3)^{2}=9$ | $(5-5)^{2}=0^{2}=0$ |\n| $(4-5)^{2}=(-1)^{2}=1$ | $(5-5)^{2}=0^{2}=0$ |\n| $(4-5)^{2}=(-1)^{2}=1$ | $(7-5)^{2}=2^{2}=4$ |\n| $(4-5)^{2}=(-1)^{2}=1$ | $(9-5)^{2}=4^{2}=16$|\n\nThe variance is the mean of these values:\n\n$$\\sigma ^{2}={\\frac {9+1+1+1+0+0+4+16}{8}}={\\frac {32}{8}}=4$$\n\nand the population standard deviation is equal to the square root of the variance:\n\n$$\\sigma ={\\sqrt {4}}=2$$\n\nWrite a function that takes an array of numbers as parameter and returns the <a href=\"https://rosettacode.org/wiki/Standard_deviation\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">standard deviation</a> of the series.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function standardDeviation(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function standardDeviation(arr) {\n  var sum = 0,\n    sum_sq = 0,\n    n = arr.length;\n  arr.forEach(function(e) {\n    sum += e;\n    sum_sq += e * e;\n  });\n\n  var std_dev = Math.sqrt(sum_sq / n - Math.pow(sum / n, 2));\n  return Math.round(std_dev * 1000) / 1000;\n}"
        }
      ],
      "tests": [
        {
          "text": "`standardDeviation` should be a function.",
          "testCode": "assert(typeof standardDeviation == 'function');"
        },
        {
          "text": "`standardDeviation([2, 4, 4, 4, 5, 5, 7, 9])` should return a number.",
          "testCode": "assert(typeof standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]) == 'number');"
        },
        {
          "text": "`standardDeviation([2, 4, 4, 4, 5, 5, 7, 9])` should return `2`.",
          "testCode": "assert.equal(standardDeviation([2, 4, 4, 4, 5, 5, 7, 9]), 2);"
        },
        {
          "text": "`standardDeviation([600, 470, 170, 430, 300])` should return `147.323`.",
          "testCode": "assert.equal(standardDeviation([600, 470, 170, 430, 300]), 147.323);"
        },
        {
          "text": "`standardDeviation([75, 83, 96, 100, 121, 125])` should return `18.239`.",
          "testCode": "assert.equal(standardDeviation([75, 83, 96, 100, 121, 125]), 18.239);"
        },
        {
          "text": "`standardDeviation([23, 37, 45, 49, 56, 63, 63, 70, 72, 82])` should return `16.87`.",
          "testCode": "assert.equal(\n  standardDeviation([23, 37, 45, 49, 56, 63, 63, 70, 72, 82]),\n  16.87\n);"
        },
        {
          "text": "`standardDeviation([271, 354, 296, 301, 333, 326, 285, 298, 327, 316, 287, 314])` should return `22.631`.",
          "testCode": "assert.equal(\n  standardDeviation([\n    271,\n    354,\n    296,\n    301,\n    333,\n    326,\n    285,\n    298,\n    327,\n    316,\n    287,\n    314\n  ]),\n  22.631\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302240,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\cumulative-standard-deviation.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e05",
      "title": "CUSIP",
      "challengeType": 1,
      "dashedName": "cusip",
      "description": "A **CUSIP** is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.",
      "instructions": "Write a function that takes a string as a parameter and checks if the string is valid CUSIP.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isCusip(s) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isCusip(s) {\n  if (s.length != 9) return false;\n  var sum = 0;\n  var ASCII = x => x.charCodeAt(0);\n  for (var i = 0; i < 7; i++) {\n    var c = s.charCodeAt(i);\n\n    var v;\n    if (c >= ASCII('0') && c <= ASCII('9')) {\n      v = c - 48;\n    } else if (c >= ASCII('A') && c <= ASCII('Z')) {\n      v = c - 64; // lower case letters apparently invalid\n    } else if (c == ASCII('*')) {\n      v = 36;\n    } else if (c == ASCII('@')) {\n      v = 37;\n    } else if (c == ASCII('#')) {\n      v = 38;\n    } else {\n      return false;\n    }\n    if (i % 2 == 1) v *= 2; // check if odd as using 0-based indexing\n    sum += Math.floor(v / 10) + (v % 10);\n  }\n  return s.charCodeAt(8) - 48 == (10 - (sum % 10)) % 10;\n}"
        }
      ],
      "tests": [
        {
          "text": "`isCusip` should be a function.",
          "testCode": "assert(typeof isCusip == 'function');"
        },
        {
          "text": "`isCusip(\"037833100\")` should return a boolean.",
          "testCode": "assert(typeof isCusip('037833100') == 'boolean');"
        },
        {
          "text": "`isCusip(\"037833100\")` should return `true`.",
          "testCode": "assert.equal(isCusip('037833100'), true);"
        },
        {
          "text": "`isCusip(\"17275R102\")` should return `true`.",
          "testCode": "assert.equal(isCusip('17275R102'), true);"
        },
        {
          "text": "`isCusip(\"38259P50a\")` should return `false`.",
          "testCode": "assert.equal(isCusip('38259P50a'), false);"
        },
        {
          "text": "`isCusip(\"38259P508\")` should return `true`.",
          "testCode": "assert.equal(isCusip('38259P508'), true);"
        },
        {
          "text": "`isCusip(\"38259P50#\")` should return `false`.",
          "testCode": "assert.equal(isCusip('38259P50#'), false);"
        },
        {
          "text": "`isCusip(\"68389X105\")` should return `true`.",
          "testCode": "assert.equal(isCusip('68389X105'), true);"
        },
        {
          "text": "`isCusip(\"68389X106\")` should return `false`.",
          "testCode": "assert.equal(isCusip('68389X106'), false);"
        },
        {
          "text": "`isCusip(\"5949181\")` should return `false`.",
          "testCode": "assert.equal(isCusip('5949181'), false);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302241,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\cusip.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e06",
      "title": "Cut a rectangle",
      "challengeType": 1,
      "dashedName": "cut-a-rectangle",
      "description": "A given rectangle is made from *m* × *n* squares. If *m* and *n* are not both odd, then it is possible to cut a path through the rectangle along the square edges such that the rectangle splits into two connected pieces with the same shape (after rotating one of the pieces by 180°). All such paths for 2 × 2 and 4 × 3 rectangles are shown below.\n\n<div style=\"width: 100%; text-align: center;\">\n  <svg xmlns=\"https://www.w3.org/2000/svg\" xmlns:xlink=\"https://www.w3.org/1999/xlink\" width=\"520\" height=\"170\" aria-hidden=\"true\" alt=\"Diagram showing the possible paths for 2 by 2 and 4 by 3 rectangles\">\n    <style>\n      .diagram-g { fill: none; stroke: #ccc }\n      .diagram-s, .diagram-s2 { fill: #bff; stroke: black; fill-opacity: .4 }\n      .diagram-s2 { fill: #fbf }\n      .diagram-d { stroke:black; fill:none}\n    </style>\n    <defs>\n      <g id=\"diagram-m\">\n        <g id=\"diagram-h4\">\n          <g id=\"diagram-h2\">\n            <path id=\"diagram-h\" d=\"m0 10h 640\" class=\"diagram-g\"/>\n            <use xlink:href=\"#diagram-h\" transform=\"translate(0, 20)\"/>\n          </g>\n          <use xlink:href=\"#diagram-h2\" transform=\"translate(0, 40)\"/>\n        </g>\n        <use xlink:href=\"#diagram-h4\" transform=\"translate(0, 80)\"/>\n        <g id=\"diagram-v8\">\n          <g id=\"diagram-v4\">\n            <g id=\"diagram-v2\">\n              <path id=\"diagram-v\" d=\"m10 0v160 m 20 0 v-160\" class=\"diagram-g\"/>\n              <use xlink:href=\"#diagram-v\" transform=\"translate(40, 0)\"/>\n            </g>\n            <use xlink:href=\"#diagram-v2\" transform=\"translate(80, 0)\"/>\n          </g>\n          <use xlink:href=\"#diagram-v4\" transform=\"translate(160, 0)\"/>\n        </g>\n        <use xlink:href=\"#diagram-v8\" transform=\"translate(320, 0)\"/>\n      </g>\n      <path id=\"diagram-b\" d=\"m0 0h80v60h-80z\" class=\"diagram-s\"/>\n    </defs>\n    <g transform=\"translate(.5, .5)\">\n      <use xlink:href=\"#diagram-m\"/>\n      <g transform=\"translate(10, 10)\">\n        <path d=\"m0 0v40h40v-40z\" class=\"diagram-s2\"/>\n        <path d=\"m20 0v40\" class=\"diagram-d\"/>\n        <path d=\"m60 0v40h40v-40z\" class=\"diagram-s2\"/>\n        <path d=\"m60 20h40\" class=\"diagram-d\"/>\n        <g transform=\"translate(120, 0)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m0 20h40v20h40\" class=\"diagram-d\"/>\n        </g>\n        <g transform=\"translate(220, 0)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m0 40h40v-20h40\" class=\"diagram-d\"/>\n        </g>\n        <g transform=\"translate(320, 0)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m20 0v40h20v-20h20v40\" class=\"diagram-d\"/>\n        </g>\n        <g transform=\"translate(420, 0)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m60 0v40h-20v-20h-20v40\" class=\"diagram-d\"/>\n        </g>\n        <g transform=\"translate(20, 80)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m40 0v60\" class=\"diagram-d\"/>\n        </g>\n        <g transform=\"translate(120, 80)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m60 0v20h-20v20h-20v20\" class=\"diagram-d\"/>\n        </g>\n        <g transform=\"translate(220, 80)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m20 0v20h20v20h20v20\" class=\"diagram-d\"/>\n        </g>\n        <g transform=\"translate(320, 80)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m0 20h20v20h20v-20h20v20h20\" class=\"diagram-d\"/>\n        </g>\n        <g transform=\"translate(420, 80)\">\n          <use xlink:href=\"#diagram-b\"/>\n          <path d=\"m0 40h20v-20h20v20h20v-20h20\" class=\"diagram-d\"/>\n        </g>\n      </g>\n    </g>\n  </svg>\n</div>",
      "instructions": "Write a function that calculates the number of different ways to cut an *m* × *n* rectangle.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function cutRectangle(w, h) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function cutRectangle(w, h) {\n  if (w % 2 == 1 && h % 2 == 1) return;\n\n  var dirs = [[0, -1], [-1, 0], [0, 1], [1, 0]];\n\n  var grid = new Array(h);\n  for (var i = 0; i < grid.length; i++) grid[i] = new Array(w);\n  var stack = [];\n\n  var half = Math.floor((w * h) / 2);\n  var bits = Math.pow(2, half) - 1;\n  var result = 0;\n  for (; bits > 0; bits -= 2) {\n    for (var i = 0; i < half; i++) {\n      var r = Math.floor(i / w);\n      var c = i % w;\n      grid[r][c] = (bits & (1 << i)) != 0 ? 1 : 0;\n      grid[h - r - 1][w - c - 1] = 1 - grid[r][c];\n    }\n\n    stack.push(0);\n    grid[0][0] = 2;\n    var count = 1;\n    while (stack.length != 0) {\n      var pos = stack.pop();\n      var r = Math.floor(pos / w);\n      var c = pos % w;\n\n      for (var dir of dirs) {\n        var nextR = r + dir[0];\n        var nextC = c + dir[1];\n\n        if (nextR >= 0 && nextR < h && nextC >= 0 && nextC < w) {\n          if (grid[nextR][nextC] == 1) {\n            stack.push(nextR * w + nextC);\n            grid[nextR][nextC] = 2;\n            count++;\n          }\n        }\n      }\n    }\n\n    if (count == half) {\n      result++;\n    }\n  }\n\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`cutRectangle` should be a function.",
          "testCode": "assert(typeof cutRectangle == 'function');"
        },
        {
          "text": "`cutRectangle(2, 2)` should return a number.",
          "testCode": "assert(typeof cutRectangle(2, 2) == 'number');"
        },
        {
          "text": "`cutRectangle(2, 2)` should return `2`.",
          "testCode": "assert.equal(cutRectangle(2, 2), 2);"
        },
        {
          "text": "`cutRectangle(4, 3)` should return `9`.",
          "testCode": "assert.equal(cutRectangle(4, 3), 9);"
        },
        {
          "text": "`cutRectangle(4, 4)` should return `22`.",
          "testCode": "assert.equal(cutRectangle(4, 4), 22);"
        },
        {
          "text": "`cutRectangle(8, 3)` should return `53`.",
          "testCode": "assert.equal(cutRectangle(8, 3), 53);"
        },
        {
          "text": "`cutRectangle(7, 4)` should return `151`.",
          "testCode": "assert.equal(cutRectangle(7, 4), 151);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302242,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\cut-a-rectangle.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59669d08d75b60482359409f",
      "title": "Date format",
      "challengeType": 1,
      "dashedName": "date-format",
      "description": "Return an array with two date strings of the current date with the following specifications:\n\n- The first string's date order should be the year number, month number, and day number separated by dashes (`-`).\n- The first string's year should be four digits in length.\n- The first string's month and day should not contain any leading zeros.\n- The second string's weekday and month names should not be abbreviated.\n- The second string's day should not contain any leading zeros.\n\nExample outputs:\n\n```js\n['2007-11-23', 'Friday, November 23, 2007']\n['2021-3-2', 'Tuesday, March 2, 2021']\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function getDateFormats() {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function getDateFormats() {\n  const date = new Date();\n  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  const fmt1 = `${date.getFullYear()}-${(1 + date.getMonth())}-${date.getDate()}`;\n  const fmt2 = `${weekdays[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;\n  return [fmt1, fmt2];\n}"
        }
      ],
      "tests": [
        {
          "text": "`getDateFormats` should be a function.",
          "testCode": "assert(typeof getDateFormats === 'function');"
        },
        {
          "text": "`getDateFormats` should return an object.",
          "testCode": "assert(typeof getDateFormats() === 'object');"
        },
        {
          "text": "`getDateFormats` should return an array with 2 elements.",
          "testCode": "assert(getDateFormats().length === 2);"
        },
        {
          "text": "`getDateFormats` should return the correct date in the right format",
          "testCode": "assert.deepEqual(getDateFormats(), dates, equalsMessage);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302243,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\date-format.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const getDateSolution = () => {\n  const date = new Date();\n  const weekdays = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];\n  const months = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];\n  const fmt1 = `${date.getFullYear()}-${(1 + date.getMonth())}-${date.getDate()}`;\n  const fmt2 = `${weekdays[date.getDay()]}, ${months[date.getMonth()]} ${date.getDate()}, ${date.getFullYear()}`;\n  return [fmt1, fmt2];\n};\n\nconst dates = getDateSolution();\nconst equalsMessage = `message: <code>getDataFormats()</code> should return <code>[\"${dates[0]}\", \"${dates[1]}\"]</code>.`;"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5966c21cf732a95f1b67dd28",
      "title": "Date manipulation",
      "challengeType": 1,
      "dashedName": "date-manipulation",
      "description": "Given a date string in EST, output the given date as a string with 12 hours added to the time. Time zone should be preserved.\n\nExample input: `\"March 6 2009 7:30pm EST\"`\n\nExample output: `\"March 7 2009 7:30am EST\"`",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function add12Hours(dateString) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function add12Hours(dateString) {\n  const months = ['January', 'February', 'March', 'April', 'May', 'June',\n    'July', 'August', 'September', 'October', 'November', 'December'];\n  // Get the parts of the string\n  const parts = dateString.split(' ');\n  const month = months.indexOf(parts[0]);\n  const day = parseInt(parts[1], 10);\n  const year = parseInt(parts[2], 10);\n  const time = parts[3].split(':');\n  let hours = parseInt(time[0], 10);\n  if (time[1].slice(-2) === 'pm') {\n    hours += 12;\n  }\n  const minutes = parseInt(time[1].slice(0, -2), 10);\n\n  // Create a date with given parts, and updated hours\n  const date = new Date();\n  date.setFullYear(year, month, day);\n  date.setHours(hours + 12);  // Add 12 hours\n  date.setMinutes(minutes);\n\n  let hoursOutput = date.getHours();\n  let abbreviation = 'am';\n  if (hoursOutput > 12) {\n    hoursOutput -= 12;\n    abbreviation = 'pm';\n  }\n\n  return `${months[date.getMonth()]} ${date.getDate()} ${date.getFullYear()} ${hoursOutput}:${date.getMinutes()}${abbreviation} EST`;\n}"
        }
      ],
      "tests": [
        {
          "text": "`add12Hours` should be a function.",
          "testCode": "assert(typeof add12Hours === 'function');"
        },
        {
          "text": "`add12Hours(dateString)` should return a string.",
          "testCode": "assert(typeof add12Hours('January 17 2017 11:43am EST') === 'string');"
        },
        {
          "text": "`add12Hours(\"January 17 2017 11:43am EST\")` should return `\"January 17 2017 11:43pm EST\"`",
          "testCode": "assert(\n  add12Hours('January 17 2017 11:43am EST') === 'January 17 2017 11:43pm EST'\n);"
        },
        {
          "text": "Should handle day change. `add12Hours(\"March 6 2009 7:30pm EST\")` should return `\"March 7 2009 7:30am EST\"`",
          "testCode": "assert(add12Hours('March 6 2009 7:30pm EST') === 'March 7 2009 7:30am EST');"
        },
        {
          "text": "Should handle month change in a leap years. `add12Hours(\"February 29 2004 9:15pm EST\")` should return `\"March 1 2004 9:15am EST\"`",
          "testCode": "assert(add12Hours('February 29 2004 9:15pm EST') === 'March 1 2004 9:15am EST');"
        },
        {
          "text": "Should handle month change in a common years. `add12Hours(\"February 28 1999 3:15pm EST\")` should return `\"March 1 1999 3:15am EST\"`",
          "testCode": "assert(add12Hours('February 28 1999 3:15pm EST') === 'March 1 1999 3:15am EST');"
        },
        {
          "text": "Should handle year change. `add12Hours(\"December 31 2020 1:45pm EST\")` should return `\"January 1 2021 1:45am EST\"`",
          "testCode": "assert(\n  add12Hours('December 31 2020 1:45pm EST') === 'January 1 2021 1:45am EST'\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302244,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\date-manipulation.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5966f99c45e8976909a85575",
      "title": "Day of the week",
      "challengeType": 1,
      "dashedName": "day-of-the-week",
      "description": "A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).",
      "instructions": "Write a function that takes a start year and an end year and return an array of all the years where the 25th of December will be a Sunday.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function findXmasSunday(start, end) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function findXmasSunday(start, end) {\n  const xmasSunday = [];\n  for (let year = start; year <= end; year++) {\n    const xmas = new Date(year, 11, 25);\n    if (xmas.getDay() === 0) {\n      xmasSunday.push(year);\n    }\n  }\n  return xmasSunday;\n}"
        }
      ],
      "tests": [
        {
          "text": "`findXmasSunday` should be a function.",
          "testCode": "assert(typeof findXmasSunday === 'function');"
        },
        {
          "text": "`findXmasSunday(2000, 2100)` should return an array.",
          "testCode": "assert(typeof findXmasSunday(2000, 2100) === 'object');"
        },
        {
          "text": "`findXmasSunday(1970, 2017)` should return `[1977, 1983, 1988, 1994, 2005, 2011, 2016]`",
          "testCode": "assert.deepEqual(findXmasSunday(1970, 2017), firstSolution);"
        },
        {
          "text": "`findXmasSunday(2008, 2121)` should return `[2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]`",
          "testCode": "assert.deepEqual(findXmasSunday(2008, 2121), secondSolution);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302245,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\day-of-the-week.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const firstSolution = [1977, 1983, 1988, 1994, 2005, 2011, 2016];\nconst secondSolution = [2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59694356a6e7011f7f1c5f4e",
      "title": "Deal cards for FreeCell",
      "challengeType": 1,
      "dashedName": "deal-cards-for-freecell",
      "description": "*FreeCell* is the solitaire card game that Paul Alfille introduced to the PLATO system in 1978. Jim Horne, at Microsoft, changed the name to FreeCell and reimplemented the game for DOS, then Windows. This version introduced 32000 numbered deals.\n\nAs the game became popular, Jim Horne disclosed the algorithm, and other implementations of FreeCell began to reproduce the Microsoft deals. These deals are numbered from 1 to 32000. Newer versions from Microsoft have 1 million deals, numbered from 1 to 1000000; some implementations allow numbers outside that range.\n\nThe algorithm uses this linear congruential generator from Microsoft C:\n\n<ul>\n  <li>$state_{n + 1} \\equiv 214013 \\times state_n + 2531011 \\pmod{2^{31}}$</li>\n  <li>$rand_n = state_n \\div 2^{16}$</li>\n  <li>$rand_n$ is in range 0 to 32767.</li>\n</ul>\n\nThe algorithm follows:\n\n<ol>\n  <li>Seed the RNG with the number of the deal.\n  </li><li>Create an array of 52 cards: Ace of Clubs, Ace of Diamonds, Ace of Hearts, Ace of Spades, 2 of Clubs, 2 of Diamonds, and so on through the ranks: Ace, 2, 3, 4, 5, 6, 7, 8, 9, 10, Jack, Queen, King. The array indexes are 0 to 51, with Ace of Clubs at 0, and King of Spades at 51.</li>\n  <li>Until the array is empty:</li>\n    <ul>\n      <li>Choose a random card at <i>index</i> ≡ <i>next random number</i> (mod <i>array length</i>).</li>\n      <li>Swap this random card with the last card of the array.</li>\n      <li>Remove this random card from the array. (Array length goes down by 1.)</li>\n      <li>Deal this random card.</li>\n    </ul>\n  <li>Deal all 52 cards, face up, across 8 columns. The first 8 cards go in 8 columns, the next 8 cards go on the first 8 cards, and so on.</li>\n</ol>\n\n**Example:**\n\n**Order to deal cards**\n\n<pre> 1  2  3  4  5  6  7  8\n 9 10 11 12 13 14 15 16\n17 18 19 20 21 22 23 24\n25 26 27 28 29 30 31 32\n33 34 35 36 37 38 39 40\n41 42 43 44 45 46 47 48\n49 50 51 52</pre>\n\n**Game #1**\n\n```js\n[\n  ['JD', '2D', '9H', 'JC', '5D', '7H', '7C', '5H'],\n  ['KD', 'KC', '9S', '5S', 'AD', 'QC', 'KH', '3H'],\n  ['2S', 'KS', '9D', 'QD', 'JS', 'AS', 'AH', '3C'],\n  ['4C', '5C', 'TS', 'QH', '4H', 'AC', '4D', '7S'],\n  ['3S', 'TD', '4S', 'TH', '8H', '2C', 'JH', '7D'],\n  ['6D', '8S', '8D', 'QS', '6C', '3D', '8C', 'TC'],\n  ['6S', '9C', '2H', '6H']\n]\n```\n\n**Game #617**\n\n```js\n[\n  ['7D', 'AD', '5C', '3S', '5S', '8C', '2D', 'AH'],\n  ['TD', '7S', 'QD', 'AC', '6D', '8H', 'AS', 'KH'],\n  ['TH', 'QC', '3H', '9D', '6S', '8D', '3D', 'TC'],\n  ['KD', '5H', '9S', '3C', '8S', '7H', '4D', 'JS'],\n  ['4C', 'QS', '9C', '9H', '7C', '6H', '2C', '2S'],\n  ['4S', 'TS', '2H', '5D', 'JC', '6C', 'JH', 'QH'],\n  ['JD', 'KS', 'KC', '4H']\n]\n```",
      "instructions": "Write a function to take a deal number and deal cards in the same order as this algorithm. The function must return a two dimensional array representing the FreeCell board.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function dealFreeCell(seed) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// RNG\nfunction FreeCellRNG(seed) {\n  return {\n    lastNum: seed,\n    next() {\n      this.lastNum = ((214013 * this.lastNum) + 2531011) % (Math.pow(2, 31));\n      return this.lastNum >> 16;\n    }\n  };\n}\n// Get cards\nfunction getDeck() {\n  const ranks = ['A', '2', '3', '4', '5', '6', '7', '8', '9', 'T', 'J', 'Q', 'K'];\n  const suits = ['C', 'D', 'H', 'S'];\n  const cards = [];\n  for (let i = 0; i < ranks.length; i += 1) {\n    for (let j = 0; j < suits.length; j += 1) {\n      cards.push(`${ranks[i]}${suits[j]}`);\n    }\n  }\n  return cards;\n}\nfunction dealFreeCell(seed) {\n  const rng = FreeCellRNG(seed);\n  const deck = getDeck();\n\n  const dealtCards = [[], [], [], [], [], [], []];\n  let currentColumn = 0;\n  let currentRow = 0;\n\n  let rand;\n  let temp;\n  let card;\n  while (deck.length > 0) {\n    // Choose a random card\n    rand = rng.next() % deck.length;\n\n    // Swap this random card with the last card in the array\n    temp = deck[deck.length - 1];\n    deck[deck.length - 1] = deck[rand];\n    deck[rand] = temp;\n\n    // Remove this card from the array\n    card = deck.pop();\n\n    // Deal this card\n    dealtCards[currentRow].push(card);\n    currentColumn += 1;\n    if (currentColumn === 8) {\n      currentColumn = 0;\n      currentRow += 1;\n    }\n  }\n\n  return dealtCards;\n}"
        }
      ],
      "tests": [
        {
          "text": "`dealFreeCell` should be a function.",
          "testCode": "assert(typeof dealFreeCell === 'function');"
        },
        {
          "text": "`dealFreeCell(seed)` should return an object.",
          "testCode": "assert(typeof dealFreeCell(1) === 'object');"
        },
        {
          "text": "`dealFreeCell(seed)` should return an array of length 7.",
          "testCode": "assert(dealFreeCell(1).length === 7);"
        },
        {
          "text": "`dealFreeCell(1)` should return an array identical to example \"Game #1\"",
          "testCode": "assert.deepEqual(dealFreeCell(1), game1);"
        },
        {
          "text": "`dealFreeCell(617)` should return an array identical to example \"Game #617\"",
          "testCode": "assert.deepEqual(dealFreeCell(617), game617);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302246,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\deal-cards-for-freecell.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const replaceThis = 3;\nconst game1 = [\n  ['JD', '2D', '9H', 'JC', '5D', '7H', '7C', '5H'],\n  ['KD', 'KC', '9S', '5S', 'AD', 'QC', 'KH', '3H'],\n  ['2S', 'KS', '9D', 'QD', 'JS', 'AS', 'AH', '3C'],\n  ['4C', '5C', 'TS', 'QH', '4H', 'AC', '4D', '7S'],\n  ['3S', 'TD', '4S', 'TH', '8H', '2C', 'JH', '7D'],\n  ['6D', '8S', '8D', 'QS', '6C', '3D', '8C', 'TC'],\n  ['6S', '9C', '2H', '6H']\n];\nconst game617 = [\n  ['7D', 'AD', '5C', '3S', '5S', '8C', '2D', 'AH'],\n  ['TD', '7S', 'QD', 'AC', '6D', '8H', 'AS', 'KH'],\n  ['TH', 'QC', '3H', '9D', '6S', '8D', '3D', 'TC'],\n  ['KD', '5H', '9S', '3C', '8S', '7H', '4D', 'JS'],\n  ['4C', 'QS', '9C', '9H', '7C', '6H', '2C', '2S'],\n  ['4S', 'TS', '2H', '5D', 'JC', '6C', 'JH', 'QH'],\n  ['JD', 'KS', 'KC', '4H']\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "596a8888ab7c01048de257d5",
      "title": "Deepcopy",
      "challengeType": 1,
      "dashedName": "deepcopy",
      "description": "Write a function that returns a deep copy of a given object. The copy must not be the same object that was given.\n\nThis task will not test for:\n\n<ul>\n  <li>Objects with properties that are functions</li>\n  <li>Date objects or object with properties that are Date objects</li>\n  <li>RegEx or object with properties that are RegEx objects</li>\n  <li>Prototype copying</li>\n</ul>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function deepcopy(obj) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function deepcopy(obj) {\n  return JSON.parse(JSON.stringify(obj));\n}"
        }
      ],
      "tests": [
        {
          "text": "`deepcopy` should be a function.",
          "testCode": "assert(typeof deepcopy === 'function');"
        },
        {
          "text": "`deepcopy({test: \"test\"})` should return an object.",
          "testCode": "assert(typeof deepcopy(obj1) === 'object');"
        },
        {
          "text": "`deepcopy` should not return the same object that was provided.",
          "testCode": "assert(deepcopy(obj2) != obj2);"
        },
        {
          "text": "When passed an object containing an array, `deepcopy` should return a deep copy of the object.",
          "testCode": "assert.deepEqual(deepcopy(obj2), obj2);"
        },
        {
          "text": "When passed an object containing another object, `deepcopy`  should return a deep copy of the object.",
          "testCode": "assert.deepEqual(deepcopy(obj3), obj3);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302247,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\deepcopy.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const obj1 = { test: 'test' };\nconst obj2 = {\n  t: 'test',\n  a: ['an', 'array']\n};\nconst obj3 = {\n  t: 'try',\n  o: obj2\n};"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "597089c87eec450c68aa1643",
      "title": "Define a primitive data type",
      "challengeType": 1,
      "dashedName": "define-a-primitive-data-type",
      "description": "Define a type that behaves like an integer but has a lowest valid value of 1 and a highest valid value of 10.\n\nError handling:\n\n<ul>\n  <li>If you try to instantiate a <code>Num</code> with a value outside of 1 - 10, it should throw a <code>TypeError</code> with an error message of <code>'Out of range'</code>.</li>\n  <li>If you try to instantiate a <code>Num</code> with a value that is not a number, it should throw a <code>TypeError</code> with an error message of <code>'Not a Number'</code>.</li>\n</ul>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function Num(n) {\n\n  return n;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function Num(n) {\n  if (isNaN(n)) {\n    throw new TypeError('Not a Number');\n  }\n  if (n < 1 || n > 10) {\n    throw new TypeError('Out of range');\n  }\n\n  this._value = +n;\n}\nNum.prototype.valueOf = function() { return this._value; };\nNum.prototype.toString = function () { return this._value.toString(); };"
        }
      ],
      "tests": [
        {
          "text": "`Num` should be a function.",
          "testCode": "assert(typeof Num === 'function');"
        },
        {
          "text": "`new Num(4)` should return an object.",
          "testCode": "assert(typeof new Num(4) === 'object');"
        },
        {
          "text": "`new Num('test')` should throw a TypeError with message 'Not a Number'.",
          "testCode": "assert.throws(() => new Num('test'), TypeError);"
        },
        {
          "text": "`new Num(0)` should throw a TypeError with message 'Out of range'.",
          "testCode": "assert.throws(() => new Num(0), TypeError);"
        },
        {
          "text": "`new Num(-5)` should throw a TypeError with message 'Out of range'.",
          "testCode": "assert.throws(() => new Num(-5), TypeError);"
        },
        {
          "text": "`new Num(10)` should throw a TypeError with message 'Out of range'.",
          "testCode": "assert.throws(() => new Num(11), TypeError);"
        },
        {
          "text": "`new Num(20)` should throw a TypeError with message 'Out of range'.",
          "testCode": "assert.throws(() => new Num(20), TypeError);"
        },
        {
          "text": "`new Num(3) + new Num(4)` should equal 7.",
          "testCode": "assert.equal(new Num(3) + new Num(4), 7);"
        },
        {
          "text": "`new Num(3) - new Num(4)` should equal -1.",
          "testCode": "assert.equal(new Num(3) - new Num(4), -1);"
        },
        {
          "text": "`new Num(3) * new Num(4)` should equal 12.",
          "testCode": "assert.equal(new Num(3) * new Num(4), 12);"
        },
        {
          "text": "`new Num(3) / new Num(4)` should equal 0.75.",
          "testCode": "assert.equal(new Num(3) / new Num(4), 0.75);"
        },
        {
          "text": "`new Num(3) < new Num(4)` should be true.",
          "testCode": "assert(new Num(3) < new Num(4));"
        },
        {
          "text": "`new Num(3) > new Num(4)` should be false.",
          "testCode": "assert(!(new Num(3) > new Num(4)));"
        },
        {
          "text": "`(new Num(5)).toString()` should return '5'",
          "testCode": "assert.equal(new Num(5).toString(), '5');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302248,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\define-a-primitive-data-type.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59f40b17e79dbf1ab720ed7a",
      "title": "Department Numbers",
      "challengeType": 1,
      "dashedName": "department-numbers",
      "description": "There is a highly organized city that has decided to assign a number to each of their departments:\n\n<ul>\n  <li>Police department</li>\n  <li>Sanitation department</li>\n  <li>Fire department</li>\n</ul>\n\nEach department can have a number between 1 and 7 (inclusive).\n\nThe three department numbers are to be unique (different from each other) and must add up to the number 12.\n\nThe Chief of the Police doesn't like odd numbers and wants to have an even number for his department.",
      "instructions": "Write a program which outputs all valid combinations as an array.\n\n```js\n[2, 3, 7] [2, 4, 6] [2, 6, 4]\n[2, 7, 3] [4, 1, 7] [4, 2, 6]\n[4, 3, 5] [4, 5, 3] [4, 6, 2]\n[4, 7, 1] [6, 1, 5] [6, 2, 4]\n[6, 4, 2] [6, 5, 1]\n```",
      "boilerplate": [
        {
          "language": "js",
          "code": "function combinations(possibleNumbers, total) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function combinations(possibleNumbers, total) {\n  let firstNumber;\n  let secondNumber;\n  let thirdNumber;\n  const allCombinations = [];\n\n  for (let i = 0; i < possibleNumbers.length; i += 1) {\n    firstNumber = possibleNumbers[i];\n\n    if (firstNumber % 2 === 0) {\n      for (let j = 0; j < possibleNumbers.length; j += 1) {\n        secondNumber = possibleNumbers[j];\n\n        if (j !== i && firstNumber + secondNumber <= total) {\n          thirdNumber = total - firstNumber - secondNumber;\n\n          if (thirdNumber !== firstNumber && thirdNumber !== secondNumber && possibleNumbers.includes(thirdNumber)) {\n            allCombinations.push([firstNumber, secondNumber, thirdNumber]);\n          }\n        }\n      }\n    }\n  }\n  return allCombinations;\n}"
        }
      ],
      "tests": [
        {
          "text": "`combinations` should be a function.",
          "testCode": "assert(typeof combinations === 'function');"
        },
        {
          "text": "`combinations([1, 2, 3], 6)` should return an Array.",
          "testCode": "assert(Array.isArray(combinations([1, 2, 3], 6)));"
        },
        {
          "text": "`combinations([1, 2, 3, 4, 5, 6, 7], 12)` should return an array of length 14.",
          "testCode": "assert(combinations(nums, total).length === len);"
        },
        {
          "text": "`combinations([1, 2, 3, 4, 5, 6, 7], 12)` should return all valid combinations.",
          "testCode": "assert.deepEqual(combinations(nums, total), result);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302249,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\department-numbers.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const nums = [1, 2, 3, 4, 5, 6, 7];\nconst total = 12;\nconst len = 14;\nconst result = [\n  [2, 3, 7],\n  [2, 4, 6],\n  [2, 6, 4],\n  [2, 7, 3],\n  [4, 1, 7],\n  [4, 2, 6],\n  [4, 3, 5],\n  [4, 5, 3],\n  [4, 6, 2],\n  [4, 7, 1],\n  [6, 1, 5],\n  [6, 2, 4],\n  [6, 4, 2],\n  [6, 5, 1]\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59f4eafba0343628bb682785",
      "title": "Discordian date",
      "challengeType": 1,
      "dashedName": "discordian-date",
      "description": "The Gregorian calendar is a solar calendar with 12 months of 28-31 days each. A week consists of seven days, and there are 52 weeks and 1 day per year. The year consists of 365 days with a leap day added to February every leap year. A leap year occurs every four years, except for the first three centurial years of every 400 years.\n\nThe <a href=\"http://www.rosettacode.org/wiki/Discordian_date\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Discordian calendar</a> is aligned with the Gregorian calendar, and begins on January 1. The week consists of five days, and there are 73 weeks per year. The year also consists of 365 days, with an extra day inserted between Chaos 59 and Chaos 60 every leap year.\n\nThe months, weekdays, Apostle events, and Holidays in the Discordian calendar are given by:\n\nSeasons: `'Chaos', 'Discord', 'Confusion', 'Bureaucracy', 'The Aftermath'`.\n  \nWeekdays: `'Sweetmorn', 'Boomtime', 'Pungenday', 'Prickle-Prickle', 'Setting Orange'`.\n\nApostle: `'Mungday', 'Mojoday', 'Syaday', 'Zaraday', 'Maladay'`.\n\nHolidays: `'Chaoflux', 'Discoflux', 'Confuflux', 'Bureflux', 'Afflux'`.",
      "instructions": "Convert a given date from the Gregorian calendar to the Discordian calendar.\n\nNote that the day Chaos 1, 3188 YOLD in the Discordian calendar is the day January 1, 2022 in the Gregorian calendar.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function discordianDate(date) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "/**\n * All Hail Discordia! - this script prints Discordian date using system date.\n *\n * lang: JavaScript\n * author: jklu\n * contributors: JamesMcGuigan\n *\n * source: https://rosettacode.org/wiki/Discordian_date#JavaScript\n */\nconst seasons = [\n  'Chaos', 'Discord', 'Confusion',\n  'Bureaucracy', 'The Aftermath'\n];\nconst weekday = [\n  'Sweetmorn', 'Boomtime', 'Pungenday',\n  'Prickle-Prickle', 'Setting Orange'\n];\n\nconst apostle = [\n  'Mungday', 'Mojoday', 'Syaday',\n  'Zaraday', 'Maladay'\n];\n\nconst holiday = [\n  'Chaoflux', 'Discoflux', 'Confuflux',\n  'Bureflux', 'Afflux'\n];\n\n\nDate.prototype.isLeapYear = function() {\n  const year = this.getFullYear();\n  if ((year & 3) !== 0) { return false; }\n  return ((year % 100) !== 0 || (year % 400) === 0);\n};\n\n// Get Day of Year\nDate.prototype.getDOY = function() {\n  const dayCount = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];\n  const mn = this.getMonth();\n  const dn = this.getDate();\n  let dayOfYear = dayCount[mn] + dn;\n  if (mn > 1 && this.isLeapYear()) { dayOfYear += 1; }\n  return dayOfYear;\n};\n\nDate.prototype.isToday = function() {\n  const today = new Date();\n  return this.getDate() === today.getDate()\n      && this.getMonth() === today.getMonth()\n      && this.getFullYear() === today.getFullYear()\n  ;\n};\n\nfunction discordianDate(date) {\n  if (!date) { date = new Date(); }\n\n  const y = date.getFullYear();\n  const yold = y + 1166;\n  let dayOfYear = date.getDOY();\n  let celebrateHoliday = null;\n\n  if (date.isLeapYear()) {\n    if (dayOfYear === 60) {\n      celebrateHoliday = 'St. Tib\\'s Day';\n    }\n    else if (dayOfYear > 60) {\n      dayOfYear--;\n    }\n  }\n  dayOfYear--;\n\n  const divDay = Math.floor(dayOfYear / 73);\n\n  const seasonDay = (dayOfYear % 73) + 1;\n  if (seasonDay === 5) {\n    celebrateHoliday = apostle[divDay];\n  }\n  if (seasonDay === 50) {\n    celebrateHoliday = holiday[divDay];\n  }\n\n  const season = seasons[divDay];\n  const dayOfWeek = weekday[dayOfYear % 5];\n\n  const nth = (seasonDay % 10 === 1) ? 'st'\n          : (seasonDay % 10 === 2) ? 'nd'\n          : (seasonDay % 10 === 3) ? 'rd'\n                                  : 'th';\n\n  return ''\n         + dayOfWeek\n         + ', the ' + seasonDay + nth\n         + ' day of ' + season\n         + ' in the YOLD ' + yold\n         + (celebrateHoliday ? '. Celebrate ' + celebrateHoliday + '!' : '')\n    ;\n}"
        }
      ],
      "tests": [
        {
          "text": "`discordianDate` should be a function.",
          "testCode": "assert(typeof discordianDate === 'function');"
        },
        {
          "text": "`discordianDate(new Date(2010, 6, 22))` should return `\"Pungenday, the 57th day of Confusion in the YOLD 3176\"`.",
          "testCode": "assert(\n  discordianDate(new Date(2010, 6, 22)) ===\n    'Pungenday, the 57th day of Confusion in the YOLD 3176'\n);"
        },
        {
          "text": "`discordianDate(new Date(2012, 1, 28))` should return `\"Prickle-Prickle, the 59th day of Chaos in the YOLD 3178\"`.",
          "testCode": "assert(\n  discordianDate(new Date(2012, 1, 28)) ===\n    'Prickle-Prickle, the 59th day of Chaos in the YOLD 3178'\n);"
        },
        {
          "text": "`discordianDate(new Date(2012, 1, 29))` should return `\"Setting Orange, the 60th day of Chaos in the YOLD 3178. Celebrate St. Tib\\'s Day!\"`.",
          "testCode": "assert(\n  discordianDate(new Date(2012, 1, 29)) ===\n    \"Setting Orange, the 60th day of Chaos in the YOLD 3178. Celebrate St. Tib's Day!\"\n);"
        },
        {
          "text": "`discordianDate(new Date(2012, 2, 1))` should return `\"Setting Orange, the 60th day of Chaos in the YOLD 3178\"`.",
          "testCode": "assert(\n  discordianDate(new Date(2012, 2, 1)) ===\n    'Setting Orange, the 60th day of Chaos in the YOLD 3178'\n);"
        },
        {
          "text": "`discordianDate(new Date(2010, 0, 5))` should return `\"Setting Orange, the 5th day of Chaos in the YOLD 3176. Celebrate Mungday!\"`.",
          "testCode": "assert(\n  discordianDate(new Date(2010, 0, 5)) ===\n    'Setting Orange, the 5th day of Chaos in the YOLD 3176. Celebrate Mungday!'\n);"
        },
        {
          "text": "`discordianDate(new Date(2011, 4, 3))` should return `\"Pungenday, the 50th day of Discord in the YOLD 3177. Celebrate Discoflux!\"`.",
          "testCode": "assert(\n  discordianDate(new Date(2011, 4, 3)) ===\n    'Pungenday, the 50th day of Discord in the YOLD 3177. Celebrate Discoflux!'\n);"
        },
        {
          "text": "`discordianDate(new Date(2015, 9, 19))` should return `\"Boomtime, the 73rd day of Bureaucracy in the YOLD 3181\"`.",
          "testCode": "assert(\n  discordianDate(new Date(2015, 9, 19)) ===\n    'Boomtime, the 73rd day of Bureaucracy in the YOLD 3181'\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302250,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\discordian-date.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e1e",
      "title": "Dot product",
      "challengeType": 1,
      "dashedName": "dot-product",
      "description": "Create a function, to compute the **dot product**, also known as the **scalar product** of two vectors.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function dotProduct(ary1, ary2) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function dotProduct(ary1, ary2) {\n  var dotprod = 0;\n  for (var i = 0; i < ary1.length; i++) dotprod += ary1[i] * ary2[i];\n  return dotprod;\n}"
        }
      ],
      "tests": [
        {
          "text": "`dotProduct` should be a function.",
          "testCode": "assert(typeof dotProduct == 'function');"
        },
        {
          "text": "`dotProduct([1, 3, -5], [4, -2, -1])` should return a number.",
          "testCode": "assert(typeof dotProduct([1, 3, -5], [4, -2, -1]) == 'number');"
        },
        {
          "text": "`dotProduct([1, 3, -5], [4, -2, -1])` should return `3`.",
          "testCode": "assert.equal(dotProduct([1, 3, -5], [4, -2, -1]), 3);"
        },
        {
          "text": "`dotProduct([1, 2, 3, 4, 5], [6, 7, 8, 9, 10])` should return `130`.",
          "testCode": "assert.equal(dotProduct([1, 2, 3, 4, 5], [6, 7, 8, 9, 10]), 130);"
        },
        {
          "text": "`dotProduct([5, 4, 3, 2], [7, 8, 9, 6])` should return `106`.",
          "testCode": "assert.equal(dotProduct([5, 4, 3, 2], [7, 8, 9, 6]), 106);"
        },
        {
          "text": "`dotProduct([-5, 4, -3, 2], [-7, -8, 9, -6])` should return `-36`.",
          "testCode": "assert.equal(dotProduct([-5, 4, -3, 2], [-7, -8, 9, -6]), -36);"
        },
        {
          "text": "`dotProduct([17, 27, 34, 43, 15], [62, 73, 48, 95, 110])` should return `10392`.",
          "testCode": "assert.equal(dotProduct([17, 27, 34, 43, 15], [62, 73, 48, 95, 110]), 10392);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302251,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\dot-product.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "599c333915e0ea32d04d4bec",
      "title": "Element-wise operations",
      "challengeType": 1,
      "dashedName": "element-wise-operations",
      "description": "Implement basic element-wise matrix-matrix and scalar-matrix operations.\n\n**Implement:**\n\n<ul>\n  <li>addition</li>\n  <li>subtraction</li>\n  <li>multiplication</li>\n  <li>division</li>\n  <li>exponentiation</li>\n</ul>\n\nThe first parameter will be the operation to be performed, for example, \"m_add\" for matrix addition and \"s_add\" for scalar addition. The second and third parameters will be the matrices on which the operations are to be performed.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function operation(op, arr1, arr2) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function operation(op, arr1, arr2) {\n  const ops = {\n    add: ((a, b) => a + b),\n    sub: ((a, b) => a - b),\n    mult: ((a, b) => a * b),\n    div: ((a, b) => a / b),\n    exp: ((a, b) => Math.pow(a, b))\n  };\n  const ifm = op.startsWith('m');\n  const doOp = ops[op.substring(2)];\n  for (let i = 0; i < arr1.length; i++) {\n    for (let j = 0; j < arr1[0].length; j++) {\n      arr1[i][j] = doOp(arr1[i][j], (ifm) ? (arr2[i][j]) : (arr2));\n    }\n  }\n  return arr1;\n}"
        }
      ],
      "tests": [
        {
          "text": "`operation` should be a function.",
          "testCode": "assert(typeof operation === 'function');"
        },
        {
          "text": "`operation(\"m_add\",[[1,2],[3,4]],[[1,2],[3,4]])` should return `[[2,4],[6,8]]`.",
          "testCode": "assert.deepEqual(\n  operation(\n    'm_add',\n    [\n      [1, 2],\n      [3, 4]\n    ],\n    [\n      [1, 2],\n      [3, 4]\n    ]\n  ),\n  [\n    [2, 4],\n    [6, 8]\n  ]\n);"
        },
        {
          "text": "`operation(\"s_add\",[[1,2],[3,4]],2)` should return `[[3,4],[5,6]]`.",
          "testCode": "assert.deepEqual(\n  operation(\n    's_add',\n    [\n      [1, 2],\n      [3, 4]\n    ],\n    2\n  ),\n  [\n    [3, 4],\n    [5, 6]\n  ]\n);"
        },
        {
          "text": "`operation(\"m_sub\",[[1,2],[3,4]],[[1,2],[3,4]])` should return `[[0,0],[0,0]]`.",
          "testCode": "assert.deepEqual(\n  operation(\n    'm_sub',\n    [\n      [1, 2],\n      [3, 4]\n    ],\n    [\n      [1, 2],\n      [3, 4]\n    ]\n  ),\n  [\n    [0, 0],\n    [0, 0]\n  ]\n);"
        },
        {
          "text": "`operation(\"m_mult\",[[1,2],[3,4]],[[1,2],[3,4]])` should return `[[1,4],[9,16]]`.",
          "testCode": "assert.deepEqual(\n  operation(\n    'm_mult',\n    [\n      [1, 2],\n      [3, 4]\n    ],\n    [\n      [1, 2],\n      [3, 4]\n    ]\n  ),\n  [\n    [1, 4],\n    [9, 16]\n  ]\n);"
        },
        {
          "text": "`operation(\"m_div\",[[1,2],[3,4]],[[1,2],[3,4]])` should return `[[1,1],[1,1]]`.",
          "testCode": "assert.deepEqual(\n  operation(\n    'm_div',\n    [\n      [1, 2],\n      [3, 4]\n    ],\n    [\n      [1, 2],\n      [3, 4]\n    ]\n  ),\n  [\n    [1, 1],\n    [1, 1]\n  ]\n);"
        },
        {
          "text": "`operation(\"m_exp\",[[1,2],[3,4]],[[1,2],[3,4]])` should return `[[1,4],[27,256]]`.",
          "testCode": "assert.deepEqual(\n  operation(\n    'm_exp',\n    [\n      [1, 2],\n      [3, 4]\n    ],\n    [\n      [1, 2],\n      [3, 4]\n    ]\n  ),\n  [\n    [1, 4],\n    [27, 256]\n  ]\n);"
        },
        {
          "text": "`operation(\"m_add\",[[1,2,3,4],[5,6,7,8]],[[9,10,11,12],[13,14,15,16]])` should return `[[10,12,14,16],[18,20,22,24]]`.",
          "testCode": "assert.deepEqual(\n  operation(\n    'm_add',\n    [\n      [1, 2, 3, 4],\n      [5, 6, 7, 8]\n    ],\n    [\n      [9, 10, 11, 12],\n      [13, 14, 15, 16]\n    ]\n  ),\n  [\n    [10, 12, 14, 16],\n    [18, 20, 22, 24]\n  ]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302252,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\element-wise-operations.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "599d0ba974141b0f508b37d5",
      "title": "Emirp primes",
      "challengeType": 1,
      "dashedName": "emirp-primes",
      "description": "An emirp (**prime** spelled backwards) are primes that when reversed (in their decimal representation) are a different prime.",
      "instructions": "Write a function that:\n\n<ul>\n  <li>Shows the first <code>n</code> emirp numbers.</li>\n  <li>Shows the emirp numbers in a range.</li>\n  <li>Shows the number of emirps in a range.</li>\n  <li>Shows the <code>n<sup>th</sup></code> emirp number.</li>\n</ul>\n\nThe function should accept two parameters. The first will receive `n` or the range as an array. The second will receive a boolean, that specifies if the function returns the emirps as an array or a single number (the number of primes in the range or the <code>n<sup>th</sup></code> prime). According to the parameters the function should return an array or a number.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function emirps(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function emirps(num, showEmirps)\n{\n  const is_prime = function(n)\n    {\n    if (!(n % 2) || !(n % 3)) return false;\n    let p = 1;\n    while (p * p < n)\n                    { if (n % (p += 4) == 0 || n % (p += 2) == 0)\n                            { return false; } }\n    return true;\n  };\n  const is_emirp = function(n) {\n    const r = parseInt(n.toString().split('').reverse().join(''));\n    return r != n && is_prime(n) && is_prime(r);\n  };\n\n  let i,\n    arr = [];\n  if (typeof num === 'number') {\n    for (i = 0; arr.length < num; i++) if (is_emirp(i)) arr.push(i);\n    // first x emirps\n    if (showEmirps) return arr;\n    // xth emirp\n    return arr.pop();\n  }\n\n  if (Array.isArray(num)) {\n    for (i = num[0]; i <= num[1]; i++) if (is_emirp(i)) arr.push(i);\n    // emirps between x .. y\n    if (showEmirps) return arr;\n    // number of emirps between x .. y\n    return arr.length;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`emirps` should be a function.",
          "testCode": "assert(typeof emirps === 'function');"
        },
        {
          "text": "`emirps(20,true)` should return `[13,17,31,37,71,73,79,97,107,113,149,157,167,179,199,311,337,347,359,389]`",
          "testCode": "assert.deepEqual(emirps(20, true), [\n  13,\n  17,\n  31,\n  37,\n  71,\n  73,\n  79,\n  97,\n  107,\n  113,\n  149,\n  157,\n  167,\n  179,\n  199,\n  311,\n  337,\n  347,\n  359,\n  389\n]);"
        },
        {
          "text": "`emirps(1000)` should return `70529`",
          "testCode": "assert.deepEqual(emirps(1000), 70529);"
        },
        {
          "text": "`emirps([7700,8000],true)` should return `[7717,7757,7817,7841,7867,7879,7901,7927,7949,7951,7963]`",
          "testCode": "assert.deepEqual(emirps([7700, 8000], true), [\n  7717,\n  7757,\n  7817,\n  7841,\n  7867,\n  7879,\n  7901,\n  7927,\n  7949,\n  7951,\n  7963\n]);"
        },
        {
          "text": "`emirps([7700,8000],false)` should return `11`",
          "testCode": "assert.deepEqual(emirps([7700, 8000], false), 11);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302253,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\emirp-primes.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "599d15309e88c813a40baf58",
      "title": "Entropy",
      "challengeType": 1,
      "dashedName": "entropy",
      "description": "Calculate the Shannon entropy H of a given input string.\n\nGiven the discrete random variable $X$ that is a string of $N$ \"symbols\" (total characters) consisting of $n$ different characters (n=2 for binary), the Shannon entropy of X in bits/symbol is:\n\n$H_2(X) = -\\\\sum\\_{i=1}^n \\\\frac{count_i}{N} \\\\log_2 \\\\left(\\\\frac{count_i}{N}\\\\right)$\n\nwhere $count_i$ is the count of character $n_i$.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function entropy(s) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function entropy(s) {\n    // Create a dictionary of character frequencies and iterate over it.\n  function process(s, evaluator) {\n    let h = Object.create(null),\n      k;\n    s.split('').forEach(c => {\n      h[c] && h[c]++ || (h[c] = 1); });\n    if (evaluator) for (k in h) evaluator(k, h[k]);\n    return h;\n  }\n    // Measure the entropy of a string in bits per symbol.\n\n  let sum = 0,\n    len = s.length;\n  process(s, (k, f) => {\n    const p = f / len;\n    sum -= p * Math.log(p) / Math.log(2);\n  });\n  return sum;\n}"
        }
      ],
      "tests": [
        {
          "text": "`entropy` should be a function.",
          "testCode": "assert(typeof entropy === 'function');"
        },
        {
          "text": "`entropy(\"0\")` should return `0`",
          "testCode": "assert.equal(entropy('0'), 0);"
        },
        {
          "text": "`entropy(\"01\")` should return `1`",
          "testCode": "assert.equal(entropy('01'), 1);"
        },
        {
          "text": "`entropy(\"0123\")` should return `2`",
          "testCode": "assert.equal(entropy('0123'), 2);"
        },
        {
          "text": "`entropy(\"01234567\")` should return `3`",
          "testCode": "assert.equal(entropy('01234567'), 3);"
        },
        {
          "text": "`entropy(\"0123456789abcdef\")` should return `4`",
          "testCode": "assert.equal(entropy('0123456789abcdef'), 4);"
        },
        {
          "text": "`entropy(\"1223334444\")` should return `1.8464393446710154`",
          "testCode": "assert.equal(entropy('1223334444'), 1.8464393446710154);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302254,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\entropy.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5987fd532b954e0f21b5d3f6",
      "title": "Equilibrium index",
      "challengeType": 1,
      "dashedName": "equilibrium-index",
      "description": "An equilibrium index of a sequence is an index into the sequence such that the sum of elements at lower indices is equal to the sum of elements at higher indices.\n\nFor example, in a sequence $A$:\n\n<ul style='list-style: none;'>\n  <li><big>$A_0 = -7$</big></li>\n  <li><big>$A_1 =  1$</big></li>\n  <li><big>$A_2 =  5$</big></li>\n  <li><big>$A_3 =  2$</big></li>\n  <li><big>$A_4 = -4$</big></li>\n  <li><big>$A_5 =  3$</big></li>\n  <li><big>$A_6 =  0$</big></li>\n</ul>\n\n`3` is an equilibrium index, because:\n\n<ul style='list-style: none;'>\n  <li><big>$A_0 + A_1 + A_2 = A_4 + A_5 + A_6$</big></li>\n</ul>\n\n`6` is also an equilibrium index, because:\n\n<ul style='list-style: none;'>\n  <li><big>$A_0 + A_1 + A_2 + A_3 + A_4 + A_5 = 0$</big></li>\n</ul>\n\n(sum of zero elements is zero)\n\n`7` is not an equilibrium index, because it is not a valid index of sequence $A$.",
      "instructions": "Write a function that, given a sequence, returns its equilibrium indices (if any).\n\nAssume that the sequence may be very long.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function equilibrium(a) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function equilibrium(a) {\n  let N = a.length,\n    i,\n    l = [],\n    r = [],\n    e = [];\n  for (l[0] = a[0], r[N - 1] = a[N - 1], i = 1; i < N; i++)\n    { l[i] = l[i - 1] + a[i], r[N - i - 1] = r[N - i] + a[N - i - 1]; }\n  for (i = 0; i < N; i++)\n    { if (l[i] === r[i]) e.push(i); }\n  return e;\n}"
        }
      ],
      "tests": [
        {
          "text": "`equilibrium` should be a function.",
          "testCode": "assert(typeof equilibrium === 'function');"
        },
        {
          "text": "`equilibrium([-7, 1, 5, 2, -4, 3, 0])` should return `[3,6]`.",
          "testCode": "assert.deepEqual(equilibrium(equilibriumTests[0]), ans[0]);"
        },
        {
          "text": "`equilibrium([2, 4, 6])` should return `[]`.",
          "testCode": "assert.deepEqual(equilibrium(equilibriumTests[1]), ans[1]);"
        },
        {
          "text": "`equilibrium([2, 9, 2])` should return `[1]`.",
          "testCode": "assert.deepEqual(equilibrium(equilibriumTests[2]), ans[2]);"
        },
        {
          "text": "`equilibrium([1, -1, 1, -1, 1, -1, 1])` should return `[0,1,2,3,4,5,6]`.",
          "testCode": "assert.deepEqual(equilibrium(equilibriumTests[3]), ans[3]);"
        },
        {
          "text": "`equilibrium([1])` should return `[0]`.",
          "testCode": "assert.deepEqual(equilibrium(equilibriumTests[4]), ans[4]);"
        },
        {
          "text": "`equilibrium([])` should return `[]`.",
          "testCode": "assert.deepEqual(equilibrium(equilibriumTests[5]), ans[5]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302255,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\equilibrium-index.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const equilibriumTests =\n  [[-7, 1, 5, 2, -4, 3, 0], // 3, 6\n  [2, 4, 6], // empty\n  [2, 9, 2], // 1\n  [1, -1, 1, -1, 1, -1, 1], // 0,1,2,3,4,5,6\n  [1], // 0\n  [] // empty\n  ];\nconst ans = [[3, 6], [], [1], [0, 1, 2, 3, 4, 5, 6], [0], []];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "599d1566a02b571412643b84",
      "title": "Ethiopian multiplication",
      "challengeType": 1,
      "dashedName": "ethiopian-multiplication",
      "description": "Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.\n\n**Method:**\n\n<ol>\n  <li>Take two numbers to be multiplied and write them down at the top of two columns</li>\n  <li>In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of <code>1</code></li>\n  <li>In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows <code>1</code></li>\n  <li>Examine the table produced and discard any row where the value in the left column is even</li>\n  <li>Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together</li>\n</ol>\n\n**For example:** `17 × 34`\n\n<pre>17   34\n</pre>\n\nHalving the first column:\n\n<pre>17   34\n8\n4\n2\n1\n</pre>\n\nDoubling the second column:\n\n<pre>17   34\n8    68\n4   136\n2   272\n1   544\n</pre>\n\nStrike-out rows whose first cell is even:\n\n<pre>17   34\n8    <strike>68</strike>\n4   <strike>136</strike>\n2   <strike>272</strike>\n1   544\n</pre>\n\nSum the remaining numbers in the right-hand column:\n\n<!-- markdownlint-disable MD003 -->\n\n<pre>17   34\n8    --\n4   ---\n2   ---\n1   544\n   ====\n    578\n</pre>\n\n<!-- markdownlint-enable MD003 -->\n\nSo `17` multiplied by `34`, by the Ethiopian method is `578`.",
      "instructions": "The task is to define three named functions/methods/procedures/subroutines:\n\n<ol>\n  <li>one to halve an integer,</li>\n  <li>one to double an integer, and</li>\n  <li>one to state if an integer is even</li>\n</ol>\n\nUse these functions to create a function that does Ethiopian multiplication.\n\n<!-- markdownlint-disable MD046-->",
      "boilerplate": [
        {
          "language": "js",
          "code": "function eth_mult(a, b) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function eth_mult(a, b) {\n  let sum = 0; a = [a]; b = [b];\n\n  let half = a => a / 2,\n    double = a => a * 2,\n    is_even = a => a % 2 == 0;\n\n  while (a[0] !== 1) {\n    a.unshift(Math.floor(half(a[0])));\n    b.unshift(double(b[0]));\n  }\n\n  for (let i = a.length - 1; i > 0; i -= 1) {\n    if (!is_even(a[i])) {\n      sum += b[i];\n    }\n  }\n  return sum + b[0];\n}"
        }
      ],
      "tests": [
        {
          "text": "`eth_mult` should be a function.",
          "testCode": "assert(typeof eth_mult === 'function');"
        },
        {
          "text": "`eth_mult(17,34)` should return `578`.",
          "testCode": "assert.equal(eth_mult(17, 34), 578);"
        },
        {
          "text": "`eth_mult(23,46)` should return `1058`.",
          "testCode": "assert.equal(eth_mult(23, 46), 1058);"
        },
        {
          "text": "`eth_mult(12,27)` should return `324`.",
          "testCode": "assert.equal(eth_mult(12, 27), 324);"
        },
        {
          "text": "`eth_mult(56,98)` should return `5488`.",
          "testCode": "assert.equal(eth_mult(56, 98), 5488);"
        },
        {
          "text": "`eth_mult(63,74)` should return `4662`.",
          "testCode": "assert.equal(eth_mult(63, 74), 4662);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302257,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\ethiopian-multiplication.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59880443fb36441083c6c20e",
      "title": "Euler method",
      "challengeType": 1,
      "dashedName": "euler-method",
      "description": "Euler's method numerically approximates solutions of first-order ordinary differential equations (ODEs) with a given initial value. It is an explicit method for solving initial value problems (IVPs), as described in <a href=\"https://www.freecodecamp.org/news/eulers-method-explained-with-examples/\" title=\"Euler's Method Explained with Examples\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">this article</a>.\n\nThe ODE has to be provided in the following form:\n\n<ul style='list-style: none;'>\n  <li><big>$\\frac{dy(t)}{dt} = f(t,y(t))$</big></li>\n</ul>\n\nwith an initial value\n\n<ul style='list-style: none;'>\n  <li><big>$y(t_0) = y_0$</big></li>\n</ul>\n\nTo get a numeric solution, we replace the derivative on the LHS with a finite difference approximation:\n\n<ul style='list-style: none;'>\n  <li><big>$\\frac{dy(t)}{dt}  \\approx \\frac{y(t+h)-y(t)}{h}$</big></li>\n</ul>\n\nthen solve for $y(t+h)$:\n\n<ul style='list-style: none;'>\n  <li><big>$y(t+h) \\approx y(t) + h \\, \\frac{dy(t)}{dt}$</big></li>\n</ul>\n\nwhich is the same as\n\n<ul style='list-style: none;'>\n  <li><big>$y(t+h) \\approx y(t) + h \\, f(t,y(t))$</big></li>\n</ul>\n\nThe iterative solution rule is then:\n\n<ul style='list-style: none;'>\n  <li><big>$y_{n+1} = y_n + h \\, f(t_n, y_n)$</big></li>\n</ul>\n\nwhere $h$ is the step size, the most relevant parameter for accuracy of the solution. A smaller step size increases accuracy but also the computation cost, so it has always has to be hand-picked according to the problem at hand.\n\n**Example: Newton's Cooling Law**\n\nNewton's cooling law describes how an object of initial temperature $T(t_0) = T_0$ cools down in an environment of temperature $T_R$:\n\n<ul style='list-style: none;'>\n  <li><big>$\\frac{dT(t)}{dt} = -k \\, \\Delta T$</big></li>\n</ul>\n\nor\n\n<ul style='list-style: none;'>\n  <li><big>$\\frac{dT(t)}{dt} = -k \\, (T(t) - T_R)$</big></li>\n</ul>\n\nIt says that the cooling rate $\\\\frac{dT(t)}{dt}$ of the object is proportional to the current temperature difference $\\\\Delta T = (T(t) - T_R)$ to the surrounding environment.\n\nThe analytical solution, which we will compare to the numerical approximation, is\n\n<ul style='list-style: none;'>\n  <li><big>$T(t) = T_R + (T_0 - T_R) \\; e^{-k t}$</big></li>\n</ul>",
      "instructions": "Implement a routine of Euler's method and then use it to solve the given example of Newton's cooling law for three different step sizes of:\n\n<ul>\n  <li><code>2 s</code></li>\n  <li><code>5 s</code> and</li>\n  <li><code>10 s</code></li>\n</ul>\n\nand compare with the analytical solution.\n\n**Initial values:**\n\n<ul>\n  <li>initial temperature <big>$T_0$</big> shall be <code>100 °C</code></li>\n  <li>room temperature <big>$T_R$</big> shall be <code>20 °C</code></li>\n  <li>cooling constant <big>$k$</big> shall be <code>0.07</code></li>\n  <li>time interval to calculate shall be from <code>0 s</code> to <code>100 s</code></li>\n</ul>  \n\nFirst parameter to the function is initial time, second parameter is initial temperature, third parameter is elapsed time and fourth parameter is step size.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function eulersMethod(x1, y1, x2, h) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function eulersMethod(x1, y1, x2, h) {\n  let x = x1;\n  let y = y1;\n\n  while ((x < x2 && x1 < x2) || (x > x2 && x1 > x2)) {\n    y += h * (-0.07 * (y - 20));\n    x += h;\n  }\n\n  return y;\n}"
        }
      ],
      "tests": [
        {
          "text": "`eulersMethod` should be a function.",
          "testCode": "assert(typeof eulersMethod === 'function');"
        },
        {
          "text": "`eulersMethod(0, 100, 100, 2)` should return a number.",
          "testCode": "assert(typeof eulersMethod(0, 100, 100, 2) === 'number');"
        },
        {
          "text": "`eulersMethod(0, 100, 100, 2)` should return 20.0424631833732.",
          "testCode": "assert.equal(eulersMethod(0, 100, 100, 2), 20.0424631833732);"
        },
        {
          "text": "`eulersMethod(0, 100, 100, 5)` should return 20.01449963666907.",
          "testCode": "assert.equal(eulersMethod(0, 100, 100, 5), 20.01449963666907);"
        },
        {
          "text": "`eulersMethod(0, 100, 100, 10)` should return 20.000472392.",
          "testCode": "assert.equal(eulersMethod(0, 100, 100, 10), 20.000472392);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302258,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\euler-method.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "598de241872ef8353c58a7a2",
      "title": "Evaluate binomial coefficients",
      "challengeType": 1,
      "dashedName": "evaluate-binomial-coefficients",
      "description": "Write a function to calculate the binomial coefficient for the given value of n and k.\n\nThis formula is recommended:\n\n$\\\\binom{n}{k} = \\\\frac{n!}{(n-k)!k!} = \\\\frac{n(n-1)(n-2)\\\\ldots(n-k+1)}{k(k-1)(k-2)\\\\ldots 1}$",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function binom(n, k) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function binom(n, k) {\n  let coeff = 1;\n  for (let i = n - k + 1; i <= n; i++) coeff *= i;\n  for (let i = 1; i <= k; i++) coeff /= i;\n  return coeff;\n}"
        }
      ],
      "tests": [
        {
          "text": "`binom` should be a function.",
          "testCode": "assert(typeof binom === 'function');"
        },
        {
          "text": "`binom(5,3)` should return 10.",
          "testCode": "assert.equal(binom(5, 3), 10);"
        },
        {
          "text": "`binom(7,2)` should return 21.",
          "testCode": "assert.equal(binom(7, 2), 21);"
        },
        {
          "text": "`binom(10,4)` should return 210.",
          "testCode": "assert.equal(binom(10, 4), 210);"
        },
        {
          "text": "`binom(6,1)` should return 6.",
          "testCode": "assert.equal(binom(6, 1), 6);"
        },
        {
          "text": "`binom(12,8)` should return 495.",
          "testCode": "assert.equal(binom(12, 8), 495);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302259,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\evaluate-binomial-coefficients.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59e09e6d412c5939baa02d16",
      "title": "Execute a Markov algorithm",
      "challengeType": 1,
      "dashedName": "execute-a-markov-algorithm",
      "description": "Markov Concepts are used in machine learning, because of its simple approach in data manipulation. With a set number of `rules` you can manipulate given `data` to create a desired `output`.\n\nWe have added in the background:\n\nThe `rules` in the form of nested array, and the `data` in the form of array, too. And the desired `outputs`.\n\nThe `rules`:\n\n```js\nlet rules=[\n[\n\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\n\"the shop -> my brother\",\"a never used -> .terminating rule\"\n],\n\n[\n \"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\n \"the shop -> my brother\",\"a never used -> .terminating rule\"\n],\n\n[\n \"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\n \"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\n \"the shop -> my brother\",\"a never used -> .terminating rule\"\n],\n\n[\n \"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\n \"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\n \"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"\n],\n\n[\n\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\n\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"\n]\n\n];\n```\n\nThe `data`:\n\n```js\nlet data=[\n        \"I bought a B of As from T S.\",\n        \"I bought a B of As from T S.\",\n        \"I bought a B of As W my Bgage from T S.\",\n        \"_1111*11111_\",\n        \"000000A000000\"\n        ];\n```\n\nThe `outputs`:\n\n```js\nlet outputs=[\n    \"I bought a bag of apples from my brother.\",\n    \"I bought a bag of apples from T shop.\",\n    \"I bought a bag of apples with my money from T shop.\",\n    \"11111111111111111111\",\n    \"00011H1111000\"\n    ]\n```\n\nUsing Markov Algorithm, change the `data` into the desired `outputs` using the `rules` provided for you.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function markov(rules,data) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function markov(rules,data) {\n    let pattern = new RegExp(\"^([^#]*?)\\\\s+->\\\\s+(\\\\.?)(.*)\");\n    let origData = data;\n\n    let captures = [];\n\n    rules.forEach(function(rule){\n        let m = pattern.exec(rule);\n        for (let j = 0; j < m.length; j++)\n            m[j] = m[j + 1];\n        captures.push(m);\n    });\n\n    data = origData;\n    let copy = data;\n    for (let j = 0; j < captures.length; j++) {\n        let c = captures[j];\n        data = data.replace(c[0], c[2]);\n        if (c[1]==\".\")\n            break;\n        if (data!=copy) {\n            j = -1;\n            copy = data;\n        }\n    }\n    return data;\n}"
        }
      ],
      "tests": [
        {
          "text": "`markov` should be a function.",
          "testCode": "assert(typeof markov === 'function');"
        },
        {
          "text": "`markov([\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")` should return the string `I bought a bag of apples from my brother.`.",
          "testCode": "assert.deepEqual(markov(rules[0], datas[0]), outputs[0]);"
        },
        {
          "text": "`markov([\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As from T S.\")` should return the string `I bought a bag of apples from T shop.`.",
          "testCode": "assert.deepEqual(markov(rules[1], datas[1]), outputs[1]);"
        },
        {
          "text": "`markov([\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\"I bought a B of As W my Bgage from T S.\")` should return the string `I bought a bag of apples with my money from T shop.`.",
          "testCode": "assert.deepEqual(markov(rules[2], datas[2]), outputs[2]);"
        },
        {
          "text": "`markov([\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\"_1111*11111_\")` should return the string `11111111111111111111`.",
          "testCode": "assert.deepEqual(markov(rules[3], datas[3]), outputs[3]);"
        },
        {
          "text": "`markov([\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"],\"\")` should return the string `00011H1111000`.",
          "testCode": "assert.deepEqual(markov(rules[4], datas[4]), outputs[4]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302260,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\execute-a-markov-algorithm.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "let rules=[[\"A -> apple\",\"B -> bag\",\"S -> shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n            [\"A -> apple\",\"B -> bag\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n            [\"A -> apple\",\"WWWW -> with\",\"Bgage -> ->.*\",\"B -> bag\",\"->.* -> money\",\"W -> WW\",\"S -> .shop\",\"T -> the\",\"the shop -> my brother\",\"a never used -> .terminating rule\"],\n            [\"_+1 -> _1+\",\"1+1 -> 11+\",\"1! -> !1\",\",! -> !+\",\"_! -> _\",\"1*1 -> x,@y\",\"1x -> xX\",\"X, -> 1,1\",\"X1 -> 1X\",\"_x -> _X\",\",x -> ,X\",\"y1 -> 1y\",\"y_ -> _\",\"1@1 -> x,@y\",\"1@_ -> @_\",\",@_ -> !_\",\"++ -> +\",\"_1 -> 1\",\"1+_ -> 1\",\"_+_ -> \"],\n            [\"A0 -> 1B\",\"0A1 -> C01\",\"1A1 -> C11\",\"0B0 -> A01\",\"1B0 -> A11\",\"B1 -> 1B\",\"0C0 -> B01\",\"1C0 -> B11\",\"0C1 -> H01\",\"1C1 -> H11\"]];\nlet datas=[\"I bought a B of As from T S.\",\n            \"I bought a B of As from T S.\",\n            \"I bought a B of As W my Bgage from T S.\",\n            \"_1111*11111_\",\n            \"000000A000000\"];\nlet outputs=[\"I bought a bag of apples from my brother.\",\n            \"I bought a bag of apples from T shop.\",\n            \"I bought a bag of apples with my money from T shop.\",\n            \"11111111111111111111\",\n            \"00011H1111000\"]"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59e0a8df964e4540d5abe599",
      "title": "Execute Brain****",
      "challengeType": 1,
      "dashedName": "execute-brain",
      "description": "Write a function to implement a Brain\\*\\*\\*\\* interpreter. The function will take a string as a parameter and should return a string as the output. More details are given below:\n\nRCBF is a set of <a href=\"https://rosettacode.org/wiki/Brainf***\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Brainf\\*\\*\\*</a> compilers and interpreters written for Rosetta Code in a variety of languages.\n\nBelow are links to each of the versions of RCBF.\n\nAn implementation need only properly implement the following instructions:\n\n| Command           | Description                                                                        |\n| ----------------- | ---------------------------------------------------------------------------------- |\n| <code>></code>    | Move the pointer to the right                                                      |\n| <code>&lt;</code> | Move the pointer to the left                                                       |\n| <code>+</code>    | Increment the memory cell under the pointer                                        |\n| <code>-</code>    | Decrement the memory cell under the pointer                                        |\n| <code>.</code>    | Output the character signified by the cell at the pointer                          |\n| <code>,</code>    | Input a character and store it in the cell at the pointer                          |\n| <code>\\[</code>   | Jump past the matching <code>]</code> if the cell under the pointer is 0           |\n| <code>]</code>    | Jump back to the matching <code>\\[</code> if the cell under the pointer is nonzero |\n\nAny cell size is allowed, EOF (*E*nd-*O*-*F*ile) support is optional, as is whether you have bounded or unbounded memory.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function brain(prog) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function brain(prog){\n  var output=\"\";\n    var code; // formatted code\n  var ip = 0; // current instruction within code\n  var nest = 0; // current bracket nesting (for Out button)\n  var ahead = []; // locations of matching brackets\n\n  var data = [0]; // data array (mod by +, -)\n  var dp = 0; // index into data (mod by <, >)\n\n  var inp = 0; // current input character (fetch with ,)\n  var quit = 0;\n    var commands = {\n    '>':function() { if (++dp >= data.length) data[dp]=0 },\n    '<':function() { if (--dp < 0) quit++ },\n    '+':function() { ++data[dp] },\n    '-':function() { --data[dp] },\n    '[':function() { if (!data[dp]) ip = ahead[ip]; else ++nest },\n    ']':function() { if ( data[dp]) ip = ahead[ip]; else --nest },\n    ',':function() {\n        var c = document.getElementById(\"input\").value.charCodeAt(inp++);\n        data[dp] = isNaN(c) ? 0 : c; // EOF: other options are -1 or no change\n    },\n    '.':function() {\n            output+=String.fromCharCode(data[dp]);\n            /*var s = document.getElementById(\"output\").innerHTML)\n             + String.fromCharCode(data[dp]);\n            s = s.replace(/\\n/g,\"<br>\").replace(/ /g,\"&amp;nbsp;\");\n            document.getElementById(\"output\").innerHTML = s;*/\n        },\n    };\n\n    let ar=prog.split('');\n    var st = [], back, error = -1;\n    for (ip=0; ip<ar.length; ip++) {\n        switch(ar[ip]) {\n        case '[':\n            st.push(ip);\n            break;\n        case ']':\n            if (st.length == 0) error = ip;\n            back = st.pop();\n            ahead[ip] = back;\n            ahead[back] = ip;\n            break;\n        }\n    }\n\n    for(ip=0;ip<ar.length;ip++){\n    if(commands.hasOwnProperty(ar[ip]))\n          commands[ar[ip]]();\n    }\n\n    return output;\n}"
        }
      ],
      "tests": [
        {
          "text": "`brain(hello)` should return a string",
          "testCode": "assert(typeof brain(hello) === 'string');"
        },
        {
          "text": "`brain(\"++++++[>++++++++++<-]>+++++.\")` should return \"A\"",
          "testCode": "assert.equal(brain('++++++[>++++++++++<-]>+++++.'), 'A');"
        },
        {
          "text": "`brain(hello)` should return `Hello World!\\n`",
          "testCode": "assert.equal(brain(hello), 'Hello World!\\n');"
        },
        {
          "text": "`brain(fib)` should return `1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89`",
          "testCode": "assert.equal(brain(fib), '1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302261,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\execute-brain.md"
      },
      "additionalCode": {
        "beforeUserCode": [
          {
            "language": "js",
            "code": "let fib=`+\n\n++\n\n+++\n\n++++\n\n+>+>>\n\n>>++++\n\n+++++++\n\n++++++++\n\n+++++++++\n\n++++++++++\n\n++++++>++++\n\n++++++++++++\n\n+++++++++++++\n\n+++<<<<<<[>[>>\n\n>>>>+>+<<<<<<<-\n\n]>>>>>>>[<<<<<<<\n\n+>>>>>>>-]<[>++++\n\n++++++[-<-[>>+>+<<\n\n<-]>>>[<<<+>>>-]+<[\n\n>[-]<[-]]>[<<[>>>+<<\n\n<-]>>[-]]<<]>>>[>>+>+\n\n<<<-]>>>[<<<+>>>-]+<[>\n\n[-]<[-]]>[<<+>>[-]]<<<<\n\n<<<]>>>>>[++++++++++++++\n\n+++++++++++++++++++++++++\n\n+++++++++.[-]]++++++++++<[\n\n->-<]>+++++++++++++++++++++\n\n+++++++++++++++++++++++++++.\n\n[-]<<<<<<<<<<<<[>>>+>+<<<<-]>\n\n>>>[<<<<+>>>>-]<-[>>.>.<<<[-]]\n\n<<[>>+>+<<<-]>>>[<<<+>>>-]<<[<+\n\n>-]>[<+>-]<<<-]`;\nlet hello='++++++++[>++++[>++>+++>+++>+<<<<-]>+>+>->>+[<]<-]>>.>---.+++++++..+++.>>.<-.<.+++.------.--------.>>+.>++.'"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "598ee8b91b410510ae82efef",
      "title": "Extensible prime generator",
      "challengeType": 1,
      "dashedName": "extensible-prime-generator",
      "description": "Write a generator of prime numbers, in order, that will automatically adjust to accommodate the generation of any reasonably high prime.\n\nThe generator should be able to:\n\n<ul>\n  <li>Show the first <code>n</code> prime numbers</li>\n  <li>Show the prime numbers in a range</li>\n  <li>Show the number of primes in a range</li>\n  <li>Show the <code>n<sup>th</sup></code> prime number</li>\n</ul>\n\nThe function should have two parameters. The first will receive `n` or the range as an array. The second will receive a boolean, that specifies if the function returns the prime numbers as an array or a single number(the number of primes in the range or the <code>n<sup>th</sup></code> prime). According to the parameters the function should return an array.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function primeGenerator(num, showPrimes) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function primeGenerator(num, showPrimes) {\n  let i,\n    arr = [];\n\n  function isPrime(num) {\n    // try primes <= 16\n    if (num <= 16) { return (\n      num == 2 || num == 3 || num == 5 || num == 7 || num == 11 || num == 13\n    ); }\n    // cull multiples of 2, 3, 5 or 7\n    if (num % 2 == 0 || num % 3 == 0 || num % 5 == 0 || num % 7 == 0)\n      { return false; }\n    // cull square numbers ending in 1, 3, 7 or 9\n    for (let i = 10; i * i <= num; i += 10) {\n      if (num % (i + 1) == 0) return false;\n      if (num % (i + 3) == 0) return false;\n      if (num % (i + 7) == 0) return false;\n      if (num % (i + 9) == 0) return false;\n    }\n    return true;\n  }\n\n  if (typeof num === 'number') {\n    for (i = 0; arr.length < num; i++) if (isPrime(i)) arr.push(i);\n    // first x primes\n    if (showPrimes) return arr;\n    // xth prime\n    return arr.pop();\n  }\n\n  if (Array.isArray(num)) {\n    for (i = num[0]; i <= num[1]; i++) if (isPrime(i)) arr.push(i);\n    // primes between x .. y\n    if (showPrimes) return arr;\n    // number of primes between x .. y\n    return arr.length;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`primeGenerator` should be a function.",
          "testCode": "assert(typeof primeGenerator === 'function');"
        },
        {
          "text": "`primeGenerator(20, true)` should return `[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71]`.",
          "testCode": "assert.deepEqual(primeGenerator(20, true), [\n  2,\n  3,\n  5,\n  7,\n  11,\n  13,\n  17,\n  19,\n  23,\n  29,\n  31,\n  37,\n  41,\n  43,\n  47,\n  53,\n  59,\n  61,\n  67,\n  71\n]);"
        },
        {
          "text": "`primeGenerator([100, 150], true)` should return `[101, 103, 107, 109, 113, 127, 131, 137, 139, 149]`.",
          "testCode": "assert.deepEqual(primeGenerator([100, 150], true), [\n  101,\n  103,\n  107,\n  109,\n  113,\n  127,\n  131,\n  137,\n  139,\n  149\n]);"
        },
        {
          "text": "`primeGenerator([7700, 8000], false)` should return `30`.",
          "testCode": "assert.equal(primeGenerator([7700, 8000], false), 30);"
        },
        {
          "text": "`primeGenerator(10000, false)` should return `104729`.",
          "testCode": "assert.equal(primeGenerator(10000, false), 104729);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302262,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\extensible-prime-generator.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "597b2b2a2702b44414742771",
      "title": "Factorial",
      "challengeType": 1,
      "dashedName": "factorial",
      "description": "Write a function to return the factorial of a number.\n\nFactorial of a number is given by:\n\n<pre><big>n! = n * (n-1) * (n-2) * ..... * 1</big>\n</pre>\n\nFor example:\n\n<ul>\n  <li><code>3! = 3 * 2 * 1 = 6</code></li>\n  <li><code>4! = 4 * 3 * 2 * 1 = 24</code></li>\n</ul>\n\n**Note:** `0! = 1`",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function factorial(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function factorial(n) {\n  let sum = 1;\n  while (n > 1) {\n    sum *= n;\n    n--;\n  }\n  return sum;\n}"
        }
      ],
      "tests": [
        {
          "text": "`factorial` should be a function.",
          "testCode": "assert(typeof factorial === 'function');"
        },
        {
          "text": "`factorial(2)` should return a number.",
          "testCode": "assert(typeof factorial(2) === 'number');"
        },
        {
          "text": "`factorial(3)` should return 6.",
          "testCode": "assert.equal(factorial(3), 6);"
        },
        {
          "text": "`factorial(5)` should return 120.",
          "testCode": "assert.equal(factorial(5), 120);"
        },
        {
          "text": "`factorial(10)` should return 3,628,800.",
          "testCode": "assert.equal(factorial(10), 3628800);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302263,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\factorial.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "598eea87e5cf4b116c3ff81a",
      "title": "Factors of a Mersenne number",
      "challengeType": 1,
      "dashedName": "factors-of-a-mersenne-number",
      "description": "A Mersenne number is a number in the form of <code>2<sup>P</sup>-1</code>.\n\nIf `P` is prime, the Mersenne number may be a Mersenne prime. (If `P` is not prime, the Mersenne number is also not prime.)\n\nIn the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a, potentially lengthy, <a href=\"https://rosettacode.org/wiki/Lucas-Lehmer test\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Lucas-Lehmer test</a>.\n\nThere are very efficient algorithms for determining if a number divides <code>2<sup>P</sup>-1</code> (or equivalently, if <code>2<sup>P</sup> mod (the number) = 1</code>).\n\nSome languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar).\n\nThe following is how to implement this modPow yourself:\n\nFor example, let's compute <code>2<sup>23</sup> mod 47</code>.\n\nConvert the exponent 23 to binary, you get 10111. Starting with <code><tt>square</tt> = 1</code>, repeatedly square it.\n\nRemove the top bit of the exponent, and if it's 1 multiply `square` by the base of the exponentiation (2), then compute <code><tt>square</tt> modulo 47</code>.\n\nUse the result of the modulo from the last step as the initial value of `square` in the next step:\n\n<pre>Remove   Optional\nsquare        top bit  multiply by 2  mod 47\n------------  -------  -------------  ------\n1*1 = 1       1  0111  1*2 = 2           2\n2*2 = 4       0   111     no             4\n4*4 = 16      1    11  16*2 = 32        32\n32*32 = 1024  1     1  1024*2 = 2048    27\n27*27 = 729   1        729*2 = 1458      1\n</pre>\n\nSince <code>2<sup>23</sup> mod 47 = 1</code>, 47 is a factor of <code>2<sup>P</sup>-1</code>.\n\n(To see this, subtract 1 from both sides: <code>2<sup>23</sup>-1 = 0 mod 47</code>.)\n\nSince we've shown that 47 is a factor, <code>2<sup>23</sup>-1</code> is not prime.\n\nFurther properties of Mersenne numbers allow us to refine the process even more.\n\nAny factor `q` of <code>2<sup>P</sup>-1</code> must be of the form `2kP+1`, `k` being a positive integer or zero. Furthermore, `q` must be `1` or `7 mod 8`.\n\nFinally any potential factor `q` must be <a href=\"https://rosettacode.org/wiki/Primality_by_trial_division\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">prime</a>.\n\nAs in other trial division algorithms, the algorithm stops when `2kP+1 > sqrt(N)`.These primarily tests only work on Mersenne numbers where `P` is prime. For example, <code>M<sub>4</sub>=15</code> yields no factors using these techniques, but factors into 3 and 5, neither of which fit `2kP+1`.",
      "instructions": "Using the above method find a factor of <code>2<sup>p</sup>-1</code>.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function check_mersenne(p) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function check_mersenne(p){\n    function isPrime(value){\n      for (let i=2; i < value; i++){\n        if (value % i == 0){\n          return false;\n        }\n        if (value % i != 0){\n          return true;\n         }\n      }\n    }\n\n    function trial_factor(base, exp, mod){\n      let square, bits;\n      square = 1;\n      bits = exp.toString(2).split('');\n      for (let i=0,ln=bits.length; i<ln; i++){\n        square = Math.pow(square, 2) * (bits[i] == 1 ? base : 1) % mod;\n      }\n      return (square == 1);\n    }\n\n    function mersenne_factor(p){\n      let limit, k, q;\n      limit = Math.sqrt(Math.pow(2,p) - 1);\n      k = 1;\n      while ((2*k*p - 1) < limit){\n        q = 2*k*p + 1;\n        if (isPrime(q) && (q % 8 == 1 || q % 8 == 7) && trial_factor(2,p,q)){\n          return q; // q is a factor of 2**p-1\n        }\n        k++;\n      }\n      return null;\n    }\n  let f, result;\n  result=\"M\"+p+\" = 2^\"+p+\"-1 is \";\n  f = mersenne_factor(p);\n  result+=f == null ? \"prime\" : \"composite with factor \"+f;\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`check_mersenne` should be a function.",
          "testCode": "assert(typeof check_mersenne === 'function');"
        },
        {
          "text": "`check_mersenne(3)` should return a string.",
          "testCode": "assert(typeof check_mersenne(3) == 'string');"
        },
        {
          "text": "`check_mersenne(3)` should return the string `M3 = 2^3-1 is prime`.",
          "testCode": "assert.equal(check_mersenne(3), 'M3 = 2^3-1 is prime');"
        },
        {
          "text": "`check_mersenne(23)` should return the string `M23 = 2^23-1 is composite with factor 47`.",
          "testCode": "assert.equal(check_mersenne(23), 'M23 = 2^23-1 is composite with factor 47');"
        },
        {
          "text": "`check_mersenne(929)` should return the string `M929 = 2^929-1 is composite with factor 13007`.",
          "testCode": "assert.equal(\n  check_mersenne(929),\n  'M929 = 2^929-1 is composite with factor 13007'\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302264,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\factors-of-a-mersenne-number.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "597f1e7fbc206f0e9ba95dc4",
      "title": "Factors of an integer",
      "challengeType": 1,
      "dashedName": "factors-of-an-integer",
      "description": "Write a function that returns the factors of a positive integer as an array.\n\nThese factors are the positive integers by which the number being factored can be divided to yield a positive integer result.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function factors(num) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function factors(num)\n{\n let n_factors = [], i, sqr=Math.floor(Math.sqrt(num));\n\n for (i = 1; i <=sqr ; i += 1)\n  if (num % i === 0)\n  {\n   n_factors.push(i);\n   if (num / i !== i)\n    n_factors.push(num / i);\n  }\n n_factors.sort(function(a, b){return a - b;});\n return n_factors;\n}"
        }
      ],
      "tests": [
        {
          "text": "`factors` should be a function.",
          "testCode": "assert(typeof factors === 'function');"
        },
        {
          "text": "`factors(45)` should return `[1,3,5,9,15,45]`.",
          "testCode": "assert.deepEqual(factors(45), ans[0]);"
        },
        {
          "text": "`factors(53)` should return `[1,53]`.",
          "testCode": "assert.deepEqual(factors(53), ans[1]);"
        },
        {
          "text": "`factors(64)` should return `[1,2,4,8,16,32,64]`.",
          "testCode": "assert.deepEqual(factors(64), ans[2]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302265,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\factors-of-an-integer.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const ans=[[1,3,5,9,15,45],[1,53],[1,2,4,8,16,32,64]];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59c3ec9f15068017c96eb8a3",
      "title": "Farey sequence",
      "challengeType": 1,
      "dashedName": "farey-sequence",
      "description": "The Farey sequence <code>F<sub>n</sub></code> of order `n` is the sequence of completely reduced fractions between `0` and `1` which, when in lowest terms, have denominators less than or equal to `n`, arranged in order of increasing size.\n\nThe *Farey sequence* is sometimes incorrectly called a *Farey series*.\n\nEach Farey sequence:\n\n<ul>\n  <li>starts with the value  0,  denoted by the fraction  $ \\frac{0}{1} $</li>\n  <li>ends with the value  1,  denoted by the fraction  $ \\frac{1}{1}$.</li>\n</ul>\n\nThe Farey sequences of orders `1` to `5` are:\n\n<ul>\n  <li style='list-style: none;'>${\\bf\\it{F}}_1 = \\frac{0}{1}, \\frac{1}{1}$</li>\n  <li style='list-style: none;'>${\\bf\\it{F}}_2 = \\frac{0}{1}, \\frac{1}{2}, \\frac{1}{1}$</li>\n  <li style='list-style: none;'>${\\bf\\it{F}}_3 = \\frac{0}{1}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{1}{1}$</li>\n  <li style='list-style: none;'>${\\bf\\it{F}}_4 = \\frac{0}{1}, \\frac{1}{4}, \\frac{1}{3}, \\frac{1}{2}, \\frac{2}{3}, \\frac{3}{4}, \\frac{1}{1}$</li>\n  <li style='list-style: none;'>${\\bf\\it{F}}_5 = \\frac{0}{1}, \\frac{1}{5}, \\frac{1}{4}, \\frac{1}{3}, \\frac{2}{5}, \\frac{1}{2}, \\frac{3}{5}, \\frac{2}{3}, \\frac{3}{4}, \\frac{4}{5}, \\frac{1}{1}$</li>\n</ul>",
      "instructions": "Write a function that returns the Farey sequence of order `n`. The function should have one parameter that is `n`. It should return the sequence as an array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function farey(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function farey(n) {\n  const sequence = [{ string: \"0/1\", float: 0.0 }];\n  for (let i = 1; i < n; i++) {\n    for (let j = n; j >= i; j--) {\n      if (i === 1 || j % i > 0) {\n        sequence.push({ string: `${i}/${j}`, float: i / j });\n      }\n    }\n  }\n  return sequence\n    .sort((a, b) => a.float - b.float)\n    .map(e => e.string)\n}"
        }
      ],
      "tests": [
        {
          "text": "`farey` should be a function.",
          "testCode": "assert(typeof farey === 'function');"
        },
        {
          "text": "`farey(3)` should return an array",
          "testCode": "assert(Array.isArray(farey(3)));"
        },
        {
          "text": "`farey(3)` should return `['0/1','1/3','1/2','2/3','1/1']`",
          "testCode": "assert.deepEqual(farey(3),['0/1', '1/3', '1/2', '2/3', '1/1']);"
        },
        {
          "text": "`farey(4)` should return `['0/1','1/4','1/3','1/2','2/3','3/4','1/1']`",
          "testCode": "assert.deepEqual(farey(4), ['0/1', '1/4', '1/3', '1/2', '2/3', '3/4', '1/1']);"
        },
        {
          "text": "`farey(5)` should return `['0/1','1/5','1/4','1/3','2/5','1/2','3/5','2/3','3/4','4/5','1/1']`",
          "testCode": "assert.deepEqual(farey(5), [\n  '0/1',\n  '1/5',\n  '1/4',\n  '1/3',\n  '2/5',\n  '1/2',\n  '3/5',\n  '2/3',\n  '3/4',\n  '4/5',\n  '1/1'\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302266,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\farey-sequence.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "598eef80ba501f1268170e1e",
      "title": "Fibonacci n-step number sequences",
      "challengeType": 1,
      "dashedName": "fibonacci-n-step-number-sequences",
      "description": "These number series are an expansion of the ordinary Fibonacci sequence where:\n\n<ol>\n  <li>For $n = 2$ we have the Fibonacci sequence; with initial values $[1, 1]$ and $F_k^2 = F_{k-1}^2 + F_{k-2}^2$</li>\n  <li>For $n = 3$ we have the tribonacci sequence; with initial values $[1, 1, 2]$ and $F_k^3 = F_{k-1}^3 + F_{k-2}^3 + F_{k-3}^3$</li>\n  <li>For $n = 4$ we have the tetranacci sequence; with initial values $[1, 1, 2, 4]$ and $F_k^4 = F_{k-1}^4 + F_{k-2}^4 + F_{k-3}^4 + F_{k-4}^4$...</li>\n  <li>For general $n>2$ we have the Fibonacci $n$-step sequence - $F_k^n$; with initial values of the first $n$ values of the $(n-1)$'th Fibonacci $n$-step sequence $F_k^{n-1}$; and $k$'th value of this $n$'th sequence being $F_k^n = \\sum_{i=1}^{(n)} {F_{k-i}^{(n)}}$</li>\n</ol>\n\nFor small values of $n$, Greek numeric prefixes are sometimes used to individually name each series.\n\nFibonacci $n$-step sequences:\n\n| $n$ | Series name | Values                                                 |\n| --- | ----------- | ------------------------------------------------------ |\n| 2   | fibonacci   | 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 ...         |\n| 3   | tribonacci  | 1 1 2 4 7 13 24 44 81 149 274 504 927 1705 3136 ...    |\n| 4   | tetranacci  | 1 1 2 4 8 15 29 56 108 208 401 773 1490 2872 5536 ...  |\n| 5   | pentanacci  | 1 1 2 4 8 16 31 61 120 236 464 912 1793 3525 6930 ...  |\n| 6   | hexanacci   | 1 1 2 4 8 16 32 63 125 248 492 976 1936 3840 7617 ...  |\n| 7   | heptanacci  | 1 1 2 4 8 16 32 64 127 253 504 1004 2000 3984 7936 ... |\n| 8   | octonacci   | 1 1 2 4 8 16 32 64 128 255 509 1016 2028 4048 8080 ... |\n| 9   | nonanacci   | 1 1 2 4 8 16 32 64 128 256 511 1021 2040 4076 8144 ... |\n| 10  | decanacci   | 1 1 2 4 8 16 32 64 128 256 512 1023 2045 4088 8172 ... |\n\nAllied sequences can be generated where the initial values are changed: The Lucas series sums the two preceding values like the fibonacci series for $n=2$ but uses $\\[2, 1]$ as its initial values.",
      "instructions": "Write a function to generate Fibonacci $n$-step number sequences and Lucas sequences. The first parameter will be $n$. The second parameter will be the number of elements to be returned. The third parameter will specify whether to output the Fibonacci sequence or the Lucas sequence. If the parameter is `\"f\"` then return the Fibonacci sequence and if it is `\"l\"`, then return the Lucas sequence. The sequences must be returned as an array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function fib_luc(n, len, w) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function fib_luc(n, len, w) {\n    function nacci(a, n, len) {\n        while (a.length < len) {\n            let sum = 0;\n            for (let i = Math.max(0, a.length - n); i < a.length; i++)\n                sum += a[i];\n            a.push(sum);\n        }\n        return a;\n    }\n    if(w==\"f\"){\n        return nacci(nacci([1,1], n, n), n, len);\n    }else{\n        return nacci(nacci([2,1], n, n), n, len);\n    }\n}"
        }
      ],
      "tests": [
        {
          "text": "`fib_luc` should be a function.",
          "testCode": "assert(typeof fib_luc === 'function');"
        },
        {
          "text": "`fib_luc(2,10,\"f\")` should return `[1,1,2,3,5,8,13,21,34,55]`.",
          "testCode": "assert.deepEqual(fib_luc(2, 10, 'f'), ans[0]);"
        },
        {
          "text": "`fib_luc(3,15,\"f\")` should return `[1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136]`.",
          "testCode": "assert.deepEqual(fib_luc(3, 15, 'f'), ans[1]);"
        },
        {
          "text": "`fib_luc(4,15,\"f\")` should return `[1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536]`.",
          "testCode": "assert.deepEqual(fib_luc(4, 15, 'f'), ans[2]);"
        },
        {
          "text": "`fib_luc(2,10,\"l\")` should return `[ 2, 1, 3, 4, 7, 11, 18, 29, 47, 76]`.",
          "testCode": "assert.deepEqual(fib_luc(2, 10, 'l'), ans[3]);"
        },
        {
          "text": "`fib_luc(3,15,\"l\")` should return `[ 2, 1, 3, 6, 10, 19, 35, 64, 118, 217, 399, 734, 1350, 2483, 4567 ]`.",
          "testCode": "assert.deepEqual(fib_luc(3, 15, 'l'), ans[4]);"
        },
        {
          "text": "`fib_luc(4,15,\"l\")` should return `[ 2, 1, 3, 6, 12, 22, 43, 83, 160, 308, 594, 1145, 2207, 4254, 8200 ]`.",
          "testCode": "assert.deepEqual(fib_luc(4, 15, 'l'), ans[5]);"
        },
        {
          "text": "`fib_luc(5,15,\"l\")` should return `[ 2, 1, 3, 6, 12, 24, 46, 91, 179, 352, 692, 1360, 2674, 5257, 10335 ]`.",
          "testCode": "assert.deepEqual(fib_luc(5, 15, 'l'), ans[6]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302267,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\fibonacci-n-step-number-sequences.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const ans = [[1,1,2,3,5,8,13,21,34,55],\n[1,1,2,4,7,13,24,44,81,149,274,504,927,1705,3136],\n[1,1,2,4,8,15,29,56,108,208,401,773,1490,2872,5536],\n[ 2, 1, 3, 4, 7, 11, 18, 29, 47, 76],\n[ 2, 1, 3, 6, 10, 19, 35, 64, 118, 217, 399, 734, 1350, 2483, 4567 ],\n[ 2, 1, 3, 6, 12, 22, 43, 83, 160, 308, 594, 1145, 2207, 4254, 8200 ],\n[ 2, 1, 3, 6, 12, 24, 46, 91, 179, 352, 692, 1360, 2674, 5257, 10335 ]];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "597f24c1dda4e70f53c79c81",
      "title": "Fibonacci sequence",
      "challengeType": 1,
      "dashedName": "fibonacci-sequence",
      "description": "Write a function to generate the <code>n<sup>th</sup></code> Fibonacci number.\n\nThe <code>n<sup>th</sup></code> Fibonacci number is given by:\n\n<code>F<sub>n</sub> = F<sub>n-1</sub> + F<sub>n-2</sub></code>\n\nThe first two terms of the series are 0 and 1.\n\nHence, the series is: 0, 1, 1, 2, 3, 5, 8, 13...",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function fibonacci(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function fibonacci(n) {\n  let a = 0, b = 1, t;\n  while (--n >= 0) {\n    t = a;\n    a = b;\n    b += t;\n  }\n  return a;\n}"
        }
      ],
      "tests": [
        {
          "text": "`fibonacci` should be a function.",
          "testCode": "assert(typeof fibonacci === 'function');"
        },
        {
          "text": "`fibonacci(2)` should return a number.",
          "testCode": "assert(typeof fibonacci(2) == 'number');"
        },
        {
          "text": "`fibonacci(3)` should return 2.",
          "testCode": "assert.equal(fibonacci(3), 2);"
        },
        {
          "text": "`fibonacci(5)` should return 5.",
          "testCode": "assert.equal(fibonacci(5), 5);"
        },
        {
          "text": "`fibonacci(10)` should return 55.",
          "testCode": "assert.equal(fibonacci(10), 55);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302268,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\fibonacci-sequence.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5992e222d397f00d21122931",
      "title": "Fibonacci word",
      "challengeType": 1,
      "dashedName": "fibonacci-word",
      "description": "The Fibonacci Word Sequence may be created in a manner analogous to the Fibonacci Sequence, but it focuses on iterating concatenation.\n\n<pre>Define  F_Word<sub>1</sub>  as  <strong>1</strong>\nDefine  F_Word<sub>2</sub>  as  <strong>0</strong>\nForm   F_Word<sub>3</sub>  as  F_Word<sub>2</sub>   concatenated with  F_Word<sub>1</sub>   i.e.:  <strong>01</strong>\nForm   F_Word<sub>n</sub>  as  F_Word<sub>n-1</sub>  concatenated with  F_word<sub>n-2</sub>\n</pre>\n\nEntropy calculation is required in this challenge, <a href=\"https://www.freecodecamp.org/learn/coding-interview-prep/rosetta-code/entropy\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">as shown in this Rosetta Code challenge</a>",
      "instructions": "Write a function to return the first `n` Fibonacci Words. The number of `n` is provided as a parameter to the function. The function should return an array of objects. The objects should be of the form: `{ N: 1, Length: 1, Entropy: 0, Word: '1' }`. `Entropy` is computed for the string `Word` and rounded to 8 decimal digits of accuracy. Note that the indices of this sequence start at `1`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function fibWord(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// Round to digits\nfunction roundFloat(num, digits) {\n  return Math.round(num * 10.0**digits) / (10.0**digits);\n}\n\n// Entropy calculation for string with only 0 and 1\nfunction entropy(word) {\n  function digitEntropy(count) {\n    return count < 1 ? 0\n      : - count / word.length * Math.log2(count / word.length);\n  }\n  const numZeros = word.split('').filter(e => e === '0').length;\n  const numOnes  = word.length - numZeros;\n  return roundFloat(digitEntropy(numZeros) + digitEntropy(numOnes), 8);\n}\n\n// Compute array of Fibonacci words\nfunction fibWord(n) {\n  return [...Array(n).keys()]\n    .reduce((words, i) => {\n      const word = i === 0 ? \"1\"\n                 : i === 1 ? \"0\"\n                 : words[i - 1].Word + words[i - 2].Word;\n      words.push(\n        { N: i + 1, Length: word.length, Entropy: entropy(word), Word: word }\n      );\n      return words;\n    }, []);\n}"
        }
      ],
      "tests": [
        {
          "text": "`fibWord` should be a function.",
          "testCode": "assert(typeof fibWord === 'function');"
        },
        {
          "text": "`fibWord(5)` should return an array.",
          "testCode": "assert(Array.isArray(fibWord(5)));"
        },
        {
          "text": "`fibWord(5)` should return `[{ N:1, Length:1, Entropy:0, Word:\"1\" },{ N:2, Length:1, Entropy:0, Word:\"0\" },{ N:3, Length:2, Entropy:1, Word:\"01\" },{ N:4, Length:3, Entropy:0.91829583, Word:\"010\" },{ N:5, Length:5, Entropy:0.97095059, Word:\"01001\" }]`.",
          "testCode": "assert.deepEqual(fibWord(5), words5);"
        },
        {
          "text": "`fibWord(7)` should return `[{ N:1, Length:1, Entropy:0, Word:\"1\" },{ N:2, Length:1, Entropy:0, Word:\"0\" },{ N:3, Length:2, Entropy:1, Word:\"01\" },{ N:4, Length:3, Entropy:0.91829583, Word:\"010\" },{ N:5, Length:5, Entropy:0.97095059, Word:\"01001\" }, { N:6, Length:8, Entropy:0.954434, Word:'01001010' }, { N:7, Length:13, Entropy:0.9612366, Word:'0100101001001' }]`.",
          "testCode": "assert.deepEqual(fibWord(7), words7);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302269,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\fibonacci-word.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const words5 = [\n  { N: 1, Length: 1, Entropy: 0, Word: '1' },\n  { N: 2, Length: 1, Entropy: 0, Word: '0' },\n  { N: 3, Length: 2, Entropy: 1, Word: '01' },\n  { N: 4, Length: 3, Entropy: 0.91829583, Word: '010' },\n  { N: 5, Length: 5, Entropy: 0.97095059, Word: '01001' }\n];\n\nconst words7 = [\n  { N: 1, Length: 1, Entropy: 0, Word: '1' },\n  { N: 2, Length: 1, Entropy: 0, Word: '0' },\n  { N: 3, Length: 2, Entropy: 1, Word: '01' },\n  { N: 4, Length: 3, Entropy: 0.91829583, Word: '010' },\n  { N: 5, Length: 5, Entropy: 0.97095059, Word: '01001' },\n  { N: 6, Length: 8, Entropy: 0.954434, Word: '01001010' },\n  { N: 7, Length: 13, Entropy: 0.9612366, Word: '0100101001001' }\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e9ddb06ec35240f39657419",
      "title": "FizzBuzz",
      "challengeType": 1,
      "dashedName": "fizzbuzz",
      "description": "Write a program that generates an array of integers from 1 to 100 (inclusive). But:\n\n<ul>\n    <li>for multiples of 3, add <code>\"Fizz\"</code> to the array instead of the number</li>\n    <li>for multiples of 5, add <code>\"Buzz\"</code> to the array instead of the number</li>\n    <li>for multiples of 3 and 5, add <code>\"FizzBuzz\"</code> to the array instead of the number</li>\n</ul>",
      "instructions": "Your program should return an array containing the results based on the rules above.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function fizzBuzz() {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function fizzBuzz() {\n    let res=[];\n    for (let i =1; i < 101; i++) {\n        if (i % 3 === 0  && i % 5 === 0) {\n            res.push(\"FizzBuzz\");\n        }\n        else if (i % 3 === 0) {\n            res.push(\"Fizz\");\n        }\n        else if (i % 5 === 0) {\n            res.push(\"Buzz\");\n        } \n        else {\n            res.push(i);\n        }\n    }\n    return res;\n}"
        }
      ],
      "tests": [
        {
          "text": "`fizzBuzz` should be a function.",
          "testCode": "assert(typeof fizzBuzz == 'function');"
        },
        {
          "text": "`fizzBuzz()` should return an Array.",
          "testCode": "assert(Array.isArray(fizzBuzz()) == true);"
        },
        {
          "text": "Numbers divisible by only 3 should return `\"Fizz\"`.",
          "testCode": "assert.equal(fizzBuzz()[2], 'Fizz');"
        },
        {
          "text": "Numbers divisible by only 5 should return `\"Buzz\"`.",
          "testCode": "assert.equal(fizzBuzz()[99], 'Buzz');"
        },
        {
          "text": "Numbers divisible by both 3 and 5 should return `\"FizzBuzz\"`.",
          "testCode": "assert.equal(fizzBuzz()[89], 'FizzBuzz');"
        },
        {
          "text": "Numbers not divisible by either 3 or 5 should return the number itself.",
          "testCode": "assert.equal(fizzBuzz()[12], 13);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385370,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\fizzbuzz.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a7dad05be01840e1778a0d1",
      "title": "Fractran",
      "challengeType": 1,
      "dashedName": "fractran",
      "description": "FRACTRAN is a Turing-complete esoteric programming language invented by the mathematician John Horton Conway.\n\nA FRACTRAN program is an ordered list of positive fractions $P = (f_1, f_2, \\\\ldots, f_m)$, together with an initial positive integer input $n$.\n\nThe program is run by updating the integer $n$ as follows:\n\n<ul>\n  <li>for the first fraction, $f_i$, in the list for which $nf_i$ is an integer, replace $n$ with $nf_i$ ;</li>\n  <li>repeat this rule until no fraction in the list produces an integer when multiplied by $n$, then halt.</li>\n</ul>\n\nConway gave a program for primes in FRACTRAN:\n\n$\\\\dfrac{17}{91}$, $\\\\dfrac{78}{85}$, $\\\\dfrac{19}{51}$, $\\\\dfrac{23}{38}$, $\\\\dfrac{29}{33}$, $\\\\dfrac{77}{29}$, $\\\\dfrac{95}{23}$, $\\\\dfrac{77}{19}$, $\\\\dfrac{1}{17}$, $\\\\dfrac{11}{13}$, $\\\\dfrac{13}{11}$, $\\\\dfrac{15}{14}$, $\\\\dfrac{15}{2}$, $\\\\dfrac{55}{1}$\n\nStarting with $n=2$, this FRACTRAN program will change $n$ to $15=2\\\\times (\\\\frac{15}{2})$, then $825=15\\\\times (\\\\frac{55}{1})$, generating the following sequence of integers:\n\n$2$, $15$, $825$, $725$, $1925$, $2275$, $425$, $390$, $330$, $290$, $770$, $\\\\ldots$\n\nAfter 2, this sequence contains the following powers of 2:\n\n$2^2=4$, $2^3=8$, $2^5=32$, $2^7=128$, $2^{11}=2048$, $2^{13}=8192$, $2^{17}=131072$, $2^{19}=524288$, $\\\\ldots$\n\nwhich are the prime powers of 2.",
      "instructions": "Write a function that takes a fractran program as a string parameter and returns the first 10 numbers of the program as an array. If the result does not have 10 numbers then return the numbers as is.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function fractran(progStr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function fractran(progStr){\n  var num = new Array();\n  var den = new Array();\n  var val ;\n  var out=\"\";\n  function compile(prog){\n    var regex = /\\s*(\\d*)\\s*\\/\\s*(\\d*)\\s*(.*)/m;\n    while(regex.test(prog)){\n      num.push(regex.exec(prog)[1]);\n      den.push(regex.exec(prog)[2]);\n      prog = regex.exec(prog)[3];\n    }\n  }\n\n  function step(val){\n    var i=0;\n    while(i<den.length && val%den[i] != 0) i++;\n    return num[i]*val/den[i];\n  }\n\n  var seq=[]\n\n  function exec(val){\n    var i = 0;\n    while(val && i<limit){\n      seq.push(val)\n      val = step(val);\n      i ++;\n    }\n  }\n\n  // Main\n  compile(progStr);\n  var limit = 10;\n  exec(2);\n  return seq;\n}"
        }
      ],
      "tests": [
        {
          "text": "`fractran` should be a function.",
          "testCode": "assert(typeof fractran == 'function');"
        },
        {
          "text": "`fractran(\"3/2, 1/3\")` should return an array.",
          "testCode": "assert(Array.isArray(fractran('3/2, 1/3')));"
        },
        {
          "text": "`fractran(\"3/2, 1/3\")` should return `[ 2, 3, 1 ]`.",
          "testCode": "assert.deepEqual(fractran('3/2, 1/3'), [2, 3, 1]);"
        },
        {
          "text": "`fractran(\"3/2, 5/3, 1/5\")` should return `[ 2, 3, 5, 1 ]`.",
          "testCode": "assert.deepEqual(fractran('3/2, 5/3, 1/5'), [2, 3, 5, 1]);"
        },
        {
          "text": "`fractran(\"3/2, 6/3\")` should return `[ 2, 3, 6, 9, 18, 27, 54, 81, 162, 243 ]`.",
          "testCode": "assert.deepEqual(fractran('3/2, 6/3'), [2, 3, 6, 9, 18, 27, 54, 81, 162, 243]);"
        },
        {
          "text": "`fractran(\"2/7, 7/2\")` should return `[ 2, 7, 2, 7, 2, 7, 2, 7, 2, 7 ]`.",
          "testCode": "assert.deepEqual(fractran('2/7, 7/2'), [2, 7, 2, 7, 2, 7, 2, 7, 2, 7]);"
        },
        {
          "text": "`fractran(\"17/91, 78/85, 19/51, 23/38, 29/33, 77/29, 95/23, 77/19, 1/17, 11/13, 13/11, 15/14, 15/2, 55/1\")` should return `[ 2, 15, 825, 725, 1925, 2275, 425, 390, 330, 290 ]`.",
          "testCode": "assert.deepEqual(\n  fractran(\n    '17/91, 78/85, 19/51, 23/38, 29/33, 77/29, 95/23, 77/19, 1/17, 11/13, 13/11, 15/14, 15/2, 55/1'\n  ),\n  [2, 15, 825, 725, 1925, 2275, 425, 390, 330, 290]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302270,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\fractran.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e76",
      "title": "Gamma function",
      "challengeType": 1,
      "dashedName": "gamma-function",
      "description": "Implement one algorithm (or more) to compute the Gamma function (in the real field only).\n\nThe Gamma function can be defined as:\n\n<div style='padding-left: 4em;'><big><big>$\\Gamma(x) = \\displaystyle\\int_0^\\infty t^{x-1}e^{-t} dt$</big></big></div>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function gamma(x) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function gamma(x) {\n  var p = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n  771.32342877765313, -176.61502916214059, 12.507343278686905,\n  -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7\n  ];\n\n  var g = 7;\n  if (x < 0.5) {\n    return Math.PI / (Math.sin(Math.PI * x) * gamma(1 - x));\n  }\n\n  x -= 1;\n  var a = p[0];\n  var t = x + g + 0.5;\n  for (var i = 1; i < p.length; i++) {\n  a += p[i] / (x + i);\n  }\n\n  var result=Math.sqrt(2 * Math.PI) * Math.pow(t, x + 0.5) * Math.exp(-t) * a;\n\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`gamma` should be a function.",
          "testCode": "assert(typeof gamma == 'function');"
        },
        {
          "text": "`gamma(.1)` should return a number.",
          "testCode": "assert(typeof gamma(0.1) == 'number');"
        },
        {
          "text": "`gamma(.1)` should return `9.513507698668736`.",
          "testCode": "assert.equal(round(gamma(0.1)), round(9.513507698668736));"
        },
        {
          "text": "`gamma(.2)` should return `4.590843711998803`.",
          "testCode": "assert.equal(round(gamma(0.2)), round(4.590843711998803));"
        },
        {
          "text": "`gamma(.3)` should return `2.9915689876875904`.",
          "testCode": "assert.equal(round(gamma(0.3)), round(2.9915689876875904));"
        },
        {
          "text": "`gamma(.4)` should return `2.218159543757687`.",
          "testCode": "assert.equal(round(gamma(0.4)), round(2.218159543757687));"
        },
        {
          "text": "`gamma(.5)` should return `1.7724538509055159`.",
          "testCode": "assert.equal(round(gamma(0.5)), round(1.7724538509055159));"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302271,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\gamma-function.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "function round(x) {\n  return Number(x).toPrecision(13);\n}"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e77",
      "title": "Gaussian elimination",
      "challengeType": 1,
      "dashedName": "gaussian-elimination",
      "description": "Write a function to solve \\\\(Ax = b\\\\) using Gaussian elimination then backwards substitution.\n\n\\\\(A\\\\) being an \\\\(n \\\\times n\\\\) matrix. Also, \\\\(x\\\\) and \\\\(b\\\\) are \\\\(n\\\\) by 1 vectors.\n\nTo improve accuracy, please use partial pivoting and scaling.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function gaussianElimination(A,b) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function gaussianElimination(A, b) {\n  // Lower Upper Decomposition\n  function ludcmp(A) {\n    // A is a matrix that we want to decompose into Lower and Upper matrices.\n    var d = true\n    var n = A.length\n    var idx = new Array(n) // Output vector with row permutations from partial pivoting\n    var vv = new Array(n) // Scaling information\n\n    for (var i=0; i<n; i++) {\n        var max = 0\n        for (var j=0; j<n; j++) {\n            var temp = Math.abs(A[i][j])\n            if (temp > max) max = temp\n        }\n        if (max == 0) return // Singular Matrix!\n        vv[i] = 1 / max // Scaling\n    }\n\n        var Acpy = new Array(n)\n        for (var i=0; i<n; i++) {\n            var Ai = A[i]\n            let Acpyi = new Array(Ai.length)\n            for (j=0; j<Ai.length; j+=1) Acpyi[j] = Ai[j]\n            Acpy[i] = Acpyi\n        }\n        A = Acpy\n\n    var tiny = 1e-20 // in case pivot element is zero\n    for (var i=0; ; i++) {\n        for (var j=0; j<i; j++) {\n            var sum = A[j][i]\n            for (var k=0; k<j; k++) sum -= A[j][k] * A[k][i];\n            A[j][i] = sum\n        }\n        var jmax = 0\n        var max = 0;\n        for (var j=i; j<n; j++) {\n            var sum = A[j][i]\n            for (var k=0; k<i; k++) sum -= A[j][k] * A[k][i];\n            A[j][i] = sum\n            var temp = vv[j] * Math.abs(sum)\n            if (temp >= max) {\n                max = temp\n                jmax = j\n            }\n        }\n        if (i <= jmax) {\n            for (var j=0; j<n; j++) {\n                var temp = A[jmax][j]\n                A[jmax][j] = A[i][j]\n                A[i][j] = temp\n            }\n            d = !d;\n            vv[jmax] = vv[i]\n        }\n        idx[i] = jmax;\n        if (i == n-1) break;\n        var temp = A[i][i]\n        if (temp == 0) A[i][i] = temp = tiny\n        temp = 1 / temp\n        for (var j=i+1; j<n; j++) A[j][i] *= temp\n    }\n    return {A:A, idx:idx, d:d}\n  }\n\n  // Lower Upper Back Substitution\n  function lubksb(lu, b) {\n    // solves the set of n linear equations A*x = b.\n    // lu is the object containing A, idx and d as determined by the routine ludcmp.\n    var A = lu.A\n    var idx = lu.idx\n    var n = idx.length\n\n        var bcpy = new Array(n)\n        for (var i=0; i<b.length; i+=1) bcpy[i] = b[i]\n        b = bcpy\n\n    for (var ii=-1, i=0; i<n; i++) {\n        var ix = idx[i]\n        var sum = b[ix]\n        b[ix] = b[i]\n        if (ii > -1)\n            for (var j=ii; j<i; j++) sum -= A[i][j] * b[j]\n        else if (sum)\n            ii = i\n        b[i] = sum\n    }\n    for (var i=n-1; i>=0; i--) {\n        var sum = b[i]\n        for (var j=i+1; j<n; j++) sum -= A[i][j] * b[j]\n        b[i] = sum / A[i][i]\n    }\n    return b // solution vector x\n  }\n\n    var lu = ludcmp(A)\n    if (lu === undefined) return // Singular Matrix!\n    return lubksb(lu, b)\n}"
        }
      ],
      "tests": [
        {
          "text": "`gaussianElimination` should be a function.",
          "testCode": "assert(typeof gaussianElimination == 'function');"
        },
        {
          "text": "`gaussianElimination([[1,1],[1,-1]], [5,1])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    gaussianElimination(\n      [\n        [1, 1],\n        [1, -1]\n      ],\n      [5, 1]\n    )\n  )\n);"
        },
        {
          "text": "`gaussianElimination([[1,1],[1,-1]], [5,1])` should return `[ 3, 2 ]`.",
          "testCode": "assert.deepEqual(\n  gaussianElimination(\n    [\n      [1, 1],\n      [1, -1]\n    ],\n    [5, 1]\n  ),\n  [3, 2]\n);"
        },
        {
          "text": "`gaussianElimination([[2,3],[2,1]] , [8,4])` should return `[ 1, 2 ]`.",
          "testCode": "assert.deepEqual(\n  gaussianElimination(\n    [\n      [2, 3],\n      [2, 1]\n    ],\n    [8, 4]\n  ),\n  [1, 2]\n);"
        },
        {
          "text": "`gaussianElimination([[1,3],[5,-2]], [14,19])` should return `[ 5, 3 ]`.",
          "testCode": "assert.deepEqual(\n  gaussianElimination(\n    [\n      [1, 3],\n      [5, -2]\n    ],\n    [14, 19]\n  ),\n  [5, 3]\n);"
        },
        {
          "text": "`gaussianElimination([[1,1],[5,-1]] , [10,14])` should return `[ 4, 6 ]`.",
          "testCode": "assert.deepEqual(\n  gaussianElimination(\n    [\n      [1, 1],\n      [5, -1]\n    ],\n    [10, 14]\n  ),\n  [4, 6]\n);"
        },
        {
          "text": "`gaussianElimination([[1,2,3],[4,5,6],[7,8,8]] , [6,15,23])` should return `[ 1, 1, 1 ]`.",
          "testCode": "assert.deepEqual(\n  gaussianElimination(\n    [\n      [1, 2, 3],\n      [4, 5, 6],\n      [7, 8, 8]\n    ],\n    [6, 15, 23]\n  ),\n  [1, 1, 1]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302272,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\gaussian-elimination.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e78",
      "title": "General FizzBuzz",
      "challengeType": 1,
      "dashedName": "general-fizzbuzz",
      "description": "Write a generalized version of <a href=\"https://rosettacode.org/wiki/FizzBuzz\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">FizzBuzz</a> that works for any list of factors, along with their words.\n\nThis is basically a \"fizzbuzz\" implementation where the rules of the game are supplied to the user. Create a function to implement this. The function should take two parameters.\n\nThe first will be an array with the FizzBuzz rules. For example: `[ [3, \"Fizz\"] , [5, \"Buzz\"] ]`.\n\nThis indicates that `Fizz` should be printed if the number is a multiple of 3 and `Buzz` if it is a multiple of 5. If it is a multiple of both then the strings should be concatenated in the order specified in the array. In this case, `FizzBuzz` if the number is a multiple of 3 and 5.\n\nThe second parameter is the number for which the function should return a string as stated above.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function genFizzBuzz(rules, num) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function genFizzBuzz(rules, num) {\n  let res='';\n  rules.forEach(function (e) {\n    if(num % e[0] == 0)\n      res+=e[1];\n  })\n\n  if(res==''){\n    res=num.toString();\n  }\n\n  return res;\n}"
        }
      ],
      "tests": [
        {
          "text": "`genFizzBuzz` should be a function.",
          "testCode": "assert(typeof genFizzBuzz == 'function');"
        },
        {
          "text": "`genFizzBuzz([[3, \"Fizz\"],[5, \"Buzz\"]], 6)` should return a string.",
          "testCode": "assert(\n  typeof genFizzBuzz(\n    [\n      [3, 'Fizz'],\n      [5, 'Buzz']\n    ],\n    6\n  ) == 'string'\n);"
        },
        {
          "text": "`genFizzBuzz([[3, \"Fizz\"],[5, \"Buzz\"]], 6)` should return `\"Fizz\"`.",
          "testCode": "assert.equal(\n  genFizzBuzz(\n    [\n      [3, 'Fizz'],\n      [5, 'Buzz']\n    ],\n    6\n  ),\n  'Fizz'\n);"
        },
        {
          "text": "`genFizzBuzz([[3, \"Fizz\"],[5, \"Buzz\"]], 10)` should return `\"Buzz\"`.",
          "testCode": "assert.equal(\n  genFizzBuzz(\n    [\n      [3, 'Fizz'],\n      [5, 'Buzz']\n    ],\n    10\n  ),\n  'Buzz'\n);"
        },
        {
          "text": "`genFizzBuzz([[3, \"Buzz\"],[5, \"Fizz\"]], 12)` should return `\"Buzz\"`.",
          "testCode": "assert.equal(\n  genFizzBuzz(\n    [\n      [3, 'Buzz'],\n      [5, 'Fizz']\n    ],\n    12\n  ),\n  'Buzz'\n);"
        },
        {
          "text": "`genFizzBuzz([[3, \"Buzz\"],[5, \"Fizz\"]], 13)` should return `\"13\"`.",
          "testCode": "assert.equal(\n  genFizzBuzz(\n    [\n      [3, 'Buzz'],\n      [5, 'Fizz']\n    ],\n    13\n  ),\n  '13'\n);"
        },
        {
          "text": "`genFizzBuzz([[3, \"Buzz\"],[5, \"Fizz\"]], 15)` should return `\"BuzzFizz\"`.",
          "testCode": "assert.equal(\n  genFizzBuzz(\n    [\n      [3, 'Buzz'],\n      [5, 'Fizz']\n    ],\n    15\n  ),\n  'BuzzFizz'\n);"
        },
        {
          "text": "`genFizzBuzz([[3, \"Fizz\"],[5, \"Buzz\"]], 15)` should return `\"FizzBuzz\"`.",
          "testCode": "assert.equal(\n  genFizzBuzz(\n    [\n      [3, 'Fizz'],\n      [5, 'Buzz']\n    ],\n    15\n  ),\n  'FizzBuzz'\n);"
        },
        {
          "text": "`genFizzBuzz([[3, \"Fizz\"],[5, \"Buzz\"],[7, \"Baxx\"]], 105)` should return `\"FizzBuzzBaxx\"`.",
          "testCode": "assert.equal(\n  genFizzBuzz(\n    [\n      [3, 'Fizz'],\n      [5, 'Buzz'],\n      [7, 'Baxx']\n    ],\n    105\n  ),\n  'FizzBuzzBaxx'\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302273,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\general-fizzbuzz.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e7a",
      "title": "Generate lower case ASCII alphabet",
      "challengeType": 1,
      "dashedName": "generate-lower-case-ascii-alphabet",
      "description": "Write a function to generate an array of lower case ASCII characters for a given range. For example, given the range `['a', 'd']`, the function should return `['a', 'b', 'c', 'd']`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function lascii(cFrom, cTo) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function lascii(cFrom, cTo) {\n\n  function cRange(cFrom, cTo) {\n    var iStart = cFrom.charCodeAt(0);\n\n    return Array.apply(\n      null, Array(cTo.charCodeAt(0) - iStart + 1)\n    ).map(function (_, i) {\n\n      return String.fromCharCode(iStart + i);\n\n    });\n  }\n\n  return cRange(cFrom, cTo);\n\n}"
        }
      ],
      "tests": [
        {
          "text": "`lascii` should be a function.",
          "testCode": "assert(typeof lascii == 'function');"
        },
        {
          "text": "`lascii(\"a\",\"d\")` should return an array.",
          "testCode": "assert(Array.isArray(lascii('a', 'd')));"
        },
        {
          "text": "`lascii('a','d')` should return `[ 'a', 'b', 'c', 'd' ]`.",
          "testCode": "assert.deepEqual(lascii('a', 'd'), results[0]);"
        },
        {
          "text": "`lascii('c','i')` should return `[ 'c', 'd', 'e', 'f', 'g', 'h', 'i' ]`.",
          "testCode": "assert.deepEqual(lascii('c', 'i'), results[1]);"
        },
        {
          "text": "`lascii('m','q')` should return `[ 'm', 'n', 'o', 'p', 'q' ]`.",
          "testCode": "assert.deepEqual(lascii('m', 'q'), results[2]);"
        },
        {
          "text": "`lascii('k','n')` should return `[ 'k', 'l', 'm', 'n' ]`.",
          "testCode": "assert.deepEqual(lascii('k', 'n'), results[3]);"
        },
        {
          "text": "`lascii('t','z')` should return `[ 't', 'u', 'v', 'w', 'x', 'y', 'z' ]`.",
          "testCode": "assert.deepEqual(lascii('t', 'z'), results[4]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302274,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\generate-lower-case-ascii-alphabet.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "let results=[\n  [ 'a', 'b', 'c', 'd' ],\n  [ 'c', 'd', 'e', 'f', 'g', 'h', 'i' ],\n  [ 'm', 'n', 'o', 'p', 'q' ],\n  [ 'k', 'l', 'm', 'n' ],\n  [ 't', 'u', 'v', 'w', 'x', 'y', 'z' ]\n]"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e7b",
      "title": "Generator/Exponential",
      "challengeType": 1,
      "dashedName": "generatorexponential",
      "description": "A generator is an executable entity (like a function or procedure) that contains code that yields a sequence of values, one at a time, so that each time you call the generator, the next value in the sequence is provided.\n\nGenerators are often built on top of coroutines or objects so that the internal state of the object is handled \"naturally\".\n\nGenerators are often used in situations where a sequence is potentially infinite, and where it is possible to construct the next value of the sequence with only minimal state.",
      "instructions": "Write a function that uses generators to generate squares and cubes. Create a new generator that filters all cubes from the generator of squares.\n\nThe function should return the \\\\( n^{th} \\\\) value of the filtered generator.\n\nFor example for \\\\(n=7\\\\), the function should return 81 as the sequence would be 4, 9, 16, 25, 36, 49, 81. Here 64 is filtered out, as it is a cube.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function exponentialGenerator(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function exponentialGenerator(n){\n  function* PowersGenerator(m) {\n    var n=0;\n    while(1) {\n        yield Math.pow(n, m);\n        n += 1;\n    }\n  }\n\n  function* FilteredGenerator(g, f){\n    var value = g.next().value;\n    var filter = f.next().value;\n    while(1) {\n        if( value < filter ) {\n            yield value;\n            value = g.next().value;\n        } else if ( value > filter ) {\n            filter = f.next().value;\n        } else {\n            value = g.next().value;\n            filter = f.next().value;\n        }\n    }\n  }\n\n  var squares = PowersGenerator(2);\n  var cubes = PowersGenerator(3);\n\n  var filtered = FilteredGenerator(squares, cubes);\n\n  var curr=0;\n  for(var i=0;i<n;i++) curr=filtered.next();\n\n  return curr.value;\n}"
        }
      ],
      "tests": [
        {
          "text": "`exponentialGenerator` should be a function.",
          "testCode": "assert(typeof exponentialGenerator == 'function');"
        },
        {
          "text": "`exponentialGenerator()` should return a number.",
          "testCode": "assert(typeof exponentialGenerator(10) == 'number');"
        },
        {
          "text": "`exponentialGenerator(10)` should return `144`.",
          "testCode": "assert.equal(exponentialGenerator(10), 144);"
        },
        {
          "text": "`exponentialGenerator(12)` should return `196`.",
          "testCode": "assert.equal(exponentialGenerator(12), 196);"
        },
        {
          "text": "`exponentialGenerator(14)` should return `256`.",
          "testCode": "assert.equal(exponentialGenerator(14), 256);"
        },
        {
          "text": "`exponentialGenerator(20)` should return `484`.",
          "testCode": "assert.equal(exponentialGenerator(20), 484);"
        },
        {
          "text": "`exponentialGenerator(25)` should return `784`.",
          "testCode": "assert.equal(exponentialGenerator(25), 784);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302275,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\generator-exponential.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e80",
      "title": "Gray code",
      "challengeType": 1,
      "dashedName": "gray-code",
      "description": "Gray code is a form of binary encoding where transitions between consecutive numbers differ by only one bit.\n\nThis is a useful encoding for reducing hardware data hazards with values that change rapidly and/or connect to slower hardware as inputs.\n\nIt is also useful for generating inputs for Karnaugh maps in order from left to right or top to bottom.",
      "instructions": "Create a function to encode a number to and decode a number from Gray code. The function should will have 2 parameters.\n\nThe first would be a boolean. The function should encode for true and decode for false. The second parameter would be the number to be encoded/decoded.\n\nDisplay the normal binary representations, Gray code representations, and decoded Gray code values for all 5-bit binary numbers (0-31 inclusive, leading 0's not necessary).\n\nThere are many possible Gray codes. The following encodes what is called \"binary reflected Gray code.\"\n\nEncoding (MSB is bit 0, b is binary, g is Gray code):\n\n<pre>if b[i-1] = 1\n  g[i] = not b[i]\nelse\n  g[i] = b[i]\n</pre>\n\nOr:\n\n<pre>g = b xor (b logically right shifted 1 time)\n</pre>\n\nDecoding (MSB is bit 0, b is binary, g is Gray code):\n\n<pre>b[0] = g[0]<br>\nfor other bits:\nb[i] = g[i] xor b[i-1]\n</pre>",
      "boilerplate": [
        {
          "language": "js",
          "code": "function gray(enc, number) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function gray(enc, number){\n  if(enc){\n      return number ^ (number >> 1);\n  }else{\n      let n = number;\n\n      while (number >>= 1) {\n          n ^= number;\n      }\n      return n;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`gray` should be a function.",
          "testCode": "assert(typeof gray == 'function');"
        },
        {
          "text": "`gray(true,177)` should return a number.",
          "testCode": "assert(typeof gray(true, 177) == 'number');"
        },
        {
          "text": "`gray(true,177)` should return `233`.",
          "testCode": "assert.equal(gray(true, 177), 233);"
        },
        {
          "text": "`gray(true,425)` should return `381`.",
          "testCode": "assert.equal(gray(true, 425), 381);"
        },
        {
          "text": "`gray(true,870)` should return `725`.",
          "testCode": "assert.equal(gray(true, 870), 725);"
        },
        {
          "text": "`gray(false,233)` should return `177`.",
          "testCode": "assert.equal(gray(false, 233), 177);"
        },
        {
          "text": "`gray(false,381)` should return `425`.",
          "testCode": "assert.equal(gray(false, 381), 425);"
        },
        {
          "text": "`gray(false,725)` should return `870`.",
          "testCode": "assert.equal(gray(false, 725), 870);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302276,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\gray-code.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e82",
      "title": "Greatest common divisor",
      "challengeType": 1,
      "dashedName": "greatest-common-divisor",
      "description": "Write a function that returns the greatest common divisor of two integers.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function gcd(a, b) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function gcd(a, b) {\n  return b==0 ? Math.abs(a):gcd(b, a % b);\n}"
        }
      ],
      "tests": [
        {
          "text": "`gcd` should be a function.",
          "testCode": "assert(typeof gcd == 'function');"
        },
        {
          "text": "`gcd(24,36)` should return a number.",
          "testCode": "assert(typeof gcd(24, 36) == 'number');"
        },
        {
          "text": "`gcd(24,36)` should return `12`.",
          "testCode": "assert.equal(gcd(24, 36), 12);"
        },
        {
          "text": "`gcd(30,48)` should return `6`.",
          "testCode": "assert.equal(gcd(30, 48), 6);"
        },
        {
          "text": "`gcd(10,15)` should return `5`.",
          "testCode": "assert.equal(gcd(10, 15), 5);"
        },
        {
          "text": "`gcd(100,25)` should return `25`.",
          "testCode": "assert.equal(gcd(100, 25), 25);"
        },
        {
          "text": "`gcd(13,250)` should return `1`.",
          "testCode": "assert.equal(gcd(13, 250), 1);"
        },
        {
          "text": "`gcd(1300,250)` should return `50`.",
          "testCode": "assert.equal(gcd(1300, 250), 50);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302277,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\greatest-common-divisor.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7e84",
      "title": "Greatest subsequential sum",
      "challengeType": 1,
      "dashedName": "greatest-subsequential-sum",
      "description": "Given a sequence of integers, find a continuous subsequence which maximizes the sum of its elements, that is, the elements of no other single subsequence add up to a value larger than this one.\n\nAn empty subsequence is considered to have the sum of \\\\( 0 \\\\); thus if all elements are negative, the result must be the empty sequence.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function maximumSubsequence(population) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function maximumSubsequence(population) {\n  function sumValues(arr) {\n      var result = 0;\n      for (var i = 0, len = arr.length; i < len; i++) {\n          result += arr[i];\n      }\n      return result;\n  }\n  var greatest;\n  var maxValue = 0;\n\n  for (var i = 0, len = population.length; i < len; i++) {\n      for (var j = i; j <= len; j++) {\n          var subsequence = population.slice(i, j);\n          var value = sumValues(subsequence);\n          if (value > maxValue) {\n              maxValue = value;\n              greatest = subsequence;\n          };\n      }\n  }\n\n  return greatest;\n}"
        }
      ],
      "tests": [
        {
          "text": "`maximumSubsequence` should be a function.",
          "testCode": "assert(typeof maximumSubsequence == 'function');"
        },
        {
          "text": "`maximumSubsequence([ 1, 2, -1, 3, 10, -10 ])` should return an array.",
          "testCode": "assert(Array.isArray(maximumSubsequence([1, 2, -1, 3, 10, -10])));"
        },
        {
          "text": "`maximumSubsequence([ 1, 2, -1, 3, 10, -10 ])` should return `[ 1, 2, -1, 3, 10 ]`.",
          "testCode": "assert.deepEqual(maximumSubsequence([1, 2, -1, 3, 10, -10]), [1, 2, -1, 3, 10]);"
        },
        {
          "text": "`maximumSubsequence([ 0, 8, 10, -2, -4, -1, -5, -3 ])` should return `[ 0, 8, 10 ]`.",
          "testCode": "assert.deepEqual(maximumSubsequence([0, 8, 10, -2, -4, -1, -5, -3]), [\n  0,\n  8,\n  10\n]);"
        },
        {
          "text": "`maximumSubsequence([ 9, 9, -10, 1 ])` should return `[ 9, 9 ]`.",
          "testCode": "assert.deepEqual(maximumSubsequence([9, 9, -10, 1]), [9, 9]);"
        },
        {
          "text": "`maximumSubsequence([ 7, 1, -5, -3, -8, 1 ])` should return `[ 7, 1 ]`.",
          "testCode": "assert.deepEqual(maximumSubsequence([7, 1, -5, -3, -8, 1]), [7, 1]);"
        },
        {
          "text": "`maximumSubsequence([ -3, 6, -1, 4, -4, -6 ])` should return `[ 6, -1, 4 ]`.",
          "testCode": "assert.deepEqual(maximumSubsequence([-3, 6, -1, 4, -4, -6]), [6, -1, 4]);"
        },
        {
          "text": "`maximumSubsequence([ -1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1 ])` should return `[ 3, 5, 6, -2, -1, 4 ]`.",
          "testCode": "assert.deepEqual(maximumSubsequence([-1, -2, 3, 5, 6, -2, -1, 4, -4, 2, -1]), [\n  3,\n  5,\n  6,\n  -2,\n  -1,\n  4\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302278,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\greatest-subsequential-sum.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "595608ff8bcd7a50bd490181",
      "title": "Hailstone sequence",
      "challengeType": 1,
      "dashedName": "hailstone-sequence",
      "description": "The Hailstone sequence of numbers can be generated from a starting positive integer, `n` by:\n\n- If `n` is `1` then the sequence ends\n- If `n` is `even` then the next `n` of the sequence `= n/2`\n- If `n` is `odd` then the next `n` of the sequence `= (3 * n) + 1`\n\nThe (unproven) Collatz conjecture is that the hailstone sequence for any starting number always terminates.\n\nThe hailstone sequence is also known as hailstone numbers (because the values are usually subject to multiple descents and ascents like hailstones in a cloud), or as the Collatz sequence.",
      "instructions": "1. Create a routine to generate the hailstone sequence for a number\n2. Your function should return an array with the number less than `limit` which has the longest hailstone sequence and that sequence's length. (But don't show the actual sequence!)",
      "boilerplate": [
        {
          "language": "js",
          "code": "function hailstoneSequence(limit) {\n  const res = [];\n\n\n  return res;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function hailstoneSequence (limit) {\n  function hailstone(n) {\n    const seq = [n];\n    while (n > 1) {\n      n = n % 2 ? 3 * n + 1 : n / 2;\n      seq.push(n);\n    }\n    return seq;\n  }\n\n  let n = 0;\n  let max = 0;\n  for (let i = limit; --i;) {\n    const seq = hailstone(i);\n    const sLen = seq.length;\n\n    if (sLen > max) {\n      n = i;\n      max = sLen;\n    }\n  }\n\n  return [n, max];\n}"
        }
      ],
      "tests": [
        {
          "text": "`hailstoneSequence` should be a function.",
          "testCode": "assert(typeof hailstoneSequence === 'function');"
        },
        {
          "text": "`hailstoneSequence(30)` should return an array.",
          "testCode": "assert(Array.isArray(hailstoneSequence(30)));"
        },
        {
          "text": "`hailstoneSequence(30)` should return `[27, 112]`.",
          "testCode": "assert.deepEqual(hailstoneSequence(30), [27, 112]);"
        },
        {
          "text": "`hailstoneSequence(50000)` should return `[35655, 324]`.",
          "testCode": "assert.deepEqual(hailstoneSequence(50000), [35655, 324]);"
        },
        {
          "text": "`hailstoneSequence(100000)` should return `[77031, 351]`.",
          "testCode": "assert.deepEqual(hailstoneSequence(100000), [77031, 351]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302279,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\hailstone-sequence.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad1",
      "title": "Happy numbers",
      "challengeType": 1,
      "dashedName": "happy-numbers",
      "description": "A happy number is defined by the following process:\n\nStarting with any positive integer, replace the number by the sum of the squares of its digits, and repeat the process until the number equals `1` (where it will stay), or it loops endlessly in a cycle which does not include `1`. Those numbers for which this process ends in `1` are happy numbers, while those that do not end in `1` are unhappy numbers.",
      "instructions": "Implement a function that returns true if the number is happy, or false if not.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function happy(number) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function happy (number) {\n  let m;\n  let digit;\n  const cycle = [];\n\n  while (number !== 1 && cycle[number] !== true) {\n    cycle[number] = true;\n    m = 0;\n    while (number > 0) {\n      digit = number % 10;\n      m += Math.pow(digit, 2);\n      number = (number - digit) / 10;\n    }\n    number = m;\n  }\n  return (number === 1);\n}"
        }
      ],
      "tests": [
        {
          "text": "`happy` should be a function.",
          "testCode": "assert(typeof happy === 'function');"
        },
        {
          "text": "`happy(1)` should return a boolean.",
          "testCode": "assert(typeof happy(1) === 'boolean');"
        },
        {
          "text": "`happy(1)` should return `true`.",
          "testCode": "assert(happy(1));"
        },
        {
          "text": "`happy(2)` should return `false`.",
          "testCode": "assert(!happy(2));"
        },
        {
          "text": "`happy(7)` should return `true`.",
          "testCode": "assert(happy(7));"
        },
        {
          "text": "`happy(10)` should return `true`.",
          "testCode": "assert(happy(10));"
        },
        {
          "text": "`happy(13)` should return `true`.",
          "testCode": "assert(happy(13));"
        },
        {
          "text": "`happy(19)` should return `true`.",
          "testCode": "assert(happy(19));"
        },
        {
          "text": "`happy(23)` should return `true`.",
          "testCode": "assert(happy(23));"
        },
        {
          "text": "`happy(28)` should return `true`.",
          "testCode": "assert(happy(28));"
        },
        {
          "text": "`happy(31)` should return `true`.",
          "testCode": "assert(happy(31));"
        },
        {
          "text": "`happy(32)` should return `true`.",
          "testCode": "assert(happy(32));"
        },
        {
          "text": "`happy(33)` should return `false`.",
          "testCode": "assert(!happy(33));"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302280,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\happy-numbers.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "595668ca4cfe1af2fb9818d4",
      "title": "Harshad or Niven series",
      "challengeType": 1,
      "dashedName": "harshad-or-niven-series",
      "description": "The Harshad or Niven numbers are positive integers ≥ 1 that are divisible by the sum of their digits.\n\nFor example, `42` is a Harshad number as `42` is divisible by `(4 + 2)` without remainder.\n\nAssume that the series is defined as the numbers in increasing order.",
      "instructions": "Implement a function to generate successive members of the Harshad sequence.\n\nUse it to return an array with ten members of the sequence, starting with first Harshad number greater than `n`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isHarshadOrNiven(n) {\n  const res = [];\n\n  return res;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isHarshadOrNiven(n) {\n  function isHarshad(num) {\n    let s = 0;\n    const nStr = num.toString();\n    for (let i = 0; i < nStr.length; ++i) {\n      s += parseInt(nStr.charAt(i), 10);\n    }\n    return n % s === 0;\n  }\n\n  const res = [];\n  let count = 0;\n\n  while (count < 10) {\n    n++;\n    if (isHarshad(n)) {\n      count++;\n      res.push(n);\n    }\n  }\n\n  return res;\n}"
        }
      ],
      "tests": [
        {
          "text": "`isHarshadOrNiven` should be a function.",
          "testCode": "assert(typeof isHarshadOrNiven === 'function');"
        },
        {
          "text": "`isHarshadOrNiven(10)` should return `[12, 18, 20, 21, 24, 27, 30, 36, 40, 42]`",
          "testCode": "assert.deepEqual(isHarshadOrNiven(10), [12, 18, 20, 21, 24, 27, 30, 36, 40, 42]);"
        },
        {
          "text": "`isHarshadOrNiven(400)` should return `[402, 405, 407, 408, 410, 414, 420, 423, 432, 440]`",
          "testCode": "assert.deepEqual(isHarshadOrNiven(400), [402, 405, 407, 408, 410, 414, 420, 423, 432, 440]);"
        },
        {
          "text": "`isHarshadOrNiven(1000)` should return `[1002, 1008, 1010, 1011, 1012, 1014, 1015, 1016, 1017, 1020]`",
          "testCode": "assert.deepEqual(isHarshadOrNiven(1000), [1002, 1008, 1010, 1011, 1012, 1014, 1015, 1016, 1017, 1020]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302281,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\harshad-or-niven-series.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "595671d4d2cdc305f0d5b36f",
      "title": "Hash from two arrays",
      "challengeType": 1,
      "dashedName": "hash-from-two-arrays",
      "description": "Given two arrays, create a hash object where the elements from one array (the keys) are linked to the elements of the other (the values).\n\nExample:\n\n```js\nconst firstArr = [1, 2, 3];\nconst secondArr = [\"a\", \"b\", \"c\"];\nconst hashObj = arrToObj(firstArr, secondArr);\n```\n\nThe hash object created from the arrays above will be `{1: \"a\", 2: \"b\", 3: \"c\"}`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function arrToObj (keys, vals) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function arrToObj (keys, vals) {\n  return keys.reduce((map, key, index) => {\n    map[key] = vals[index];\n    return map;\n  }, {});\n}"
        }
      ],
      "tests": [
        {
          "text": "`arrToObj` should be a function.",
          "testCode": "assert(typeof arrToObj === 'function');"
        },
        {
          "text": "`arrToObj([1, 2, 3, 4, 5], [\"a\", \"b\", \"c\", \"d\", \"e\"])` should return `{ 1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: \"e\" }`",
          "testCode": "assert.deepEqual(arrToObj(...testCases[0]), res[0]);"
        },
        {
          "text": "`arrToObj([1, 2, 3, 4, 5], [\"a\", \"b\", \"c\", \"d\"])` should return `{ 1: \"a\", 2: \"b\", 3: \"c\", 4: \"d\", 5: undefined }`",
          "testCode": "assert.deepEqual(arrToObj(...testCases[1]), res[1]);"
        },
        {
          "text": "`arrToObj([1, 2, 3], [\"a\", \"b\", \"c\", \"d\", \"e\"])` should return `{ 1: \"a\", 2: \"b\", 3: \"c\" }`",
          "testCode": "assert.deepEqual(arrToObj(...testCases[2]), res[2]);"
        },
        {
          "text": "`arrToObj([\"a\", \"b\", \"c\", \"d\", \"e\"], [1, 2, 3, 4, 5])` should return `{ \"a\": 1, \"b\": 2, \"c\": 3 , \"d\": 4, \"e\": 5 }`",
          "testCode": "assert.deepEqual(arrToObj(...testCases[3]), res[3]);"
        },
        {
          "text": "`arrToObj([\"a\", \"b\", \"c\", \"d\", \"e\"], [1, 2, 3, 4])` should return `{ \"a\": 1, \"b\": 2, \"c\": 3 , \"d\": 4, \"e\": undefined }`",
          "testCode": "assert.deepEqual(arrToObj(...testCases[4]), res[4]);"
        },
        {
          "text": "`arrToObj([\"a\", \"b\", \"c\"], [1, 2, 3, 4, 5])` should return `{ \"a\": 1, \"b\": 2, \"c\": 3 }`",
          "testCode": "assert.deepEqual(arrToObj(...testCases[5]), res[5]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302283,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\hash-from-two-arrays.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases = [\n  [[1, 2, 3, 4, 5], ['a', 'b', 'c', 'd', 'e']],\n  [[1, 2, 3, 4, 5], ['a', 'b', 'c', 'd']],\n  [[1, 2, 3], ['a', 'b', 'c', 'd', 'e']],\n  [['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4, 5]],\n  [['a', 'b', 'c', 'd', 'e'], [1, 2, 3, 4]],\n  [['a', 'b', 'c'], [1, 2, 3, 4, 5]]\n];\n\nconst res = [\n  { 1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: 'e' },\n  { 1: 'a', 2: 'b', 3: 'c', 4: 'd', 5: undefined },\n  { 1: 'a', 2: 'b', 3: 'c' },\n  { a: 1, b: 2, c: 3, d: 4, e: 5 },\n  { a: 1, b: 2, c: 3, d: 4, e: undefined },\n  { a: 1, b: 2, c: 3 }\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5956795bc9e2c415eb244de1",
      "title": "Hash join",
      "challengeType": 1,
      "dashedName": "hash-join",
      "description": "An inner join is an operation that combines two data tables into one table, based on matching column values. The simplest way of implementing this operation is the nested loop join algorithm, but a more scalable alternative is the hash join algorithm.\n\nThe \"hash join\" algorithm consists of two steps:\n\n<ol>\n  <li><strong>Hash phase:</strong> Create a multimap from one of the two tables, mapping from each join column value to all the rows that contain it.</li>\n  <ul>\n    <li>The multimap must support hash-based lookup which scales better than a simple linear search, because that's the whole point of this algorithm.</li>\n    <li>Ideally we should create the multimap for the smaller table, thus minimizing its creation time and memory size.</li>\n  </ul>\n  <li><strong>Join phase:</strong> Scan the other table, and find matching rows by looking in the multimap created before.</li>\n</ol>\n\nIn pseudo-code, the algorithm could be expressed as follows:\n\n<pre><strong>let</strong> <i>A</i> = the first input table (or ideally, the larger one)\n<strong>let</strong> <i>B</i> = the second input table (or ideally, the smaller one)\n<strong>let</strong> <i>j<sub>A</sub></i> = the join column ID of table <i>A</i>\n<strong>let</strong> <i>j<sub>B</sub></i> = the join column ID of table <i>B</i>\n<strong>let</strong> <i>M<sub>B</sub></i> = a multimap for mapping from single values to multiple rows of table <i>B</i> (starts out empty)\n<strong>let</strong> <i>C</i> = the output table (starts out empty)\n<strong>for each</strong> row <i>b</i> in table <i>B</i>:\n  <strong>place</strong> <i>b</i> in multimap <i>M<sub>B</sub></i> under key <i>b(j<sub>B</sub>)</i>\n<strong>for each</strong> row <i>a</i> in table <i>A</i>:\n  <strong>for each</strong> row <i>b</i> in multimap <i>M<sub>B</sub></i> under key <i>a(j<sub>A</sub>)</i>:\n    <strong>let</strong> <i>c</i> = the concatenation of row <i>a</i> and row <i>b</i>\n    <strong>place</strong> row <i>c</i> in table <i>C</i>\n</pre>",
      "instructions": "Implement the \"hash join\" algorithm as a function and demonstrate that it passes the test-case listed below. The function should accept two arrays of objects and return an array of combined objects.\n\n**Input**\n\n<table>\n  <tr>\n    <td style=\"padding: 4px; margin: 5px;\">\n      <table style=\"border:none; border-collapse:collapse;\">\n        <tr>\n          <td style=\"border:none\"><i>A =</i></td>\n          <td style=\"border:none\">\n            <table>\n              <tr>\n                <th style=\"padding: 4px; margin: 5px;\">Age</th>\n                <th style=\"padding: 4px; margin: 5px;\">Name</th>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">27</td>\n                <td style=\"padding: 4px; margin: 5px;\">Jonah</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">18</td>\n                <td style=\"padding: 4px; margin: 5px;\">Alan</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">28</td>\n                <td style=\"padding: 4px; margin: 5px;\">Glory</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">18</td>\n                <td style=\"padding: 4px; margin: 5px;\">Popeye</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">28</td>\n                <td style=\"padding: 4px; margin: 5px;\">Alan</td>\n              </tr>\n            </table>\n          </td>\n          <td style=\"border:none; padding-left:1.5em;\" rowspan=\"2\"></td>\n          <td style=\"border:none\"><i>B =</i></td>\n          <td style=\"border:none\">\n            <table>\n              <tr>\n                <th style=\"padding: 4px; margin: 5px;\">Character</th>\n                <th style=\"padding: 4px; margin: 5px;\">Nemesis</th>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">Jonah</td>\n                <td style=\"padding: 4px; margin: 5px;\">Whales</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">Jonah</td>\n                <td style=\"padding: 4px; margin: 5px;\">Spiders</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">Alan</td>\n                <td style=\"padding: 4px; margin: 5px;\">Ghosts</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">Alan</td>\n                <td style=\"padding: 4px; margin: 5px;\">Zombies</td>\n              </tr>\n              <tr>\n                <td style=\"padding: 4px; margin: 5px;\">Glory</td>\n                <td style=\"padding: 4px; margin: 5px;\">Buffy</td>\n              </tr>\n            </table>\n          </td>\n        </tr>\n        <tr>\n          <td style=\"border:none\">\n            <i>j<sub>A</sub> =</i>\n          </td>\n          <td style=\"border:none\">\n            <i><code>Name</code> (i.e. column 1)</i>\n          </td>\n          <td style=\"border:none\">\n            <i>j<sub>B</sub> =</i>\n          </td>\n          <td style=\"border:none\">\n            <i><code>Character</code> (i.e. column 0)</i>\n          </td>\n        </tr>\n      </table>\n    </td>\n  </tr>\n</table>\n\n**Output**\n\n| A_age | A_name | B_character | B_nemesis |\n| ----- | ------ | ----------- | --------- |\n| 27    | Jonah  | Jonah       | Whales    |\n| 27    | Jonah  | Jonah       | Spiders   |\n| 18    | Alan   | Alan        | Ghosts    |\n| 18    | Alan   | Alan        | Zombies   |\n| 28    | Glory  | Glory       | Buffy     |\n| 28    | Alan   | Alan        | Ghosts    |\n| 28    | Alan   | Alan        | Zombies   |\n\nThe order of the rows in the output table is not significant.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function hashJoin(hash1, hash2) {\n\n  return [];\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function hashJoin(hash1, hash2) {\n  const hJoin = (tblA, tblB, strJoin) => {\n    const [jA, jB] = strJoin.split('=');\n    const M = tblB.reduce((a, x) => {\n      const id = x[jB];\n      return (\n        a[id] ? a[id].push(x) : (a[id] = [x]),\n        a\n      );\n    }, {});\n\n    return tblA.reduce((a, x) => {\n      const match = M[x[jA]];\n      return match ? (\n                a.concat(match.map(row => dictConcat(x, row)))\n            ) : a;\n    }, []);\n  };\n\n  const dictConcat = (dctA, dctB) => {\n    const ok = Object.keys;\n    return ok(dctB).reduce(\n            (a, k) => (a[`B_${k}`] = dctB[k]) && a,\n            ok(dctA).reduce(\n                (a, k) => (a[`A_${k}`] = dctA[k]) && a, {}\n            )\n        );\n  };\n\n  return hJoin(hash1, hash2, 'name=character');\n}"
        }
      ],
      "tests": [
        {
          "text": "`hashJoin` should be a function.",
          "testCode": "assert(typeof hashJoin === 'function');"
        },
        {
          "text": "`hashJoin([{ age: 27, name: \"Jonah\" }, { age: 18, name: \"Alan\" }, { age: 28, name: \"Glory\" }, { age: 18, name: \"Popeye\" }, { age: 28, name: \"Alan\" }], [{ character: \"Jonah\", nemesis: \"Whales\" }, { character: \"Jonah\", nemesis: \"Spiders\" }, { character: \"Alan\", nemesis: \"Ghosts\" }, { character:\"Alan\", nemesis: \"Zombies\" }, { character: \"Glory\", nemesis: \"Buffy\" }, { character: \"Bob\", nemesis: \"foo\" }])` should return `[{\"A_age\": 27,\"A_name\": \"Jonah\", \"B_character\": \"Jonah\", \"B_nemesis\": \"Whales\"}, {\"A_age\": 27,\"A_name\": \"Jonah\", \"B_character\": \"Jonah\", \"B_nemesis\": \"Spiders\"}, {\"A_age\": 18,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Ghosts\"}, {\"A_age\": 18,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Zombies\"}, {\"A_age\": 28,\"A_name\": \"Glory\", \"B_character\": \"Glory\", \"B_nemesis\": \"Buffy\"}, {\"A_age\": 28,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Ghosts\"}, {\"A_age\": 28,\"A_name\": \"Alan\", \"B_character\": \"Alan\", \"B_nemesis\": \"Zombies\"}]`",
          "testCode": "assert.deepEqual(hashJoin(hash1, hash2), res);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302284,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\hash-join.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const hash1 = [\n    { age: 27, name: 'Jonah' },\n    { age: 18, name: 'Alan' },\n    { age: 28, name: 'Glory' },\n    { age: 18, name: 'Popeye' },\n    { age: 28, name: 'Alan' }\n];\n\nconst hash2 = [\n    { character: 'Jonah', nemesis: 'Whales' },\n    { character: 'Jonah', nemesis: 'Spiders' },\n    { character: 'Alan', nemesis: 'Ghosts' },\n    { character: 'Alan', nemesis: 'Zombies' },\n    { character: 'Glory', nemesis: 'Buffy' },\n    { character: 'Bob', nemesis: 'foo' }\n];\n\nconst res = [\n    { A_age: 27, A_name: 'Jonah', B_character: 'Jonah', B_nemesis: 'Whales' },\n    { A_age: 27, A_name: 'Jonah', B_character: 'Jonah', B_nemesis: 'Spiders' },\n    { A_age: 18, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Ghosts' },\n    { A_age: 18, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Zombies' },\n    { A_age: 28, A_name: 'Glory', B_character: 'Glory', B_nemesis: 'Buffy' },\n    { A_age: 28, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Ghosts' },\n    { A_age: 28, A_name: 'Alan', B_character: 'Alan', B_nemesis: 'Zombies' }\n];\n\nconst bench1 = [{ name: 'u2v7v', num: 1 }, { name: 'n53c8', num: 10 }, { name: 'oysce', num: 9 }, { name: '0mto2s', num: 1 }, { name: 'vkh5id', num: 4 }, { name: '5od0cf', num: 8 }, { name: 'uuulue', num: 10 }, { name: '3rgsbi', num: 9 }, { name: 'kccv35r', num: 4 }, { name: '80un74', num: 9 }, { name: 'h4pp3', num: 6 }, { name: '51bit', num: 7 }, { name: 'j9ndf', num: 8 }, { name: 'vf3u1', num: 10 }, { name: 'g0bw0om', num: 10 }, { name: 'j031x', num: 7 }, { name: 'ij3asc', num: 9 }, { name: 'byv83y', num: 8 }, { name: 'bjzp4k', num: 4 }, { name: 'f3kbnm', num: 10 }];\nconst bench2 = [{ friend: 'o8b', num: 8 }, { friend: 'ye', num: 2 }, { friend: '32i', num: 5 }, { friend: 'uz', num: 3 }, { friend: 'a5k', num: 4 }, { friend: 'uad', num: 7 }, { friend: '3w5', num: 10 }, { friend: 'vw', num: 10 }, { friend: 'ah', num: 4 }, { friend: 'qv', num: 7 }, { friend: 'ozv', num: 2 }, { friend: '9ri', num: 10 }, { friend: '7nu', num: 4 }, { friend: 'w3', num: 9 }, { friend: 'tgp', num: 8 }, { friend: 'ibs', num: 1 }, { friend: 'ss7', num: 6 }, { friend: 'g44', num: 9 }, { friend: 'tab', num: 9 }, { friend: 'zem', num: 10 }];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "595b98f8b5a2245e243aa831",
      "title": "Heronian triangles",
      "challengeType": 1,
      "dashedName": "heronian-triangles",
      "description": "Hero's formula for the area of a triangle given the length of its three sides `a`, `b`, and `c` is given by:\n\n$A = \\\\sqrt{s(s-a)(s-b)(s-c)},$\n\nwhere `s` is half the perimeter of the triangle; that is,\n\n$s=\\\\frac{a+b+c}{2}.$\n\nHeronian triangles are triangles whose sides and area are all integers.\n\nAn example is the triangle with sides `3, 4, 5` whose area is `6` (and whose perimeter is `12`).\n\nNote that any triangle whose sides are all an integer multiple of `3, 4, 5`; such as `6, 8, 10,` will also be a Heronian triangle.\n\nDefine a Primitive Heronian triangle as a Heronian triangle where the greatest common divisor\n\nof all three sides is `1` (unity).\n\nThis will exclude, for example, triangle `6, 8, 10.`",
      "instructions": "Implement a function based on Hero's formula that returns the first <code>n<sub>th</sub></code> ordered triangles in an array of arrays.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function heronianTriangle(n) {\n\n\n  return [];\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function heronianTriangle(n) {\n  const list = [];\n  const result = [];\n\n  let j = 0;\n  for (let c = 1; c <= 200; c++) {\n    for (let b = 1; b <= c; b++) {\n      for (let a = 1; a <= b; a++) {\n        if (gcd(gcd(a, b), c) === 1 && isHeron(heronArea(a, b, c))) {\n          list[j++] = new Array(a, b, c, heronArea(a, b, c));\n        }\n      }\n    }\n  }\n\n  sort(list);\n\n  for (let i = 0; i < n; i++) {\n    result[i] = [list[i][0], list[i][1], list[i][2]];\n  }\n\n  return result;\n\n  function heronArea(a, b, c) {\n    const s = (a + b + c) / 2;\n    return Math.sqrt(s * (s - a) * (s - b) * (s - c));\n  }\n\n  function isHeron(h) { return h % 1 === 0 && h > 0; }\n\n  function gcd(a, b) {\n    let leftover = 1;\n    let dividend = a > b ? a : b;\n    let divisor = a > b ? b : a;\n    while (leftover !== 0) {\n      leftover = dividend % divisor;\n      if (leftover > 0) {\n        dividend = divisor;\n        divisor = leftover;\n      }\n    }\n    return divisor;\n  }\n\n  function sort(arg) {\n    let swapped = true;\n    let temp = [];\n    while (swapped) {\n      swapped = false;\n      for (let i = 1; i < arg.length; i++) {\n        if (arg[i][4] < arg[i - 1][4] || arg[i][4] === arg[i - 1][4] && arg[i][3] < arg[i - 1][3]) {\n          temp = arg[i];\n          arg[i] = arg[i - 1];\n          arg[i - 1] = temp;\n          swapped = true;\n        }\n      }\n    }\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`heronianTriangle` should be a function.",
          "testCode": "assert(typeof heronianTriangle === 'function');"
        },
        {
          "text": "`heronianTriangle(10)` should return `[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17]]`",
          "testCode": "assert.deepEqual(heronianTriangle(testCases[0]), res[0]);"
        },
        {
          "text": "`heronianTriangle(15)` should return `[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15]],`",
          "testCode": "assert.deepEqual(heronianTriangle(testCases[1]), res[1]);"
        },
        {
          "text": "`heronianTriangle(20)` should return `[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53]],`",
          "testCode": "assert.deepEqual(heronianTriangle(testCases[2]), res[2]);"
        },
        {
          "text": "`heronianTriangle(25)` should return `[[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53], [19, 20, 37],[16, 17, 17], [17, 17, 30], [16, 25, 39], [13, 20, 21]]`",
          "testCode": "assert.deepEqual(heronianTriangle(testCases[3]), res[3]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302285,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\heronian-triangles.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCases = [10, 15, 20, 25];\n\nconst res = [\n  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17]],\n  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15]],\n  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53]],\n  [[3, 4, 5], [5, 5, 6], [5, 5, 8], [4, 13, 15], [5, 12, 13], [9, 10, 17], [3, 25, 26], [7, 15, 20], [10, 13, 13], [8, 15, 17], [13, 13, 24], [6, 25, 29], [11, 13, 20], [5, 29, 30], [13, 14, 15], [10, 17, 21], [7, 24, 25], [8, 29, 35], [12, 17, 25], [4, 51, 53], [19, 20, 37], [16, 17, 17], [17, 17, 30], [16, 25, 39], [13, 20, 21]]\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59622f89e4e137560018a40e",
      "title": "Hofstadter Figure-Figure sequences",
      "challengeType": 1,
      "dashedName": "hofstadter-figure-figure-sequences",
      "description": "The Hofstadter Figure-Figure sequences $R_n$ and $S_n$ are given by\n\n$R_1 = 1\\\\ ;\\\\ S_1 = 2 \\\\\\\\R_n = R_{n-1} + S_{n-1}, \\\\quad n>1.$\n\nSpecifically, the sequence $R_n$ contains the values\n\n<pre>1, 3, 7, 12, 18, ...</pre>\n\nand the sequence $S_n$ contains the values\n\n<pre>2, 4, 5, 6, 8, ...</pre>\n\nThe sequence $R_n$ is defined by the recurrence relation $R_n = R_{n-1} + S_{n-1}$, while $S_n$ is defined as sequence of positive integers that are not included in the sequence $R_n$.",
      "instructions": "Create two functions named `ffr` and `ffs` that return `R(n)` or `S(n)`, respectively, for any index `n`. Note that the Hofstadter Figure-Figure sequences are 1-indexed, with $R_1 = 1$ and $S_1 = 2$.\n\nNo maximum value for `n` should be assumed.\n\n**References**\n\n <p>Rosetta: <a href='https://rosettacode.org/wiki/Hofstadter_Figure-Figure_sequences' target='_blank'>Hofstadter Figure-Figure sequences</a></p>.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function ffr(n) {\n  return n;\n}\n\nfunction ffs(n) {\n  return n;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "const R = [null, 1];\nconst S = [null, 2];\n\nfunction extendSequences (n) {\n  let current = Math.max(R[R.length - 1], S[S.length - 1]);\n  let i;\n  while (R.length <= n || S.length <= n) {\n    i = Math.min(R.length, S.length) - 1;\n    current += 1;\n    if (current === R[i] + S[i]) {\n      R.push(current);\n    } else {\n      S.push(current);\n    }\n  }\n}\n\nfunction ffr (n) {\n  extendSequences(n);\n  return R[n];\n}\n\nfunction ffs (n) {\n  extendSequences(n);\n  return S[n];\n}"
        }
      ],
      "tests": [
        {
          "text": "`ffr` should be a function.",
          "testCode": "assert(typeof ffr === 'function');"
        },
        {
          "text": "`ffs` should be a function.",
          "testCode": "assert(typeof ffs === 'function');"
        },
        {
          "text": "`ffr` should return integer.",
          "testCode": "assert(Number.isInteger(ffr(1)));"
        },
        {
          "text": "`ffs` should return integer.",
          "testCode": "assert(Number.isInteger(ffs(1)));"
        },
        {
          "text": "`ffr(10)` should return `69`",
          "testCode": "assert.equal(ffr(ffrParamRes[0][0]), ffrParamRes[0][1]);"
        },
        {
          "text": "`ffr(50)` should return `1509`",
          "testCode": "assert.equal(ffr(ffrParamRes[1][0]), ffrParamRes[1][1]);"
        },
        {
          "text": "`ffr(100)` should return `5764`",
          "testCode": "assert.equal(ffr(ffrParamRes[2][0]), ffrParamRes[2][1]);"
        },
        {
          "text": "`ffr(1000)` should return `526334`",
          "testCode": "assert.equal(ffr(ffrParamRes[3][0]), ffrParamRes[3][1]);"
        },
        {
          "text": "`ffs(10)` should return `14`",
          "testCode": "assert.equal(ffs(ffsParamRes[0][0]), ffsParamRes[0][1]);"
        },
        {
          "text": "`ffs(50)` should return `59`",
          "testCode": "assert.equal(ffs(ffsParamRes[1][0]), ffsParamRes[1][1]);"
        },
        {
          "text": "`ffs(100)` should return `112`",
          "testCode": "assert.equal(ffs(ffsParamRes[2][0]), ffsParamRes[2][1]);"
        },
        {
          "text": "`ffs(1000)` should return `1041`",
          "testCode": "assert.equal(ffs(ffsParamRes[3][0]), ffsParamRes[3][1]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302286,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\hofstadter-figure-figure-sequences.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const ffrParamRes = [[10, 69], [50, 1509], [100, 5764], [1000, 526334]];\nconst ffsParamRes = [[10, 14], [50, 59], [100, 112], [1000, 1041]];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59637c4d89f6786115efd814",
      "title": "Hofstadter Q sequence",
      "challengeType": 1,
      "dashedName": "hofstadter-q-sequence",
      "description": "The Hofstadter Q sequence is defined as:\n\n$Q(1)=Q(2)=1, \\\\\\\\ Q(n)=Q\\\\big(n-Q(n-1)\\\\big)+Q\\\\big(n-Q(n-2)), \\\\quad n>2.$\n\nIt is defined like the Fibonacci sequence, but whereas the next term in the Fibonacci sequence is the sum of the previous two terms, in the Q sequence the previous two terms tell you how far to go back in the Q sequence to find the two numbers to sum to make the next term of the sequence.",
      "instructions": "Implement the Hofstadter Q Sequence equation as a function. The function should accept number, `n`, and return an integer.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function hofstadterQ(n) {\n\n  return n;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function hofstadterQ (n) {\n  const memo = [1, 1, 1];\n  const Q = function (i) {\n    let result = memo[i];\n    if (typeof result !== 'number') {\n      result = Q(i - Q(i - 1)) + Q(i - Q(i - 2));\n      memo[i] = result;\n    }\n    return result;\n  };\n  return Q(n);\n}"
        }
      ],
      "tests": [
        {
          "text": "`hofstadterQ` should be a function.",
          "testCode": "assert(typeof hofstadterQ === 'function');"
        },
        {
          "text": "`hofstadterQ()` should return `integer`",
          "testCode": "assert(Number.isInteger(hofstadterQ(1000)));"
        },
        {
          "text": "`hofstadterQ(1000)` should return `502`",
          "testCode": "assert.equal(hofstadterQ(testCase[0]), res[0]);"
        },
        {
          "text": "`hofstadterQ(1500)` should return `755`",
          "testCode": "assert.equal(hofstadterQ(testCase[1]), res[1]);"
        },
        {
          "text": "`hofstadterQ(2000)` should return `1005`",
          "testCode": "assert.equal(hofstadterQ(testCase[2]), res[2]);"
        },
        {
          "text": "`hofstadterQ(2500)` should return `1261`",
          "testCode": "assert.equal(hofstadterQ(testCase[3]), res[3]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302287,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\hofstadter-q-sequence.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testCase = [1000, 1500, 2000, 2500];\nconst res = [502, 755, 1005, 1261];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7eb0",
      "title": "I before E except after C",
      "challengeType": 1,
      "dashedName": "i-before-e-except-after-c",
      "description": "**<a href=\"http://www.rosettacode.org/wiki/I_before_E_except_after_C\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">\"I before E, except after C\"</a>** is a general rule for English language spelling. If one is unsure whether a word is spelled with the digraph `ei` or `ie`, the rhyme suggests that the correct order is `ie` unless the preceding letter is `c`, in which case it may be `ei`.\n\nUsing the words provided, check if the two sub-clauses of the phrase are plausible individually:\n\n<ol>\n  <li>\n    <i>\"I before E when not preceded by C\".</i>\n  </li>\n  <li>\n    <i>\"E before I when preceded by C\".</i>\n  </li>\n</ol>\n\nIf both sub-phrases are plausible then the original phrase can be said to be plausible.",
      "instructions": "Write a function that accepts a word and check if the word follows this rule. The function should return true if the word follows the rule and false if it does not.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function IBeforeExceptC(word) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function IBeforeExceptC(word)\n{\n    if(word.indexOf(\"c\")==-1 && word.indexOf(\"ie\")!=-1)\n        return true;\n    else if(word.indexOf(\"cei\")!=-1)\n        return true;\n    return false;\n}"
        }
      ],
      "tests": [
        {
          "text": "`IBeforeExceptC` should be a function.",
          "testCode": "assert(typeof IBeforeExceptC == 'function');"
        },
        {
          "text": "`IBeforeExceptC(\"receive\")` should return a boolean.",
          "testCode": "assert(typeof IBeforeExceptC('receive') == 'boolean');"
        },
        {
          "text": "`IBeforeExceptC(\"receive\")` should return `true`.",
          "testCode": "assert.equal(IBeforeExceptC('receive'), true);"
        },
        {
          "text": "`IBeforeExceptC(\"science\")` should return `false`.",
          "testCode": "assert.equal(IBeforeExceptC('science'), false);"
        },
        {
          "text": "`IBeforeExceptC(\"imperceivable\")` should return `true`.",
          "testCode": "assert.equal(IBeforeExceptC('imperceivable'), true);"
        },
        {
          "text": "`IBeforeExceptC(\"inconceivable\")` should return `true`.",
          "testCode": "assert.equal(IBeforeExceptC('inconceivable'), true);"
        },
        {
          "text": "`IBeforeExceptC(\"insufficient\")` should return `false`.",
          "testCode": "assert.equal(IBeforeExceptC('insufficient'), false);"
        },
        {
          "text": "`IBeforeExceptC(\"omniscient\")` should return `false`.",
          "testCode": "assert.equal(IBeforeExceptC('omniscient'), false);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302288,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\i-before-e-except-after-c.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7eaf",
      "title": "IBAN",
      "challengeType": 1,
      "dashedName": "iban",
      "description": "The International Bank Account Number (IBAN) is an internationally agreed means of identifying bank accounts across national borders with a reduced risk of propagating transcription errors.\n\nThe <abbr title=\"International Bank Account Number\">IBAN</abbr> consists of up to 34 alphanumeric characters:\n\n<ul>\n  <li>first the two-letter <abbr title=\"International Organization for Standardization\">ISO</abbr> 3166-1 alpha-2 country code</li>\n  <li>then two check digits, and</li>\n  <li>finally a country-specific Basic Bank Account Number (BBAN).</li>\n</ul>\n\nThe check digits enable a sanity check of the bank account number to confirm its integrity even before submitting a transaction.",
      "instructions": "Write a function that takes IBAN string as parameter. If it is valid return true. Otherwise, return false.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isValid(iban) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isValid(iban) {\n  var ibanLen = {\n    NO:15, BE:16, DK:18, FI:18, FO:18, GL:18, NL:18, MK:19,\n    SI:19, AT:20, BA:20, EE:20, KZ:20, LT:20, LU:20, CR:21,\n    CH:21, HR:21, LI:21, LV:21, BG:22, BH:22, DE:22, GB:22,\n    GE:22, IE:22, ME:22, RS:22, AE:23, GI:23, IL:23, AD:24,\n    CZ:24, ES:24, MD:24, PK:24, RO:24, SA:24, SE:24, SK:24,\n    VG:24, TN:24, PT:25, IS:26, TR:26, FR:27, GR:27, IT:27,\n    MC:27, MR:27, SM:27, AL:28, AZ:28, CY:28, DO:28, GT:28,\n    HU:28, LB:28, PL:28, BR:29, PS:29, KW:30, MU:30, MT:31\n  }\n    iban = __helpers.removeWhiteSpace(iban)\n    if (!iban.match(/^[\\dA-Z]+$/)) return false\n    var len = iban.length\n    if (len != ibanLen[iban.substring(0,2)]) return false\n    iban = iban.substring(4) + iban.substring(0,4)\n    for (var s='', i=0; i<len; i+=1) s+=parseInt(iban.charAt(i),36)\n    for (var m=s.substring(0,15)%97, s=s.substring(15); s; s=s.substring(13)) m=(m+s.substring(0,13))%97\n    return m == 1\n}"
        }
      ],
      "tests": [
        {
          "text": "`isValid` should be a function.",
          "testCode": "assert(typeof isValid == 'function');"
        },
        {
          "text": "`isValid(\"GB82 WEST 1234 5698 7654 32\")` should return a boolean.",
          "testCode": "assert(typeof isValid('GB82 WEST 1234 5698 7654 32') == 'boolean');"
        },
        {
          "text": "`isValid(\"GB82 WEST 1234 5698 7654 32\")` should return `true`.",
          "testCode": "assert.equal(isValid('GB82 WEST 1234 5698 7654 32'), true);"
        },
        {
          "text": "`isValid(\"GB82 WEST 1.34 5698 7654 32\")` should return `false`.",
          "testCode": "assert.equal(isValid('GB82 WEST 1.34 5698 7654 32'), false);"
        },
        {
          "text": "`isValid(\"GB82 WEST 1234 5698 7654 325\")` should return `false`.",
          "testCode": "assert.equal(isValid('GB82 WEST 1234 5698 7654 325'), false);"
        },
        {
          "text": "`isValid(\"GB82 TEST 1234 5698 7654 32\")` should return `false`.",
          "testCode": "assert.equal(isValid('GB82 TEST 1234 5698 7654 32'), false);"
        },
        {
          "text": "`isValid(\"SA03 8000 0000 6080 1016 7519\")` should return `true`.",
          "testCode": "assert.equal(isValid('SA03 8000 0000 6080 1016 7519'), true);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302289,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\iban.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7eb1",
      "title": "Identity matrix",
      "challengeType": 1,
      "dashedName": "identity-matrix",
      "description": "An *identity matrix* is a square matrix of size \\\\( n \\\\times n \\\\), where the diagonal elements are all `1`s (ones), and all the other elements are all `0`s (zeroes).\n\n<ul>\n  <li style='list-style: none;'>\\(\\displaystyle I_{n}=\\begin{bmatrix} 1 &#x26; 0 &#x26; 0 \\cr 0 &#x26; 1 &#x26; 0 \\cr 0 &#x26; 0 &#x26; 1 \\cr \\end{bmatrix}\\)</li>\n</ul>",
      "instructions": "Write a function that takes a number `n` as a parameter and returns the identity matrix of order \\\\( n \\\\times n \\\\).",
      "boilerplate": [
        {
          "language": "js",
          "code": "function idMatrix(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function idMatrix(n) {\n    return Array.apply(null, new Array(n)).map(function (x, i, xs) {\n        return xs.map(function (_, k) {\n            return i === k ? 1 : 0;\n        })\n    });\n}"
        }
      ],
      "tests": [
        {
          "text": "`idMatrix` should be a function.",
          "testCode": "assert(typeof idMatrix == 'function');"
        },
        {
          "text": "`idMatrix(1)` should return an array.",
          "testCode": "assert(Array.isArray(idMatrix(1)));"
        },
        {
          "text": "`idMatrix(1)` should return `[ [ 1 ] ]`.",
          "testCode": "assert.deepEqual(idMatrix(1), results[0]);"
        },
        {
          "text": "`idMatrix(2)` should return `[ [ 1, 0 ], [ 0, 1 ] ]`.",
          "testCode": "assert.deepEqual(idMatrix(2), results[1]);"
        },
        {
          "text": "`idMatrix(3)` should return `[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ]`.",
          "testCode": "assert.deepEqual(idMatrix(3), results[2]);"
        },
        {
          "text": "`idMatrix(4)` should return `[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ]`.",
          "testCode": "assert.deepEqual(idMatrix(4), results[3]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302290,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\identity-matrix.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "let results=[[ [ 1 ] ],\n[ [ 1, 0 ], [ 0, 1 ] ],\n[ [ 1, 0, 0 ], [ 0, 1, 0 ], [ 0, 0, 1 ] ],\n[ [ 1, 0, 0, 0 ], [ 0, 1, 0, 0 ], [ 0, 0, 1, 0 ], [ 0, 0, 0, 1 ] ]]"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ec1",
      "title": "Iterated digits squaring",
      "challengeType": 1,
      "dashedName": "iterated-digits-squaring",
      "description": "If you add the square of the digits of a Natural number (an integer bigger than zero), you always end with either 1 or 89:\n\n<pre>15 -> 26 -> 40 -> 16 -> 37 -> 58 -> 89\n7 -> 49 -> 97 -> 130 -> 10 -> 1\n</pre>",
      "instructions": "Write a function that takes a number as a parameter and returns 1 or 89 after performing the mentioned process.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function iteratedSquare(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function iteratedSquare(n) {\n    var total;\n    while (n != 89 && n != 1) {\n        total = 0;\n        while (n > 0) {\n            total += Math.pow(n % 10, 2);\n            n = Math.floor(n/10);\n        }\n        n = total;\n    }\n    return n;\n}"
        }
      ],
      "tests": [
        {
          "text": "`iteratedSquare` should be a function.",
          "testCode": "assert(typeof iteratedSquare == 'function');"
        },
        {
          "text": "`iteratedSquare(4)` should return a number.",
          "testCode": "assert(typeof iteratedSquare(4) == 'number');"
        },
        {
          "text": "`iteratedSquare(4)` should return `89`.",
          "testCode": "assert.equal(iteratedSquare(4), 89);"
        },
        {
          "text": "`iteratedSquare(7)` should return `1`.",
          "testCode": "assert.equal(iteratedSquare(7), 1);"
        },
        {
          "text": "`iteratedSquare(15)` should return `89`.",
          "testCode": "assert.equal(iteratedSquare(15), 89);"
        },
        {
          "text": "`iteratedSquare(20)` should return `89`.",
          "testCode": "assert.equal(iteratedSquare(20), 89);"
        },
        {
          "text": "`iteratedSquare(70)` should return `1`.",
          "testCode": "assert.equal(iteratedSquare(70), 1);"
        },
        {
          "text": "`iteratedSquare(100)` should return `1`.",
          "testCode": "assert.equal(iteratedSquare(100), 1);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302291,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\iterated-digits-squaring.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ec2",
      "title": "Jaro distance",
      "challengeType": 1,
      "dashedName": "jaro-distance",
      "description": "The Jaro distance is a measure of similarity between two strings. The higher the Jaro distance for two strings is, the more similar the strings are. The score is normalized such that `0` equates to no similarity and `1` is an exact match.\n\n**Definition**\n\nThe Jaro distance \\\\( d_j \\\\) of two given strings \\\\(s_1\\\\) and \\\\(s_2\\\\) is\n\n\\\\begin{align}d_j = \\\\begin{cases}0& & \\\\text{if }m=0 \\\\\\\\\\\\\\\\{\\\\frac {1}{3}}\\\\left({\\\\frac {m}{|s\\_{1}|}}+{\\\\frac {m}{|s\\_{2}|}}+{\\\\frac {m-t}{m}}\\\\right)& & \\\\text{otherwise}\\\\end{cases}\\\\end{align}\n\nWhere:\n\n<ul>\n  <li>\\(m\\) is the number of <i>matching characters</i>;</li>\n  <li> \\(t\\) is half the number of <i>transpositions</i>.</li>\n</ul>\n\nTwo characters from \\\\(s_1\\\\) and \\\\(s_2\\\\) respectively, are considered *matching* only if they are the same and not farther than \\\\(\\\\left\\\\lfloor\\\\frac{\\\\max(|s_1|,|s_2|)}{2}\\\\right\\\\rfloor-1\\\\).\n\nEach character of \\\\(s_1\\\\) is compared with all its matching characters in \\\\(s_2\\\\) . The number of matching (but different sequence order) characters divided by 2 defines the number of *transpositions*.\n\n**Example**\n\nGiven the strings \\\\(s_1\\\\) *DWAYNE* and \\\\(s_2\\\\) *DUANE* we find:\n\n<ul>\n  <li>\\(m = 4\\)</li>\n  <li>\\(|s_1| = 6\\)</li>\n  <li>\\(|s_2| = 5\\)</li>\n  <li>\\(t = 0\\)</li>\n</ul>\n\nWe find a Jaro score of: \\\\(d_j = \\\\frac{1}{3}\\\\left(\\\\frac{4}{6} + \\\\frac{4}{5} + \\\\frac{4-0}{4}\\\\right) = 0.822\\\\).",
      "instructions": "Write a function a that takes two strings as parameters and returns the associated Jaro distance.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function jaro(s, t) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function jaro(s, t) {\n  var s_len = s.length;\n  var t_len = t.length;\n\n  if (s_len == 0 && t_len == 0) return 1;\n\n  var match_distance = Math.max(s_len, t_len) / 2 - 1;\n\n  var s_matches = new Array(s_len);\n  var t_matches = new Array(t_len);\n\n  var matches = 0;\n  var transpositions = 0;\n\n  for (var i = 0; i < s_len; i++) {\n    var start = Math.max(0, i - match_distance);\n    var end = Math.min(i + match_distance + 1, t_len);\n\n    for (var j = start; j < end; j++) {\n      if (t_matches[j]) continue;\n      if (s.charAt(i) != t.charAt(j)) continue;\n      s_matches[i] = true;\n      t_matches[j] = true;\n      matches++;\n      break;\n    }\n  }\n\n  if (matches == 0) return 0;\n\n  var k = 0;\n  for (var i = 0; i < s_len; i++) {\n    if (!s_matches[i]) continue;\n    while (!t_matches[k]) k++;\n    if (s.charAt(i) != t.charAt(k)) transpositions++;\n    k++;\n  }\n\n  return ((matches / s_len) +\n    (matches / t_len) +\n    ((matches - transpositions / 2.0) / matches)) / 3.0;\n}"
        }
      ],
      "tests": [
        {
          "text": "`jaro` should be a function.",
          "testCode": "assert(typeof jaro == 'function');"
        },
        {
          "text": "`jaro(\"MARTHA\", \"MARHTA\")` should return a number.",
          "testCode": "assert(typeof jaro('MARTHA', 'MARHTA') == 'number');"
        },
        {
          "text": "`jaro(\"MARTHA\", \"MARHTA\")` should return `0.9444444444444445`.",
          "testCode": "assert.equal(jaro('MARTHA', 'MARHTA'), 0.9444444444444445);"
        },
        {
          "text": "`jaro(\"DIXON\", \"DICKSONX\")` should return `0.7666666666666666`.",
          "testCode": "assert.equal(jaro('DIXON', 'DICKSONX'), 0.7666666666666666);"
        },
        {
          "text": "`jaro(\"JELLYFISH\", \"SMELLYFISH\")` should return `0.8962962962962964`.",
          "testCode": "assert.equal(jaro('JELLYFISH', 'SMELLYFISH'), 0.8962962962962964);"
        },
        {
          "text": "`jaro(\"HELLOS\", \"CHELLO\")` should return `0.888888888888889`.",
          "testCode": "assert.equal(jaro('HELLOS', 'CHELLO'), 0.888888888888889);"
        },
        {
          "text": "`jaro(\"ABCD\", \"BCDA\")` should return `0.8333333333333334`.",
          "testCode": "assert.equal(jaro('ABCD', 'BCDA'), 0.8333333333333334);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302292,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\jaro-distance.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ec4",
      "title": "JortSort",
      "challengeType": 1,
      "dashedName": "jortsort",
      "description": "jortSort is a sorting toolset that makes the user do the work and guarantees efficiency because you don't have to sort ever again. It was originally presented by Jenn \"Moneydollars\" Schiffer at the prestigious JSConf2014.\n\njortSort should be a function that takes a single array of comparable objects as its argument. It then sorts the array in ascending order and compares the sorted array to the originally provided array. If the arrays match (i.e. the original array was already sorted), the function returns true. If the arrays do not match (i.e. the original array was not sorted), the function returns false.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function jortsort(array) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function jortsort(array) {\n  // sort the array\n  var originalArray = array.slice(0);\n  array.sort( function(a,b){return a - b} );\n\n  // compare to see if it was originally sorted\n  for (var i = 0; i < originalArray.length; ++i) {\n    if (originalArray[i] !== array[i]) return false;\n  }\n\n  return true;\n};"
        }
      ],
      "tests": [
        {
          "text": "`jortsort` should be a function.",
          "testCode": "assert(typeof jortsort == 'function');"
        },
        {
          "text": "`jortsort([1,2,3,4,5])` should return a boolean.",
          "testCode": "assert(typeof jortsort([1, 2, 3, 4, 5]) == 'boolean');"
        },
        {
          "text": "`jortsort([1,2,3,4,5])` should return `true`.",
          "testCode": "assert.equal(jortsort([1, 2, 3, 4, 5]), true);"
        },
        {
          "text": "`jortsort([1,2,13,4,5])` should return `false`.",
          "testCode": "assert.equal(jortsort([1, 2, 13, 4, 5]), false);"
        },
        {
          "text": "`jortsort([12,4,51,2,4])` should return `false`.",
          "testCode": "assert.equal(jortsort([12, 4, 51, 2, 4]), false);"
        },
        {
          "text": "`jortsort([1,2])` should return `true`.",
          "testCode": "assert.equal(jortsort([1, 2]), true);"
        },
        {
          "text": "`jortsort([5,4,3,2,1])` should return `false`.",
          "testCode": "assert.equal(jortsort([5, 4, 3, 2, 1]), false);"
        },
        {
          "text": "`jortsort([1,1,1,1,1])` should return `true`.",
          "testCode": "assert.equal(jortsort([1, 1, 1, 1, 1]), true);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302293,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\jortsort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ec5",
      "title": "Josephus problem",
      "challengeType": 1,
      "dashedName": "josephus-problem",
      "description": "Josephus problem is a math puzzle with a grim description: $n$ prisoners are standing on a circle, sequentially numbered from $0$ to $n-1$.\n\nAn executioner walks along the circle, starting from prisoner $0$, removing every $k$-th prisoner and killing him.\n\nAs the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed.\n\nFor example, if there are $n=5$ prisoners and $k=2$, the order the prisoners are killed in (let's call it the \"killing sequence\") will be 1, 3, 0, and 4, and the survivor will be #2.\n\nGiven any $n, k > 0$, find out which prisoner will be the final survivor.\n\nIn one such incident, there were 41 prisoners and every 3<sup>rd</sup> prisoner was being killed ($k=3$).\n\nAmong them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale.\n\nWhich number was he?",
      "instructions": "Write a function that takes the initial number of prisoners and `k` as parameters and returns the number of the prisoner that survives.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function josephus(init, kill) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function josephus(init, kill) {\n  const arr = Array.from(Array(init).keys());\n  let curr = -1\n  while (arr.length > 1) {\n    curr = (curr + kill) % arr.length;\n    arr.splice(curr, 1);\n    curr--;\n  }\n  return arr[0];\n}"
        }
      ],
      "tests": [
        {
          "text": "`josephus` should be a function.",
          "testCode": "assert(typeof josephus == 'function');"
        },
        {
          "text": "`josephus(30,3)` should return a number.",
          "testCode": "assert(typeof josephus(30, 3) == 'number');"
        },
        {
          "text": "`josephus(30,3)` should return `28`.",
          "testCode": "assert.equal(josephus(30, 3), 28);"
        },
        {
          "text": "`josephus(30,5)` should return `2`.",
          "testCode": "assert.equal(josephus(30, 5), 2);"
        },
        {
          "text": "`josephus(20,2)` should return `8`.",
          "testCode": "assert.equal(josephus(20, 2), 8);"
        },
        {
          "text": "`josephus(17,6)` should return `1`.",
          "testCode": "assert.equal(josephus(17, 6), 1);"
        },
        {
          "text": "`josephus(29,4)` should return `1`.",
          "testCode": "assert.equal(josephus(29, 4), 1);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302294,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\josephus-problem.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ecb",
      "title": "K-d tree",
      "challengeType": 1,
      "dashedName": "k-d-tree",
      "description": "A k-d tree (short for *k*-dimensional tree) is a space-partitioning data structure for organizing points in a k-dimensional space. k-d trees are a useful data structure for several applications, such as searches involving a multidimensional search key (e.g. range searches and nearest neighbor searches). k-d trees are a special case of binary space partitioning trees. k-d trees are not suitable, however, for efficiently finding the nearest neighbor in high dimensional spaces. As a general rule, if the dimensionality is *k*, the number of points in the data, *N*, should be *N* ≫ 2<sup><i>k</i></sup>. Otherwise, when k-d trees are used with high-dimensional data, most of the points in the tree will be evaluated and the efficiency is no better than exhaustive search, and other methods such as approximate nearest-neighbor are used instead.",
      "instructions": "Write a function to perform a nearest neighbor search using k-d tree. The function takes two parameters: an array of k-dimensional points, and a single k-dimensional point whose nearest neighbor should be returned by the function. A k-dimensional point will be given as an array of k elements.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function kdNN(fpoints, fpoint) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function kdNN(fpoints, fpoint) {\n  function Node(obj, dimension, parent) {\n    this.obj = obj;\n    this.left = null;\n    this.right = null;\n    this.parent = parent;\n    this.dimension = dimension;\n  }\n\n  function kdTree(points, metric, dimensions) {\n    var self = this;\n\n    function buildTree(points, depth, parent) {\n      var dim = depth % dimensions.length,\n        median,\n        node;\n\n      if (points.length === 0) {\n        return null;\n      }\n      if (points.length === 1) {\n        return new Node(points[0], dim, parent);\n      }\n\n      points.sort(function(a, b) {\n        return a[dimensions[dim]] - b[dimensions[dim]];\n      });\n\n      median = Math.floor(points.length / 2);\n      node = new Node(points[median], dim, parent);\n      node.left = buildTree(points.slice(0, median), depth + 1, node);\n      node.right = buildTree(points.slice(median + 1), depth + 1, node);\n\n      return node;\n    }\n\n    this.root = buildTree(points, 0, null);\n\n    this.insert = function(point) {\n      function innerSearch(node, parent) {\n        if (node === null) {\n          return parent;\n        }\n\n        var dimension = dimensions[node.dimension];\n        if (point[dimension] < node.obj[dimension]) {\n          return innerSearch(node.left, node);\n        } else {\n          return innerSearch(node.right, node);\n        }\n      }\n\n      var insertPosition = innerSearch(this.root, null),\n        newNode,\n        dimension;\n\n      if (insertPosition === null) {\n        this.root = new Node(point, 0, null);\n        return;\n      }\n\n      newNode = new Node(\n        point,\n        (insertPosition.dimension + 1) % dimensions.length,\n        insertPosition\n      );\n      dimension = dimensions[insertPosition.dimension];\n\n      if (point[dimension] < insertPosition.obj[dimension]) {\n        insertPosition.left = newNode;\n      } else {\n        insertPosition.right = newNode;\n      }\n    };\n\n    this.nearest = function(point, maxNodes, maxDistance) {\n      var i, result, bestNodes;\n\n      bestNodes = new BinaryHeap(function(e) {\n        return -e[1];\n      });\n\n      function nearestSearch(node) {\n        var bestChild,\n          dimension = dimensions[node.dimension],\n          ownDistance = metric(point, node.obj),\n          linearPoint = {},\n          linearDistance,\n          otherChild,\n          i;\n\n        function saveNode(node, distance) {\n          bestNodes.push([node, distance]);\n          if (bestNodes.size() > maxNodes) {\n            bestNodes.pop();\n          }\n        }\n\n        for (i = 0; i < dimensions.length; i += 1) {\n          if (i === node.dimension) {\n            linearPoint[dimensions[i]] = point[dimensions[i]];\n          } else {\n            linearPoint[dimensions[i]] = node.obj[dimensions[i]];\n          }\n        }\n\n        linearDistance = metric(linearPoint, node.obj);\n\n        if (node.right === null && node.left === null) {\n          if (\n            bestNodes.size() < maxNodes ||\n            ownDistance < bestNodes.peek()[1]\n          ) {\n            saveNode(node, ownDistance);\n          }\n          return;\n        }\n\n        if (node.right === null) {\n          bestChild = node.left;\n        } else if (node.left === null) {\n          bestChild = node.right;\n        } else {\n          if (point[dimension] < node.obj[dimension]) {\n            bestChild = node.left;\n          } else {\n            bestChild = node.right;\n          }\n        }\n\n        nearestSearch(bestChild);\n\n        if (bestNodes.size() < maxNodes || ownDistance < bestNodes.peek()[1]) {\n          saveNode(node, ownDistance);\n        }\n\n        if (\n          bestNodes.size() < maxNodes ||\n          Math.abs(linearDistance) < bestNodes.peek()[1]\n        ) {\n          if (bestChild === node.left) {\n            otherChild = node.right;\n          } else {\n            otherChild = node.left;\n          }\n          if (otherChild !== null) {\n            nearestSearch(otherChild);\n          }\n        }\n      }\n\n      if (maxDistance) {\n        for (i = 0; i < maxNodes; i += 1) {\n          bestNodes.push([null, maxDistance]);\n        }\n      }\n\n      if (self.root) nearestSearch(self.root);\n\n      result = [];\n\n      for (i = 0; i < Math.min(maxNodes, bestNodes.content.length); i += 1) {\n        if (bestNodes.content[i][0]) {\n          result.push([bestNodes.content[i][0].obj, bestNodes.content[i][1]]);\n        }\n      }\n      return result;\n    };\n  }\n\n  function BinaryHeap(scoreFunction) {\n    this.content = [];\n    this.scoreFunction = scoreFunction;\n  }\n\n  BinaryHeap.prototype = {\n    push: function(element) {\n      // Add the new element to the end of the array.\n      this.content.push(element);\n      // Allow it to bubble up.\n      this.bubbleUp(this.content.length - 1);\n    },\n\n    pop: function() {\n      // Store the first element so we can return it later.\n      var result = this.content[0];\n      // Get the element at the end of the array.\n      var end = this.content.pop();\n      // If there are any elements left, put the end element at the\n      // start, and let it sink down.\n      if (this.content.length > 0) {\n        this.content[0] = end;\n        this.sinkDown(0);\n      }\n      return result;\n    },\n\n    peek: function() {\n      return this.content[0];\n    },\n\n    size: function() {\n      return this.content.length;\n    },\n\n    bubbleUp: function(n) {\n      // Fetch the element that has to be moved.\n      var element = this.content[n];\n      // When at 0, an element can not go up any further.\n      while (n > 0) {\n        // Compute the parent element's index, and fetch it.\n        var parentN = Math.floor((n + 1) / 2) - 1,\n          parent = this.content[parentN];\n        // Swap the elements if the parent is greater.\n        if (this.scoreFunction(element) < this.scoreFunction(parent)) {\n          this.content[parentN] = element;\n          this.content[n] = parent;\n          // Update 'n' to continue at the new position.\n          n = parentN;\n        }\n        // Found a parent that is less, no need to move it further.\n        else {\n          break;\n        }\n      }\n    },\n\n    sinkDown: function(n) {\n      // Look up the target element and its score.\n      var length = this.content.length,\n        element = this.content[n],\n        elemScore = this.scoreFunction(element);\n\n      while (true) {\n        // Compute the indices of the child elements.\n        var child2N = (n + 1) * 2,\n          child1N = child2N - 1;\n        // This is used to store the new position of the element,\n        // if any.\n        var swap = null;\n        // If the first child exists (is inside the array)...\n        if (child1N < length) {\n          // Look it up and compute its score.\n          var child1 = this.content[child1N],\n            child1Score = this.scoreFunction(child1);\n          // If the score is less than our element's, we need to swap.\n          if (child1Score < elemScore) swap = child1N;\n        }\n        // Do the same checks for the other child.\n        if (child2N < length) {\n          var child2 = this.content[child2N],\n            child2Score = this.scoreFunction(child2);\n          if (child2Score < (swap == null ? elemScore : child1Score)) {\n            swap = child2N;\n          }\n        }\n\n        // If the element needs to be moved, swap it, and continue.\n        if (swap != null) {\n          this.content[n] = this.content[swap];\n          this.content[swap] = element;\n          n = swap;\n        }\n        // Otherwise, we are done.\n        else {\n          break;\n        }\n      }\n    }\n  };\n\n  var dims = [];\n\n  for (var i = 0; i < fpoint.length; i++) dims.push(i);\n\n  var tree = new kdTree(\n    fpoints,\n    function(e1, e2) {\n      var d = 0;\n      var e3 = e1;\n      if (!Array.isArray(e1)) {\n        e3 = [];\n        for (var key in e1) e3.push(e1[key]);\n\n        e1 = e3;\n      }\n      e1.forEach(function(e, i) {\n        var sqd = e1[i] - e2[i];\n        d += sqd * sqd;\n      });\n      return d;\n    },\n    dims\n  );\n\n  return tree.nearest(fpoint, 1, 1000)[0][0];\n}"
        }
      ],
      "tests": [
        {
          "text": "`kdNN` should be a function.",
          "testCode": "assert(typeof kdNN == 'function');"
        },
        {
          "text": "`kdNN([[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]], [9, 2])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    kdNN(\n      [\n        [2, 3],\n        [5, 4],\n        [9, 6],\n        [4, 7],\n        [8, 1],\n        [7, 2]\n      ],\n      [9, 2]\n    )\n  )\n);"
        },
        {
          "text": "`kdNN([[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]], [9, 2])` should return `[ 8, 1 ]`.",
          "testCode": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3],\n      [5, 4],\n      [9, 6],\n      [4, 7],\n      [8, 1],\n      [7, 2]\n    ],\n    [9, 2]\n  ),\n  [8, 1]\n);"
        },
        {
          "text": "`kdNN([[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]], [7, 1])` should return `[ 8, 1 ]`.",
          "testCode": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3],\n      [5, 4],\n      [9, 6],\n      [4, 7],\n      [8, 1],\n      [7, 2]\n    ],\n    [7, 1]\n  ),\n  [8, 1]\n);"
        },
        {
          "text": "`kdNN([[[2, 3], [5, 4], [9, 6], [4, 7], [8, 1], [7, 2]], [3, 2])` should return `[ 2, 3 ]`.",
          "testCode": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3],\n      [5, 4],\n      [9, 6],\n      [4, 7],\n      [8, 1],\n      [7, 2]\n    ],\n    [3, 2]\n  ),\n  [2, 3]\n);"
        },
        {
          "text": "`kdNN([[2, 3, 1], [9, 4, 5], [4, 6, 7], [1, 2, 5], [7, 8, 9], [3, 6, 1]], [1, 2, 3])` should return `[ 1, 2, 5 ]`.",
          "testCode": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3, 1],\n      [9, 4, 5],\n      [4, 6, 7],\n      [1, 2, 5],\n      [7, 8, 9],\n      [3, 6, 1]\n    ],\n    [1, 2, 3]\n  ),\n  [1, 2, 5]\n);"
        },
        {
          "text": "`kdNN([[2, 3, 1], [9, 4, 5], [4, 6, 7], [1, 2, 5], [7, 8, 9], [3, 6, 1]], [4, 5, 6])` should return `[ 4, 6, 7 ]`.",
          "testCode": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3, 1],\n      [9, 4, 5],\n      [4, 6, 7],\n      [1, 2, 5],\n      [7, 8, 9],\n      [3, 6, 1]\n    ],\n    [4, 5, 6]\n  ),\n  [4, 6, 7]\n);"
        },
        {
          "text": "`kdNN([[2, 3, 1], [9, 4, 5], [4, 6, 7], [1, 2, 5], [7, 8, 9], [3, 6, 1]], [8, 8, 8])` should return `[ 7, 8, 9 ]`.",
          "testCode": "assert.deepEqual(\n  kdNN(\n    [\n      [2, 3, 1],\n      [9, 4, 5],\n      [4, 6, 7],\n      [1, 2, 5],\n      [7, 8, 9],\n      [3, 6, 1]\n    ],\n    [8, 8, 8]\n  ),\n  [7, 8, 9]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302295,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\k-d-tree.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7eca",
      "title": "Kaprekar numbers",
      "challengeType": 1,
      "dashedName": "kaprekar-numbers",
      "description": "A positive integer is a Kaprekar number if:\n\n<ul>\n  <li>It is 1, or,</li>\n  <li>The decimal representation of its square may be split once into two parts consisting of positive integers which sum to the original number. </li>\n</ul>\n\nNote that a split resulting in a part consisting purely of 0s is not valid, as 0 is not considered positive.\n\nExample Kaprekar numbers:\n\n<ul>\n  <li><code>2223</code> is a Kaprekar number, as <code>2223 * 2223 = 4941729</code>, <code>4941729</code> may be split to <code>494</code> and <code>1729</code>, and <code>494 + 1729 = 2223</code></li>\n  <li>The series of Kaprekar numbers is known as A006886, and begins as <code>1, 9, 45, 55, ...</code></li>\n</ul>",
      "instructions": "Write a function that takes a number $n$, a base $bs$, and returns true if the number is a Kaprekar number for the given base. Otherwise, the function returns false.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isKaprekar(n, bs) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isKaprekar(n, bs) {\n  if (n < 1) return false;\n  if (n == 1) return true;\n  for (var a = n * n, b = 0, s = 1; a; s *= bs) {\n    b += (a % bs) * s;\n    a = Math.floor(a / bs);\n    if (b && a + b == n) return true;\n  }\n  return false;\n}"
        }
      ],
      "tests": [
        {
          "text": "`isKaprekar` should be a function.",
          "testCode": "assert(typeof isKaprekar == 'function');"
        },
        {
          "text": "`isKaprekar(1, 10)` should return a boolean.",
          "testCode": "assert(typeof isKaprekar(1, 10) == 'boolean');"
        },
        {
          "text": "`isKaprekar(1, 10)` should return `true`.",
          "testCode": "assert.equal(isKaprekar(1, 10), true);"
        },
        {
          "text": "`isKaprekar(9, 10)` should return `true`.",
          "testCode": "assert.equal(isKaprekar(9, 10), true);"
        },
        {
          "text": "`isKaprekar(2223, 10)` should return `true`.",
          "testCode": "assert.equal(isKaprekar(2223, 10), true);"
        },
        {
          "text": "`isKaprekar(22823, 10)` should return `false`.",
          "testCode": "assert.equal(isKaprekar(22823, 10), false);"
        },
        {
          "text": "`isKaprekar(9, 17)` should return `false`.",
          "testCode": "assert.equal(isKaprekar(9, 17), false);"
        },
        {
          "text": "`isKaprekar(225, 17)` should return `true`.",
          "testCode": "assert.equal(isKaprekar(225, 17), true);"
        },
        {
          "text": "`isKaprekar(999, 17)` should return `false`.",
          "testCode": "assert.equal(isKaprekar(999, 17), false);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302296,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\kaprekar-numbers.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ed1",
      "title": "Knapsack problem/0-1",
      "challengeType": 1,
      "dashedName": "knapsack-problem0-1",
      "description": "The 0-1 knapsack problem is defined as follows:\n\nYou are given an array of objects representing items to be put in a knapsack. The objects have 3 attributes: name, weight, and value. The items need to be selected so that the total weight does not exceed the maximum weight and the value is maximized.",
      "instructions": "Write a function to solve the knapsack problem. The function is given the array of objects and the maximum weight as parameters. It should return the maximum total value possible.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function knapsack(items, maxweight) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function knapsack(items, maxweight) {\n  var _ = {\n    max: function(e) {\n      var mx = e[0];\n      e.forEach(function(f) {\n        if (mx < f) mx = f;\n      });\n      return mx;\n    },\n    map: function(array, func) {\n      return array.map(func);\n    },\n    isUndefined: function(a) {\n      if (a) {\n        return false;\n      }\n      return true;\n    },\n    range: function(start, end, step) {\n      var a = [];\n      var f = (f = (i, end) => i < end);\n      if (start > end) f = (i, end) => i > end;\n\n      for (var i = start; f(i, end); i += step) a.push(i);\n      return a;\n    }\n  };\n\n  var valuefn = e => e.value;\n  var weightfn = e => e.weight;\n  var _epsilon = 0.01;\n  var _p = _.max(_.map(items, valuefn));\n  var _k = (_epsilon * _p) / items.length;\n\n  var _memo = (function() {\n    var _mem = {};\n    var _key = function(i, w) {\n      return i + '::' + w;\n    };\n    return {\n      get: function(i, w) {\n        return _mem[_key(i, w)];\n      },\n      put: function(i, w, r) {\n        _mem[_key(i, w)] = r;\n        return r;\n      }\n    };\n  })();\n\n  var _m = function(i, w) {\n    i = Math.round(i);\n    w = Math.round(w);\n\n    if (i < 0 || w === 0) {\n      // empty base case\n      return { items: [], totalWeight: 0, totalValue: 0 };\n    }\n\n    var mm = _memo.get(i, w);\n    if (!_.isUndefined(mm)) {\n      return mm;\n    }\n\n    var item = items[i];\n    if (weightfn(item) > w) {\n      //item does not fit, try the next item\n      return _memo.put(i, w, _m(i - 1, w));\n    }\n    // this item could fit.\n    // are we better off excluding it?\n    var excluded = _m(i - 1, w);\n    // or including it?\n    var included = _m(i - 1, w - weightfn(item));\n    if (\n      included.totalValue + Math.floor(valuefn(item) / _k) >\n      excluded.totalValue\n    ) {\n      // better off including it\n      // make a copy of the list\n      var i1 = included.items.slice();\n      i1.push(item);\n      return _memo.put(i, w, {\n        items: i1,\n        totalWeight: included.totalWeight + weightfn(item),\n        totalValue: included.totalValue + Math.floor(valuefn(item) / _k)\n      });\n    }\n    //better off excluding it\n    return _memo.put(i, w, excluded);\n  };\n  var scaled = _m(items.length - 1, maxweight);\n\n  var val = 0;\n  scaled.items.forEach(function(e) {\n    val += e.value;\n  });\n  return val;\n}"
        }
      ],
      "tests": [
        {
          "text": "`knapsack([{ name:'map', weight:9, value:150 }, { name:'compass', weight:13, value:35 }, { name:'water', weight:153, value:200 }, { name:'sandwich', weight:50, value:160 }, { name:'glucose', weight:15, value:60 }, { name:'tin', weight:68, value:45 }, { name:'banana', weight:27, value:60 }, { name:'apple', weight:39, value:40 }], 100)` should return `405`.",
          "testCode": "assert.equal(\n  knapsack(\n    [\n      { name: 'map', weight: 9, value: 150 },\n      { name: 'compass', weight: 13, value: 35 },\n      { name: 'water', weight: 153, value: 200 },\n      { name: 'sandwich', weight: 50, value: 160 },\n      { name: 'glucose', weight: 15, value: 60 },\n      { name: 'tin', weight: 68, value: 45 },\n      { name: 'banana', weight: 27, value: 60 },\n      { name: 'apple', weight: 39, value: 40 }\n    ],\n    100\n  ),\n  405\n);"
        },
        {
          "text": "`knapsack([{ name:'map', weight:9, value:150 }, { name:'compass', weight:13, value:35 }, { name:'water', weight:153, value:200 }, { name:'sandwich', weight:50, value:160 }, { name:'glucose', weight:15, value:60 }, { name:'tin', weight:68, value:45 }, { name:'banana', weight:27, value:60 }, { name:'apple', weight:39, value:40 }], 200)` should return `510`.",
          "testCode": "assert.equal(\n  knapsack(\n    [\n      { name: 'map', weight: 9, value: 150 },\n      { name: 'compass', weight: 13, value: 35 },\n      { name: 'water', weight: 153, value: 200 },\n      { name: 'sandwich', weight: 50, value: 160 },\n      { name: 'glucose', weight: 15, value: 60 },\n      { name: 'tin', weight: 68, value: 45 },\n      { name: 'banana', weight: 27, value: 60 },\n      { name: 'apple', weight: 39, value: 40 }\n    ],\n    200\n  ),\n  510\n);"
        },
        {
          "text": "`knapsack([{ name:'cheese', weight:23, value:30 }, { name:'beer', weight:52, value:10 }, { name:'suntan cream', weight:11, value:70 }, { name:'camera', weight:32, value:30 }, { name:'T-shirt', weight:24, value:15 }, { name:'trousers', weight:48, value:10 }, { name:'umbrella', weight:73, value:40 }], 100)` should return `145`.",
          "testCode": "assert.equal(\n  knapsack(\n    [\n      { name: 'cheese', weight: 23, value: 30 },\n      { name: 'beer', weight: 52, value: 10 },\n      { name: 'suntan cream', weight: 11, value: 70 },\n      { name: 'camera', weight: 32, value: 30 },\n      { name: 'T-shirt', weight: 24, value: 15 },\n      { name: 'trousers', weight: 48, value: 10 },\n      { name: 'umbrella', weight: 73, value: 40 }\n    ],\n    100\n  ),\n  145\n);"
        },
        {
          "text": "`knapsack([{ name:'cheese', weight:23, value:30 }, { name:'beer', weight:52, value:10 }, { name:'suntan cream', weight:11, value:70 }, { name:'camera', weight:32, value:30 }, { name:'T-shirt', weight:24, value:15 }, { name:'trousers', weight:48, value:10 }, { name:'umbrella', weight:73, value:40 }], 200)` should return `185`.",
          "testCode": "assert.equal(\n  knapsack(\n    [\n      { name: 'cheese', weight: 23, value: 30 },\n      { name: 'beer', weight: 52, value: 10 },\n      { name: 'suntan cream', weight: 11, value: 70 },\n      { name: 'camera', weight: 32, value: 30 },\n      { name: 'T-shirt', weight: 24, value: 15 },\n      { name: 'trousers', weight: 48, value: 10 },\n      { name: 'umbrella', weight: 73, value: 40 }\n    ],\n    200\n  ),\n  185\n);"
        },
        {
          "text": "`knapsack([{ name:'waterproof trousers', weight:42, value:70 }, { name:'waterproof overclothes', weight:43, value:75 }, { name:'note-case', weight:22, value:80 }, { name:'sunglasses', weight:7, value:20 }, { name:'towel', weight:18, value:12 }, { name:'socks', weight:4, value:50 }, { name:'book', weight:30, value:10 }], 100)` should return `237`.",
          "testCode": "assert.equal(\n  knapsack(\n    [\n      { name: 'waterproof trousers', weight: 42, value: 70 },\n      { name: 'waterproof overclothes', weight: 43, value: 75 },\n      { name: 'note-case', weight: 22, value: 80 },\n      { name: 'sunglasses', weight: 7, value: 20 },\n      { name: 'towel', weight: 18, value: 12 },\n      { name: 'socks', weight: 4, value: 50 },\n      { name: 'book', weight: 30, value: 10 }\n    ],\n    100\n  ),\n  237\n);"
        },
        {
          "text": "`knapsack([{ name:'waterproof trousers', weight:42, value:70 }, { name:'waterproof overclothes', weight:43, value:75 }, { name:'note-case', weight:22, value:80 }, { name:'sunglasses', weight:7, value:20 }, { name:'towel', weight:18, value:12 }, { name:'socks', weight:4, value:50 }, { name:'book', weight:30, value:10 }], 200)` should return `317`.'",
          "testCode": "assert.equal(\n  knapsack(\n    [\n      { name: 'waterproof trousers', weight: 42, value: 70 },\n      { name: 'waterproof overclothes', weight: 43, value: 75 },\n      { name: 'note-case', weight: 22, value: 80 },\n      { name: 'sunglasses', weight: 7, value: 20 },\n      { name: 'towel', weight: 18, value: 12 },\n      { name: 'socks', weight: 4, value: 50 },\n      { name: 'book', weight: 30, value: 10 }\n    ],\n    200\n  ),\n  317\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 323649,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\knapsack-problem-0-1.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ed2",
      "title": "Knapsack problem/Bounded",
      "challengeType": 1,
      "dashedName": "knapsack-problembounded",
      "description": "The bounded knapsack problem is defined as follows:\n\nYou are given an array of objects representing items to be put in a knapsack. The objects have 4 attributes: name, pieces (the number of the particular item), weight, and value. The items need to be selected so that the total weight does not exceed the maximum weight and the value is maximized. Keep in mind that each item can appear between 0 and `pieces` times.",
      "instructions": "Write a function to solve the knapsack problem. The function is given the array of objects and the maximum weight as parameters. It should return the maximum total value possible.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function findBestPack(data, maxweight) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function findBestPack(data, maxweight) {\n  var m = [[0]]; // maximum pack value found so far\n  var b = [[0]]; // best combination found so far\n  var opts = [0]; // item index for 0 of item 0\n  var P = [1]; // item encoding for 0 of item 0\n  var choose = 0;\n  for (var j = 0; j < data.length; j++) {\n    opts[j + 1] = opts[j] + data[j].pieces; // item index for 0 of item j+1\n    P[j + 1] = P[j] * (1 + data[j].pieces); // item encoding for 0 of item j+1\n  }\n  for (var j = 0; j < opts[data.length]; j++) {\n    m[0][j + 1] = b[0][j + 1] = 0; // best values and combos for empty pack: nothing\n  }\n  for (var w = 1; w <= maxweight; w++) {\n    m[w] = [0];\n    b[w] = [0];\n    for (var j = 0; j < data.length; j++) {\n      var N = data[j].pieces; // how many of these can we have?\n      var base = opts[j]; // what is the item index for 0 of these?\n      for (var n = 1; n <= N; n++) {\n        var W = n * data[j].weight; // how much do these items weigh?\n        var s = w >= W ? 1 : 0; // can we carry this many?\n        var v = s * n * data[j].value; // how much are they worth?\n        var I = base + n; // what is the item number for this many?\n        var wN = w - s * W; // how much other stuff can we be carrying?\n        var C = n * P[j] + b[wN][base]; // encoded combination\n        m[w][I] = Math.max(m[w][I - 1], v + m[wN][base]); // best value\n        choose = b[w][I] = m[w][I] > m[w][I - 1] ? C : b[w][I - 1];\n      }\n    }\n  }\n\n  var best = [];\n  for (var j = data.length - 1; j >= 0; j--) {\n    best[j] = Math.floor(choose / P[j]);\n    choose -= best[j] * P[j];\n  }\n\n  var wgt = 0;\n  var val = 0;\n  for (var i = 0; i < best.length; i++) {\n    if (0 == best[i]) continue;\n    wgt += best[i] * data[i].weight;\n    val += best[i] * data[i].value;\n  }\n\n  return val;\n}"
        }
      ],
      "tests": [
        {
          "text": "`findBestPack([{ name:'map', weight:9, value:150, pieces:1 }, { name:'compass', weight:13, value:35, pieces:1 }, { name:'water', weight:153, value:200, pieces:2 }, { name:'sandwich', weight:50, value:60, pieces:2 }, { name:'glucose', weight:15, value:60, pieces:2 }, { name:'tin', weight:68, value:45, pieces:3 }, { name:'banana', weight:27, value:60, pieces:3 }, { name:'apple', weight:39, value:40, pieces:3 }, { name:'cheese', weight:23, value:30, pieces:1 }, { name:'beer', weight:52, value:10, pieces:3 }, { name:'suntan, cream', weight:11, value:70, pieces:1 }, { name:'camera', weight:32, value:30, pieces:1 }, { name:'T-shirt', weight:24, value:15, pieces:2 }], 300)` should return `755`.",
          "testCode": "assert.equal(\n  findBestPack(\n    [\n      { name: 'map', weight: 9, value: 150, pieces: 1 },\n      { name: 'compass', weight: 13, value: 35, pieces: 1 },\n      { name: 'water', weight: 153, value: 200, pieces: 2 },\n      { name: 'sandwich', weight: 50, value: 60, pieces: 2 },\n      { name: 'glucose', weight: 15, value: 60, pieces: 2 },\n      { name: 'tin', weight: 68, value: 45, pieces: 3 },\n      { name: 'banana', weight: 27, value: 60, pieces: 3 },\n      { name: 'apple', weight: 39, value: 40, pieces: 3 },\n      { name: 'cheese', weight: 23, value: 30, pieces: 1 },\n      { name: 'beer', weight: 52, value: 10, pieces: 3 },\n      { name: 'suntan, cream', weight: 11, value: 70, pieces: 1 },\n      { name: 'camera', weight: 32, value: 30, pieces: 1 },\n      { name: 'T-shirt', weight: 24, value: 15, pieces: 2 }\n    ],\n    300\n  ),\n  755\n);"
        },
        {
          "text": "`findBestPack([{ name:'map', weight:9, value:150, pieces:1 }, { name:'compass', weight:13, value:35, pieces:1 }, { name:'water', weight:153, value:200, pieces:2 }, { name:'sandwich', weight:50, value:60, pieces:2 }, { name:'glucose', weight:15, value:60, pieces:2 }, { name:'tin', weight:68, value:45, pieces:3 }, { name:'banana', weight:27, value:60, pieces:3 }, { name:'apple', weight:39, value:40, pieces:3 }, { name:'cheese', weight:23, value:30, pieces:1 }, { name:'beer', weight:52, value:10, pieces:3 }, { name:'suntan, cream', weight:11, value:70, pieces:1 }, { name:'camera', weight:32, value:30, pieces:1 }, { name:'T-shirt', weight:24, value:15, pieces:2 }], 400)` should return `875`.",
          "testCode": "assert.equal(\n  findBestPack(\n    [\n      { name: 'map', weight: 9, value: 150, pieces: 1 },\n      { name: 'compass', weight: 13, value: 35, pieces: 1 },\n      { name: 'water', weight: 153, value: 200, pieces: 2 },\n      { name: 'sandwich', weight: 50, value: 60, pieces: 2 },\n      { name: 'glucose', weight: 15, value: 60, pieces: 2 },\n      { name: 'tin', weight: 68, value: 45, pieces: 3 },\n      { name: 'banana', weight: 27, value: 60, pieces: 3 },\n      { name: 'apple', weight: 39, value: 40, pieces: 3 },\n      { name: 'cheese', weight: 23, value: 30, pieces: 1 },\n      { name: 'beer', weight: 52, value: 10, pieces: 3 },\n      { name: 'suntan, cream', weight: 11, value: 70, pieces: 1 },\n      { name: 'camera', weight: 32, value: 30, pieces: 1 },\n      { name: 'T-shirt', weight: 24, value: 15, pieces: 2 }\n    ],\n    400\n  ),\n  875\n);"
        },
        {
          "text": "`findBestPack([{ name:'map', weight:9, value:150, pieces:1 }, { name:'compass', weight:13, value:35, pieces:1 }, { name:'water', weight:153, value:200, pieces:2 }, { name:'sandwich', weight:50, value:60, pieces:2 }, { name:'glucose', weight:15, value:60, pieces:2 }, { name:'tin', weight:68, value:45, pieces:3 }, { name:'banana', weight:27, value:60, pieces:3 }, { name:'apple', weight:39, value:40, pieces:3 }, { name:'cheese', weight:23, value:30, pieces:1 }, { name:'beer', weight:52, value:10, pieces:3 }, { name:'suntan, cream', weight:11, value:70, pieces:1 }, { name:'camera', weight:32, value:30, pieces:1 }, { name:'T-shirt', weight:24, value:15, pieces:2 }], 500)` should return `1015`.",
          "testCode": "assert.equal(\n  findBestPack(\n    [\n      { name: 'map', weight: 9, value: 150, pieces: 1 },\n      { name: 'compass', weight: 13, value: 35, pieces: 1 },\n      { name: 'water', weight: 153, value: 200, pieces: 2 },\n      { name: 'sandwich', weight: 50, value: 60, pieces: 2 },\n      { name: 'glucose', weight: 15, value: 60, pieces: 2 },\n      { name: 'tin', weight: 68, value: 45, pieces: 3 },\n      { name: 'banana', weight: 27, value: 60, pieces: 3 },\n      { name: 'apple', weight: 39, value: 40, pieces: 3 },\n      { name: 'cheese', weight: 23, value: 30, pieces: 1 },\n      { name: 'beer', weight: 52, value: 10, pieces: 3 },\n      { name: 'suntan, cream', weight: 11, value: 70, pieces: 1 },\n      { name: 'camera', weight: 32, value: 30, pieces: 1 },\n      { name: 'T-shirt', weight: 24, value: 15, pieces: 2 }\n    ],\n    500\n  ),\n  1015\n);"
        },
        {
          "text": "`findBestPack([{ name:'map', weight:9, value:150, pieces:1 }, { name:'compass', weight:13, value:35, pieces:1 }, { name:'water', weight:153, value:200, pieces:2 }, { name:'sandwich', weight:50, value:60, pieces:2 }, { name:'glucose', weight:15, value:60, pieces:2 }, { name:'tin', weight:68, value:45, pieces:3 }, { name:'banana', weight:27, value:60, pieces:3 }, { name:'apple', weight:39, value:40, pieces:3 }, { name:'cheese', weight:23, value:30, pieces:1 }, { name:'beer', weight:52, value:10, pieces:3 }, { name:'suntan, cream', weight:11, value:70, pieces:1 }, { name:'camera', weight:32, value:30, pieces:1 }, { name:'T-shirt', weight:24, value:15, pieces:2 }], 600)` should return `1120`.",
          "testCode": "assert.equal(\n  findBestPack(\n    [\n      { name: 'map', weight: 9, value: 150, pieces: 1 },\n      { name: 'compass', weight: 13, value: 35, pieces: 1 },\n      { name: 'water', weight: 153, value: 200, pieces: 2 },\n      { name: 'sandwich', weight: 50, value: 60, pieces: 2 },\n      { name: 'glucose', weight: 15, value: 60, pieces: 2 },\n      { name: 'tin', weight: 68, value: 45, pieces: 3 },\n      { name: 'banana', weight: 27, value: 60, pieces: 3 },\n      { name: 'apple', weight: 39, value: 40, pieces: 3 },\n      { name: 'cheese', weight: 23, value: 30, pieces: 1 },\n      { name: 'beer', weight: 52, value: 10, pieces: 3 },\n      { name: 'suntan, cream', weight: 11, value: 70, pieces: 1 },\n      { name: 'camera', weight: 32, value: 30, pieces: 1 },\n      { name: 'T-shirt', weight: 24, value: 15, pieces: 2 }\n    ],\n    600\n  ),\n  1120\n);"
        },
        {
          "text": "`findBestPack([{ name:'map', weight:9, value:150, pieces:1 }, { name:'compass', weight:13, value:35, pieces:1 }, { name:'water', weight:153, value:200, pieces:2 }, { name:'sandwich', weight:50, value:60, pieces:2 }, { name:'glucose', weight:15, value:60, pieces:2 }, { name:'tin', weight:68, value:45, pieces:3 }, { name:'banana', weight:27, value:60, pieces:3 }, { name:'apple', weight:39, value:40, pieces:3 }, { name:'cheese', weight:23, value:30, pieces:1 }, { name:'beer', weight:52, value:10, pieces:3 }, { name:'suntan, cream', weight:11, value:70, pieces:1 }, { name:'camera', weight:32, value:30, pieces:1 }, { name:'T-shirt', weight:24, value:15, pieces:2 }], 700)` should return `1225`.",
          "testCode": "assert.equal(\n  findBestPack(\n    [\n      { name: 'map', weight: 9, value: 150, pieces: 1 },\n      { name: 'compass', weight: 13, value: 35, pieces: 1 },\n      { name: 'water', weight: 153, value: 200, pieces: 2 },\n      { name: 'sandwich', weight: 50, value: 60, pieces: 2 },\n      { name: 'glucose', weight: 15, value: 60, pieces: 2 },\n      { name: 'tin', weight: 68, value: 45, pieces: 3 },\n      { name: 'banana', weight: 27, value: 60, pieces: 3 },\n      { name: 'apple', weight: 39, value: 40, pieces: 3 },\n      { name: 'cheese', weight: 23, value: 30, pieces: 1 },\n      { name: 'beer', weight: 52, value: 10, pieces: 3 },\n      { name: 'suntan, cream', weight: 11, value: 70, pieces: 1 },\n      { name: 'camera', weight: 32, value: 30, pieces: 1 },\n      { name: 'T-shirt', weight: 24, value: 15, pieces: 2 }\n    ],\n    700\n  ),\n  1225\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 323652,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\knapsack-problem-bounded.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ed3",
      "title": "Knapsack problem/Continuous",
      "challengeType": 1,
      "dashedName": "knapsack-problemcontinuous",
      "description": "A thief burgles a butcher's shop, where he can select from some items.\n\nThe thief knows the weights and prices of each items. Because he has a knapsack with a limit on the maximum weight that it can carry, he wants to select the items such that he would have his profit maximized. He may cut the items; the item has a reduced price after cutting that is proportional to the original price by the ratio of masses. That means: half of an item has half the price of the original.",
      "instructions": "Write a function that takes an array of objects representing the items available in the shop. Each object has 3 attributes: name, weight, and value. The function also takes the maximum weight as a parameter. The function should return the maximum value possible, and the total weight of the selected items should not exceed the maximum weight.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function knapContinuous(items, maxweight) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function knapContinuous(items, maxweight) {\n  function item_cmp(a, b) {\n    const ua = a.unitVal,\n      ub = b.unitVal;\n    return ua < ub ? 1 : ua > ub ? -1 : 0;\n  }\n  items = items.map(({ value, weight }) => ({\n    unitVal: value / weight,\n    weight\n  }));\n  items.sort(item_cmp);\n\n  let val = 0;\n  let wt = 0;\n  for (let { unitVal, weight } of items) {\n    var portion = Math.min(maxweight - wt, weight);\n    wt += portion;\n    var addVal = portion * unitVal;\n    val += addVal;\n    if (wt >= maxweight) {\n      break;\n    }\n  }\n  return val;\n}"
        }
      ],
      "tests": [
        {
          "text": "`knapContinuous([{ \"weight\":3.8, \"value\":36, name:\"beef\" }, { \"weight\":5.4, \"value\":43, name:\"pork\" }, { \"weight\":3.6, \"value\":90, name:\"ham\" }, { \"weight\":2.4, \"value\":45, name:\"greaves\" }, { \"weight\":4.0, \"value\":30, name:\"flitch\" }, { \"weight\":2.5, \"value\":56, name:\"brawn\" }, { \"weight\":3.7, \"value\":67, name:\"welt\" }, { \"weight\":3.0, \"value\":95, name:\"salami\" }, { \"weight\":5.9, \"value\":98, name:\"sausage\" }], 10)` should return `257.875`.",
          "testCode": "assert.equal(\n  knapContinuous(\n    [\n      { weight: 3.8, value: 36, name: 'beef' },\n      { weight: 5.4, value: 43, name: 'pork' },\n      { weight: 3.6, value: 90, name: 'ham' },\n      { weight: 2.4, value: 45, name: 'greaves' },\n      { weight: 4.0, value: 30, name: 'flitch' },\n      { weight: 2.5, value: 56, name: 'brawn' },\n      { weight: 3.7, value: 67, name: 'welt' },\n      { weight: 3.0, value: 95, name: 'salami' },\n      { weight: 5.9, value: 98, name: 'sausage' }\n    ],\n    10\n  ),\n  257.875\n);"
        },
        {
          "text": "`knapContinuous([{ \"weight\":3.8, \"value\":36, name:\"beef\" }, { \"weight\":5.4, \"value\":43, name:\"pork\" }, { \"weight\":3.6, \"value\":90, name:\"ham\" }, { \"weight\":2.4, \"value\":45, name:\"greaves\" }, { \"weight\":4.0, \"value\":30, name:\"flitch\" }, { \"weight\":2.5, \"value\":56, name:\"brawn\" }, { \"weight\":3.7, \"value\":67, name:\"welt\" }, { \"weight\":3.0, \"value\":95, name:\"salami\" }, { \"weight\":5.9, \"value\":98, name:\"sausage\" }], 12)` should return `295.05405405405406`.",
          "testCode": "assert.equal(\n  knapContinuous(\n    [\n      { weight: 3.8, value: 36, name: 'beef' },\n      { weight: 5.4, value: 43, name: 'pork' },\n      { weight: 3.6, value: 90, name: 'ham' },\n      { weight: 2.4, value: 45, name: 'greaves' },\n      { weight: 4.0, value: 30, name: 'flitch' },\n      { weight: 2.5, value: 56, name: 'brawn' },\n      { weight: 3.7, value: 67, name: 'welt' },\n      { weight: 3.0, value: 95, name: 'salami' },\n      { weight: 5.9, value: 98, name: 'sausage' }\n    ],\n    12\n  ),\n  295.05405405405406\n);"
        },
        {
          "text": "`knapContinuous([{ \"weight\":3.8, \"value\":36, name:\"beef\" }, { \"weight\":5.4, \"value\":43, name:\"pork\" }, { \"weight\":3.6, \"value\":90, name:\"ham\" }, { \"weight\":2.4, \"value\":45, name:\"greaves\" }, { \"weight\":4.0, \"value\":30, name:\"flitch\" }, { \"weight\":2.5, \"value\":56, name:\"brawn\" }, { \"weight\":3.7, \"value\":67, name:\"welt\" }, { \"weight\":3.0, \"value\":95, name:\"salami\" }, { \"weight\":5.9, \"value\":98, name:\"sausage\" }], 15)` should return `349.3783783783784`.",
          "testCode": "assert.equal(\n  knapContinuous(\n    [\n      { weight: 3.8, value: 36, name: 'beef' },\n      { weight: 5.4, value: 43, name: 'pork' },\n      { weight: 3.6, value: 90, name: 'ham' },\n      { weight: 2.4, value: 45, name: 'greaves' },\n      { weight: 4.0, value: 30, name: 'flitch' },\n      { weight: 2.5, value: 56, name: 'brawn' },\n      { weight: 3.7, value: 67, name: 'welt' },\n      { weight: 3.0, value: 95, name: 'salami' },\n      { weight: 5.9, value: 98, name: 'sausage' }\n    ],\n    15\n  ),\n  349.3783783783784\n);"
        },
        {
          "text": "`knapContinuous([{ \"weight\":3.8, \"value\":36, name:\"beef\" }, { \"weight\":5.4, \"value\":43, name:\"pork\" }, { \"weight\":3.6, \"value\":90, name:\"ham\" }, { \"weight\":2.4, \"value\":45, name:\"greaves\" }, { \"weight\":4.0, \"value\":30, name:\"flitch\" }, { \"weight\":2.5, \"value\":56, name:\"brawn\" }, { \"weight\":3.7, \"value\":67, name:\"welt\" }, { \"weight\":3.0, \"value\":95, name:\"salami\" }, { \"weight\":5.9, \"value\":98, name:\"sausage\" }], 22)` should return `459.5263157894737`.",
          "testCode": "assert.equal(\n  knapContinuous(\n    [\n      { weight: 3.8, value: 36, name: 'beef' },\n      { weight: 5.4, value: 43, name: 'pork' },\n      { weight: 3.6, value: 90, name: 'ham' },\n      { weight: 2.4, value: 45, name: 'greaves' },\n      { weight: 4.0, value: 30, name: 'flitch' },\n      { weight: 2.5, value: 56, name: 'brawn' },\n      { weight: 3.7, value: 67, name: 'welt' },\n      { weight: 3.0, value: 95, name: 'salami' },\n      { weight: 5.9, value: 98, name: 'sausage' }\n    ],\n    22\n  ),\n  459.5263157894737\n);"
        },
        {
          "text": "`knapContinuous([{ \"weight\":3.8, \"value\":36, name:\"beef\" }, { \"weight\":5.4, \"value\":43, name:\"pork\" }, { \"weight\":3.6, \"value\":90, name:\"ham\" }, { \"weight\":2.4, \"value\":45, name:\"greaves\" }, { \"weight\":4.0, \"value\":30, name:\"flitch\" }, { \"weight\":2.5, \"value\":56, name:\"brawn\" }, { \"weight\":3.7, \"value\":67, name:\"welt\" }, { \"weight\":3.0, \"value\":95, name:\"salami\" }, { \"weight\":5.9, \"value\":98, name:\"sausage\" }], 24)` should return `478.4736842105263`.",
          "testCode": "assert.equal(\n  knapContinuous(\n    [\n      { weight: 3.8, value: 36, name: 'beef' },\n      { weight: 5.4, value: 43, name: 'pork' },\n      { weight: 3.6, value: 90, name: 'ham' },\n      { weight: 2.4, value: 45, name: 'greaves' },\n      { weight: 4.0, value: 30, name: 'flitch' },\n      { weight: 2.5, value: 56, name: 'brawn' },\n      { weight: 3.7, value: 67, name: 'welt' },\n      { weight: 3.0, value: 95, name: 'salami' },\n      { weight: 5.9, value: 98, name: 'sausage' }\n    ],\n    24\n  ),\n  478.4736842105263\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 323654,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\knapsack-problem-continuous.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ed4",
      "title": "Knapsack problem/Unbounded",
      "challengeType": 1,
      "dashedName": "knapsack-problemunbounded",
      "description": "A traveler gets diverted and has to make an unscheduled stop in what turns out to be Shangri-La. Opting to leave, he is allowed to take as much as he likes of the items available there, so long as it will fit in his knapsack, and he can carry it.\n\nHe knows that he can carry no more than a particular value of maximum weight in total; and that the capacity of his knapsack has a limited volume.\n\nLooking just above the bar codes on the items he finds their weights and volumes. He digs out his recent copy of a financial paper and gets the value of each item.\n\nHe can only take whole units of any item, but there is much more of any item than he could ever carry.",
      "instructions": "Write a function that takes an array of objects, maximum weight, and maximum volume as parameters. Each object has 4 attributes: name, value, weight, and volume. The function should return the maximum value of items the traveller can take with him.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function knapsackUnbounded(items, maxweight, maxvolume) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function knapsackUnbounded(items, maxWeight, maxVolume) {\n  function getPickTotals(items, pick) {\n    let totalValue = 0;\n    let totalWeight = 0;\n    let totalVolume = 0;\n    for (let i = 0; i < items.length; i++) {\n      totalValue += pick[i] * items[i].value;\n      totalWeight += pick[i] * items[i].weight;\n      totalVolume += pick[i] * items[i].volume;\n    }\n    return [totalValue, totalWeight, totalVolume];\n  }\n\n  function getMaxes(items, maxWeight, maxVolume) {\n    const maxes = [];\n    for (let i = 0; i < items.length; i++) {\n      const maxUnitsInWeight = Math.floor(maxWeight / items[i].weight);\n      const maxUnitsInVolume = Math.floor(maxVolume / items[i].volume);\n      const maxUnitsInLimit = Math.min(maxUnitsInWeight, maxUnitsInVolume);\n      maxes.push(maxUnitsInLimit);\n    }\n    return maxes;\n  }\n\n  function isInLimit(value, limit) {\n    return value <= limit;\n  }\n\n  function getCombinations(maxValues, curPicks, combinations) {\n    if (maxValues.length === 0) {\n      combinations.push(curPicks);\n    }\n\n    const curMax = maxValues[0];\n    const leftMaxValues = maxValues.slice(1);\n    for (let i = 0; i <= curMax; i++) {\n      getCombinations(leftMaxValues, curPicks.concat(i), combinations);\n    }\n    return combinations;\n  }\n\n  let bestValue = 0;\n  let bestPick = [];\n  const maxes = getMaxes(items, maxWeight, maxVolume);\n  const combinations = getCombinations(maxes, [], []);\n  for (let i = 0; i < combinations.length; i++) {\n    const curPick = combinations[i];\n    const [curValue, curWeight, curVolume] = getPickTotals(items, curPick);\n    if (!isInLimit(curWeight, maxWeight) || !isInLimit(curVolume, maxVolume)) {\n      continue;\n    }\n\n    if (curValue > bestValue) {\n      bestValue = curValue;\n      bestPick = [curPick];\n    } else if (curValue === bestValue) {\n      bestPick.push(curPick);\n    }\n  }\n\n  return bestValue;\n}"
        }
      ],
      "tests": [
        {
          "text": "`knapsackUnbounded([{ name:\"panacea\", value:3000, weight:0.3, volume:0.025 }, { name:\"ichor\", value:1800, weight:0.2, volume:0.015 }, { name:\"gold\", value:2500, weight:2, volume:0.002 }], 25, 0.25)` should return `54500`.",
          "testCode": "assert.equal(\n  knapsackUnbounded(\n    [\n      { name: 'panacea', value: 3000, weight: 0.3, volume: 0.025 },\n      { name: 'ichor', value: 1800, weight: 0.2, volume: 0.015 },\n      { name: 'gold', value: 2500, weight: 2, volume: 0.002 }\n    ],\n    25,\n    0.25\n  ),\n  54500\n);"
        },
        {
          "text": "`knapsackUnbounded([{ name:\"panacea\", value:3000, weight:0.3, volume:0.025 }, { name:\"ichor\", value:1800, weight:0.2, volume:0.015 }, { name:\"gold\", value:2500, weight:2, volume:0.002 }], 55, 0.25)` should return `88400`.",
          "testCode": "assert.equal(\n  knapsackUnbounded(\n    [\n      { name: 'panacea', value: 3000, weight: 0.3, volume: 0.025 },\n      { name: 'ichor', value: 1800, weight: 0.2, volume: 0.015 },\n      { name: 'gold', value: 2500, weight: 2, volume: 0.002 }\n    ],\n    55,\n    0.25\n  ),\n  88400\n);"
        },
        {
          "text": "`knapsackUnbounded([{ name:\"panacea\", value:3000, weight:0.3, volume:0.025 }, { name:\"ichor\", value:1800, weight:0.2, volume:0.015 }, { name:\"gold\", value:2500, weight:2, volume:0.002 }], 25, 0.15)` should return `42500`.",
          "testCode": "assert.equal(\n  knapsackUnbounded(\n    [\n      { name: 'panacea', value: 3000, weight: 0.3, volume: 0.025 },\n      { name: 'ichor', value: 1800, weight: 0.2, volume: 0.015 },\n      { name: 'gold', value: 2500, weight: 2, volume: 0.002 }\n    ],\n    25,\n    0.15\n  ),\n  42500\n);"
        },
        {
          "text": "`knapsackUnbounded([{ name:\"panacea\", value:3000, weight:0.3, volume:0.025 }, { name:\"ichor\", value:1800, weight:0.2, volume:0.015 }, { name:\"gold\", value:2500, weight:2, volume:0.002 }], 35, 0.35)` should return `75900`.",
          "testCode": "assert.equal(\n  knapsackUnbounded(\n    [\n      { name: 'panacea', value: 3000, weight: 0.3, volume: 0.025 },\n      { name: 'ichor', value: 1800, weight: 0.2, volume: 0.015 },\n      { name: 'gold', value: 2500, weight: 2, volume: 0.002 }\n    ],\n    35,\n    0.35\n  ),\n  75900\n);"
        },
        {
          "text": "`knapsackUnbounded([{ name:\"panacea\", value:3000, weight:0.3, volume:0.025 }, { name:\"ichor\", value:1800, weight:0.2, volume:0.015 }, { name:\"gold\", value:2500, weight:2, volume:0.002 }], 15, 0.25)` should return `43200`.",
          "testCode": "assert.equal(\n  knapsackUnbounded(\n    [\n      { name: 'panacea', value: 3000, weight: 0.3, volume: 0.025 },\n      { name: 'ichor', value: 1800, weight: 0.2, volume: 0.015 },\n      { name: 'gold', value: 2500, weight: 2, volume: 0.002 }\n    ],\n    15,\n    0.25\n  ),\n  43200\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 323655,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\knapsack-problem-unbounded.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ed5",
      "title": "Knight's tour",
      "challengeType": 1,
      "dashedName": "knights-tour",
      "description": "Knight's Tour Problem: You have an empty `width` \\* `height` chessboard, but for a single knight on some square. The knight must perform a sequence of legal moves that result in the knight visiting every square on the chessboard exactly once. Note that it is *not* a requirement that the tour be \"closed\"; that is, the knight need not end within a single move of its start position.",
      "instructions": "Write a function that takes `width` and `height` as parameters and returns the number of initial positions from where it is possible to achieve the task stated above.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function knightTour(width, height) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function knightTour(width, height) {\n  function createBoards(rows, columns) {\n    const board = [];\n    const visited = [];\n    for (let i = 0; i < rows; i++) {\n      board.push(new Array(columns).fill(-1));\n      visited.push(new Array(columns).fill(false));\n    }\n    return [board, visited];\n  }\n\n  function copyBoard(board) {\n    const copied = [];\n    for (let i = 0; i < board.length; i++) {\n      copied.push([...board[i]]);\n    }\n    return copied;\n  }\n\n  function isOnBoard(value, limit) {\n    return value >= 0 && value < limit;\n  }\n\n  function markVisited(board, visited, row, column) {\n    visited[row][column] = true;\n    board[row][column] = -1;\n  }\n\n  function areAllVisited(visited) {\n    return (\n      visited.filter(row => row.filter(column => column === false).length !== 0)\n        .length === 0\n    );\n  }\n\n  function getMovesFrom(board, row, column) {\n    const possibleMoves = [];\n    for (let i = 0; i < moves.length; i++) {\n      const [rowChange, colChange] = moves[i];\n      const [rowN, colN] = [row + rowChange, column + colChange];\n      if (!isOnBoard(rowN, board.length) || !isOnBoard(colN, board[0].length)) {\n        continue;\n      }\n      possibleMoves.push([rowN, colN]);\n    }\n    return possibleMoves;\n  }\n\n  function fillAllowedMovesCounts(board) {\n    for (let row = 0; row < board.length; row++) {\n      for (let column = 0; column < board[0].length; column++) {\n        board[row][column] = getMovesFrom(board, row, column).length;\n      }\n    }\n  }\n\n  function updateAllowedMovesCounts(board, possibleMoves) {\n    for (let i = 0; i < possibleMoves.length; i++) {\n      const [row, column] = possibleMoves[i];\n      if (board[row][column] > 0) {\n        board[row][column]--;\n      }\n    }\n  }\n\n  function getBestNextMoves(board, allowedMoves) {\n    let bestMoves = [];\n    let fewestNextMoves = Infinity;\n    let zeroMove = [];\n    for (let i = 0; i < allowedMoves.length; i++) {\n      const [moveRow, moveCol] = allowedMoves[i];\n      const numMoves = board[moveRow][moveCol];\n      if (numMoves === -1) {\n        continue;\n      }\n      if (numMoves === 0) {\n        zeroMove.push(allowedMoves[i]);\n      }\n      if (numMoves < fewestNextMoves) {\n        bestMoves = [allowedMoves[i]];\n        fewestNextMoves = numMoves;\n      } else if (numMoves === fewestNextMoves) {\n        bestMoves.push(allowedMoves[i]);\n      }\n    }\n\n    if (bestMoves.length > 0) {\n      return bestMoves;\n    }\n    return zeroMove;\n  }\n\n  function solve(board, visited, lastRow, lastColumn) {\n    if (areAllVisited(visited)) {\n      return true;\n    }\n    const nextMoves = getMovesFrom(board, lastRow, lastColumn);\n    updateAllowedMovesCounts(board, nextMoves);\n    const allowedMoves = nextMoves.filter(\n      ([row, column]) => !visited[row][column]\n    );\n\n    const bestMoves = getBestNextMoves(board, allowedMoves);\n    const restMoves = allowedMoves.filter(\n      move => bestMoves.indexOf(move) === -1\n    );\n    const possibleMoves = [...bestMoves];\n    possibleMoves.push(...getBestNextMoves(board, restMoves));\n\n    for (let i = 0; i < possibleMoves.length; i++) {\n      const [moveRow, moveCol] = possibleMoves[i];\n      const newBoard = copyBoard(board);\n      const newVisited = copyBoard(visited);\n      markVisited(newBoard, newVisited, moveRow, moveCol);\n      if (solve(newBoard, newVisited, moveRow, moveCol)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  function solveStart(board, visited, startRow, startColumn) {\n    const newBoard = copyBoard(board);\n    const newVisited = copyBoard(visited);\n    markVisited(newBoard, newVisited, startRow, startColumn);\n    return solve(newBoard, newVisited, startRow, startColumn);\n  }\n\n  const moves = [\n    [-1, -2],\n    [-2, -1],\n    [-2, 1],\n    [-1, 2],\n    [1, 2],\n    [2, 1],\n    [2, -1],\n    [1, -2]\n  ];\n\n  const [baseBoard, baseVisited] = createBoards(height, width);\n  fillAllowedMovesCounts(baseBoard);\n  let solvedCount = 0;\n  for (let row = 0; row < height; row++) {\n    for (let column = 0; column < width; column++) {\n      if (solveStart(baseBoard, baseVisited, row, column)) {\n        solvedCount++;\n      }\n    }\n  }\n  return solvedCount;\n}"
        }
      ],
      "tests": [
        {
          "text": "`knightTour` should be a function.",
          "testCode": "assert(typeof knightTour == 'function');"
        },
        {
          "text": "`knightTour(6, 6)` should return a number.",
          "testCode": "assert(typeof knightTour(6, 6) == 'number');"
        },
        {
          "text": "`knightTour(6, 6)` should return `36`.",
          "testCode": "assert.equal(knightTour(6, 6), 36);"
        },
        {
          "text": "`knightTour(5, 6)` should return `30`.",
          "testCode": "assert.equal(knightTour(5, 6), 30);"
        },
        {
          "text": "`knightTour(4, 6)` should return `12`.",
          "testCode": "assert.equal(knightTour(4, 6), 12);"
        },
        {
          "text": "`knightTour(7, 3)` should return `10`.",
          "testCode": "assert.equal(knightTour(7, 3), 10);"
        },
        {
          "text": "`knightTour(8, 6)` should return `48`.",
          "testCode": "assert.equal(knightTour(8, 6), 48);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302297,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\knights-tour.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7edb",
      "title": "Largest int from concatenated ints",
      "challengeType": 1,
      "dashedName": "largest-int-from-concatenated-ints",
      "description": "Given a set of positive integers, write a function to order the integers in such a way that the concatenation of the numbers forms the largest possible integer and return this integer.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function maxCombine(xs) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function maxCombine(xs) {\n  return parseInt(\n    xs\n      .sort(function(x, y) {\n        var a = x.toString(),\n          b = y.toString(),\n          ab = parseInt(a + b),\n          ba = parseInt(b + a);\n\n        return ab > ba ? -1 : ab < ba ? 1 : 0;\n      })\n      .join(''),\n    10\n  );\n}"
        }
      ],
      "tests": [
        {
          "text": "`maxCombine` should be a function.",
          "testCode": "assert(typeof maxCombine == 'function');"
        },
        {
          "text": "`maxCombine([1, 3, 3, 4, 55])` should return a number.",
          "testCode": "assert(typeof maxCombine([1, 3, 3, 4, 55]) == 'number');"
        },
        {
          "text": "`maxCombine([1, 3, 3, 4, 55])` should return `554331`.",
          "testCode": "assert.equal(maxCombine([1, 3, 3, 4, 55]), 554331);"
        },
        {
          "text": "`maxCombine([71, 45, 23, 4, 5])` should return `71545423`.",
          "testCode": "assert.equal(maxCombine([71, 45, 23, 4, 5]), 71545423);"
        },
        {
          "text": "`maxCombine([14, 43, 53, 114, 55])` should return `55534314114`.",
          "testCode": "assert.equal(maxCombine([14, 43, 53, 114, 55]), 55534314114);"
        },
        {
          "text": "`maxCombine([1, 34, 3, 98, 9, 76, 45, 4])` should return `998764543431`.",
          "testCode": "assert.equal(maxCombine([1, 34, 3, 98, 9, 76, 45, 4]), 998764543431);"
        },
        {
          "text": "`maxCombine([54, 546, 548, 60])` should return `6054854654`.",
          "testCode": "assert.equal(maxCombine([54, 546, 548, 60]), 6054854654);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302298,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\largest-int-from-concatenated-ints.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7edc",
      "title": "Last Friday of each month",
      "challengeType": 1,
      "dashedName": "last-friday-of-each-month",
      "description": "Write a function that returns the date of the last Friday of a given month for a given year.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function lastFriday(year, month) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function lastFriday(year, month) {\n  var i, last_day;\n  i = 0;\n  while (true) {\n    last_day = new Date(year, month, i);\n    if (last_day.getDay() === 5) {\n      return last_day.getDate();\n    }\n    i -= 1;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`lastFriday` should be a function.",
          "testCode": "assert(typeof lastFriday == 'function');"
        },
        {
          "text": "`lastFriday(2018, 1)` should return a number.",
          "testCode": "assert(typeof lastFriday(2018, 1) == 'number');"
        },
        {
          "text": "`lastFriday(2018, 1)` should return `26`.",
          "testCode": "assert.equal(lastFriday(2018, 1), 26);"
        },
        {
          "text": "`lastFriday(2017, 2)` should return `24`.",
          "testCode": "assert.equal(lastFriday(2017, 2), 24);"
        },
        {
          "text": "`lastFriday(2012, 3)` should return `30`.",
          "testCode": "assert.equal(lastFriday(2012, 3), 30);"
        },
        {
          "text": "`lastFriday(1900, 4)` should return `27`.",
          "testCode": "assert.equal(lastFriday(1900, 4), 27);"
        },
        {
          "text": "`lastFriday(2000, 5)` should return `26`.",
          "testCode": "assert.equal(lastFriday(2000, 5), 26);"
        },
        {
          "text": "`lastFriday(2006, 6)` should return `30`.",
          "testCode": "assert.equal(lastFriday(2006, 6), 30);"
        },
        {
          "text": "`lastFriday(2010, 7)` should return `30`.",
          "testCode": "assert.equal(lastFriday(2010, 7), 30);"
        },
        {
          "text": "`lastFriday(2005, 8)` should return `26`.",
          "testCode": "assert.equal(lastFriday(2005, 8), 26);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302299,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\last-friday-of-each-month.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e4ce2b6ac708cc68c1df25e",
      "title": "Last letter-first letter",
      "challengeType": 1,
      "dashedName": "last-letter-first-letter",
      "description": "A certain children's game involves starting with a word in a particular category. Each participant in turn says a word, but that word must begin with the final letter of the previous word. Once a word has been given, it cannot be repeated. If an opponent cannot give a word in the category, they fall out of the game.\n\nFor example, with \"animals\" as the category,\n\n<pre>Child 1: dog\nChild 2: goldfish\nChild 1: hippopotamus\nChild 2: snake\n...\n</pre>",
      "instructions": "Write a function that takes an input array of words. The function should return an array of words where the first letter of each word is the same as the last letter of the previous word. Only use the words in the input array, and once a word is used it cannot be repeated. The words in the return array should be selected and sequenced so that its length is maximized.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function findLongestChain(items) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function findLongestChain(items) {\n  function Ref(index, first_char, last_char) {\n    this.index = index;\n    this.first_char = first_char;\n    this.last_char = last_char;\n  }\n\n  var items_len = items.length\n  var refs_len = items_len;\n  var refs = []\n\n  // enough space for all items\n  var longest_path_refs_len = 0;\n  var longest_path_refs = new Array(items_len);\n\n  function search(curr_len) {\n    if (curr_len > longest_path_refs_len) {\n      longest_path_refs_len = curr_len;\n\n      for (var i = 0; i < curr_len; i++) {\n        longest_path_refs[i] = refs[i];\n      }\n    }\n\n    // recursive search\n    var last_char = refs[curr_len - 1].last_char;\n    for (var i = curr_len; i < refs_len; i++)\n      if (refs[i].first_char == last_char) {\n        var aux = refs[curr_len];\n        refs[curr_len] = refs[i];\n        refs[i] = aux;\n        search(curr_len + 1);\n        refs[i] = refs[curr_len];\n        refs[curr_len] = aux;\n      }\n  }\n\n  for (var i = 0; i < items_len; i++) {\n    var itemsi_len = items[i].length;\n    refs.push(new Ref(i, items[i][0], items[i][itemsi_len - 1]));\n  }\n\n  // try each item as possible start\n  for (var i = 0; i < items_len; i++) {\n    var aux = refs[0];\n    refs[0] = refs[i];\n    refs[i] = aux;\n    search(1);\n    refs[i] = refs[0];\n    refs[0] = aux;\n  }\n\n  var longest_path_len = longest_path_refs_len;\n  var longest_path = new Array(longest_path_len);\n\n  for (var i = 0; i < longest_path_len; i++)\n    longest_path[i] = items[longest_path_refs[i].index];\n\n  return longest_path;\n}"
        }
      ],
      "tests": [
        {
          "text": "`findLongestChain` should be a function.",
          "testCode": "assert(typeof findLongestChain == 'function');"
        },
        {
          "text": "`findLongestChain([\"certain\", \"each\", \"game\", \"involves\", \"starting\", \"with\", \"word\"])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    findLongestChain([\n      'certain',\n      'each',\n      'game',\n      'involves',\n      'starting',\n      'with',\n      'word'\n    ])\n  )\n);"
        },
        {
          "text": "`findLongestChain([\"certain\", \"each\", \"game\", \"involves\", \"starting\", \"with\", \"word\"])` should return `[\"involves\", \"starting\", \"game\", \"each\"]`.",
          "testCode": "assert.deepEqual(\n  findLongestChain([\n    'certain',\n    'each',\n    'game',\n    'involves',\n    'starting',\n    'with',\n    'word'\n  ]),\n  ['involves', 'starting', 'game', 'each']\n);"
        },
        {
          "text": "`findLongestChain([\"audino\", \"bagon\", \"kangaskhan\", \"banette\", \"bidoof\", \"braviary\", \"exeggcute\", \"yamask\"])` should return `[\"braviary\", \"yamask\", \"kangaskhan\"]`",
          "testCode": "assert.deepEqual(\n  findLongestChain([\n    'audino',\n    'bagon',\n    'kangaskhan',\n    'banette',\n    'bidoof',\n    'braviary',\n    'exeggcute',\n    'yamask'\n  ]),\n  ['braviary', 'yamask', 'kangaskhan']\n);"
        },
        {
          "text": "`findLongestChain([\"harp\", \"poliwrath\", \"poochyena\", \"porygon2\", \"porygonz\", \"archana\"])` should return `[\"poliwrath\", \"harp\", \"poochyena\", \"archana\"]`.",
          "testCode": "assert.deepEqual(\n  findLongestChain([\n    'harp',\n    'poliwrath',\n    'poochyena',\n    'porygon2',\n    'porygonz',\n    'archana'\n  ]),\n  ['poliwrath', 'harp', 'poochyena', 'archana']\n);"
        },
        {
          "text": "`findLongestChain([\"scolipede\", \"elephant\", \"zeaking\", \"sealeo\", \"silcoon\", \"tigers\"])` should return `[\"scolipede\", \"elephant\", \"tigers\", \"sealeo\"]`.",
          "testCode": "assert.deepEqual(\n  findLongestChain([\n    'scolipede',\n    'elephant',\n    'zeaking',\n    'sealeo',\n    'silcoon',\n    'tigers'\n  ]),\n  ['scolipede', 'elephant', 'tigers', 'sealeo']\n);"
        },
        {
          "text": "`findLongestChain([\"loudred\", \"lumineon\", \"lunatone\", \"machamp\", \"magnezone\", \"nosepass\", \"petilil\", \"pidgeotto\", \"pikachu\"])` should return `[\"machamp\", \"petilil\", \"lumineon\", \"nosepass\"]`.",
          "testCode": "assert.deepEqual(\n  findLongestChain([\n    'loudred',\n    'lumineon',\n    'lunatone',\n    'machamp',\n    'magnezone',\n    'nosepass',\n    'petilil',\n    'pidgeotto',\n    'pikachu'\n  ]),\n  ['machamp', 'petilil', 'lumineon', 'nosepass']\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385256,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\last-letter-first-letter.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ede",
      "title": "Leap year",
      "challengeType": 1,
      "dashedName": "leap-year",
      "description": "Determine whether a given year is a leap year in the Gregorian calendar.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isLeapYear(year) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isLeapYear(year) {\n  return year % 100 === 0 ? year % 400 === 0 : year % 4 === 0;\n}"
        }
      ],
      "tests": [
        {
          "text": "`isLeapYear` should be a function.",
          "testCode": "assert(typeof isLeapYear == 'function');"
        },
        {
          "text": "`isLeapYear()` should return a boolean.",
          "testCode": "assert(typeof isLeapYear(2018) == 'boolean');"
        },
        {
          "text": "`isLeapYear(2018)` should return `false`.",
          "testCode": "assert.equal(isLeapYear(2018), false);"
        },
        {
          "text": "`isLeapYear(2016)` should return `true`.",
          "testCode": "assert.equal(isLeapYear(2016), true);"
        },
        {
          "text": "`isLeapYear(2000)` should return `true`.",
          "testCode": "assert.equal(isLeapYear(2000), true);"
        },
        {
          "text": "`isLeapYear(1900)` should return `false`.",
          "testCode": "assert.equal(isLeapYear(1900), false);"
        },
        {
          "text": "`isLeapYear(1996)` should return `true`.",
          "testCode": "assert.equal(isLeapYear(1996), true);"
        },
        {
          "text": "`isLeapYear(1800)` should return `false`.",
          "testCode": "assert.equal(isLeapYear(1800), false);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302300,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\leap-year.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7edf",
      "title": "Least common multiple",
      "challengeType": 1,
      "dashedName": "least-common-multiple",
      "description": "The least common multiple of 12 and 18 is 36, because 12 is a factor (12 × 3 = 36), and 18 is a factor (18 × 2 = 36), and there is no positive integer less than 36 that has both factors. As a special case, if either $m$ or $n$ is zero, then the least common multiple is zero. One way to calculate the least common multiple is to iterate all the multiples of $m$, until you find one that is also a multiple of $n$. If you already have $gcd$ for <a href=\"https://rosettacode.org/wiki/Greatest_common_divisor\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">greatest common divisor</a>, then this formula calculates $lcm$. \n\n$$\n\\\\operatorname{lcm}(m, n) = \\\\frac{|m \\\\times n|}{\\\\operatorname{gcd}(m, n)}\n$$",
      "instructions": "Compute the least common multiple of an array of integers. Given *m* and *n*, the least common multiple is the smallest positive integer that has both *m* and *n* as factors.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function LCM(A) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function LCM(A) {\n  var n = A.length,\n    a = Math.abs(A[0]);\n  for (var i = 1; i < n; i++) {\n    var b = Math.abs(A[i]),\n      c = a;\n    while (a && b) {\n      a > b ? (a %= b) : (b %= a);\n    }\n    a = Math.abs(c * A[i]) / (a + b);\n  }\n  return a;\n}"
        }
      ],
      "tests": [
        {
          "text": "`LCM` should be a function.",
          "testCode": "assert(typeof LCM == 'function');"
        },
        {
          "text": "`LCM([2, 4, 8])` should return a number.",
          "testCode": "assert(typeof LCM([2, 4, 8]) == 'number');"
        },
        {
          "text": "`LCM([2, 4, 8])` should return `8`.",
          "testCode": "assert.equal(LCM([2, 4, 8]), 8);"
        },
        {
          "text": "`LCM([4, 8, 12])` should return `24`.",
          "testCode": "assert.equal(LCM([4, 8, 12]), 24);"
        },
        {
          "text": "`LCM([3, 4, 5, 12, 40])` should return `120`.",
          "testCode": "assert.equal(LCM([3, 4, 5, 12, 40]), 120);"
        },
        {
          "text": "`LCM([11, 33, 90])` should return `990`.",
          "testCode": "assert.equal(LCM([11, 33, 90]), 990);"
        },
        {
          "text": "`LCM([-50, 25, -45, -18, 90, 447])` should return `67050`.",
          "testCode": "assert.equal(LCM([-50, 25, -45, -18, 90, 447]), 67050);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302301,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\least-common-multiple.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ee0",
      "title": "Left factorials",
      "challengeType": 1,
      "dashedName": "left-factorials",
      "description": "**Left factorials**, $ !n $, may refer to either *subfactorials* or to *factorial sums*. The same notation can be confusingly seen used for the two different definitions. Sometimes, *subfactorials* (also known as *derangements*) may use any of the notations:\n\n<ul>\n  <li>$!n`$</li>\n  <li>$!n$</li>\n  <li>$n¡$</li>\n</ul>\n\n(It may not be visually obvious, but the last example uses an upside-down exclamation mark.) This task will be using this formula for **left factorial**:\n\n$ !n = \\\\sum\\_{k=0}^{n-1} k! $\n\nwhere $!0 = 0$",
      "instructions": "Write a function to calculate the left factorial of a given number.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function leftFactorial(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function leftFactorial(n) {\n  if (n == 0) return 0;\n  if (n == 1) return 1;\n\n  // Note: for n>=20, the result may not be correct.\n  // This is because JavaScript uses 53 bit integers and\n  // for n>=20 result becomes too large.\n\n  let res = 2,\n    fact = 2;\n  for (var i = 2; i < n; i++) {\n    res += fact;\n    fact *= i + 1;\n  }\n\n  return res;\n}"
        }
      ],
      "tests": [
        {
          "text": "`leftFactorial` should be a function.",
          "testCode": "assert(typeof leftFactorial == 'function');"
        },
        {
          "text": "`leftFactorial(0)` should return a number.",
          "testCode": "assert(typeof leftFactorial(0) == 'number');"
        },
        {
          "text": "`leftFactorial(0)` should return `0`.",
          "testCode": "assert.equal(leftFactorial(0), 0);"
        },
        {
          "text": "`leftFactorial(1)` should return `1`.",
          "testCode": "assert.equal(leftFactorial(1), 1);"
        },
        {
          "text": "`leftFactorial(2)` should return `2`.",
          "testCode": "assert.equal(leftFactorial(2), 2);"
        },
        {
          "text": "`leftFactorial(3)` should return `4`.",
          "testCode": "assert.equal(leftFactorial(3), 4);"
        },
        {
          "text": "`leftFactorial(10)` should return `409114`.",
          "testCode": "assert.equal(leftFactorial(10), 409114);"
        },
        {
          "text": "`leftFactorial(17)` should return `22324392524314`.",
          "testCode": "assert.equal(leftFactorial(17), 22324392524314);"
        },
        {
          "text": "`leftFactorial(19)` should return `6780385526348314`.",
          "testCode": "assert.equal(leftFactorial(19), 6780385526348314);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302302,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\left-factorials.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e4ce2bbac708cc68c1df25f",
      "title": "Letter frequency",
      "challengeType": 1,
      "dashedName": "letter-frequency",
      "description": "Given a string, calculate the frequency of each character.\n\nAll characters should be counted. This includes lower and upper case letters, digits, whitespace, special characters, or any other distinct characters.",
      "instructions": "Write a function to count the occurrences of each character in a given string.\n\nThe function should return a 2D array with each of the elements in the following form: `['char', freq]`. The character should be a string with a length of 1, and frequency is a number denoting the count.\n\nFor example, given the string \"ab\", your function should return `[['a', 1], ['b', 1]]`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function letterFrequency(txt) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function letterFrequency(txt) {\n    var cs = txt.split(''),\n        i = cs.length,\n        dct =  {},\n        c = '',\n        keys;\n\n    while (i--) {\n        c = cs[i];\n        dct[c] = (dct[c] || 0) + 1;\n    }\n\n    keys = Object.keys(dct);\n    keys.sort();\n    return keys.map(function (c) { return [c, dct[c]]; });\n}"
        }
      ],
      "tests": [
        {
          "text": "`letterFrequency` should be a function.",
          "testCode": "assert(typeof letterFrequency == 'function');"
        },
        {
          "text": "`letterFrequency(\"Not all that Mrs. Bennet, however\")` should return an array.",
          "testCode": "assert(Array.isArray(letterFrequency('Not all that Mrs. Bennet, however')));"
        },
        {
          "text": "`letterFrequency(\"Not all that Mrs. Bennet, however\")` should return `[[\" \", 5], [\",\", 1], [\".\", 1], [\"B\", 1], [\"M\", 1], [\"N\", 1], [\"a\", 2], [\"e\", 4], [\"h\", 2], [\"l\", 2], [\"n\", 2], [\"o\", 2], [\"r\", 2], [\"s\", 1], [\"t\", 4], [\"v\", 1], [\"w\", 1]]`.",
          "testCode": "assert.deepEqual(letterFrequency('Not all that Mrs. Bennet, however'), [\n  [' ', 5],\n  [',', 1],\n  ['.', 1],\n  ['B', 1],\n  ['M', 1],\n  ['N', 1],\n  ['a', 2],\n  ['e', 4],\n  ['h', 2],\n  ['l', 2],\n  ['n', 2],\n  ['o', 2],\n  ['r', 2],\n  ['s', 1],\n  ['t', 4],\n  ['v', 1],\n  ['w', 1]\n]);"
        },
        {
          "text": "`letterFrequency(\"daughters, could ask on the \")` should return `[[\" \", 5],[\",\", 1],[\"a\", 2],[\"c\", 1],[\"d\", 2],[\"e\", 2],[\"g\", 1],[\"h\", 2],[\"k\", 1],[\"l\", 1],[\"n\", 1],[\"o\", 2],[\"r\", 1],[\"s\", 2],[\"t\", 2],[\"u\", 2]]`.",
          "testCode": "assert.deepEqual(letterFrequency('daughters, could ask on the '), [\n  [' ', 5],\n  [',', 1],\n  ['a', 2],\n  ['c', 1],\n  ['d', 2],\n  ['e', 2],\n  ['g', 1],\n  ['h', 2],\n  ['k', 1],\n  ['l', 1],\n  ['n', 1],\n  ['o', 2],\n  ['r', 1],\n  ['s', 2],\n  ['t', 2],\n  ['u', 2]\n]);"
        },
        {
          "text": "`letterFrequency(\"husband any satisfactory description\")` should return `[[\" \", 3], [\"a\", 4], [\"b\", 1], [\"c\", 2], [\"d\", 2], [\"e\", 1], [\"f\", 1], [\"h\", 1], [\"i\", 3], [\"n\", 3], [\"o\", 2], [\"p\", 1], [\"r\", 2], [\"s\", 4], [\"t\", 3], [\"u\", 1], [\"y\", 2]]`.",
          "testCode": "assert.deepEqual(letterFrequency('husband any satisfactory description'), [\n  [' ', 3],\n  ['a', 4],\n  ['b', 1],\n  ['c', 2],\n  ['d', 2],\n  ['e', 1],\n  ['f', 1],\n  ['h', 1],\n  ['i', 3],\n  ['n', 3],\n  ['o', 2],\n  ['p', 1],\n  ['r', 2],\n  ['s', 4],\n  ['t', 3],\n  ['u', 1],\n  ['y', 2]\n]);"
        },
        {
          "text": "`letterFrequency(\"in various ways--with barefaced\")` should return `[[\" \", 3], [\"-\", 2], [\"a\", 4], [\"b\", 1], [\"c\", 1], [\"d\", 1], [\"e\", 2], [\"f\", 1], [\"h\", 1], [\"i\", 3], [\"n\", 1], [\"o\", 1], [\"r\", 2], [\"s\", 2], [\"t\", 1], [\"u\", 1], [\"v\", 1], [\"w\", 2], [\"y\", 1]]`.",
          "testCode": "assert.deepEqual(letterFrequency('in various ways--with barefaced'), [\n  [' ', 3],\n  ['-', 2],\n  ['a', 4],\n  ['b', 1],\n  ['c', 1],\n  ['d', 1],\n  ['e', 2],\n  ['f', 1],\n  ['h', 1],\n  ['i', 3],\n  ['n', 1],\n  ['o', 1],\n  ['r', 2],\n  ['s', 2],\n  ['t', 1],\n  ['u', 1],\n  ['v', 1],\n  ['w', 2],\n  ['y', 1]\n]);"
        },
        {
          "text": "`letterFrequency(\"distant surmises; but he eluded\")` should return `[[\" \", 4], [\";\", 1], [\"a\", 1], [\"b\", 1], [\"d\", 3], [\"e\", 4], [\"h\", 1], [\"i\", 2], [\"l\", 1], [\"m\", 1], [\"n\", 1], [\"r\", 1], [\"s\", 4], [\"t\", 3], [\"u\", 3]]`.",
          "testCode": "assert.deepEqual(letterFrequency('distant surmises; but he eluded'), [\n  [' ', 4],\n  [';', 1],\n  ['a', 1],\n  ['b', 1],\n  ['d', 3],\n  ['e', 4],\n  ['h', 1],\n  ['i', 2],\n  ['l', 1],\n  ['m', 1],\n  ['n', 1],\n  ['r', 1],\n  ['s', 4],\n  ['t', 3],\n  ['u', 3]\n]);"
        },
        {
          "text": "`letterFrequency(\"last obliged to accept the second-hand,\")` should return `[[\" \", 5], [\",\", 1], [\"-\", 1], [\"a\", 3], [\"b\", 1], [\"c\", 3], [\"d\", 3], [\"e\", 4], [\"g\", 1], [\"h\", 2], [\"i\", 1], [\"l\", 2], [\"n\", 2], [\"o\", 3], [\"p\", 1], [\"s\", 2], [\"t\", 4]]`.",
          "testCode": "assert.deepEqual(letterFrequency('last obliged to accept the second-hand,'), [\n  [' ', 5],\n  [',', 1],\n  ['-', 1],\n  ['a', 3],\n  ['b', 1],\n  ['c', 3],\n  ['d', 3],\n  ['e', 4],\n  ['g', 1],\n  ['h', 2],\n  ['i', 1],\n  ['l', 2],\n  ['n', 2],\n  ['o', 3],\n  ['p', 1],\n  ['s', 2],\n  ['t', 4]\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385263,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\letter-frequency.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e4ce2eaac708cc68c1df260",
      "title": "Levenshtein distance",
      "challengeType": 1,
      "dashedName": "levenshtein-distance",
      "description": "In information theory and computer science, the **Levenshtein distance** is a metric for measuring the amount of difference between two sequences (i.e. an edit distance). The Levenshtein distance between two strings is defined as the minimum number of edits needed to transform one string into the other, with the allowable edit operations being insertion, deletion, or substitution of a single character.\n\nExample:\n\nThe Levenshtein distance between \"**kitten**\" and \"**sitting**\" is 3, since the following three edits change one into the other, and there isn't a way to do it with fewer than three edits:\n\n<ul>\n  <li><strong>k</strong>itten   <strong>s</strong>itten    (substitution of 'k' with 's')</li>\n  <li>sitt<strong>e</strong>n   sitt<strong>i</strong>n    (substitution of 'e' with 'i')</li>\n  <li>sittin   sittin<strong>g</strong>    (insert 'g' at the end).</li>\n</ul>\n\n*The Levenshtein distance between \"**rosettacode**\", \"**raisethysword**\" is **8**.*\n\n*The distance between two strings is same as that when both strings are reversed.*",
      "instructions": "Write a function that returns the Levenshtein distance between two strings given as parameters.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function levenshtein(a, b) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function levenshtein(a, b) {\n  var t = [], u, i, j, m = a.length, n = b.length;\n  if (!m) { return n; }\n  if (!n) { return m; }\n  for (j = 0; j <= n; j++) { t[j] = j; }\n  for (i = 1; i <= m; i++) {\n    for (u = [i], j = 1; j <= n; j++) {\n      u[j] = a[i - 1] === b[j - 1] ? t[j - 1] : Math.min(t[j - 1], t[j], u[j - 1]) + 1;\n    } t = u;\n  } return u[n];\n}"
        }
      ],
      "tests": [
        {
          "text": "`levenshtein` should be a function.",
          "testCode": "assert(typeof levenshtein == 'function');"
        },
        {
          "text": "`levenshtein(\"mist\", \"dist\")` should return a number.",
          "testCode": "assert(typeof levenshtein('mist', 'dist') == 'number');"
        },
        {
          "text": "`levenshtein(\"mist\", \"dist\")` should return `1`.",
          "testCode": "assert.equal(levenshtein('mist', 'dist'), 1);"
        },
        {
          "text": "`levenshtein(\"tier\", \"tor\")` should return `2`.",
          "testCode": "assert.equal(levenshtein('tier', 'tor'), 2);"
        },
        {
          "text": "`levenshtein(\"kitten\", \"sitting\")` should return `3`.",
          "testCode": "assert.equal(levenshtein('kitten', 'sitting'), 3);"
        },
        {
          "text": "`levenshtein(\"stop\", \"tops\")` should return `2`.",
          "testCode": "assert.equal(levenshtein('stop', 'tops'), 2);"
        },
        {
          "text": "`levenshtein(\"rosettacode\", \"raisethysword\")` should return `8`.",
          "testCode": "assert.equal(levenshtein('rosettacode', 'raisethysword'), 8);"
        },
        {
          "text": "`levenshtein(\"mississippi\", \"swiss miss\")` should return `8`.",
          "testCode": "assert.equal(levenshtein('mississippi', 'swiss miss'), 8);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385264,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\levenshtein-distance.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e4ce2f5ac708cc68c1df261",
      "title": "Linear congruential generator",
      "challengeType": 1,
      "dashedName": "linear-congruential-generator",
      "description": "A linear congruential generator (LCG) is an <em>algorithm</em> that yields a sequence of pseudo-randomized numbers calculated with a discontinuous piecewise linear equation. All linear congruential generators use this formula:\n\n$$r_{n + 1} = (a \\times r_n + c) \\bmod m$$\n\nWhere:\n\n<ul>\n<li>$ r_0 $ is a seed.</li>\n<li>$r_1$, $r_2$, $r_3$, ..., are the random numbers.</li>\n<li>$a$, $c$, $m$ are constants.</li>\n</ul>\n\nIf one chooses the values of $a$, $c$ and $m$ with care, then the generator produces a uniform distribution of integers from $0$ to $m - 1$.\n\n<abbr title=\"linear congruential generator\">LCG</abbr> numbers have poor quality. $r_n$ and $r\\_{n + 1}$ are not independent, as true random numbers would be. Anyone who knows $r_n$ can predict $r\\_{n + 1}$, therefore <abbr title=\"linear congruential generator\">LCG</abbr> is not cryptographically secure. The <abbr title=\"linear congruential generator\">LCG</abbr> is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the <abbr title=\"linear congruential generator\">LCG</abbr>, one can easily reproduce a sequence of numbers, from the same $r_0$. One can also reproduce such sequence with a different programming language, because the formula is so simple.",
      "instructions": "Write a function that takes $r_0,a,c,m,n$ as parameters and returns $r_n$.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function linearCongGenerator(r0, a, c, m, n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function linearCongGenerator(r0, a, c, m, n) {\n    for (let i = 0; i < n; i++) {\n        r0 = (a * r0 + c) % m;\n    }\n    return r0;\n}"
        }
      ],
      "tests": [
        {
          "text": "`linearCongGenerator` should be a function.",
          "testCode": "assert(typeof linearCongGenerator == 'function');"
        },
        {
          "text": "`linearCongGenerator(324, 1145, 177, 2148, 3)` should return a number.",
          "testCode": "assert(typeof linearCongGenerator(324, 1145, 177, 2148, 3) == 'number');"
        },
        {
          "text": "`linearCongGenerator(324, 1145, 177, 2148, 3)` should return `855`.",
          "testCode": "assert.equal(linearCongGenerator(324, 1145, 177, 2148, 3), 855);"
        },
        {
          "text": "`linearCongGenerator(234, 11245, 145, 83648, 4)` should return `1110`.",
          "testCode": "assert.equal(linearCongGenerator(234, 11245, 145, 83648, 4), 1110);"
        },
        {
          "text": "`linearCongGenerator(85, 11, 1234, 214748, 5)` should return `62217`.",
          "testCode": "assert.equal(linearCongGenerator(85, 11, 1234, 214748, 5), 62217);"
        },
        {
          "text": "`linearCongGenerator(0, 1103515245, 12345, 2147483648, 1)` should return `12345`.",
          "testCode": "assert.equal(linearCongGenerator(0, 1103515245, 12345, 2147483648, 1), 12345);"
        },
        {
          "text": "`linearCongGenerator(0, 1103515245, 12345, 2147483648, 2)` should return `1406932606`.",
          "testCode": "assert.equal(\n  linearCongGenerator(0, 1103515245, 12345, 2147483648, 2),\n  1406932606\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385266,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\linear-congruential-generator.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e4ce2a1ac708cc68c1df25d",
      "title": "Long multiplication",
      "challengeType": 1,
      "dashedName": "long-multiplication",
      "description": "Explicitly implement long multiplication.\n\nThis is one possible approach to arbitrary-precision integer algebra.",
      "instructions": "Write a function that takes two strings of large numbers as parameters. Your function should return the product of these two large numbers as a string.\n\n**Note:** In JavaScript, arithmetic operations are inaccurate with large numbers, so you will have to implement precise multiplication yourself.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function mult(strNum1, strNum2) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function mult(strNum1, strNum2) {\n    var a1 = strNum1.split(\"\").reverse();\n    var a2 = strNum2.toString().split(\"\").reverse();\n    var aResult = new Array;\n\n    for ( var iterNum1 = 0; iterNum1 < a1.length; iterNum1++ ) {\n        for ( var iterNum2 = 0; iterNum2 < a2.length; iterNum2++ ) {\n            var idxIter = iterNum1 + iterNum2;    // Get the current array position.\n            aResult[idxIter] = a1[iterNum1] * a2[iterNum2] + ( idxIter >= aResult.length ? 0 : aResult[idxIter] );\n\n            if ( aResult[idxIter] > 9 ) {    // Carrying\n                aResult[idxIter + 1] = Math.floor( aResult[idxIter] / 10 ) + ( idxIter + 1 >= aResult.length ? 0 : aResult[idxIter + 1] );\n                aResult[idxIter] %= 10;\n            }\n        }\n    }\n    return aResult.reverse().join(\"\");\n}"
        }
      ],
      "tests": [
        {
          "text": "`mult` should be a function.",
          "testCode": "assert(typeof mult == 'function');"
        },
        {
          "text": "`mult(\"18446744073709551616\", \"18446744073709551616\")` should return a string.",
          "testCode": "assert(typeof mult('18446744073709551616', '18446744073709551616') == 'string');"
        },
        {
          "text": "`mult(\"18446744073709551616\", \"18446744073709551616\")` should return `\"340282366920938463463374607431768211456\"`.",
          "testCode": "assert.equal(\n  mult('18446744073709551616', '18446744073709551616'),\n  '340282366920938463463374607431768211456'\n);"
        },
        {
          "text": "`mult(\"31844674073709551616\", \"1844674407309551616\")` should return `\"58743055272886011737990786529368211456\"`.",
          "testCode": "assert.equal(\n  mult('31844674073709551616', '1844674407309551616'),\n  '58743055272886011737990786529368211456'\n);"
        },
        {
          "text": "`mult(\"1846744073709551616\", \"44844644073709551616\")` should return `\"82816580680737279241781007431768211456\"`.",
          "testCode": "assert.equal(\n  mult('1846744073709551616', '44844644073709551616'),\n  '82816580680737279241781007431768211456'\n);"
        },
        {
          "text": "`mult(\"1844674407370951616\", \"1844674407709551616\")` should return `\"3402823669833978308014392742590611456\"`.",
          "testCode": "assert.equal(\n  mult('1844674407370951616', '1844674407709551616'),\n  '3402823669833978308014392742590611456'\n);"
        },
        {
          "text": "`mult(\"2844674407370951616\", \"1844674407370955616\")` should return `\"5247498076580334548376218009219475456\"`.",
          "testCode": "assert.equal(\n  mult('2844674407370951616', '1844674407370955616'),\n  '5247498076580334548376218009219475456'\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385269,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\long-multiplication.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e6dd1278e6ca105cde40ea9",
      "title": "Longest common subsequence",
      "challengeType": 1,
      "dashedName": "longest-common-subsequence",
      "description": "The **longest common subsequence** (or **LCS**) of groups A and B is the longest group of elements from A and B that are common between the two groups and in the same order in each group. For example, the sequences `1234` and `1224533324` have an LCS of `1234`:\n\n<u>1234</u>\n\n<u>12</u>245<u>3</u>332<u>4</u>\n\nFor a string example, consider the sequences `thisisatest` and `testing123testing`. An LCS would be `tsitest`:\n\n<u>t</u>hi<u>si</u>sa<u>test</u>\n\n<u>t</u>e<u>s</u>t<u>i</u>ng123<u>test</u>ing.\n\nYour code only needs to deal with strings.",
      "instructions": "Write a case-sensitive function that returns the LCS of two strings. You don't need to show multiple LCS's.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function lcs(a, b) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function lcs(a, b) {\n  var aSub = a.substring(0, a.length - 1);\n  var bSub = b.substring(0, b.length - 1);\n\n  if (a.length === 0 || b.length === 0) {\n    return '';\n  } else if (a.charAt(a.length - 1) === b.charAt(b.length - 1)) {\n    return lcs(aSub, bSub) + a.charAt(a.length - 1);\n  } else {\n    var x = lcs(a, bSub);\n    var y = lcs(aSub, b);\n    return (x.length > y.length) ? x : y;\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`lcs` should be a function.",
          "testCode": "assert(typeof lcs == 'function');"
        },
        {
          "text": "`lcs(\"thisisatest\", \"testing123testing\")` should return a string.",
          "testCode": "assert(typeof lcs('thisisatest', 'testing123testing') == 'string');"
        },
        {
          "text": "`lcs(\"thisisatest\", \"testing123testing\")` should return `\"tsitest\"`.",
          "testCode": "assert.equal(lcs('thisisatest', 'testing123testing'), 'tsitest');"
        },
        {
          "text": "`lcs(\"ABCDGH\", \"AEDFHR\")` should return `\"ADH\"`.",
          "testCode": "assert.equal(lcs('ABCDGH', 'AEDFHR'), 'ADH');"
        },
        {
          "text": "`lcs(\"AGGTAB\", \"GXTXAYB\")` should return `\"GTAB\"`.",
          "testCode": "assert.equal(lcs('AGGTAB', 'GXTXAYB'), 'GTAB');"
        },
        {
          "text": "`lcs(\"BDACDB\", \"BDCB\")` should return `\"BDCB\"`.",
          "testCode": "assert.equal(lcs('BDACDB', 'BDCB'), 'BDCB');"
        },
        {
          "text": "`lcs(\"ABAZDC\", \"BACBAD\")` should return `\"ABAD\"`.",
          "testCode": "assert.equal(lcs('ABAZDC', 'BACBAD'), 'ABAD');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385271,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\longest-common-subsequence.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e6dd139859c290b6ab80292",
      "title": "Longest increasing subsequence",
      "challengeType": 1,
      "dashedName": "longest-increasing-subsequence",
      "description": "The longest increasing subsequence problem is to find a subsequence of a given sequence in which the subsequence's elements are in sorted order, lowest to highest, and in which the subsequence is as long as possible. An example:\n\nFor the following array:\n\n```js\nconst array = [3, 10, 2, 1, 20];\n```\n\nLongest increasing sequence is:\n\n$\\\\{3, 10, 20\\\\}$",
      "instructions": "Write a function that takes an array of numbers as a parameter and returns the longest increasing subsequence.\n\nIt is guaranteed that every array will have a longest increasing subsequence.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function findSequence(input) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function findSequence(input) {\n    var len = input.length;\n    var result = []\n    for (var i = 0; i < len; i++) result.push(1)\n\n    for (var i = 0; i < len; i++)\n        for (var j = i - 1; j >= 0; j--)\n            if (input[i] > input[j] && result[j] >= result[i])\n                result[i] = result[j] + 1;\n\n    var maxValue = Math.max.apply(null, result);\n    var maxIndex = result.indexOf(Math.max.apply(Math, result));\n    var output = [];\n    output.push(input[maxIndex]);\n    for (var i = maxIndex; i >= 0; i--) {\n        if (maxValue == 0) break;\n        if (input[maxIndex] > input[i] && result[i] == maxValue - 1) {\n            output.push(input[i]);\n            maxValue--;\n        }\n    }\n    output.reverse();\n    return output;\n}"
        }
      ],
      "tests": [
        {
          "text": "`findSequence` should be a function.",
          "testCode": "assert(typeof findSequence == 'function');"
        },
        {
          "text": "`findSequence([3, 10, 2, 1, 20])` should return a array.",
          "testCode": "assert(Array.isArray(findSequence([3, 10, 2, 1, 20])));"
        },
        {
          "text": "`findSequence([3, 10, 2, 1, 20])` should return `[3, 10, 20]`.",
          "testCode": "assert.deepEqual(findSequence([3, 10, 2, 1, 20]), [3, 10, 20]);"
        },
        {
          "text": "`findSequence([2, 7, 3, 5, 8])` should return `[2, 3, 5, 8]`.",
          "testCode": "assert.deepEqual(findSequence([2, 7, 3, 5, 8]), [2, 3, 5, 8]);"
        },
        {
          "text": "`findSequence([2, 6, 4, 5, 1])` should return `[2, 4, 5]`.",
          "testCode": "assert.deepEqual(findSequence([2, 6, 4, 5, 1]), [2, 4, 5]);"
        },
        {
          "text": "`findSequence([10, 22, 9, 33, 21, 50, 60, 80])` should return `[10, 22, 33, 50, 60, 80]`.",
          "testCode": "assert.deepEqual(findSequence([10, 22, 9, 33, 21, 50, 60, 80]), [\n  10,\n  22,\n  33,\n  50,\n  60,\n  80\n]);"
        },
        {
          "text": "`findSequence([0, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15])` should return `[0, 2, 6, 9, 11, 15`.",
          "testCode": "assert.deepEqual(\n  findSequence([0, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]),\n  [0, 2, 6, 9, 11, 15]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385272,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\longest-increasing-subsequence.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e6dd14192286d95fc43046e",
      "title": "Longest string challenge",
      "challengeType": 1,
      "dashedName": "longest-string-challenge",
      "description": "In this challenge, you have to find the strings that are the longest among the given strings.",
      "instructions": "Write a function that takes an array of strings and returns the strings that have a length equal to the longest length.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function longestString(strings) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function longestString(strings) {\n    var mx = 0;\n    var result = []\n    strings.forEach(function (e) {\n        if (e.length > mx) {\n            mx = e.length\n            result = [e]\n        } else if (e.length == mx)\n            result.push(e)\n    })\n\n    return result\n}"
        }
      ],
      "tests": [
        {
          "text": "`longestString` should be a function.",
          "testCode": "assert(typeof longestString == 'function');"
        },
        {
          "text": "`longestString([\"a\", \"bb\", \"ccc\", \"ee\", \"f\", \"ggg\"])` should return a array.",
          "testCode": "assert(Array.isArray(longestString(['a', 'bb', 'ccc', 'ee', 'f', 'ggg'])));"
        },
        {
          "text": "`longestString([\"a\", \"bb\", \"ccc\", \"ee\", \"f\", \"ggg\"])` should return `[\"ccc\", \"ggg\"]`.",
          "testCode": "assert.deepEqual(longestString(['a', 'bb', 'ccc', 'ee', 'f', 'ggg']), [\n  'ccc',\n  'ggg'\n]);"
        },
        {
          "text": "`longestString([\"afedg\", \"bb\", \"sdccc\", \"efdee\", \"f\", \"geegg\"])` should return `[\"afedg\", \"sdccc\", \"efdee\", \"geegg\"]`.",
          "testCode": "assert.deepEqual(\n  longestString(['afedg', 'bb', 'sdccc', 'efdee', 'f', 'geegg']),\n  ['afedg', 'sdccc', 'efdee', 'geegg']\n);"
        },
        {
          "text": "`longestString([\"a\", \"bhghgb\", \"ccc\", \"efde\", \"fssdrr\", \"ggg\"])` should return `[\"bhghgb\", \"fssdrr\"]`.",
          "testCode": "assert.deepEqual(\n  longestString(['a', 'bhghgb', 'ccc', 'efde', 'fssdrr', 'ggg']),\n  ['bhghgb', 'fssdrr']\n);"
        },
        {
          "text": "`longestString([\"ahgfhg\", \"bdsfsb\", \"ccc\", \"ee\", \"f\", \"ggdsfg\"])` should return `[\"ahgfhg\", \"bdsfsb\", \"ggdsfg\"]`.",
          "testCode": "assert.deepEqual(\n  longestString(['ahgfhg', 'bdsfsb', 'ccc', 'ee', 'f', 'ggdsfg']),\n  ['ahgfhg', 'bdsfsb', 'ggdsfg']\n);"
        },
        {
          "text": "`longestString([\"a\", \"bbdsf\", \"ccc\", \"edfe\", \"gzzzgg\"])` should return `[\"gzzzgg\"]`.",
          "testCode": "assert.deepEqual(longestString(['a', 'bbdsf', 'ccc', 'edfe', 'gzzzgg']), [\n  'gzzzgg'\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385275,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\longest-string-challenge.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e6dd14797f5ce267c2f19d0",
      "title": "Look-and-say sequence",
      "challengeType": 1,
      "dashedName": "look-and-say-sequence",
      "description": "The Look and say sequence is a recursively defined sequence of numbers.\n\nSequence Definition\n\n<ul><li>Take a decimal number</li>\n<li><span>Look</span> at the number, visually grouping consecutive runs of the same digit.</li>\n<li><span>Say</span> the number, from left to right, group by group; as how many of that digit there are - followed by the digit grouped.</li></ul><span> This becomes the next number of the sequence.</span>\n\nAn example:\n\n<ul><li>Starting with the number 1, you have <span>one</span> 1 which produces 11</li>\n<li>Starting with 11, you have <span>two</span> 1's. I.E.: 21</li>\n<li>Starting with 21, you have <span>one</span> 2, then <span>one</span> 1. I.E.: (12)(11) which becomes 1211</li>\n<li>Starting with 1211, you have <span>one</span> 1, <span>one</span> 2, then <span>two</span> 1's. I.E.: (11)(12)(21) which becomes 111221</li></ul>",
      "instructions": "Write a function that accepts a string as a parameter, processes it, and returns the resultant string.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function lookAndSay(str) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function lookAndSay(str) {\n    return str.replace(/(.)\\1*/g, function(seq, p1) {\n      return seq.length.toString() + p1;\n    });\n}"
        }
      ],
      "tests": [
        {
          "text": "`lookAndSay` should be a function.",
          "testCode": "assert(typeof lookAndSay == 'function');"
        },
        {
          "text": "`lookAndSay(\"1\")` should return a string.",
          "testCode": "assert(typeof lookAndSay('1') == 'string');"
        },
        {
          "text": "`lookAndSay(\"1\")` should return `\"11\"`.",
          "testCode": "assert.equal(lookAndSay('1'), '11');"
        },
        {
          "text": "`lookAndSay(\"11\")` should return `\"21\"`.",
          "testCode": "assert.equal(lookAndSay('11'), '21');"
        },
        {
          "text": "`lookAndSay(\"21\")` should return `\"1211\"`.",
          "testCode": "assert.equal(lookAndSay('21'), '1211');"
        },
        {
          "text": "`lookAndSay(\"1211\")` should return `\"111221\"`.",
          "testCode": "assert.equal(lookAndSay('1211'), '111221');"
        },
        {
          "text": "`lookAndSay(\"3542\")` should return `\"13151412\"`.",
          "testCode": "assert.equal(lookAndSay('3542'), '13151412');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385277,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\look-and-say-sequence.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e6dd15004c88cf00d2a78b3",
      "title": "Loop over multiple arrays simultaneously",
      "challengeType": 1,
      "dashedName": "loop-over-multiple-arrays-simultaneously",
      "description": "Loop over multiple arrays and create a new array whose $i^{th}$ element is the concatenation of $i^{th}$ element of each of the given.\n\nFor this example, if you are given this array of arrays:\n\n```js\n[ [\"a\", \"b\", \"c\"], [\"A\", \"B\", \"C\"], [1, 2, 3] ]\n```\n\nthe output should be:\n\n```js\n[\"aA1\",\"bB2\",\"cC3\"]\n```",
      "instructions": "Write a function that takes an array of arrays as a parameter and returns an array of strings satisfying the given description.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function loopSimult(A) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function loopSimult(A) {\n    var res = [], output;\n    for (var i = 0; i < A[0].length; i += 1) {\n        output = \"\";\n        for (var j = 0; j < A.length; j++)\n            output += A[j][i];\n        res.push(output);\n    }\n    return res;\n}"
        }
      ],
      "tests": [
        {
          "text": "`loopSimult` should be a function.",
          "testCode": "assert(typeof loopSimult == 'function');"
        },
        {
          "text": "`loopSimult([[\"a\", \"b\", \"c\"], [\"A\", \"B\", \"C\"], [1, 2, 3]])` should return a array.",
          "testCode": "assert(\n  Array.isArray(\n    loopSimult([\n      ['a', 'b', 'c'],\n      ['A', 'B', 'C'],\n      [1, 2, 3]\n    ])\n  )\n);"
        },
        {
          "text": "`loopSimult([[\"a\", \"b\", \"c\"], [\"A\", \"B\", \"C\"], [1, 2, 3]])` should return `[\"aA1\", \"bB2\", \"cC3\"]`.",
          "testCode": "assert.deepEqual(\n  loopSimult([\n    ['a', 'b', 'c'],\n    ['A', 'B', 'C'],\n    [1, 2, 3]\n  ]),\n  ['aA1', 'bB2', 'cC3']\n);"
        },
        {
          "text": "`loopSimult([[\"c\", \"b\", \"c\"], [\"4\", \"5\", \"C\"], [7, 7, 3]])` should return `[\"c47\", \"b57\", \"cC3\"]`.",
          "testCode": "assert.deepEqual(\n  loopSimult([\n    ['c', 'b', 'c'],\n    ['4', '5', 'C'],\n    [7, 7, 3]\n  ]),\n  ['c47', 'b57', 'cC3']\n);"
        },
        {
          "text": "`loopSimult([[\"a\", \"b\", \"c\", \"d\"], [\"A\", \"B\", \"C\", \"d\"], [1, 2, 3, 4]])` should return `[\"aA1\", \"bB2\", \"cC3\", \"dd4\"]`.",
          "testCode": "assert.deepEqual(\n  loopSimult([\n    ['a', 'b', 'c', 'd'],\n    ['A', 'B', 'C', 'd'],\n    [1, 2, 3, 4]\n  ]),\n  ['aA1', 'bB2', 'cC3', 'dd4']\n);"
        },
        {
          "text": "`loopSimult([[\"a\", \"b\"], [\"A\", \"B\"], [1, 2]])` should return `[\"aA1\", \"bB2\"]`.",
          "testCode": "assert.deepEqual(\n  loopSimult([\n    ['a', 'b'],\n    ['A', 'B'],\n    [1, 2]\n  ]),\n  ['aA1', 'bB2']\n);"
        },
        {
          "text": "`loopSimult([[\"b\", \"c\"], [\"B\", \"C\"], [2, 3]])` should return `[\"bB2\", \"cC3\"]`.",
          "testCode": "assert.deepEqual(\n  loopSimult([\n    ['b', 'c'],\n    ['B', 'C'],\n    [2, 3]\n  ]),\n  ['bB2', 'cC3']\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385279,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\loop-over-multiple-arrays-simultaneously.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e6decd8ec8d7db960950d1c",
      "title": "LU decomposition",
      "challengeType": 1,
      "dashedName": "lu-decomposition",
      "description": "Every square matrix $A$ can be decomposed into a product of a lower triangular matrix $L$ and a upper triangular matrix $U$. This is known as the LU decomposition.\n\n$A = LU$\n\nIt is a modified form of Gaussian elimination.\n\nWhile the Cholesky decomposition only works for symmetric, positive definite matrices, the more general LU decomposition works for any square matrix.\n\nThere are several algorithms for calculating $L$ and $U$.\n\nTo derive *Crout's algorithm* for a 3x3 example, we have to solve the following system:\n\n\\\\begin{align}A = \\\\begin{pmatrix} a\\_{11} & a\\_{12} & a\\_{13}\\\\\\\\ a\\_{21} & a\\_{22} & a\\_{23}\\\\\\\\ a\\_{31} & a\\_{32} & a\\_{33}\\\\\\\\ \\\\end{pmatrix}= \\\\begin{pmatrix} l\\_{11} & 0 & 0 \\\\\\\\ l\\_{21} & l\\_{22} & 0 \\\\\\\\ l\\_{31} & l\\_{32} & l\\_{33}\\\\\\\\ \\\\end{pmatrix} \\\\begin{pmatrix} u\\_{11} & u\\_{12} & u\\_{13} \\\\\\\\ 0 & u\\_{22} & u\\_{23} \\\\\\\\ 0 & 0 & u\\_{33} \\\\end{pmatrix} = LU\\\\end{align}\n\nWe now would have to solve 9 equations with 12 unknowns. To make the system uniquely solvable, usually the diagonal elements of $L$ are set to 1\n\n$l\\_{11}=1$\n\n$l\\_{22}=1$\n\n$l\\_{33}=1$\n\nso we get a solvable system of 9 unknowns and 9 equations.\n\n\\\\begin{align}A = \\\\begin{pmatrix} a\\_{11} & a\\_{12} & a\\_{13}\\\\\\\\ a\\_{21} & a\\_{22} & a\\_{23}\\\\\\\\ a\\_{31} & a\\_{32} & a\\_{33}\\\\\\\\ \\\\end{pmatrix} = \\\\begin{pmatrix} 1 & 0 & 0 \\\\\\\\ l\\_{21} & 1 & 0 \\\\\\\\ l\\_{31} & l\\_{32} & 1\\\\\\\\ \\\\end{pmatrix} \\\\begin{pmatrix} u\\_{11} & u\\_{12} & u\\_{13} \\\\\\\\ 0 & u\\_{22} & u\\_{23} \\\\\\\\ 0 & 0 & u\\_{33} \\\\end{pmatrix} = \\\\begin{pmatrix} u\\_{11} & u\\_{12} & u\\_{13} \\\\\\\\ u\\_{11}l\\_{21} & u\\_{12}l\\_{21}+u\\_{22} & u\\_{13}l\\_{21}+u\\_{23} \\\\\\\\ u\\_{11}l\\_{31} & u\\_{12}l\\_{31}+u\\_{22}l\\_{32} & u\\_{13}l\\_{31} + u\\_{23}l\\_{32}+u\\_{33} \\\\end{pmatrix} = LU\\\\end{align}\n\nSolving for the other $l$ and $u$, we get the following equations:\n\n$u\\_{11}=a\\_{11}$\n\n$u\\_{12}=a\\_{12}$\n\n$u\\_{13}=a\\_{13}$\n\n$u\\_{22}=a\\_{22} - u\\_{12}l\\_{21}$\n\n$u\\_{23}=a\\_{23} - u\\_{13}l\\_{21}$\n\n$u\\_{33}=a\\_{33} - (u\\_{13}l\\_{31} + u\\_{23}l\\_{32})$\n\nand for $l$:\n\n$l\\_{21}=\\\\frac{1}{u\\_{11}} a\\_{21}$\n\n$l\\_{31}=\\\\frac{1}{u\\_{11}} a\\_{31}$\n\n$l\\_{32}=\\\\frac{1}{u\\_{22}} (a\\_{32} - u\\_{12}l\\_{31})$\n\nWe see that there is a calculation pattern, which can be expressed as the following formulas, first for $U$\n\n$u\\_{ij} = a\\_{ij} - \\\\sum\\_{k=1}^{i-1} u\\_{kj}l\\_{ik}$\n\nand then for $L$\n\n$l\\_{ij} = \\\\frac{1}{u\\_{jj}} (a\\_{ij} - \\\\sum\\_{k=1}^{j-1} u\\_{kj}l\\_{ik})$\n\nWe see in the second formula that to get the $l\\_{ij}$ below the diagonal, we have to divide by the diagonal element (pivot) $u\\_{jj}$, so we get problems when $u\\_{jj}$ is either 0 or very small, which leads to numerical instability.\n\nThe solution to this problem is *pivoting* $A$, which means rearranging the rows of $A$, prior to the $LU$ decomposition, in a way that the largest element of each column gets onto the diagonal of $A$. Rearranging the rows means to multiply $A$ by a permutation matrix $P$:\n\n$PA \\\\Rightarrow A'$\n\nExample:\n\n\\\\begin{align} \\\\begin{pmatrix} 0 & 1 \\\\\\\\ 1 & 0 \\\\end{pmatrix} \\\\begin{pmatrix} 1 & 4 \\\\\\\\ 2 & 3 \\\\end{pmatrix} \\\\Rightarrow \\\\begin{pmatrix} 2 & 3 \\\\\\\\ 1 & 4 \\\\end{pmatrix} \\\\end{align}\n\nThe decomposition algorithm is then applied on the rearranged matrix so that\n\n$PA = LU$",
      "instructions": "The task is to implement a routine which will take a square nxn matrix $A$ and return a lower triangular matrix $L$, a upper triangular matrix $U$ and a permutation matrix $P$, so that the above equation is fulfilled. The returned value should be in the form `[L, U, P]`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function luDecomposition(A) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function luDecomposition(A) {\n\n    function dotProduct(a, b) {\n        var sum = 0;\n        for (var i = 0; i < a.length; i++)\n            sum += a[i] * b[i]\n        return sum;\n    }\n\n    function matrixMul(A, B) {\n        var result = new Array(A.length);\n        for (var i = 0; i < A.length; i++)\n            result[i] = new Array(B[0].length)\n        var aux = new Array(B.length);\n\n        for (var j = 0; j < B[0].length; j++) {\n\n            for (var k = 0; k < B.length; k++)\n                aux[k] = B[k][j];\n\n            for (var i = 0; i < A.length; i++)\n                result[i][j] = dotProduct(A[i], aux);\n        }\n        return result;\n    }\n\n    function pivotize(m) {\n        var n = m.length;\n        var id = new Array(n);\n        for (var i = 0; i < n; i++) {\n            id[i] = new Array(n);\n            id[i].fill(0)\n            id[i][i] = 1;\n        }\n\n        for (var i = 0; i < n; i++) {\n            var maxm = m[i][i];\n            var row = i;\n            for (var j = i; j < n; j++)\n                if (m[j][i] > maxm) {\n                    maxm = m[j][i];\n                    row = j;\n                }\n\n            if (i != row) {\n                var tmp = id[i];\n                id[i] = id[row];\n                id[row] = tmp;\n            }\n        }\n        return id;\n    }\n\n    var n = A.length;\n    var L = new Array(n);\n    for (var i = 0; i < n; i++) { L[i] = new Array(n); L[i].fill(0) }\n    var U = new Array(n);\n    for (var i = 0; i < n; i++) { U[i] = new Array(n); U[i].fill(0) }\n    var P = pivotize(A);\n    var A2 = matrixMul(P, A);\n\n    for (var j = 0; j < n; j++) {\n        L[j][j] = 1;\n        for (var i = 0; i < j + 1; i++) {\n            var s1 = 0;\n            for (var k = 0; k < i; k++)\n                s1 += U[k][j] * L[i][k];\n            U[i][j] = A2[i][j] - s1;\n        }\n        for (var i = j; i < n; i++) {\n            var s2 = 0;\n            for (var k = 0; k < j; k++)\n                s2 += U[k][j] * L[i][k];\n            L[i][j] = (A2[i][j] - s2) / U[j][j];\n        }\n    }\n    return [L, U, P];\n}"
        }
      ],
      "tests": [
        {
          "text": "`luDecomposition` should be a function.",
          "testCode": "assert(typeof luDecomposition == 'function');"
        },
        {
          "text": "`luDecomposition([[1, 3, 5], [2, 4, 7], [1, 1, 0]])` should return a array.",
          "testCode": "assert(\n  Array.isArray(\n    luDecomposition([\n      [1, 3, 5],\n      [2, 4, 7],\n      [1, 1, 0]\n    ])\n  )\n);"
        },
        {
          "text": "`luDecomposition([[1, 3, 5], [2, 4, 7], [1, 1, 0]])` should return `[[[1, 0, 0], [0.5, 1, 0], [0.5, -1, 1]], [[2, 4, 7], [0, 1, 1.5], [0, 0, -2]], [[0, 1, 0], [1, 0, 0], [0, 0, 1]]]`.",
          "testCode": "assert.deepEqual(\n  luDecomposition([\n    [1, 3, 5],\n    [2, 4, 7],\n    [1, 1, 0]\n  ]),\n  [\n    [\n      [1, 0, 0],\n      [0.5, 1, 0],\n      [0.5, -1, 1]\n    ],\n    [\n      [2, 4, 7],\n      [0, 1, 1.5],\n      [0, 0, -2]\n    ],\n    [\n      [0, 1, 0],\n      [1, 0, 0],\n      [0, 0, 1]\n    ]\n  ]\n);"
        },
        {
          "text": "`luDecomposition([[11, 9, 24, 2], [1, 5, 2, 6], [3, 17, 18, 1], [2, 5, 7, 1]])` should return `[[[1, 0, 0, 0], [0.2727272727272727, 1, 0, 0], [0.09090909090909091, 0.2875, 1, 0], [0.18181818181818182, 0.23124999999999996, 0.0035971223021580693, 1]], [[11, 9, 24, 2], [0, 14.545454545454547, 11.454545454545455, 0.4545454545454546], [0, 0, -3.4749999999999996, 5.6875], [0, 0, 0, 0.510791366906476]], [[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]]`.",
          "testCode": "assert.deepEqual(\n  luDecomposition([\n    [11, 9, 24, 2],\n    [1, 5, 2, 6],\n    [3, 17, 18, 1],\n    [2, 5, 7, 1]\n  ]),\n  [\n    [\n      [1, 0, 0, 0],\n      [0.2727272727272727, 1, 0, 0],\n      [0.09090909090909091, 0.2875, 1, 0],\n      [0.18181818181818182, 0.23124999999999996, 0.0035971223021580693, 1]\n    ],\n    [\n      [11, 9, 24, 2],\n      [0, 14.545454545454547, 11.454545454545455, 0.4545454545454546],\n      [0, 0, -3.4749999999999996, 5.6875],\n      [0, 0, 0, 0.510791366906476]\n    ],\n    [\n      [1, 0, 0, 0],\n      [0, 0, 1, 0],\n      [0, 1, 0, 0],\n      [0, 0, 0, 1]\n    ]\n  ]\n);"
        },
        {
          "text": "`luDecomposition([[1, 1, 1], [4, 3, -1], [3, 5, 3]])` should return `[[[1, 0, 0], [0.75, 1, 0], [0.25, 0.09090909090909091, 1]], [[4, 3, -1], [0, 2.75, 3.75], [0, 0, 0.9090909090909091]], [[0, 1, 0], [0, 0, 1], [1, 0, 0]]]`.",
          "testCode": "assert.deepEqual(\n  luDecomposition([\n    [1, 1, 1],\n    [4, 3, -1],\n    [3, 5, 3]\n  ]),\n  [\n    [\n      [1, 0, 0],\n      [0.75, 1, 0],\n      [0.25, 0.09090909090909091, 1]\n    ],\n    [\n      [4, 3, -1],\n      [0, 2.75, 3.75],\n      [0, 0, 0.9090909090909091]\n    ],\n    [\n      [0, 1, 0],\n      [0, 0, 1],\n      [1, 0, 0]\n    ]\n  ]\n);"
        },
        {
          "text": "`luDecomposition([[1, -2, 3], [2, -5, 12], [0, 2, -10]])` should return `[[[1, 0, 0], [0, 1, 0], [0.5, 0.25, 1]], [[2, -5, 12], [0, 2, -10], [0, 0, -0.5]], [[0, 1, 0], [0, 0, 1], [1, 0, 0]]]`.",
          "testCode": "assert.deepEqual(\n  luDecomposition([\n    [1, -2, 3],\n    [2, -5, 12],\n    [0, 2, -10]\n  ]),\n  [\n    [\n      [1, 0, 0],\n      [0, 1, 0],\n      [0.5, 0.25, 1]\n    ],\n    [\n      [2, -5, 12],\n      [0, 2, -10],\n      [0, 0, -0.5]\n    ],\n    [\n      [0, 1, 0],\n      [0, 0, 1],\n      [1, 0, 0]\n    ]\n  ]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385280,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\lu-decomposition.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e6dee7749a0b85a3f1fc7d5",
      "title": "Lucas-Lehmer test",
      "challengeType": 1,
      "dashedName": "lucas-lehmer-test",
      "description": "Lucas-Lehmer Test: for $p$ an odd prime, the Mersenne number $2^p-1$ is prime if and only if $2^p-1$ divides $S(p-1)$ where $S(n+1)=(S(n))^2-2$, and $S(1)=4$.",
      "instructions": "Write a function that returns whether the given Mersenne number is prime or not.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function lucasLehmer(p) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function lucasLehmer(p) {\n    function isPrime(p) {\n        if (p == 2)\n            return true;\n        else if (p <= 1 || p % 2 == 0)\n            return false;\n        else {\n            var to = Math.sqrt(p);\n            for (var i = 3; i <= to; i += 2)\n                if (p % i == 0)\n                    return false;\n            return true;\n        }\n    }\n\n    function isMersennePrime(p) {\n        if (p == 2)\n            return true;\n        else {\n            var m_p = Math.pow(2, p) - 1\n            var s = 4;\n            for (var i = 3; i <= p; i++)\n                s = (s * s - 2) % m_p\n            return s == 0;\n        }\n    }\n\n    return isPrime(p) && isMersennePrime(p)\n}"
        }
      ],
      "tests": [
        {
          "text": "`lucasLehmer` should be a function.",
          "testCode": "assert(typeof lucasLehmer == 'function');"
        },
        {
          "text": "`lucasLehmer(11)` should return a boolean.",
          "testCode": "assert(typeof lucasLehmer(11) == 'boolean');"
        },
        {
          "text": "`lucasLehmer(11)` should return `false`.",
          "testCode": "assert.equal(lucasLehmer(11), false);"
        },
        {
          "text": "`lucasLehmer(15)` should return `false`.",
          "testCode": "assert.equal(lucasLehmer(15), false);"
        },
        {
          "text": "`lucasLehmer(13)` should return `true`.",
          "testCode": "assert.equal(lucasLehmer(13), true);"
        },
        {
          "text": "`lucasLehmer(17)` should return `true`.",
          "testCode": "assert.equal(lucasLehmer(17), true);"
        },
        {
          "text": "`lucasLehmer(19)` should return `true`.",
          "testCode": "assert.equal(lucasLehmer(19), true);"
        },
        {
          "text": "`lucasLehmer(21)` should return `false`.",
          "testCode": "assert.equal(lucasLehmer(21), false);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385281,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\lucas-lehmer-test.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5ea281203167d2b0bdefca00",
      "title": "Ludic numbers",
      "challengeType": 1,
      "dashedName": "ludic-numbers",
      "description": "Ludic numbers are related to prime numbers as they are generated by a sieve quite like the Sieve of Eratosthenes is used to generate prime numbers.\n\nThe first ludic number is 1.\n\nTo generate succeeding ludic numbers create an array of increasing integers starting from 2.\n\n<code style='margin-left: 2em;'><span style='color:blue;font-weight:bold'>2</span> 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ...</code>\n\n(Loop)\n\n<ul>\n  <li>Take the first member of the resultant array as the next ludic number <span style='color:blue;font-weight:bold'>2</span>.</li>\n  <li>Remove every <strong>2<sup>nd</sup></strong> indexed item from the array (including the first).</li>\n  <code style='margin-left: 2em;'><span style='color:blue;font-weight:bold;'><s>2</s></span> 3 <s>4</s> 5 <s>6</s> 7 <s>8</s> 9 <s>10</s> 11 <s>12</s> 13 <s>14</s> 15 <s>16</s> 17 <s>18</s> 19 <s>20</s> 21 <s>22</s> 23 <s>24</s> 25 <s>26</s> ...</code>\n</ul>\n\n<ul>\n  <li>(Unrolling a few loops...)</li>\n  <li>Take the first member of the resultant array as the next ludic number <span style='color:blue;font-weight:bold'>3</span>.</li>\n  <li>Remove every <strong>3<sup>rd</sup></strong> indexed item from the array (including the first).</li>\n  <code style='margin-left: 2em;'><span style='color:blue;font-weight:bold'><s>3</s></span> 5 7 <s>9</s> 11 13 <s>15</s> 17 19 <s>21</s> 23 25 <s>27</s> 29 31 <s>33</s> 35 37 <s>39</s> 41 43 <s>45</s> 47 49 <s>51</s> ...</code>\n</ul>\n\n<ul>\n  <li>Take the first member of the resultant array as the next ludic number <span style='color:blue;font-weight:bold'>5</span>.</li>\n  <li>Remove every <strong>5<sup>th</sup></strong> indexed item from the array (including the first).</li>\n  <code style='margin-left: 2em;'><span style='color:blue;font-weight:bold'><s>5</s></span> 7 11 13 17 <s>19</s> 23 25 29 31 <s>35</s> 37 41 43 47 <s>49</s> 53 55 59 61 <s>65</s> 67 71 73 77 ...</code>\n</ul>\n\n<ul>\n  <li>Take the first member of the resultant array as the next ludic number <span style='color:blue;font-weight:bold'>7</span>.</li>\n  <li>Remove every <strong>7<sup>th</sup></strong> indexed item from the array (including the first).</li>\n  <code style='margin-left: 2em;'><span style='color:blue;font-weight:bold'><s>7</s></span> 11 13 17 23 25 29 <s>31</s> 37 41 43 47 53 55 <s>59</s> 61 67 71 73 77 83 <s>85</s> 89 91 97 ...</code>\n</ul>\n\n<ul>\n  <li><big><b> ... </b></big></li>\n  <li>Take the first member of the current array as the next ludic number <span style='color:blue;font-weight:bold'>L</span>.</li>\n  <li>Remove every <strong>L<sup>th</sup></strong> indexed item from the array (including the first).</li>\n  <li><big><b> ... </b></big></li>\n</ul>",
      "instructions": "Write a function that returns all the ludic numbers less than or equal to the given number.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function ludic(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function ludic(n) {\n  const makeArr = (s, e) => new Array(e + 1 - s).fill(s).map((e, i) => e + i);\n\n  const filterAtInc = (arr, n) => arr.filter((e, i) => (i + 1) % n);\n\n  const makeLudic = (arr, result) => {\n    const iter = arr.shift();\n    result.push(iter);\n    return arr.length ? makeLudic(filterAtInc(arr, iter), result) : result;\n  };\n\n  const ludicResult = makeLudic(makeArr(2, n), [1]);\n\n  return ludicResult;\n}"
        }
      ],
      "tests": [
        {
          "text": "`ludic` should be a function.",
          "testCode": "assert(typeof ludic === 'function', '<code>ludic</code> should be a function.');"
        },
        {
          "text": "`ludic(2)` should return a array.",
          "testCode": "assert(Array.isArray(ludic(2)));"
        },
        {
          "text": "`ludic(2)` should return `[1, 2]`.",
          "testCode": "assert.deepEqual(ludic(2), [1, 2]);"
        },
        {
          "text": "`ludic(3)` should return `[1, 2, 3]`.",
          "testCode": "assert.deepEqual(ludic(3), [1, 2, 3]);"
        },
        {
          "text": "`ludic(5)` should return `[1, 2, 3, 5]`.",
          "testCode": "assert.deepEqual(ludic(5), [1, 2, 3, 5]);"
        },
        {
          "text": "`ludic(20)` should return `[1, 2, 3, 5, 7, 11, 13, 17]`.",
          "testCode": "assert.deepEqual(ludic(20), [1, 2, 3, 5, 7, 11, 13, 17]);"
        },
        {
          "text": "`ludic(26)` should return `[1, 2, 3, 5, 7, 11, 13, 17, 23, 25]`.",
          "testCode": "assert.deepEqual(ludic(26), [1, 2, 3, 5, 7, 11, 13, 17, 23, 25]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385282,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\ludic-numbers.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5ea28156e79528a9ab248f27",
      "title": "Luhn test of credit card numbers",
      "challengeType": 1,
      "dashedName": "luhn-test-of-credit-card-numbers",
      "description": "The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.\n\nThose companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:\n\n<ol>\n  <li> Reverse the order of the digits in the number.</li>\n  <li> Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1</li>\n  <li> Taking the second, fourth ... and every other even digit in the reversed digits:</li>\n    <ol>\n      <li>Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits.</li>\n      <li>Sum the partial sums of the even digits to form s2.</li>\n    </ol>\n  <li>If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.</li>\n</ol>\n\nFor example, if the trial number is 49927398716:\n\n```md\nReverse the digits:\n  61789372994\nSum the odd digits:\n  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1\nThe even digits:\n    1, 8, 3, 2, 9\n  Two times each even digit:\n    2, 16, 6, 4, 18\n  Sum the digits of each multiplication:\n    2, 7, 6, 4, 9\n  Sum the last:\n    2 + 7 + 6 + 4 + 9 = 28 = s2\n\ns1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test.\n```",
      "instructions": "Write a function that will validate a number with the Luhn test. Return true if it's a valid number. Otherwise, return false.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function luhnTest(str) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function luhnTest(str) {\n  var luhnArr = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];\n  var counter = 0;\n  var incNum;\n  var odd = false;\n  var temp = String(str).replace(/[^\\d]/g, '');\n  if (temp.length == 0) return false;\n  for (var i = temp.length - 1; i >= 0; --i) {\n    incNum = parseInt(temp.charAt(i), 10);\n    counter += (odd = !odd) ? incNum : luhnArr[incNum];\n  }\n  return counter % 10 == 0;\n}"
        }
      ],
      "tests": [
        {
          "text": "`luhnTest` should be a function.",
          "testCode": "assert(typeof luhnTest === 'function');"
        },
        {
          "text": "`luhnTest(\"4111111111111111\")` should return a boolean.",
          "testCode": "assert(typeof luhnTest('4111111111111111') === 'boolean');"
        },
        {
          "text": "`luhnTest(\"4111111111111111\")` should return `true`.",
          "testCode": "assert.equal(luhnTest('4111111111111111'), true);"
        },
        {
          "text": "`luhnTest(\"4111111111111112\")` should return `false`.",
          "testCode": "assert.equal(luhnTest('4111111111111112'), false);"
        },
        {
          "text": "`luhnTest(\"49927398716\")` should return `true`.",
          "testCode": "assert.equal(luhnTest('49927398716'), true);"
        },
        {
          "text": "`luhnTest(\"49927398717\")` should return `false`.",
          "testCode": "assert.equal(luhnTest('49927398717'), false);"
        },
        {
          "text": "`luhnTest(\"1234567812345678\")` should return `false`.",
          "testCode": "assert.equal(luhnTest('1234567812345678'), false);"
        },
        {
          "text": "`luhnTest(\"1234567812345670\")` should return `true`.",
          "testCode": "assert.equal(luhnTest('1234567812345670'), true);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385284,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\luhn-test-of-credit-card-numbers.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5ea2815a8640bcc6cb7dab3c",
      "title": "Lychrel numbers",
      "challengeType": 1,
      "dashedName": "lychrel-numbers",
      "description": "<ol>\n  <li>Take an integer <code>n₀</code>, greater than zero.</li>\n  <li>Form the next number <code>n</code> of the series by reversing <code>n₀</code> and adding it to <code>n₀</code></li>\n  <li>Stop when <code>n</code> becomes palindromic - i.e. the digits of <code>n</code> in reverse order == <code>n</code>.</li>\n</ol>\n\nThe above recurrence relation when applied to most starting numbers `n` = 1, 2, ... terminates in a palindrome quite quickly.\n\nFor example if `n₀` = 12 we get:\n\n```md\n12\n12 + 21 = 33,  a palindrome!\n```\n\nAnd if `n₀` = 55 we get:\n\n```md\n55\n55 + 55 = 110\n110 + 011 = 121,  a palindrome!\n```\n\nNotice that the check for a palindrome happens *after* an addition.\n\nSome starting numbers seem to go on forever; the recurrence relation for 196 has been calculated for millions of repetitions forming numbers with millions of digits, without forming a palindrome. These numbers that do not end in a palindrome are called **Lychrel numbers**.\n\nFor the purposes of this task a Lychrel number is any starting number that does not form a palindrome within 500 (or more) iterations.\n\n**Seed and related Lychrel numbers:**\n\nAny integer produced in the sequence of a Lychrel number is also a Lychrel number.\n\nIn general, any sequence from one Lychrel number *might* converge to join the sequence from a prior Lychrel number candidate; for example the sequences for the numbers 196 and then 689 begin:\n\n```md\n    196\n    196 + 691 = 887\n    887 + 788 = 1675\n    1675 + 5761 = 7436\n    7436 + 6347 = 13783\n    13783 + 38731 = 52514\n    52514 + 41525 = 94039\n    ...\n    689\n    689 + 986 = 1675\n    1675 + 5761 = 7436\n    ...\n```\n\nSo we see that the sequence starting with 689 converges to, and continues with the same numbers as that for 196.\n\nBecause of this we can further split the Lychrel numbers into true **Seed** Lychrel number candidates, and **Related** numbers that produce no palindromes but have integers in their sequence seen as part of the sequence generated from a lower Lychrel number.",
      "instructions": "Write a function that takes a number as a parameter. Return true if the number is a Lynchrel number. Otherwise, return false. Remember that the iteration limit is 500.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isLychrel(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isLychrel(n) {\n  function reverse(num) {\n    return parseInt(\n      num\n        .toString()\n        .split('')\n        .reverse()\n        .join('')\n    );\n  }\n\n  var i;\n  for (i = 0; i < 500; i++) {\n    n = n + reverse(n);\n    if (n == reverse(n)) break;\n  }\n\n  return i == 500;\n}"
        }
      ],
      "tests": [
        {
          "text": "`isLychrel` should be a function.",
          "testCode": "assert(typeof isLychrel === 'function');"
        },
        {
          "text": "`isLychrel(12)` should return a boolean.",
          "testCode": "assert(typeof isLychrel(12) === 'boolean');"
        },
        {
          "text": "`isLychrel(12)` should return `false`.",
          "testCode": "assert.equal(isLychrel(12), false);"
        },
        {
          "text": "`isLychrel(55)` should return `false`.",
          "testCode": "assert.equal(isLychrel(55), false);"
        },
        {
          "text": "`isLychrel(196)` should return `true`.",
          "testCode": "assert.equal(isLychrel(196), true);"
        },
        {
          "text": "`isLychrel(879)` should return `true`.",
          "testCode": "assert.equal(isLychrel(879), true);"
        },
        {
          "text": "`isLychrel(44987)` should return `false`.",
          "testCode": "assert.equal(isLychrel(44987), false);"
        },
        {
          "text": "`isLychrel(7059)` should return `true`.",
          "testCode": "assert.equal(isLychrel(7059), true);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385287,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\lychrel-numbers.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5ea2815e364d9a2222ea55f8",
      "title": "LZW compression",
      "challengeType": 1,
      "dashedName": "lzw-compression",
      "description": "The Lempel-Ziv-Welch (LZW) algorithm provides loss-less data compression.",
      "instructions": "Write a function that takes two parameters. The first parameter is a boolean where `true` indicates compress and `false` indicates decompress. The second parameter is either a string or an array to be processed. If it is a string to be compressed, return an array of numbers. If it's an array of numbers to be decompressed, return a string.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function LZW (compressData, input) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function LZW (compressData, input) {\n  function compress(uncompressed) {\n    // Build the dictionary.\n    var i,\n      dictionary = {},\n      c,\n      wc,\n      w = \"\",\n      result = [],\n      dictSize = 256;\n    for (i = 0; i < 256; i += 1) {\n      dictionary[String.fromCharCode(i)] = i;\n    }\n\n    for (i = 0; i < uncompressed.length; i += 1) {\n      c = uncompressed.charAt(i);\n      wc = w + c;\n      //Do not use dictionary[wc] because javascript arrays\n      //will return values for array['pop'], array['push'] etc\n      // if (dictionary[wc]) {\n      if (dictionary.hasOwnProperty(wc)) {\n        w = wc;\n      } else {\n        result.push(dictionary[w]);\n        // Add wc to the dictionary.\n        dictionary[wc] = dictSize++;\n        w = String(c);\n      }\n    }\n\n    // Output the code for w.\n    if (w !== \"\") {\n      result.push(dictionary[w]);\n    }\n    return result;\n  }\n\n\n  function decompress(compressed) {\n    // Build the dictionary.\n    var i,\n      dictionary = [],\n      w,\n      result,\n      k,\n      entry = \"\",\n      dictSize = 256;\n    for (i = 0; i < 256; i += 1) {\n      dictionary[i] = String.fromCharCode(i);\n    }\n\n    w = String.fromCharCode(compressed[0]);\n    result = w;\n    for (i = 1; i < compressed.length; i += 1) {\n      k = compressed[i];\n      if (dictionary[k]) {\n        entry = dictionary[k];\n      } else {\n        if (k === dictSize) {\n          entry = w + w.charAt(0);\n        } else {\n          return null;\n        }\n      }\n\n      result += entry;\n\n      // Add w+entry[0] to the dictionary.\n      dictionary[dictSize++] = w + entry.charAt(0);\n\n      w = entry;\n    }\n    return result;\n  }\n\n  if(compressData){\n    return compress(input)\n  }else{\n    return decompress(input)\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`LZW` should be a function.",
          "testCode": "assert(typeof LZW === 'function');"
        },
        {
          "text": "`LZW(true, \"TOBEORNOTTOBEORTOBEORNOT\")` should return a array.",
          "testCode": "assert(Array.isArray(LZW(true, 'TOBEORNOTTOBEORTOBEORNOT')));"
        },
        {
          "text": "`LZW(false, [84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263])` should return a string.",
          "testCode": "assert(\n  typeof LZW(false, [\n    84,\n    79,\n    66,\n    69,\n    79,\n    82,\n    78,\n    79,\n    84,\n    256,\n    258,\n    260,\n    265,\n    259,\n    261,\n    263\n  ]) === 'string'\n);"
        },
        {
          "text": "`LZW(true, \"TOBEORNOTTOBEORTOBEORNOT\")` should return `[84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263]`.",
          "testCode": "assert.deepEqual(LZW(true, 'TOBEORNOTTOBEORTOBEORNOT'), [\n  84,\n  79,\n  66,\n  69,\n  79,\n  82,\n  78,\n  79,\n  84,\n  256,\n  258,\n  260,\n  265,\n  259,\n  261,\n  263\n]);"
        },
        {
          "text": "`LZW(false, [84, 79, 66, 69, 79, 82, 78, 79, 84, 256, 258, 260, 265, 259, 261, 263])` should return `\"TOBEORNOTTOBEORTOBEORNOT\"`.",
          "testCode": "assert.equal(\n  LZW(false, [\n    84,\n    79,\n    66,\n    69,\n    79,\n    82,\n    78,\n    79,\n    84,\n    256,\n    258,\n    260,\n    265,\n    259,\n    261,\n    263\n  ]),\n  'TOBEORNOTTOBEORTOBEORNOT'\n);"
        },
        {
          "text": "`LZW(true, \"0123456789\")` should return `[48, 49, 50, 51, 52, 53, 54, 55, 56, 57]`.",
          "testCode": "assert.deepEqual(LZW(true, '0123456789'), [\n  48,\n  49,\n  50,\n  51,\n  52,\n  53,\n  54,\n  55,\n  56,\n  57\n]);"
        },
        {
          "text": "`LZW(false, [48, 49, 50, 51, 52, 53, 54, 55, 56, 57])` should return `\"0123456789\"`.",
          "testCode": "assert.equal(\n  LZW(false, [48, 49, 50, 51, 52, 53, 54, 55, 56, 57]),\n  '0123456789'\n);"
        },
        {
          "text": "`LZW(true, \"BABAABAAA\")` should return `[66, 65, 256, 257, 65, 260]`.",
          "testCode": "assert.deepEqual(LZW(true, 'BABAABAAA'), [66, 65, 256, 257, 65, 260]);"
        },
        {
          "text": "`LZW(false, [66, 65, 256, 257, 65, 260])` should return `\"BABAABAAA\"`.",
          "testCode": "assert.equal(LZW(false, [66, 65, 256, 257, 65, 260]), 'BABAABAAA');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385288,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\lzw-compression.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59667989bf71cf555dd5d2ff",
      "title": "S-Expressions",
      "challengeType": 1,
      "dashedName": "s-expressions",
      "description": "<a href=\"https://rosettacode.org/wiki/S-expressions\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">S-Expressions</a> are one convenient way to parse and store data.",
      "instructions": "Write a simple reader/parser for S-Expressions that handles quoted and unquoted strings, integers and floats.\n\nThe function should read a single but nested S-Expression from a string and return it as a (nested) array.\n\nNewlines and other whitespace may be ignored unless contained within a quoted string.\n\n\"`()`\" inside quoted strings are not interpreted, but treated as part of the string.\n\nHandling escaped quotes inside a string is optional; thus \"`(foo\"bar)`\" may be treated as a string \"`foo\"bar`\", or as an error.\n\nFor this, the reader need not recognize `\\` for escaping, but should, in addition, recognize numbers if the language has appropriate data types.\n\nNote that with the exception of `()\"` (`\\` if escaping is supported) and whitespace, there are no special characters. Anything else is allowed without quotes.\n\nThe reader should be able to read the following input\n\n<pre>((data \"quoted data\" 123 4.5)\n(data (!@# (4.5) \"(more\" \"data)\")))\n</pre>\n\nand turn it into a native data structure.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function parseSexpr(str) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function parseSexpr(str) {\n  const t = str.match(/\\s*(\"[^\"]*\"|\\(|\\)|\"|[^\\s()\"]+)/g);\n  for (var o, c = 0, i = t.length - 1; i >= 0; i--) {\n    var n,\n      ti = t[i].trim();\n    if (ti == '\"') return;\n    else if (ti == '(') t[i] = '[', c += 1;\n    else if (ti == ')') t[i] = ']', c -= 1;\n    else if ((n = +ti) == ti) t[i] = n;\n    else t[i] = `'${ti.replace('\\'', '\\\\\\'')}'`;\n    if (i > 0 && ti != ']' && t[i - 1].trim() != '(') t.splice(i, 0, ',');\n    if (!c) if (!o) o = true; else return;\n  }\n  return c ? undefined : eval(t.join(''));\n}"
        }
      ],
      "tests": [
        {
          "text": "`parseSexpr` should be a function.",
          "testCode": "assert(typeof parseSexpr === 'function');"
        },
        {
          "text": "`parseSexpr('(data1 data2 data3)')` should return `['data1', 'data2', 'data3']`",
          "testCode": "assert.deepEqual(parseSexpr(simpleSExpr), simpleSolution);"
        },
        {
          "text": "`parseSexpr('((data \"quoted data\" 123 4.5) (data (!@# (4.5) \"(more\" \"data)\")))')` should return `[['data', '\"quoted data\"', 123, 4.5], ['data', ['!@#', [4.5], '\"(more\"', '\"data)\"']]]`.",
          "testCode": "assert.deepEqual(parseSexpr(basicSExpr), basicSolution);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302303,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\s-expressions.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const simpleSExpr = '(data1 data2 data3)';\nconst simpleSolution = ['data1', 'data2', 'data3'];\n\nconst basicSExpr = '((data \"quoted data\" 123 4.5) (data (!@# (4.5) \"(more\" \"data)\")))';\nconst basicSolution = [[\"data\",\"\\\"quoted data\\\"\",123,4.5],[\"data\",[\"!@#\",[4.5],\"\\\"(more\\\"\",\"\\\"data)\\\"\"]]];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59da22823d04c95919d46269",
      "title": "Sailors, coconuts and a monkey problem",
      "challengeType": 1,
      "dashedName": "sailors-coconuts-and-a-monkey-problem",
      "description": "Five sailors are shipwrecked on an island and collect a large pile of coconuts during the day. \n\nThat night the first sailor wakes up and decides to take his first share early so tries to divide the pile of coconuts equally into five piles but finds that there is one coconut left over, so he tosses it to a monkey and then hides \"his\" one of the five equally sized piles of coconuts and pushes the other four piles together to form a single visible pile of coconuts again and goes to bed. \n\nTo cut a long story short, each of the sailors in turn gets up once during the night and performs the same actions of dividing the coconut pile into five, finding that one coconut is left over and giving that single remainder coconut to the monkey, then push the other four piles together to form a single pile. \n\nIn the morning (after the surreptitious and separate action of each of the five sailors during the night), the remaining coconuts are divided into five equal piles for each of the sailors, whereupon it is found that the pile of coconuts divides equally amongst the sailors with no remainder. (Nothing for the monkey in the morning.)",
      "instructions": "Create a function that returns the minimum possible size of the initial pile of coconuts collected during the day for `N` sailors. **Note:** Of course the tale is told in a world where the collection of any number of coconuts in a day and multiple divisions of the pile, etc. can occur in time fitting the story line, so as not to affect mathematics.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function splitCoconuts(intSailors) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function splitCoconuts(intSailors) {\n  let intNuts = intSailors;\n  let result = splitCoconutsHelper(intNuts, intSailors);\n  while (!result) {\n    intNuts += 1;\n    result = splitCoconutsHelper(intNuts, intSailors);\n  }\n\n  return intNuts;\n}\n\nfunction splitCoconutsHelper(intNuts, intSailors, intDepth) {\n  const nDepth = intDepth !== undefined ? intDepth : intSailors;\n  const portion = Math.floor(intNuts / intSailors);\n  const remain = intNuts % intSailors;\n\n  if (portion <= 0 || remain !== (nDepth ? 1 : 0)) {\n    return null;\n  }\n\n  if (nDepth) {\n    return splitCoconutsHelper(\n      intNuts - portion - remain, intSailors, nDepth - 1\n    );\n  }\n\n  return intNuts;\n}"
        }
      ],
      "tests": [
        {
          "text": "`splitCoconuts` should be a function.",
          "testCode": "assert(typeof splitCoconuts === 'function');"
        },
        {
          "text": "`splitCoconuts(5)` should return 3121.",
          "testCode": "assert(splitCoconuts(5) === 3121);"
        },
        {
          "text": "`splitCoconuts(6)` should return 233275.",
          "testCode": "assert(splitCoconuts(6) === 233275);"
        },
        {
          "text": "`splitCoconuts(7)` should return 823537.",
          "testCode": "assert(splitCoconuts(7) === 823537);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302304,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sailors-coconuts-and-a-monkey-problem.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5eb3e497b8d6d7f63c5517ea",
      "title": "Search a list of records",
      "challengeType": 1,
      "dashedName": "search-a-list-of-records",
      "description": "A record consists of attributes that describe an entity. Each attribute has a name and a value. For example, a person can have an attribute `age` with a value of 25. An important operation on a list of records is to find a record with a particular attribute value.",
      "instructions": "Write a function that takes a string as a parameter. The function should return the index of the item in `list` for which the value of the `name` attribute matches the given string.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function searchCity(name) {\n\n}\n\nconst list = [\n  { name: 'Lagos', population: 21.0 },\n  { name: 'Cairo', population: 15.2 },\n  { name: 'Kinshasa-Brazzaville', population: 11.3 },\n  { name: 'Greater Johannesburg', population: 7.55 },\n  { name: 'Mogadishu', population: 5.85 },\n  { name: 'Khartoum-Omdurman', population: 4.98 },\n  { name: 'Dar Es Salaam', population: 4.7 },\n  { name: 'Alexandria', population: 4.58 },\n  { name: 'Abidjan', population: 4.4 },\n  { name: 'Casablanca', population: 3.98 }\n];"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function searchCity(name) {\n  return list.findIndex(item => item.name === name);\n}\n\nconst list = [\n  { name: 'Lagos', population: 21.0 },\n  { name: 'Cairo', population: 15.2 },\n  { name: 'Kinshasa-Brazzaville', population: 11.3 },\n  { name: 'Greater Johannesburg', population: 7.55 },\n  { name: 'Mogadishu', population: 5.85 },\n  { name: 'Khartoum-Omdurman', population: 4.98 },\n  { name: 'Dar Es Salaam', population: 4.7 },\n  { name: 'Alexandria', population: 4.58 },\n  { name: 'Abidjan', population: 4.4 },\n  { name: 'Casablanca', population: 3.98 }\n];"
        }
      ],
      "tests": [
        {
          "text": "`searchCity` should be a function.",
          "testCode": "assert(typeof searchCity === 'function');"
        },
        {
          "text": "`searchCity(\"Dar Es Salaam\")` should return a number.",
          "testCode": "assert(typeof searchCity('Dar Es Salaam') === 'number');"
        },
        {
          "text": "`searchCity(\"Dar Es Salaam\")` should return `6`.",
          "testCode": "assert.equal(searchCity('Dar Es Salaam'), 6);"
        },
        {
          "text": "`searchCity(\"Casablanca\")` should return `9`.",
          "testCode": "assert.equal(searchCity('Casablanca'), 9);"
        },
        {
          "text": "`searchCity(\"Cairo\")` should return `1`.",
          "testCode": "assert.equal(searchCity('Cairo'), 1);"
        },
        {
          "text": "`searchCity(\"Mogadishu\")` should return `4`.",
          "testCode": "assert.equal(searchCity('Mogadishu'), 4);"
        },
        {
          "text": "`searchCity(\"Lagos\")` should return `0`.",
          "testCode": "assert.equal(searchCity('Lagos'), 0);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385315,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\search-a-list-of-records.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "59d9c6bc214c613ba73ff012",
      "title": "SEDOLs",
      "challengeType": 1,
      "dashedName": "sedols",
      "description": "<abbr title=\"Stock Exchange Daily Official List\">SEDOL</abbr> is a list of securities identification numbers issued by the London Stock Exchange.\n\nFor each number list of 6-digit <abbr title=\"Stock Exchange Daily Official List\">SEDOL</abbr>s, calculate and append the checksum digit. That is, given the input string on the left, your function should return the corresponding string on the right:\n\n<pre>\n710889 => 7108899\nB0YBKJ => B0YBKJ7\n406566 => 4065663\nB0YBLH => B0YBLH2\n228276 => 2282765\nB0YBKL => B0YBKL9\n557910 => 5579107\nB0YBKR => B0YBKR5\n585284 => 5852842\nB0YBKT => B0YBKT7\nB00030 => B000300\n</pre>\n\nCheck that each input is correctly formed, especially with respect to valid characters allowed in a SEDOL string. Your function should return `null` on an invalid input.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sedol(input) {\n  const checkSum = 0\n  \n  return checkSum;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sedol(input) {\n  const checkDigit = sedolCheckDigit(input);\n  if (checkDigit !== null) {\n    return input + checkDigit;\n  }\n  return null;\n}\n\nconst weight = [1, 3, 1, 7, 3, 9, 1];\nfunction sedolCheckDigit(char6) {\n  if (char6.search(/^[0-9BCDFGHJKLMNPQRSTVWXYZ]{6}$/) === -1) {\n    return null;\n  }\n\n  let sum = 0;\n  for (let i = 0; i < char6.length; i++) {\n    sum += weight[i] * parseInt(char6.charAt(i), 36);\n  }\n  const checkSum = (10 - (sum % 10)) % 10;\n  return checkSum.toString();\n}"
        }
      ],
      "tests": [
        {
          "text": "`sedol` should be a function.",
          "testCode": "assert(typeof sedol === 'function');"
        },
        {
          "text": "`sedol('a')` should return null.",
          "testCode": "assert(sedol('a') === null);"
        },
        {
          "text": "`sedol('710889')` should return '7108899'.",
          "testCode": "assert(sedol('710889') === '7108899');"
        },
        {
          "text": "`sedol('BOATER')` should return null.",
          "testCode": "assert(sedol('BOATER') === null);"
        },
        {
          "text": "`sedol('228276')` should return '2282765'.",
          "testCode": "assert(sedol('228276') === '2282765');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302305,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sedols.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5eaf48389ee512d4d103684b",
      "title": "Self Describing Numbers",
      "challengeType": 1,
      "dashedName": "self-describing-numbers",
      "description": "There are several so-called \"self-describing\" or \"self-descriptive\" integers.\n\nAn integer is said to be \"self-describing\" if it has the property that, when digit positions are labeled 0 to N-1, the digit in each position is equal to the number of times that digit appears in the number.\n\nFor example, **2020** is a four-digit self describing number:\n\n<ul>\n    <li> position 0 has value 2 and there are two 0s in the number; </li>\n    <li> position 1 has value 0 and there are no 1s in the number; </li>\n    <li> position 2 has value 2 and there are two 2s; </li>\n    <li> position 3 has value 0 and there are zero 3s; </li>\n</ul>\n\nSelf-describing numbers &lt; 100,000,000 are: 1210, 2020, 21200, 3211000, 42101000.",
      "instructions": "Write a function that takes a positive integer as a parameter. If it is self-describing return true. Otherwise, return false.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isSelfDescribing(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isSelfDescribing(n) {\n    let digits = String(n).split(\"\");\n    digits = digits.map(function(e) {return parseInt(e)});\n    let count = digits.map((x) => {return 0})\n    digits.forEach((d) =>{\n        if (d >= count.length) {\n            return false\n        }\n        count[d] += 1;\n    });\n\n     if (digits === count) {\n        return true;\n    }\n    if (digits.length != count.length) {\n        return false;\n    }\n    \n    for (let i=0; i< digits.length; i++){\n      if (digits[i] !== count[i]) {\n        return false;\n      }\n    }\n    return true;\n}"
        }
      ],
      "tests": [
        {
          "text": "`isSelfDescribing` should be a function.",
          "testCode": "assert(typeof isSelfDescribing == 'function');"
        },
        {
          "text": "`isSelfDescribing()` should return a boolean.",
          "testCode": "assert(typeof isSelfDescribing(2020) == 'boolean');"
        },
        {
          "text": "`isSelfDescribing(2020)` should return `true`.",
          "testCode": "assert.equal(isSelfDescribing(2020), true);"
        },
        {
          "text": "`isSelfDescribing(3021)` should return `false`.",
          "testCode": "assert.equal(isSelfDescribing(3021), false);"
        },
        {
          "text": "`isSelfDescribing(3211000)` should return `true`.",
          "testCode": "assert.equal(isSelfDescribing(3211000), true);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385289,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\self-describing-numbers.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5eb3e4a21f462f409d656c73",
      "title": "Self-referential sequence",
      "challengeType": 1,
      "dashedName": "self-referential-sequence",
      "description": "There are several ways to generate a self-referential sequence. One very common one (the <a href=\"https://rosettacode.org/wiki/Look-and-say_sequence\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Look-and-say sequence</a>) is to start with a positive integer, then generate the next term by concatenating enumerated groups of adjacent alike digits:\n\n<pre>0, 10, 1110, 3110, 132110, 1113122110, 311311222110 ...</pre>\n\nThe terms generated grow in length geometrically and never converge.\n\nAnother way to generate a self-referential sequence is to summarize the previous term.\n\nCount how many of each alike digit there is, then concatenate the sum and digit for each of the sorted enumerated digits. Note that the first five terms are the same as for the previous sequence.\n\n<pre>0, 10, 1110, 3110, 132110, 13123110, 23124110 ...</pre>\n\nSort the digits largest to smallest. Do not include counts of digits that do not appear in the previous term.\n\nDepending on the seed value, series generated this way always either converge to a stable value or to a short cyclical pattern. (For our purposes, converge means that an element matches a previously seen element.) The sequence shown, with a seed value of 0, converges to a stable value of 1433223110 after 11 iterations. The seed value that converges most quickly is 22. It goes stable after the first element. (The next element is 22, which has been seen before.)",
      "instructions": "Write a function that takes the seed value as parameter, generates a self referential sequence until it converges, and returns it as an array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function selfReferential(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function selfReferential(n) {\n  var descending,\n    i,\n    incr,\n    j,\n    max_i,\n    max_len,\n    max_seq,\n    seq,\n    sequence,\n    indexOf =\n      [].indexOf ||\n      function(item) {\n        for (var i = 0, l = this.length; i < l; i++) {\n          if (i in this && this[i] === item) return i;\n        }\n        return -1;\n      };\n\n  sequence = function(n) {\n    var c, cnt, cnts, d, digit, i, j, l, len, new_cnts, ref, s, seq;\n    cnts = {};\n    ref = n.toString();\n    for (j = 0, len = ref.length; j < len; j++) {\n      c = ref[j];\n      d = parseInt(c);\n      incr(cnts, d);\n    }\n    seq = [ref];\n    while (true) {\n      s = '';\n      for (i = l = 9; l >= 0; i = --l) {\n        if (cnts[i]) {\n          s += '' + cnts[i] + i;\n        }\n      }\n      if (indexOf.call(seq, s) >= 0) {\n        break;\n      }\n      seq.push(s);\n      new_cnts = {};\n      for (digit in cnts) {\n        cnt = cnts[digit];\n        incr(new_cnts, cnt);\n        incr(new_cnts, digit);\n      }\n      cnts = new_cnts;\n    }\n    return seq;\n  };\n\n  incr = function(h, k) {\n    if (h[k] == null) {\n      h[k] = 0;\n    }\n    return (h[k] += 1);\n  };\n\n  descending = function(n) {\n    var tens;\n    if (n < 10) {\n      return true;\n    }\n    tens = n / 10;\n    if (n % 10 > tens % 10) {\n      return false;\n    }\n    return descending(tens);\n  };\n\n  return sequence(n);\n}"
        }
      ],
      "tests": [
        {
          "text": "`selfReferential` should be a function.",
          "testCode": "assert(typeof selfReferential === 'function');"
        },
        {
          "text": "`selfReferential(40)` should return a array.",
          "testCode": "assert(Array.isArray(selfReferential(40)));"
        },
        {
          "text": "`selfReferential(40)` should return `[\"40\", \"1410\", \"142110\", \"14123110\", \"1413124110\", \"2413125110\", \"151413224110\", \"152413225110\", \"251413324110\", \"152423224110\", \"152413423110\"]`.",
          "testCode": "assert.deepEqual(selfReferential(40), [\n  '40',\n  '1410',\n  '142110',\n  '14123110',\n  '1413124110',\n  '2413125110',\n  '151413224110',\n  '152413225110',\n  '251413324110',\n  '152423224110',\n  '152413423110'\n]);"
        },
        {
          "text": "`selfReferential(132110)` should return `[\"132110\", \"13123110\", \"23124110\", \"1413223110\", \"1423224110\", \"2413323110\", \"1433223110\"]`.",
          "testCode": "assert.deepEqual(selfReferential(132110), [\n  '132110',\n  '13123110',\n  '23124110',\n  '1413223110',\n  '1423224110',\n  '2413323110',\n  '1433223110'\n]);"
        },
        {
          "text": "`selfReferential(132211)` should return `[\"132211\", \"132231\", \"232221\", \"134211\", \"14131231\", \"14231241\", \"24132231\", \"14233221\"]`.",
          "testCode": "assert.deepEqual(selfReferential(132211), [\n  '132211',\n  '132231',\n  '232221',\n  '134211',\n  '14131231',\n  '14231241',\n  '24132231',\n  '14233221'\n]);"
        },
        {
          "text": "`selfReferential(1413223110)` should return `[\"1413223110\", \"1423224110\", \"2413323110\", \"1433223110\"]`.",
          "testCode": "assert.deepEqual(selfReferential(1413223110), [\n  '1413223110',\n  '1423224110',\n  '2413323110',\n  '1433223110'\n]);"
        },
        {
          "text": "`selfReferential(251413126110)` should return `[\"251413126110\", \"16151413225110\", \"16251413226110\", \"26151413325110\", \"16251423225110\", \"16251413424110\", \"16153413225110\"]`.",
          "testCode": "assert.deepEqual(selfReferential(251413126110), [\n  '251413126110',\n  '16151413225110',\n  '16251413226110',\n  '26151413325110',\n  '16251423225110',\n  '16251413424110',\n  '16153413225110'\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385317,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\self-referential-sequence.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5eb3e4aa847216613aa81983",
      "title": "Semiprime",
      "challengeType": 1,
      "dashedName": "semiprime",
      "description": "Semiprime numbers are natural numbers that are products of exactly two (possibly equal) <a href=\"https://rosettacode.org/wiki/prime_number\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">prime numbers</a>.\n\n<pre>1679  =  23 x 73</pre>",
      "instructions": "Write a function that returns true if a number is semiprime, or false if it is not.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function isSemiPrime(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function isSemiPrime(n) {\n  if (n <= 3) return false;\n\n  var ans = [];\n  var done = false;\n  while (!done) {\n    if (n % 2 === 0) {\n      ans.push(2);\n      n /= 2;\n      continue;\n    }\n    if (n % 3 === 0) {\n      ans.push(3);\n      n /= 3;\n      continue;\n    }\n    if (n === 1) return ans.length == 2;\n    var sr = Math.sqrt(n);\n    done = true;\n    // try to divide the checked number by all numbers till its square root.\n    for (var i = 6; i <= sr; i += 6) {\n      if (n % (i - 1) === 0) {\n        // is n divisible by i-1?\n        ans.push(i - 1);\n        n /= i - 1;\n        done = false;\n        break;\n      }\n      if (n % (i + 1) === 0) {\n        // is n divisible by i+1?\n        ans.push(i + 1);\n        n /= i + 1;\n        done = false;\n        break;\n      }\n    }\n  }\n  ans.push(n);\n  return ans.length == 2;\n}"
        }
      ],
      "tests": [
        {
          "text": "`isSemiPrime` should be a function.",
          "testCode": "assert(typeof isSemiPrime === 'function');"
        },
        {
          "text": "`isSemiPrime(100)` should return a boolean.",
          "testCode": "assert(typeof isSemiPrime(100) === 'boolean');"
        },
        {
          "text": "`isSemiPrime(100)` should return `false`.",
          "testCode": "assert.equal(isSemiPrime(100), false);"
        },
        {
          "text": "`isSemiPrime(504)` should return `false`.",
          "testCode": "assert.equal(isSemiPrime(504), false);"
        },
        {
          "text": "`isSemiPrime(4)` should return `true`.",
          "testCode": "assert.equal(isSemiPrime(4), true);"
        },
        {
          "text": "`isSemiPrime(46)` should return `true`.",
          "testCode": "assert.equal(isSemiPrime(46), true);"
        },
        {
          "text": "`isSemiPrime(13)` should return `false`.",
          "testCode": "assert.equal(isSemiPrime(13), false);"
        },
        {
          "text": "`isSemiPrime(74)` should return `true`.",
          "testCode": "assert.equal(isSemiPrime(74), true);"
        },
        {
          "text": "`isSemiPrime(1679)` should return `true`.",
          "testCode": "assert.equal(isSemiPrime(1679), true);"
        },
        {
          "text": "`isSemiPrime(2)` should return `false`.",
          "testCode": "assert.equal(isSemiPrime(2), false);"
        },
        {
          "text": "`isSemiPrime(95)` should return `true`.",
          "testCode": "assert.equal(isSemiPrime(95), true);"
        },
        {
          "text": "`isSemiPrime(124)` should return `false`.",
          "testCode": "assert.equal(isSemiPrime(124), false);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385318,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\semiprime.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5eb3e4af7d0e7b760b46cedc",
      "title": "Set consolidation",
      "challengeType": 1,
      "dashedName": "set-consolidation",
      "description": "Given two sets of items then if any item is common to any set then the result of applying *consolidation* to those sets is a set of sets whose contents is:\n\n<ul>\n  <li>The two input sets if no common item exists between the two input sets of items.</li>\n  <li>The single set that is the union of the two input sets if they share a common item.</li>\n</ul>\n\nGiven N sets of items where N > 2 then the result is the same as repeatedly replacing all combinations of two sets by their consolidation until no further consolidation between set pairs is possible. If N &lt; 2 then consolidation has no strict meaning and the input can be returned.\n\nHere are some examples:\n\n**Example 1:**\n\nGiven the two sets `{A,B}` and `{C,D}` then there is no common element between the sets and the result is the same as the input.\n\n**Example 2:**\n\nGiven the two sets `{A,B}` and `{B,D}` then there is a common element `B` between the sets and the result is the single set `{B,D,A}`. (Note that order of items in a set is immaterial: `{A,B,D}` is the same as `{B,D,A}` and `{D,A,B}`, etc).\n\n**Example 3:**\n\nGiven the three sets `{A,B}` and `{C,D}` and `{D,B}` then there is no common element between the sets `{A,B}` and `{C,D}` but the sets `{A,B}` and `{D,B}` do share a common element that consolidates to produce the result `{B,D,A}`. On examining this result with the remaining set, `{C,D}`, they share a common element and so consolidate to the final output of the single set `{A,B,C,D}`\n\n**Example 4:**\n\nThe consolidation of the five sets:\n\n`{H,I,K}`, `{A,B}`, `{C,D}`, `{D,B}`, and `{F,G,H}`\n\nIs the two sets:\n\n`{A, C, B, D}`, and `{G, F, I, H, K}`",
      "instructions": "Write a function that takes an array of strings as a parameter. Each string is represents a set with the characters representing the set elements. The function should return a 2D array containing the consolidated sets. Note: Each set should be sorted.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function setConsolidation(sets) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function setConsolidation(sets) {\n  function addAll(l1, l2) {\n    l2.forEach(function(e) {\n      if (l1.indexOf(e) == -1) l1.push(e);\n    });\n  }\n\n  function consolidate(sets) {\n    var r = [];\n    for (var i = 0; i < sets.length; i++) {\n      var s = sets[i];\n      {\n        var new_r = [];\n        new_r.push(s);\n        for (var j = 0; j < r.length; j++) {\n          var x = r[j];\n          {\n            if (\n              !(function(c1, c2) {\n                for (var i = 0; i < c1.length; i++) {\n                  if (c2.indexOf(c1[i]) >= 0) return false;\n                }\n                return true;\n              })(s, x)\n            ) {\n              (function(l1, l2) {\n                addAll(l1, l2);\n              })(s, x);\n            } else {\n              new_r.push(x);\n            }\n          }\n        }\n        r = new_r;\n      }\n    }\n    return r;\n  }\n\n  function consolidateR(sets) {\n    if (sets.length < 2) return sets;\n    var r = [];\n    r.push(sets[0]);\n    {\n      var arr1 = consolidateR(sets.slice(1, sets.length));\n      for (var i = 0; i < arr1.length; i++) {\n        var x = arr1[i];\n        {\n          if (\n            !(function(c1, c2) {\n              for (var i = 0; i < c1.length; i++) {\n                if (c2.indexOf(c1[i]) >= 0) return false;\n              }\n              return true;\n            })(r[0], x)\n          ) {\n            (function(l1, l2) {\n              return l1.push.apply(l1, l2);\n            })(r[0], x);\n          } else {\n            r.push(x);\n          }\n        }\n      }\n    }\n    return r;\n  }\n\n  function hashSetList(set) {\n    var r = [];\n    for (var i = 0; i < set.length; i++) {\n      r.push([]);\n      for (var j = 0; j < set[i].length; j++)\n        (function(s, e) {\n          if (s.indexOf(e) == -1) {\n            s.push(e);\n            return true;\n          } else {\n            return false;\n          }\n        })(r[i], set[i].charAt(j));\n    }\n    return r;\n  }\n\n  var h1 = consolidate(hashSetList(sets)).map(function(e) {\n    e.sort();\n    return e;\n  });\n  return h1;\n}"
        }
      ],
      "tests": [
        {
          "text": "`setConsolidation` should be a function.",
          "testCode": "assert(typeof setConsolidation === 'function');"
        },
        {
          "text": "`setConsolidation([\"AB\", \"CD\"])` should return a array.",
          "testCode": "assert(Array.isArray(setConsolidation(['AB', 'CD'])));"
        },
        {
          "text": "`setConsolidation([\"AB\", \"CD\"])` should return `[[\"C\", \"D\"], [\"A\", \"B\"]]`.",
          "testCode": "assert.deepEqual(setConsolidation(['AB', 'CD']), [\n  ['C', 'D'],\n  ['A', 'B']\n]);"
        },
        {
          "text": "`setConsolidation([\"AB\", \"BD\"])` should return `[[\"A\", \"B\", \"D\"]]`.",
          "testCode": "assert.deepEqual(setConsolidation(['AB', 'BD']), [['A', 'B', 'D']]);"
        },
        {
          "text": "`setConsolidation([\"AB\", \"CD\", \"DB\"])` should return `[[\"A\", \"B\", \"C\", \"D\"]]`.",
          "testCode": "assert.deepEqual(setConsolidation(['AB', 'CD', 'DB']), [['A', 'B', 'C', 'D']]);"
        },
        {
          "text": "`setConsolidation([\"HIK\", \"AB\", \"CD\", \"DB\", \"FGH\"])` should return `[[\"F\", \"G\", \"H\", \"I\", \"K\"], [\"A\", \"B\", \"C\", \"D\"]]`.",
          "testCode": "assert.deepEqual(setConsolidation(['HIK', 'AB', 'CD', 'DB', 'FGH']), [\n  ['F', 'G', 'H', 'I', 'K'],\n  ['A', 'B', 'C', 'D']\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385319,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\set-consolidation.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5eb3e4b20aa93c437f9e9717",
      "title": "Set of real numbers",
      "challengeType": 1,
      "dashedName": "set-of-real-numbers",
      "description": "All real numbers form the uncountable set ℝ. Among its subsets, relatively simple are the convex sets, each expressed as a range between two real numbers *a* and *b* where *a* ≤ *b*. There are actually four cases for the meaning of \"between\", depending on open or closed boundary:\n\n<ul>\n  <li>[<i>a</i>, <i>b</i>]: {<i>x</i> | <i>a</i> ≤ <i>x</i> and <i>x</i> ≤ <i>b</i> }</li>\n  <li>(<i>a</i>, <i>b</i>): {<i>x</i> | <i>a</i> < <i>x</i> and <i>x</i> < <i>b</i> }</li>\n  <li>[<i>a</i>, <i>b</i>): {<i>x</i> | <i>a</i> ≤ <i>x</i> and <i>x</i> < <i>b</i> }</li>\n  <li>(<i>a</i>, <i>b</i>]: {<i>x</i> | <i>a</i> < <i>x</i> and <i>x</i> ≤ <i>b</i> }</li>\n</ul>\n\nNote that if *a* = *b*, of the four only \\[*a*, *a*] would be non-empty.\n\n**Task**\n\n<ul>\n  <li>Devise a way to represent any set of real numbers, for the definition of \"any\" in the implementation notes below.</li>\n  <li>Provide methods for these common set operations (<i>x</i> is a real number; <i>A</i> and <i>B</i> are sets):</li>\n  <ul>\n    <li>\n      <i>x</i> ∈ <i>A</i>: determine if <i>x</i> is an element of <i>A</i><br>\n      example: 1 is in [1, 2), while 2, 3, ... are not.\n    </li>\n    <li>\n      <i>A</i> ∪ <i>B</i>: union of <i>A</i> and <i>B</i>, i.e. {<i>x</i> | <i>x</i> ∈ <i>A</i> or <i>x</i> ∈ <i>B</i>}<br>\n      example: [0, 2) ∪ (1, 3) = [0, 3); [0, 1) ∪ (2, 3] = well, [0, 1) ∪ (2, 3]\n    </li>\n    <li>\n      <i>A</i> ∩ <i>B</i>: intersection of <i>A</i> and <i>B</i>, i.e. {<i>x</i> | <i>x</i> ∈ <i>A</i> and <i>x</i> ∈ <i>B</i>}<br>\n      example: [0, 2) ∩ (1, 3) = (1, 2); [0, 1) ∩ (2, 3] = empty set\n    </li>\n    <li>\n      <i>A</i> - <i>B</i>: difference between <i>A</i> and <i>B</i>, also written as <i>A</i> \\ <i>B</i>, i.e. {<i>x</i> | <i>x</i> ∈ <i>A</i> and <i>x</i> ∉ <i>B</i>}<br>\n      example: [0, 2) − (1, 3) = [0, 1]\n    </li>\n  </ul>\n</ul>",
      "instructions": "Write a function that takes 2 objects, a string and an array as parameters. The objects represents the set and have attributes: `low`, `high` and `rangeType`.\n\nThe `rangeType` can have values 0, 1, 2 and 3 for `CLOSED`, `BOTH_OPEN`, `LEFT_OPEN` and `RIGHT_OPEN`, respectively. The function should implement a set using this information.\n\nThe string represents the operation to be performed on the sets. It can be: `\"union\"`, `\"intersect\"` and `\"subtract\"` (difference).\n\nAfter performing the operation, the function should check if the values in the array are present in the resultant set and store a corresponding boolean value to an array. The function should return this array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function realSet(set1, set2, operation, values) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function realSet(set1, set2, operation, values) {\n  const RangeType = {\n    CLOSED: 0,\n    BOTH_OPEN: 1,\n    LEFT_OPEN: 2,\n    RIGHT_OPEN: 3\n  };\n\n  function Predicate(test) {\n    this.test = test;\n    this.or = function(other) {\n      return new Predicate(t => this.test(t) || other.test(t));\n    };\n    this.and = function(other) {\n      return new Predicate(t => this.test(t) && other.test(t));\n    };\n    this.negate = function() {\n      return new Predicate(t => !this.test(t));\n    };\n  }\n\n  function RealSet(start, end, rangeType, predF) {\n    this.low = start;\n    this.high = end;\n\n    if (predF) {\n      this.predicate = new Predicate(predF);\n    } else {\n      this.predicate = new Predicate(d => {\n        switch (rangeType) {\n          case RangeType.CLOSED:\n            return start <= d && d <= end;\n          case RangeType.BOTH_OPEN:\n            return start < d && d < end;\n          case RangeType.LEFT_OPEN:\n            return start < d && d <= end;\n          case RangeType.RIGHT_OPEN:\n            return start <= d && d < end;\n        }\n      });\n    }\n\n    this.contains = function(d) {\n      return this.predicate.test(d);\n    };\n\n    this.union = function(other) {\n      var low2 = Math.min(this.low, other.low);\n      var high2 = Math.max(this.high, other.high);\n      return new RealSet(low2, high2, null, d =>\n        this.predicate.or(other.predicate).test(d)\n      );\n    };\n\n    this.intersect = function(other) {\n      var low2 = Math.min(this.low, other.low);\n      var high2 = Math.max(this.high, other.high);\n      return new RealSet(low2, high2, null, d =>\n        this.predicate.and(other.predicate).test(d)\n      );\n    };\n\n    this.subtract = function(other) {\n      return new RealSet(this.low, this.high, null, d =>\n        this.predicate.and(other.predicate.negate()).test(d)\n      );\n    };\n  }\n  set1 = new RealSet(set1.low, set1.high, set1.rangeType);\n  set2 = new RealSet(set2.low, set2.high, set2.rangeType);\n  var result = [];\n  values.forEach(function(value) {\n    result.push(set1[operation](set2).contains(value));\n  });\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`realSet` should be a function.",
          "testCode": "assert(typeof realSet == 'function');"
        },
        {
          "text": "`realSet({\"low\":0, \"high\":1, \"rangeType\":2}, {\"low\":0, \"high\":2, \"rangeType\":3}, \"union\", [1, 2, 3])` should return a array.",
          "testCode": "assert(\n  Array.isArray(\n    realSet(\n      { low: 0, high: 1, rangeType: 2 },\n      { low: 0, high: 2, rangeType: 3 },\n      'union',\n      [1, 2, 3]\n    )\n  )\n);"
        },
        {
          "text": "`realSet({\"low\":0, \"high\":1, \"rangeType\":2}, {\"low\":0, \"high\":2, \"rangeType\":3}, \"union\", [1, 2, 3])` should return `[true, false, false]`.",
          "testCode": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 1, rangeType: 2 },\n    { low: 0, high: 2, rangeType: 3 },\n    'union',\n    [1, 2, 3]\n  ),\n  [true, false, false]\n);"
        },
        {
          "text": "`realSet({\"low\":0, \"high\":2, \"rangeType\":3}, {\"low\":1, \"high\":2, \"rangeType\":2}, \"intersect\", [0, 1, 2])` should return `[false, false, false]`.",
          "testCode": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 2, rangeType: 3 },\n    { low: 1, high: 2, rangeType: 2 },\n    'intersect',\n    [0, 1, 2]\n  ),\n  [false, false, false]\n);"
        },
        {
          "text": "`realSet({\"low\":0, \"high\":3, \"rangeType\":3}, {\"low\":0, \"high\":1, \"rangeType\":1}, \"subtract\", [0, 1, 2])` should return `[true, true, true]`.",
          "testCode": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 3, rangeType: 3 },\n    { low: 0, high: 1, rangeType: 1 },\n    'subtract',\n    [0, 1, 2]\n  ),\n  [true, true, true]\n);"
        },
        {
          "text": "`realSet({\"low\":0, \"high\":3, \"rangeType\":3}, {\"low\":0, \"high\":1, \"rangeType\":0}, \"subtract\", [0, 1, 2])` should return `[false, false, true]`.",
          "testCode": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 3, rangeType: 3 },\n    { low: 0, high: 1, rangeType: 0 },\n    'subtract',\n    [0, 1, 2]\n  ),\n  [false, false, true]\n);"
        },
        {
          "text": "`realSet({\"low\":0, \"high\":33, \"rangeType\":1}, {\"low\":30, \"high\":31, \"rangeType\":0}, \"intersect\", [30, 31, 32])` should return `[true, true, false]`.",
          "testCode": "assert.deepEqual(\n  realSet(\n    { low: 0, high: 33, rangeType: 1 },\n    { low: 30, high: 31, rangeType: 0 },\n    'intersect',\n    [30, 31, 32]\n  ),\n  [true, true, false]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385322,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\set-of-real-numbers.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5eb3e4b5f629b9a07429a5d2",
      "title": "SHA-1",
      "challengeType": 1,
      "dashedName": "sha-1",
      "description": "**SHA-1** or **SHA1** is a one-way hash function; it computes a 160-bit message digest.\n\nSHA-1 often appears in security protocols; for example, many HTTPS websites use RSA with SHA-1 to secure their connections.\n\nBitTorrent uses SHA-1 to verify downloads.\n\nGit and Mercurial use SHA-1 digests to identify commits.\n\nA US government standard, <a href=\"https://rosettacode.org/wiki/SHA-1/FIPS-180-1\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">FIPS 180-1</a>, defines SHA-1.",
      "instructions": "Write a function that returns the SHA-1 message digest for a given string.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function SHA1(input) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function SHA1(input) {\n  var hexcase = 0;\n  var b64pad = '';\n  var chrsz = 8;\n\n  function hex_sha1(s) {\n    return binb2hex(core_sha1(str2binb(s), s.length * chrsz));\n  }\n\n  function core_sha1(x, len) {\n    x[len >> 5] |= 0x80 << (24 - (len % 32));\n    x[(((len + 64) >> 9) << 4) + 15] = len;\n\n    var w = Array(80);\n    var a = 1732584193;\n    var b = -271733879;\n    var c = -1732584194;\n    var d = 271733878;\n    var e = -1009589776;\n\n    for (var i = 0; i < x.length; i += 16) {\n      var olda = a;\n      var oldb = b;\n      var oldc = c;\n      var oldd = d;\n      var olde = e;\n\n      for (var j = 0; j < 80; j++) {\n        if (j < 16) w[j] = x[i + j];\n        else w[j] = rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);\n        var t = safe_add(\n          safe_add(rol(a, 5), sha1_ft(j, b, c, d)),\n          safe_add(safe_add(e, w[j]), sha1_kt(j))\n        );\n        e = d;\n        d = c;\n        c = rol(b, 30);\n        b = a;\n        a = t;\n      }\n\n      a = safe_add(a, olda);\n      b = safe_add(b, oldb);\n      c = safe_add(c, oldc);\n      d = safe_add(d, oldd);\n      e = safe_add(e, olde);\n    }\n    return Array(a, b, c, d, e);\n  }\n\n  function sha1_ft(t, b, c, d) {\n    if (t < 20) return (b & c) | (~b & d);\n    if (t < 40) return b ^ c ^ d;\n    if (t < 60) return (b & c) | (b & d) | (c & d);\n    return b ^ c ^ d;\n  }\n\n  function sha1_kt(t) {\n    return t < 20\n      ? 1518500249\n      : t < 40\n      ? 1859775393\n      : t < 60\n      ? -1894007588\n      : -899497514;\n  }\n\n  function safe_add(x, y) {\n    var lsw = (x & 0xffff) + (y & 0xffff);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xffff);\n  }\n\n  function rol(num, cnt) {\n    return (num << cnt) | (num >>> (32 - cnt));\n  }\n\n  function str2binb(str) {\n    var bin = Array();\n    var mask = (1 << chrsz) - 1;\n    for (var i = 0; i < str.length * chrsz; i += chrsz)\n      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << (24 - (i % 32));\n    return bin;\n  }\n\n  function binb2hex(binarray) {\n    var hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef';\n    var str = '';\n    for (var i = 0; i < binarray.length * 4; i++) {\n      str +=\n        hex_tab.charAt((binarray[i >> 2] >> ((3 - (i % 4)) * 8 + 4)) & 0xf) +\n        hex_tab.charAt((binarray[i >> 2] >> ((3 - (i % 4)) * 8)) & 0xf);\n    }\n    return str;\n  }\n\n  return hex_sha1(input);\n}"
        }
      ],
      "tests": [
        {
          "text": "`SHA1` should be a function.",
          "testCode": "assert(typeof SHA1 === 'function');"
        },
        {
          "text": "`SHA1(\"abc\")` should return a string.",
          "testCode": "assert(typeof SHA1('abc') === 'string');"
        },
        {
          "text": "`SHA1(\"abc\")` should return `\"a9993e364706816aba3e25717850c26c9cd0d89d\"`.",
          "testCode": "assert.equal(SHA1('abc'), 'a9993e364706816aba3e25717850c26c9cd0d89d');"
        },
        {
          "text": "`SHA1(\"Rosetta Code\")` should return `\"48c98f7e5a6e736d790ab740dfc3f51a61abe2b5\"`.",
          "testCode": "assert.equal(SHA1('Rosetta Code'), '48c98f7e5a6e736d790ab740dfc3f51a61abe2b5');"
        },
        {
          "text": "`SHA1(\"Hello world\")` should return `\"7b502c3a1f48c8609ae212cdfb639dee39673f5e\"`.",
          "testCode": "assert.equal(SHA1('Hello world'), '7b502c3a1f48c8609ae212cdfb639dee39673f5e');"
        },
        {
          "text": "`SHA1(\"Programming\")` should return `\"d1a946bf8b2f2a7292c250063ee28989d742cd4b\"`.",
          "testCode": "assert.equal(SHA1('Programming'), 'd1a946bf8b2f2a7292c250063ee28989d742cd4b');"
        },
        {
          "text": "`SHA1(\"is Awesome\")` should return `\"6537205da59c72b57ed3881843c2d24103d683a3\"`.",
          "testCode": "assert.equal(SHA1('is Awesome'), '6537205da59c72b57ed3881843c2d24103d683a3');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385326,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sha-1.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5eb3e4c3a894c333d2811a3f",
      "title": "SHA-256",
      "challengeType": 1,
      "dashedName": "sha-256",
      "description": "The `SHA-2` family is a stronger alternative to `SHA-1`. The main difference between them is the length of the hash.\nMeaning `SHA-1` provides a shorter code with fewer possibilities for unique combinations. `SHA-2` or `SHA-256` creates a longer and thus more complex hash with more possibilities.",
      "instructions": "Research implementation details and write a function that takes a string as the parameter and returns a hash using `SHA-256`",
      "boilerplate": [
        {
          "language": "js",
          "code": "function SHA256(input) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function SHA256(input) {\n  var chrsz = 8;\n  var hexcase = 0;\n\n  function safe_add(x, y) {\n    var lsw = (x & 0xffff) + (y & 0xffff);\n    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);\n    return (msw << 16) | (lsw & 0xffff);\n  }\n\n  function S(X, n) {\n    return (X >>> n) | (X << (32 - n));\n  }\n\n  function R(X, n) {\n    return X >>> n;\n  }\n\n  function Ch(x, y, z) {\n    return (x & y) ^ (~x & z);\n  }\n\n  function Maj(x, y, z) {\n    return (x & y) ^ (x & z) ^ (y & z);\n  }\n\n  function Sigma0256(x) {\n    return S(x, 2) ^ S(x, 13) ^ S(x, 22);\n  }\n\n  function Sigma1256(x) {\n    return S(x, 6) ^ S(x, 11) ^ S(x, 25);\n  }\n\n  function Gamma0256(x) {\n    return S(x, 7) ^ S(x, 18) ^ R(x, 3);\n  }\n\n  function Gamma1256(x) {\n    return S(x, 17) ^ S(x, 19) ^ R(x, 10);\n  }\n\n  function Sigma0512(x) {\n    return S(x, 28) ^ S(x, 34) ^ S(x, 39);\n  }\n\n  function Sigma1512(x) {\n    return S(x, 14) ^ S(x, 18) ^ S(x, 41);\n  }\n\n  function Gamma0512(x) {\n    return S(x, 1) ^ S(x, 8) ^ R(x, 7);\n  }\n\n  function Gamma1512(x) {\n    return S(x, 19) ^ S(x, 61) ^ R(x, 6);\n  }\n\n  function core_sha256(m, l) {\n    var K = new Array(\n      0x428a2f98,\n      0x71374491,\n      0xb5c0fbcf,\n      0xe9b5dba5,\n      0x3956c25b,\n      0x59f111f1,\n      0x923f82a4,\n      0xab1c5ed5,\n      0xd807aa98,\n      0x12835b01,\n      0x243185be,\n      0x550c7dc3,\n      0x72be5d74,\n      0x80deb1fe,\n      0x9bdc06a7,\n      0xc19bf174,\n      0xe49b69c1,\n      0xefbe4786,\n      0xfc19dc6,\n      0x240ca1cc,\n      0x2de92c6f,\n      0x4a7484aa,\n      0x5cb0a9dc,\n      0x76f988da,\n      0x983e5152,\n      0xa831c66d,\n      0xb00327c8,\n      0xbf597fc7,\n      0xc6e00bf3,\n      0xd5a79147,\n      0x6ca6351,\n      0x14292967,\n      0x27b70a85,\n      0x2e1b2138,\n      0x4d2c6dfc,\n      0x53380d13,\n      0x650a7354,\n      0x766a0abb,\n      0x81c2c92e,\n      0x92722c85,\n      0xa2bfe8a1,\n      0xa81a664b,\n      0xc24b8b70,\n      0xc76c51a3,\n      0xd192e819,\n      0xd6990624,\n      0xf40e3585,\n      0x106aa070,\n      0x19a4c116,\n      0x1e376c08,\n      0x2748774c,\n      0x34b0bcb5,\n      0x391c0cb3,\n      0x4ed8aa4a,\n      0x5b9cca4f,\n      0x682e6ff3,\n      0x748f82ee,\n      0x78a5636f,\n      0x84c87814,\n      0x8cc70208,\n      0x90befffa,\n      0xa4506ceb,\n      0xbef9a3f7,\n      0xc67178f2\n    );\n    var HASH = new Array(\n      0x6a09e667,\n      0xbb67ae85,\n      0x3c6ef372,\n      0xa54ff53a,\n      0x510e527f,\n      0x9b05688c,\n      0x1f83d9ab,\n      0x5be0cd19\n    );\n    var W = new Array(64);\n    var a, b, c, d, e, f, g, h, i, j;\n    var T1, T2;\n\n    m[l >> 5] |= 0x80 << (24 - (l % 32));\n    m[(((l + 64) >> 9) << 4) + 15] = l;\n\n    for (var i = 0; i < m.length; i += 16) {\n      a = HASH[0];\n      b = HASH[1];\n      c = HASH[2];\n      d = HASH[3];\n      e = HASH[4];\n      f = HASH[5];\n      g = HASH[6];\n      h = HASH[7];\n\n      for (var j = 0; j < 64; j++) {\n        if (j < 16) W[j] = m[j + i];\n        else\n          W[j] = safe_add(\n            safe_add(\n              safe_add(Gamma1256(W[j - 2]), W[j - 7]),\n              Gamma0256(W[j - 15])\n            ),\n            W[j - 16]\n          );\n\n        T1 = safe_add(\n          safe_add(safe_add(safe_add(h, Sigma1256(e)), Ch(e, f, g)), K[j]),\n          W[j]\n        );\n        T2 = safe_add(Sigma0256(a), Maj(a, b, c));\n\n        h = g;\n        g = f;\n        f = e;\n        e = safe_add(d, T1);\n        d = c;\n        c = b;\n        b = a;\n        a = safe_add(T1, T2);\n      }\n\n      HASH[0] = safe_add(a, HASH[0]);\n      HASH[1] = safe_add(b, HASH[1]);\n      HASH[2] = safe_add(c, HASH[2]);\n      HASH[3] = safe_add(d, HASH[3]);\n      HASH[4] = safe_add(e, HASH[4]);\n      HASH[5] = safe_add(f, HASH[5]);\n      HASH[6] = safe_add(g, HASH[6]);\n      HASH[7] = safe_add(h, HASH[7]);\n    }\n    return HASH;\n  }\n\n  function core_sha512(m, l) {\n    var K = new Array(\n      0x428a2f98d728ae22,\n      0x7137449123ef65cd,\n      0xb5c0fbcfec4d3b2f,\n      0xe9b5dba58189dbbc,\n      0x3956c25bf348b538,\n      0x59f111f1b605d019,\n      0x923f82a4af194f9b,\n      0xab1c5ed5da6d8118,\n      0xd807aa98a3030242,\n      0x12835b0145706fbe,\n      0x243185be4ee4b28c,\n      0x550c7dc3d5ffb4e2,\n      0x72be5d74f27b896f,\n      0x80deb1fe3b1696b1,\n      0x9bdc06a725c71235,\n      0xc19bf174cf692694,\n      0xe49b69c19ef14ad2,\n      0xefbe4786384f25e3,\n      0x0fc19dc68b8cd5b5,\n      0x240ca1cc77ac9c65,\n      0x2de92c6f592b0275,\n      0x4a7484aa6ea6e483,\n      0x5cb0a9dcbd41fbd4,\n      0x76f988da831153b5,\n      0x983e5152ee66dfab,\n      0xa831c66d2db43210,\n      0xb00327c898fb213f,\n      0xbf597fc7beef0ee4,\n      0xc6e00bf33da88fc2,\n      0xd5a79147930aa725,\n      0x06ca6351e003826f,\n      0x142929670a0e6e70,\n      0x27b70a8546d22ffc,\n      0x2e1b21385c26c926,\n      0x4d2c6dfc5ac42aed,\n      0x53380d139d95b3df,\n      0x650a73548baf63de,\n      0x766a0abb3c77b2a8,\n      0x81c2c92e47edaee6,\n      0x92722c851482353b,\n      0xa2bfe8a14cf10364,\n      0xa81a664bbc423001,\n      0xc24b8b70d0f89791,\n      0xc76c51a30654be30,\n      0xd192e819d6ef5218,\n      0xd69906245565a910,\n      0xf40e35855771202a,\n      0x106aa07032bbd1b8,\n      0x19a4c116b8d2d0c8,\n      0x1e376c085141ab53,\n      0x2748774cdf8eeb99,\n      0x34b0bcb5e19b48a8,\n      0x391c0cb3c5c95a63,\n      0x4ed8aa4ae3418acb,\n      0x5b9cca4f7763e373,\n      0x682e6ff3d6b2b8a3,\n      0x748f82ee5defb2fc,\n      0x78a5636f43172f60,\n      0x84c87814a1f0ab72,\n      0x8cc702081a6439ec,\n      0x90befffa23631e28,\n      0xa4506cebde82bde9,\n      0xbef9a3f7b2c67915,\n      0xc67178f2e372532b,\n      0xca273eceea26619c,\n      0xd186b8c721c0c207,\n      0xeada7dd6cde0eb1e,\n      0xf57d4f7fee6ed178,\n      0x06f067aa72176fba,\n      0x0a637dc5a2c898a6,\n      0x113f9804bef90dae,\n      0x1b710b35131c471b,\n      0x28db77f523047d84,\n      0x32caab7b40c72493,\n      0x3c9ebe0a15c9bebc,\n      0x431d67c49c100d4c,\n      0x4cc5d4becb3e42b6,\n      0x597f299cfc657e2a,\n      0x5fcb6fab3ad6faec,\n      0x6c44198c4a475817\n    );\n    var HASH = new Array(\n      0x6a09e667f3bcc908,\n      0xbb67ae8584caa73b,\n      0x3c6ef372fe94f82b,\n      0xa54ff53a5f1d36f1,\n      0x510e527fade682d1,\n      0x9b05688c2b3e6c1f,\n      0x1f83d9abfb41bd6b,\n      0x5be0cd19137e2179\n    );\n    var W = new Array(80);\n    var a, b, c, d, e, f, g, h, i, j;\n    var T1, T2;\n  }\n\n  function str2binb(str) {\n    var bin = Array();\n    var mask = (1 << chrsz) - 1;\n    for (var i = 0; i < str.length * chrsz; i += chrsz)\n      bin[i >> 5] |= (str.charCodeAt(i / chrsz) & mask) << (24 - (i % 32));\n    return bin;\n  }\n\n  function binb2str(bin) {\n    var str = '';\n    var mask = (1 << chrsz) - 1;\n    for (var i = 0; i < bin.length * 32; i += chrsz)\n      str += String.fromCharCode((bin[i >> 5] >>> (24 - (i % 32))) & mask);\n    return str;\n  }\n\n  function binb2hex(binarray) {\n    var hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef';\n    var str = '';\n    for (var i = 0; i < binarray.length * 4; i++) {\n      str +=\n        hex_tab.charAt((binarray[i >> 2] >> ((3 - (i % 4)) * 8 + 4)) & 0xf) +\n        hex_tab.charAt((binarray[i >> 2] >> ((3 - (i % 4)) * 8)) & 0xf);\n    }\n    return str;\n  }\n\n  function binb2b64(binarray) {\n    var tab =\n      'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n    var str = '';\n    for (var i = 0; i < binarray.length * 4; i += 3) {\n      var triplet =\n        (((binarray[i >> 2] >> (8 * (3 - (i % 4)))) & 0xff) << 16) |\n        (((binarray[(i + 1) >> 2] >> (8 * (3 - ((i + 1) % 4)))) & 0xff) << 8) |\n        ((binarray[(i + 2) >> 2] >> (8 * (3 - ((i + 2) % 4)))) & 0xff);\n      for (var j = 0; j < 4; j++) {\n        if (i * 8 + j * 6 > binarray.length * 32) str += '';\n        else str += tab.charAt((triplet >> (6 * (3 - j))) & 0x3f);\n      }\n    }\n    return str;\n  }\n\n  function hex_sha2(s) {\n    return binb2hex(core_sha256(str2binb(s), s.length * chrsz));\n  }\n\n  function b64_sha2(s) {\n    return binb2b64(core_sha256(str2binb(s), s.length * chrsz));\n  }\n\n  function str_sha2(s) {\n    return binb2str(core_sha256(str2binb(s), s.length * chrsz));\n  }\n  return hex_sha2(input);\n}"
        }
      ],
      "tests": [
        {
          "text": "`SHA256` should be a function.",
          "testCode": "assert(typeof SHA256 === 'function');"
        },
        {
          "text": "`SHA256(\"Rosetta code\")` should return a string.",
          "testCode": "assert(typeof SHA256('Rosetta code') === 'string');"
        },
        {
          "text": "`SHA256(\"Rosetta code\")` should return `\"764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf\"`.",
          "testCode": "assert.equal(\n  SHA256('Rosetta code'),\n  '764faf5c61ac315f1497f9dfa542713965b785e5cc2f707d6468d7d1124cdfcf'\n);"
        },
        {
          "text": "`SHA256(\"SHA-256 Hash\")` should return `\"bee8c0cabdcf8c7835f40217dd35a8b0dba9134520e633f1c57285f35ca7ee3e\"`.",
          "testCode": "assert.equal(\n  SHA256('SHA-256 Hash'),\n  'bee8c0cabdcf8c7835f40217dd35a8b0dba9134520e633f1c57285f35ca7ee3e'\n);"
        },
        {
          "text": "`SHA256(\"implementation\")` should return `\"da31012c40330e7e21538e7dd57503b16e8a0839159e96137090cccc9910b171\"`.",
          "testCode": "assert.equal(\n  SHA256('implementation'),\n  'da31012c40330e7e21538e7dd57503b16e8a0839159e96137090cccc9910b171'\n);"
        },
        {
          "text": "`SHA256(\"algorithm\")` should return `\"b1eb2ec8ac9f31ff7918231e67f96e6deda83a9ff33ed2c67443f1df81e5ed14\"`.",
          "testCode": "assert.equal(\n  SHA256('algorithm'),\n  'b1eb2ec8ac9f31ff7918231e67f96e6deda83a9ff33ed2c67443f1df81e5ed14'\n);"
        },
        {
          "text": "`SHA256(\"language\")` should return `\"a4ef304ba42a200bafd78b046e0869af9183f6eee5524aead5dcb3a5ab5f8f3f\"`.",
          "testCode": "assert.equal(\n  SHA256('language'),\n  'a4ef304ba42a200bafd78b046e0869af9183f6eee5524aead5dcb3a5ab5f8f3f'\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 385328,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sha-256.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc7ffe",
      "title": "Sort an array of composite structures",
      "challengeType": 1,
      "dashedName": "sort-an-array-of-composite-structures",
      "description": "Write a function that takes an array of objects as a parameter. The function should sort the array according to the 'key' attribute of the objects and return the sorted array.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sortByKey(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sortByKey (arr) {\n  return arr.sort(function(a, b) {\n    return a.key - b.key\n  });\n}"
        }
      ],
      "tests": [
        {
          "text": "`sortByKey` should be a function.",
          "testCode": "assert(typeof sortByKey == 'function');"
        },
        {
          "text": "`sortByKey([{key: 3, value: \"foo\"}, {key: 2, value: \"bar\"}, {key: 4, value: \"baz\"}, {key: 1, value: 42}, {key: 5, value: \"another string\"}])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    sortByKey([\n      { key: 3, value: 'foo' },\n      { key: 2, value: 'bar' },\n      { key: 4, value: 'baz' },\n      { key: 1, value: 42 },\n      { key: 5, value: 'another string' }\n    ])\n  )\n);"
        },
        {
          "text": "`sortByKey([{key: 3, value: \"foo\"}, {key: 2, value: \"bar\"}, {key: 4, value: \"baz\"}, {key: 1, value: 42}, {key: 5, value: \"another string\"}])` should return `[{key: 1, value: 42}, {key: 2, value: \"bar\"}, {key: 3, value: \"foo\"}, {key: 4, value: \"baz\"}, {key: 5, value: \"another string\"}]`.",
          "testCode": "assert.deepEqual(\n  sortByKey([\n    { key: 3, value: 'foo' },\n    { key: 2, value: 'bar' },\n    { key: 4, value: 'baz' },\n    { key: 1, value: 42 },\n    { key: 5, value: 'another string' }\n  ]),\n  [\n    { key: 1, value: 42 },\n    { key: 2, value: 'bar' },\n    { key: 3, value: 'foo' },\n    { key: 4, value: 'baz' },\n    { key: 5, value: 'another string' }\n  ]\n);"
        },
        {
          "text": "`sortByKey([{key: 3, name: \"Joe\"}, {key: 4, name: \"Bill\"}, {key: 20, name: \"Alice\"}, {key: 5, name: \"Harry\"}])` should return `[{key: 3, name: \"Joe\"}, {key: 4, name: \"Bill\"}, {key: 5, name: \"Harry\"}, {key: 20, name: \"Alice\"}]`.",
          "testCode": "assert.deepEqual(\n  sortByKey([\n    { key: 3, name: 'Joe' },\n    { key: 4, name: 'Bill' },\n    { key: 20, name: 'Alice' },\n    { key: 5, name: 'Harry' }\n  ]),\n  [\n    { key: 3, name: 'Joe' },\n    { key: 4, name: 'Bill' },\n    { key: 5, name: 'Harry' },\n    { key: 20, name: 'Alice' }\n  ]\n);"
        },
        {
          "text": "`sortByKey([{key: 2341, name: \"Adam\"}, {key: 122, name: \"Bernie\"}, {key: 19, name: \"David\"}, {key: 5531, name: \"Joe\"}, {key: 1234, name: \"Walter\"}])` should return `[{key: 19, name: \"David\"}, {key: 122, name: \"Bernie\"}, {key: 1234, name: \"Walter\"}, {key: 2341, name: \"Adam\"}, {key: 5531, name: \"Joe\"}]`.",
          "testCode": "assert.deepEqual(\n  sortByKey([\n    { key: 2341, name: 'Adam' },\n    { key: 122, name: 'Bernie' },\n    { key: 19, name: 'David' },\n    { key: 5531, name: 'Joe' },\n    { key: 1234, name: 'Walter' }\n  ]),\n  [\n    { key: 19, name: 'David' },\n    { key: 122, name: 'Bernie' },\n    { key: 1234, name: 'Walter' },\n    { key: 2341, name: 'Adam' },\n    { key: 5531, name: 'Joe' }\n  ]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302306,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sort-an-array-of-composite-structures.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8000",
      "title": "Sort disjoint sublist",
      "challengeType": 1,
      "dashedName": "sort-disjoint-sublist",
      "description": "Given a list of values and a set of integer indices into that value list, the task is to sort the values at the given indices, but preserving the values at indices outside the set of those to be sorted.\n\nMake your function work with the following list of values and set of indices:\n\n<code>values: [7, <b>6</b>, 5, 4, 3, 2, <b>1</b>, <b>0</b>]</code>\n\n```js\nindices(0-based): {6, 1, 7}\n```\n\nWhere the correct result would be:\n\n<code>[7, <b>0</b>, 5, 4, 3, 2, <b>1</b>, <b>6</b>]</code>.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sortDisjoint(values, indices) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sortDisjoint(values, indices) {\n  let sublist = [];\n\n  indices.sort(function(a, b) {\n    return a - b;\n  });\n\n  for (let i = 0; i < indices.length; i++) {\n    sublist.push(values[indices[i]]);\n  }\n\n  sublist.sort((a, b) => {\n    return a - b;\n  });\n\n  for (let i = 0; i < indices.length; i++) {\n    values[indices[i]] = sublist[i];\n  }\n\n  return values;\n}"
        }
      ],
      "tests": [
        {
          "text": "`sortDisjoint` should be a function.",
          "testCode": "assert(typeof sortDisjoint == 'function');"
        },
        {
          "text": "`sortDisjoint([7, 6, 5, 4, 3, 2, 1, 0], [6, 1, 7])` should return an array.",
          "testCode": "assert(Array.isArray(sortDisjoint([7, 6, 5, 4, 3, 2, 1, 0], [6, 1, 7])));"
        },
        {
          "text": "`sortDisjoint([7, 6, 5, 4, 3, 2, 1, 0], [6, 1, 7])` should return `[7, 0, 5, 4, 3, 2, 1, 6]`.",
          "testCode": "assert.deepEqual(sortDisjoint([7, 6, 5, 4, 3, 2, 1, 0], [6, 1, 7]), [\n  7,\n  0,\n  5,\n  4,\n  3,\n  2,\n  1,\n  6\n]);"
        },
        {
          "text": "`sortDisjoint([7, 6, 5, 4, 3, 2, 1, 0], [1, 2, 5, 6])` should return `[7, 1, 2, 4, 3, 5, 6, 0]`.",
          "testCode": "assert.deepEqual(sortDisjoint([7, 6, 5, 4, 3, 2, 1, 0], [1, 2, 5, 6]), [\n  7,\n  1,\n  2,\n  4,\n  3,\n  5,\n  6,\n  0\n]);"
        },
        {
          "text": "`sortDisjoint([8, 7, 6, 5, 4, 3, 2, 1], [6, 1, 7])` should return `[8, 1, 6, 5, 4, 3, 2, 7]`.",
          "testCode": "assert.deepEqual(sortDisjoint([8, 7, 6, 5, 4, 3, 2, 1], [6, 1, 7]), [\n  8,\n  1,\n  6,\n  5,\n  4,\n  3,\n  2,\n  7\n]);"
        },
        {
          "text": "`sortDisjoint([8, 7, 6, 5, 4, 3, 2, 1], [1, 3, 5, 6])` should return `[8, 2, 6, 3, 4, 5, 7, 1]`.",
          "testCode": "assert.deepEqual(sortDisjoint([8, 7, 6, 5, 4, 3, 2, 1], [1, 3, 5, 6]), [\n  8,\n  2,\n  6,\n  3,\n  4,\n  5,\n  7,\n  1\n]);"
        },
        {
          "text": "`sortDisjoint([6, 1, 7, 1, 3, 5, 6], [6, 1, 5, 4])` should return `[6, 1, 7, 1, 3, 5, 6]`.",
          "testCode": "assert.deepEqual(sortDisjoint([6, 1, 7, 1, 3, 5, 6], [6, 1, 5, 4]), [\n  6,\n  1,\n  7,\n  1,\n  3,\n  5,\n  6\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302307,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sort-disjoint-sublist.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8014",
      "title": "Sort stability",
      "challengeType": 1,
      "dashedName": "sort-stability",
      "description": "When sorting records in a table by a particular column or field, a <a href=\"https://www.freecodecamp.org/news/stability-in-sorting-algorithms-a-treatment-of-equality-fa3140a5a539/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">stable sort</a> will always retain the relative order of records that have the same key.\n\nFor example, in this table of countries and cities, a stable sort on the **second** column, the cities, would keep the US Birmingham above the UK Birmingham. (Although an unstable sort *might*, in this case, place the US Birmingham above the UK Birmingham, a stable sort routine would *guarantee* it).\n\n<pre>UK  London\nUS  New York\nUS  Birmingham\nUK  Birmingham\n</pre>\n\nSimilarly, stable sorting on just the first column would generate \"UK London\" as the first item and \"US Birmingham\" as the last item (since the order of the elements having the same first word – \"UK\" or \"US\" – would be maintained).",
      "instructions": "Write a function that takes a 2D array as a parameter. Each element has 2 elements similar to the above example. The function should sort the array as mentioned previously and return the sorted array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function stableSort(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function stableSort(arr) {\n  arr.sort(function(a, b) {\n    return a[1] < b[1] ? -1 : a[1] > b[1] ? 1 : 0;\n  });\n  return arr;\n}"
        }
      ],
      "tests": [
        {
          "text": "`stableSort` should be a function.",
          "testCode": "assert(typeof stableSort == 'function');"
        },
        {
          "text": "`stableSort([[\"UK\", \"London\"], [\"US\", \"New York\"], [\"US\", \"Birmingham\"], [\"UK\", \"Birmingham\"]])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    stableSort([\n      ['UK', 'London'],\n      ['US', 'New York'],\n      ['US', 'Birmingham'],\n      ['UK', 'Birmingham']\n    ])\n  )\n);"
        },
        {
          "text": "`stableSort([[\"UK\", \"London\"], [\"US\", \"New York\"], [\"US\", \"Birmingham\"], [\"UK\", \"Birmingham\"]])` should return `[[\"US\", \"Birmingham\"], [\"UK\", \"Birmingham\"], [\"UK\", \"London\"], [\"US\", \"New York\"]]`.",
          "testCode": "assert.deepEqual(\n  stableSort([\n    ['UK', 'London'],\n    ['US', 'New York'],\n    ['US', 'Birmingham'],\n    ['UK', 'Birmingham']\n  ]),\n  [\n    ['US', 'Birmingham'],\n    ['UK', 'Birmingham'],\n    ['UK', 'London'],\n    ['US', 'New York']\n  ]\n);"
        },
        {
          "text": "`stableSort([[2, 2], [1, 2], [1, 4], [1, 5]])` should return `[[2, 2], [1, 2], [1, 4], [1, 5]]`.",
          "testCode": "assert.deepEqual(\n  stableSort([\n    [2, 2],\n    [1, 2],\n    [1, 4],\n    [1, 5]\n  ]),\n  [\n    [2, 2],\n    [1, 2],\n    [1, 4],\n    [1, 5]\n  ]\n);"
        },
        {
          "text": "`stableSort([[11, 55], [12, 45], [11, 45], [32, 45]])` should return `[[12, 45], [11, 45], [32, 45], [11, 55]]`.",
          "testCode": "assert.deepEqual(\n  stableSort([\n    [11, 55],\n    [12, 45],\n    [11, 45],\n    [32, 45]\n  ]),\n  [\n    [12, 45],\n    [11, 45],\n    [32, 45],\n    [11, 55]\n  ]\n);"
        },
        {
          "text": "`stableSort([[10, 22], [1, 2], [1, 4], [1, 5], [10, 9]])` should return `[[1, 2], [1, 4], [1, 5], [10, 9], [10, 22]]`.",
          "testCode": "assert.deepEqual(\n  stableSort([\n    [10, 22],\n    [1, 2],\n    [1, 4],\n    [1, 5],\n    [10, 9]\n  ]),\n  [\n    [1, 2],\n    [1, 4],\n    [1, 5],\n    [10, 9],\n    [10, 22]\n  ]\n);"
        },
        {
          "text": "`stableSort([[55, 54], [12, 22], [31, 43], [31, 54], [10, 49]])` should return `[[12, 22], [31, 43], [10, 49], [55, 54], [31, 54]]`.",
          "testCode": "assert.deepEqual(\n  stableSort([\n    [55, 54],\n    [12, 22],\n    [31, 43],\n    [31, 54],\n    [10, 49]\n  ]),\n  [\n    [12, 22],\n    [31, 43],\n    [10, 49],\n    [55, 54],\n    [31, 54]\n  ]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302308,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sort-stability.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8016",
      "title": "Sort using a custom comparator",
      "challengeType": 1,
      "dashedName": "sort-using-a-custom-comparator",
      "description": "Write a function to sort an array (or list) of strings in order of descending length, and in ascending lexicographic order for strings of equal length.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function lengthSorter(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function lengthSorter(arr) {\n  arr.sort(function(a, b) {\n    var result = b.length - a.length;\n    if (result == 0) result = a.localeCompare(b);\n    return result;\n  });\n  return arr;\n}"
        }
      ],
      "tests": [
        {
          "text": "`lengthSorter` should be a function.",
          "testCode": "assert(typeof lengthSorter == 'function');"
        },
        {
          "text": "`lengthSorter([\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    lengthSorter([\n      'Here',\n      'are',\n      'some',\n      'sample',\n      'strings',\n      'to',\n      'be',\n      'sorted'\n    ])\n  )\n);"
        },
        {
          "text": "`lengthSorter([\"Here\", \"are\", \"some\", \"sample\", \"strings\", \"to\", \"be\", \"sorted\"])` should return `[\"strings\", \"sample\", \"sorted\", \"Here\", \"some\", \"are\", \"be\", \"to\"]`.",
          "testCode": "assert.deepEqual(\n  lengthSorter([\n    'Here',\n    'are',\n    'some',\n    'sample',\n    'strings',\n    'to',\n    'be',\n    'sorted'\n  ]),\n  ['strings', 'sample', 'sorted', 'Here', 'some', 'are', 'be', 'to']\n);"
        },
        {
          "text": "`lengthSorter([\"I\", \"hope\", \"your\", \"day\", \"is\", \"going\", \"good\", \"?\"])` should return `[\"going\", \"good\", \"hope\", \"your\", \"day\", \"is\", \"?\",\"I\"]`.",
          "testCode": "assert.deepEqual(\n  lengthSorter(['I', 'hope', 'your', 'day', 'is', 'going', 'good', '?']),\n  ['going', 'good', 'hope', 'your', 'day', 'is', '?', 'I']\n);"
        },
        {
          "text": "`lengthSorter([\"Mine\", \"is\", \"going\", \"great\"])` should return `[\"going\", \"great\", \"Mine\", \"is\"]`.",
          "testCode": "assert.deepEqual(lengthSorter(['Mine', 'is', 'going', 'great']), [\n  'going',\n  'great',\n  'Mine',\n  'is'\n]);"
        },
        {
          "text": "`lengthSorter([\"Have\", \"fun\", \"sorting\", \"!!\"])` should return `[\"sorting\", \"Have\", \"fun\", \"!!\"]`.",
          "testCode": "assert.deepEqual(lengthSorter(['Have', 'fun', 'sorting', '!!']), [\n  'sorting',\n  'Have',\n  'fun',\n  '!!'\n]);"
        },
        {
          "text": "`lengthSorter([\"Everything\", \"is\", \"good\", \"!!\"])` should return `[\"Everything\", \"good\", \"!!\", \"is\"]`.",
          "testCode": "assert.deepEqual(lengthSorter(['Everything', 'is', 'good', '!!']), [\n  'Everything',\n  'good',\n  '!!',\n  'is'\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302309,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sort-using-a-custom-comparator.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8001",
      "title": "Sorting algorithms/Bead sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmsbead-sort",
      "description": "A *bead sort* starts by creating a matrix of zeroes whose length is equal to the value of the largest element in the input array. The matrix is transformed by adding one to all elements between the zeroth index and the index indicated by the current element. This process is repeated, until you have filled the matrix.\n\nIterating over the matrix, summing the number of elements greater than zero, then decreasing the value of each element by one yields the sorted array.\n\n**Note:** Each element in the input array is unique.\n\nSort an array of positive integers using the Bead Sort Algorithm.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function beadSort(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function beadSort(arr) {\n  let max = 0;\n  for (let i = 0; i < arr.length; i++) if (arr[i] > max) max = arr[i];\n  const grid = new Array(arr.length);\n  for (let i = 0; i < grid.length; i++) {\n    grid[i] = new Array(max);\n  }\n  const levelcount = new Array(max);\n  levelcount.fill(0);\n  for (let i = 0; i < max; i++) {\n    levelcount[i] = 0;\n    for (let j = 0; j < arr.length; j++) grid[j][i] = '_';\n  }\n  for (let i = 0; i < arr.length; i++) {\n    let num = arr[i];\n    for (let j = 0; num > 0; j++) {\n      grid[levelcount[j]++][j] = '*';\n      num--;\n    }\n  }\n  const sorted = new Array(arr.length);\n  sorted.fill(0);\n  for (let i = 0; i < arr.length; i++) {\n    let putt = 0;\n    for (\n      let j = 0;\n      j < max &&\n      (function(c) {\n        return c.charCodeAt == null ? c : c.charCodeAt(0);\n      })(grid[arr.length - 1 - i][j]) == '*'.charCodeAt(0);\n      j++\n    )\n      putt++;\n    sorted[i] = putt;\n  }\n  return sorted;\n}"
        }
      ],
      "tests": [
        {
          "text": "`beadSort` should be a function.",
          "testCode": "assert(typeof beadSort == 'function');"
        },
        {
          "text": "`beadSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(beadSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`beadSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(beadSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`beadSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(beadSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`beadSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(beadSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`beadSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(beadSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`beadSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(beadSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302310,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-bead-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8002",
      "title": "Sorting algorithms/Bogosort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmsbogosort",
      "description": "Bogosort a list of numbers.\n\nBogosort simply shuffles a collection randomly until it is sorted.\n\n\"Bogosort\" is a perversely inefficient algorithm only used as an in-joke.\n\nIts average run-time is O(n!) because the chance that any given shuffle of a set will end up in sorted order is about one in *n* factorial, and the worst case is infinite since there's no guarantee that a random shuffling will ever produce a sorted sequence.\n\nIts best case is O(n) since a single pass through the elements may suffice to order them.\n\nPseudocode:\n\n<pre><b>while not</b> InOrder(list) <b>do</b>\n  Shuffle(list)\n<b>done</b>\n</pre>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function bogosort(v) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function bogosort(v) {\n  function shuffle(v) {\n    for (\n      var j, x, i = v.length;\n      i;\n      j = Math.floor(Math.random() * i), x = v[--i], v[i] = v[j], v[j] = x\n    );\n    return v;\n  }\n\n  function isSorted(v) {\n    for (var i = 1; i < v.length; i++) {\n      if (v[i - 1] > v[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  var sorted = false;\n  while (sorted == false) {\n    v = shuffle(v);\n    sorted = isSorted(v);\n  }\n  return v;\n}"
        }
      ],
      "tests": [
        {
          "text": "`bogosort` should be a function.",
          "testCode": "assert(typeof bogosort == 'function');"
        },
        {
          "text": "`bogosort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(bogosort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`bogosort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(bogosort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`bogosort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(bogosort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`bogosort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(bogosort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`bogosort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(bogosort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`bogosort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(bogosort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302311,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-bogosort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8004",
      "title": "Sorting algorithms/Cocktail sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmscocktail-sort",
      "description": "The <a href=\"https://rosettacode.org/wiki/Sorting_algorithms/Cocktail_sort\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">cocktail sort</a> is an improvement on the Bubble Sort. Given an array of numbers, the cocktail sort will traverse the array from start to finish, moving the largest number to the end. Then, it will traverse the array backwards and move the smallest number to the start. It repeats these two passes, moving the next largest/smallest number to its correct position in the array until it is sorted.",
      "instructions": "Write a function that sorts a given array using cocktail sort.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function cocktailSort(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function cocktailSort(arr) {\n  let isSorted = true;\n  while (isSorted) {\n    for (let i = 0; i < arr.length - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        let temp = arr[i];\n        arr[i] = arr[i + 1];\n        arr[i + 1] = temp;\n        isSorted = true;\n      }\n    }\n\n    if (!isSorted) break;\n\n    isSorted = false;\n\n    for (let j = arr.length - 1; j > 0; j--) {\n      if (arr[j - 1] > arr[j]) {\n        let temp = arr[j];\n        arr[j] = arr[j - 1];\n        arr[j - 1] = temp;\n        isSorted = true;\n      }\n    }\n  }\n\n  return arr;\n}"
        }
      ],
      "tests": [
        {
          "text": "`cocktailSort` should be a function.",
          "testCode": "assert(typeof cocktailSort == 'function');"
        },
        {
          "text": "`cocktailSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(cocktailSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`cocktailSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(cocktailSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`cocktailSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(cocktailSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`cocktailSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(cocktailSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`cocktailSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(cocktailSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`cocktailSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(cocktailSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302312,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-cocktail-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8005",
      "title": "Sorting algorithms/Comb sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmscomb-sort",
      "description": "Implement a *comb sort*.\n\nThe **Comb Sort** is a variant of the Bubble Sort.\n\nLike the Shell sort, the Comb Sort increases the gap used in comparisons and exchanges.\n\nDividing the gap by $(1-e^{-\\\\varphi})^{-1} \\\\approx 1.247330950103979$ works best, but 1.3 may be more practical.\n\nSome implementations use the insertion sort once the gap is less than a certain amount.\n\nVariants:\n\n<ul>\n  <li>Combsort11 makes sure the gap ends in (11, 8, 6, 4, 3, 2, 1), which is significantly faster than the other two possible endings.</li>\n  <li>Combsort with different endings changes to a more efficient sort when the data is almost sorted (when the gap is small). Comb sort with a low gap isn't much better than the Bubble Sort.</li>\n</ul>\n\nPseudocode:\n\n<pre><b>function</b> combsort(<b>array</b> input)\n  gap := input<b>.size</b> <i>//initialize gap size</i>\n  <b>loop until</b> gap = 1 <b>and</b> swaps = 0\n    <i>//update the gap value for a next comb. Below is an example</i>\n    gap := int(gap / 1.25)\n    <b>if</b> gap &#x3C; 1 \n      <i>//minimum gap is 1</i>\n      gap := 1\n    <b>end if</b>\n    i := 0\n    swaps := 0 <i>//see <a href='https://rosettacode.org/wiki/Sorting_algorithms/Bubble_sort' target='_blank'>Bubble Sort</a> for an explanation</i>\n    <i>//a single \"comb\" over the input list</i>\n    <b>loop until</b> i + gap >= input<b>.size</b> <i>//see <a href='https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort' target='_blank'>Shell sort</a> for similar idea</i>\n      <b>if</b> input[i] > input[i+gap]\n        <b>swap</b>(input[i], input[i+gap])\n        swaps := 1 <i>// Flag a swap has occurred, so the</i>\n            <i>// list is not guaranteed sorted</i>\n      <b>end if</b>\n      i := i + 1\n    <b>end loop</b>\n  <b>end loop</b>\n<b>end function</b>\n</pre>",
      "instructions": "Write a function that sorts a given array using Comb sort.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function combSort(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function combSort(arr) {\n  function is_array_sorted(arr) {\n    var sorted = true;\n    for (var i = 0; i < arr.length - 1; i++) {\n      if (arr[i] > arr[i + 1]) {\n        sorted = false;\n        break;\n      }\n    }\n    return sorted;\n  }\n  var iteration_count = 0;\n  var gap = arr.length - 2;\n  var decrease_factor = 1.25;\n\n  // Until array is not sorted, repeat iterations\n  while (!is_array_sorted(arr)) {\n    // If not first gap\n    if (iteration_count > 0)\n      // Calculate gap\n      gap = gap == 1 ? gap : Math.floor(gap / decrease_factor);\n\n    // Set front and back elements and increment to a gap\n    var front = 0;\n    var back = gap;\n    while (back <= arr.length - 1) {\n      // If elements are not ordered swap them\n      if (arr[front] > arr[back]) {\n        var temp = arr[front];\n        arr[front] = arr[back];\n        arr[back] = temp;\n      }\n\n      // Increment and re-run swapping\n      front += 1;\n      back += 1;\n    }\n    iteration_count += 1;\n  }\n\n  return arr;\n}"
        }
      ],
      "tests": [
        {
          "text": "`combSort` should be a function.",
          "testCode": "assert(typeof combSort == 'function');"
        },
        {
          "text": "`combSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(combSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`combSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(combSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`combSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(combSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`combSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(combSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`combSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(combSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`combSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(combSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302313,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-comb-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8007",
      "title": "Sorting algorithms/Gnome sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmsgnome-sort",
      "description": "Gnome sort is a sorting algorithm which is similar to <a href=\"https://rosettacode.org/wiki/Insertion_sort\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Insertion sort</a>, except that moving an element to its proper place is accomplished by a series of swaps, as in <a href=\"https://rosettacode.org/wiki/Bubble\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Bubble Sort</a>.\n\nThe pseudocode for the algorithm is:\n\n<pre><b>function</b> <i>gnomeSort</i>(a[0..size-1])\n  i := 1\n  j := 2\n  <b>while</b> i &#x3C; size <b>do</b>\n    <b>if</b> a[i-1] &#x3C;= a[i] <b>then</b>\n      <i>/// for descending sort, use >= for comparison</i>\n      i := j\n      j := j + 1\n    <b>else</b>\n      <b>swap</b> a[i-1] <b>and</b> a[i]\n      i := i - 1\n      <b>if</b> i = 0 <b>then</b>\n        i := j\n        j := j + 1\n      <b>endif</b>\n    <b>endif</b>\n  <b>done</b>\n</pre>",
      "instructions": "Write a function to implement the above pseudo code. The function should return the sorted array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function gnomeSort(a) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function gnomeSort(a) {\n  function moveBack(i) {\n    for (; i > 0 && a[i - 1] > a[i]; i--) {\n      var t = a[i];\n      a[i] = a[i - 1];\n      a[i - 1] = t;\n    }\n  }\n  for (var i = 1; i < a.length; i++) {\n    if (a[i - 1] > a[i]) moveBack(i);\n  }\n  return a;\n}"
        }
      ],
      "tests": [
        {
          "text": "`gnomeSort` should be a function.",
          "testCode": "assert(typeof gnomeSort == 'function');"
        },
        {
          "text": "`gnomeSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(gnomeSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`gnomeSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(gnomeSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`gnomeSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(gnomeSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`gnomeSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(gnomeSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`gnomeSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(gnomeSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`gnomeSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(gnomeSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302314,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-gnome-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc800b",
      "title": "Sorting algorithms/Pancake sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmspancake-sort",
      "description": "Write a function to sort an array of integers (of any convenient size) into ascending order using Pancake sorting. The function should return the sorted array.\n\nIn short, instead of individual elements being sorted, the only operation allowed is to \"flip\" one end of the list, like so:\n\n<pre>Before:\n<b>6 7 8 9</b> 2 5 3 4 1<br>\nAfter:\n<b>9 8 7 6</b> 2 5 3 4 1\n</pre>\n\nOnly one end of the list can be flipped; this should be the low end, but the high end is okay if it's easier to code or works better, but it **must** be the same end for the entire solution. (The end flipped can't be arbitrarily changed.)",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function pancakeSort(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function pancakeSort(arr) {\n  for (var i = arr.length - 1; i >= 1; i--) {\n    // find the index of the largest element not yet sorted\n    var max_idx = 0;\n    var max = arr[0];\n    for (var j = 1; j <= i; j++) {\n      if (arr[j] > max) {\n        max = arr[j];\n        max_idx = j;\n      }\n    }\n\n    if (max_idx == i) continue; // element already in place\n\n    var new_slice;\n\n    // flip arr max element to index 0\n    if (max_idx > 0) {\n      new_slice = arr.slice(0, max_idx + 1).reverse();\n      for (var j = 0; j <= max_idx; j++) arr[j] = new_slice[j];\n    }\n\n    // then flip the max element to its place\n    new_slice = arr.slice(0, i + 1).reverse();\n    for (var j = 0; j <= i; j++) arr[j] = new_slice[j];\n  }\n  return arr;\n}"
        }
      ],
      "tests": [
        {
          "text": "`pancakeSort` should be a function.",
          "testCode": "assert(typeof pancakeSort == 'function');"
        },
        {
          "text": "`pancakeSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(pancakeSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`pancakeSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(pancakeSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`pancakeSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(pancakeSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`pancakeSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(pancakeSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`pancakeSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(pancakeSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`pancakeSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(pancakeSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302315,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-pancake-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc800c",
      "title": "Sorting algorithms/Permutation sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmspermutation-sort",
      "description": "Write a function to implement a permutation sort, which proceeds by generating the possible permutations of the input array until discovering the sorted one. The function should return the sorted array.\n\nPseudocode:\n\n<pre><b>while not</b> InOrder(list) <b>do</b>\n  nextPermutation(list)\n<b>done</b>\n</pre>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function permutationSort(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function permutationSort(arr) {\n  function pSort(a) {\n    var list = [];\n    permute(a, a.length, list);\n    for (var i = 0; i < list.length; i++) {\n      var x = list[i];\n      if (isSorted(x)) return x;\n    }\n    return a;\n  }\n\n  function permute(a, n, list) {\n    if (n === 1) {\n      var b = a.slice();\n      list.push(b);\n      return;\n    }\n    for (var i = 0; i < n; i++) {\n      swap(a, i, n - 1);\n      permute(a, n - 1, list);\n      swap(a, i, n - 1);\n    }\n  }\n\n  function isSorted(a){\n    for(let i = 0; i < a.length - 1; i++)\n      if(a[i] > a[i + 1])\n        return false;\n    return true;\n  }\n\n  function swap(arr, i, j) {\n    var temp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = temp;\n  }\n  return pSort(arr);\n}"
        }
      ],
      "tests": [
        {
          "text": "`permutationSort` should be a function.",
          "testCode": "assert(typeof permutationSort == 'function');"
        },
        {
          "text": "`permutationSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(permutationSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`permutationSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(permutationSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`permutationSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(permutationSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`permutationSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(permutationSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`permutationSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(permutationSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`permutationSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(permutationSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302316,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-permutation-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8010",
      "title": "Sorting algorithms/Shell sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmsshell-sort",
      "description": "Write a function to sort an array of elements using the Shell sort algorithm, a diminishing increment sort. The function should return the sorted array.\n\nThe Shell sort (also known as Shellsort or Shell's method) is named after its inventor, Donald Shell, who published the algorithm in 1959.\n\nShell sort is a sequence of interleaved insertion sorts based on an increment sequence. The increment size is reduced after each pass until the increment size is 1.\n\nWith an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's \"best case\".\n\nAny sequence will sort the data as long as it ends in 1, but some work better than others.\n\nEmpirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function shellSort(a) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function shellSort(a) {\n  for (var h = a.length; h > 0; h = parseInt(h / 2)) {\n    for (var i = h; i < a.length; i++) {\n      var k = a[i];\n      for (var j = i; j >= h && k < a[j - h]; j -= h) a[j] = a[j - h];\n      a[j] = k;\n    }\n  }\n  return a;\n}"
        }
      ],
      "tests": [
        {
          "text": "`shellSort` should be a function.",
          "testCode": "assert(typeof shellSort == 'function');"
        },
        {
          "text": "`shellSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(shellSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`shellSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(shellSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`shellSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(shellSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`shellSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(shellSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`shellSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(shellSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`shellSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(shellSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302317,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-shell-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8012",
      "title": "Sorting algorithms/Stooge sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmsstooge-sort",
      "description": "Write a function to perform Stooge Sort on an array of integers. The function should return a sorted array.\n\nThe Stooge Sort algorithm is as follows:\n\n<pre><b>algorithm</b> stoogesort(<b>array</b> L, i = 0, j = <b>length</b>(L)-1)\n  <b>if</b> L[j] &#x3C; L[i] <b>then</b>\n    L[i] <b>↔</b> L[j]\n  <b>if</b> j - i > 1 <b>then</b>\n    t <b>:=</b> (j - i + 1)/3\n    stoogesort(L, i , j-t)\n    stoogesort(L, i+t, j )\n    stoogesort(L, i , j-t)\n  <b>return</b> L\n</pre>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function stoogeSort(arr) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function stoogeSort(arr) {\n  function stoogeSortRecurse(array, i, j) {\n    if (j === undefined) {\n      j = array.length - 1;\n    }\n\n    if (i === undefined) {\n      i = 0;\n    }\n\n    if (array[j] < array[i]) {\n      var aux = array[i];\n      array[i] = array[j];\n      array[j] = aux;\n    }\n\n    if (j - i > 1) {\n      var t = Math.floor((j - i + 1) / 3);\n      stoogeSortRecurse(array, i, j - t);\n      stoogeSortRecurse(array, i + t, j);\n      stoogeSortRecurse(array, i, j - t);\n    }\n  }\n  stoogeSortRecurse(arr);\n  return arr;\n}"
        }
      ],
      "tests": [
        {
          "text": "`stoogeSort` should be a function.",
          "testCode": "assert(typeof stoogeSort == 'function');"
        },
        {
          "text": "`stoogeSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(stoogeSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`stoogeSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(stoogeSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`stoogeSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(stoogeSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`stoogeSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(stoogeSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`stoogeSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(stoogeSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`stoogeSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(stoogeSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302318,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-stooge-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8013",
      "title": "Sorting algorithms/Strand sort",
      "challengeType": 1,
      "dashedName": "sorting-algorithmsstrand-sort",
      "description": "The **Strand sort** creates sorted subsets that are merged to create the final result. \n\nConsider an `unsortedArray = [3, 1, 4, 2]`. Pick the first item `3` and copy it into a separate array. Search for any bigger item following this item. When you find the a larger item, in this case `4`, copy it to the separate array, `[3, 4]`, and compare the following items to this new value, `4`.\n\nAfter you have reached the end of the array, remove the items you copied, `[3, 4]`, and start again with the first item remaining in the `unsortedArray`, in this case `1`.\n\nFollowing this process results in two sorted arrays, `[3, 4]` and `[1, 2]`. Merge these two arrays to create the `strandSortedArray`.\n\n```js\nconst unsortedArray = [3, 1, 4, 2];\nconst strandsortedArray = [1, 2, 3, 4];\n```\n\nWrite a function to sort an array using the **Strand sort**. The function should return the sorted array.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function strandSort(list) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function strandSort(list) {\n  function merge(left, right) {\n    var result = [];\n    while (left.length != 0 && right.length != 0) {\n      if (left[0] <= right[0]) result.push(left.shift());\n      else result.push(right.shift());\n    }\n    result.push.apply(result, left);\n    result.push.apply(result, right);\n    return result;\n  }\n\n  if (list.length <= 1) return list;\n  var result = [];\n  while (list.length > 0) {\n    var sorted = [];\n    sorted.push(list.shift());\n    var len = list.length;\n    for (var i = 1; i < len; i++) {\n      var elem = list[i];\n      if (sorted[i - 1] <= elem) {\n        sorted.push(elem);\n        sorted.splice(i, 1);\n      }\n    }\n\n    result = merge(result, sorted);\n  }\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`strandSort` should be a function.",
          "testCode": "assert(typeof strandSort == 'function');"
        },
        {
          "text": "`strandSort([25, 32, 12, 7, 20])` should return an array.",
          "testCode": "assert(Array.isArray(strandSort([25, 32, 12, 7, 20])));"
        },
        {
          "text": "`strandSort([25, 32, 12, 7, 20])` should return `[7, 12, 20, 25, 32]`.",
          "testCode": "assert.deepEqual(strandSort([25, 32, 12, 7, 20]), [7, 12, 20, 25, 32]);"
        },
        {
          "text": "`strandSort([38, 45, 35, 8, 13])` should return `[8, 13, 35, 38, 45]`.",
          "testCode": "assert.deepEqual(strandSort([38, 45, 35, 8, 13]), [8, 13, 35, 38, 45]);"
        },
        {
          "text": "`strandSort([43, 36, 20, 34, 24])` should return `[20, 24, 34, 36, 43]`.",
          "testCode": "assert.deepEqual(strandSort([43, 36, 20, 34, 24]), [20, 24, 34, 36, 43]);"
        },
        {
          "text": "`strandSort([12, 33, 26, 18, 1, 16, 38])` should return `[1, 12, 16, 18, 26, 33, 38]`.",
          "testCode": "assert.deepEqual(strandSort([12, 33, 26, 18, 1, 16, 38]), [\n  1,\n  12,\n  16,\n  18,\n  26,\n  33,\n  38\n]);"
        },
        {
          "text": "`strandSort([3, 39, 48, 16, 1, 4, 29])` should return `[1, 3, 4, 16, 29, 39, 48]`.",
          "testCode": "assert.deepEqual(strandSort([3, 39, 48, 16, 1, 4, 29]), [\n  1,\n  3,\n  4,\n  16,\n  29,\n  39,\n  48\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302319,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sorting-algorithms-strand-sort.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8017",
      "title": "Soundex",
      "challengeType": 1,
      "dashedName": "soundex",
      "description": "**Soundex Algorithm** deals with the *intentions* of the words. It creates a representation for similar sounding words. \n\nIt is used for searching <em>names</em> and <em>addresses</em>. This means that the person who filled in the <em>name</em>, can focus on how it sounds instead of correcting the spelling of <em>names</em>.\n\nFor example: \n\nIf you are hearing the name `Quenci` for the first time, and misspelled it, you will get **Soundex** code `Q520`. \n\nWhen you spell the name `Quincy` correctly next time, you will still get the same code `Q520`, which means you can link multiple name pronunciations into the same <em>person</em> without the need for adding every spelling. \n\nHere is the rules: \n\n<ul>\n  <li>If a vowel (A, E, I, O, U) separates two consonants that have the same soundex code, the consonant to the right of the vowel is coded. Tymczak is coded as T-522 (T, 5 for the M, 2 for the C, Z ignored (see \"Side-by-Side\" rule above), 2 for the K). Since the vowel \"A\" separates the Z and K, the K is coded.</li>\n  <li>If \"H\" or \"W\" separate two consonants that have the same soundex code, the consonant to the right of the vowel is not coded. Example: Ashcraft is coded A-261 (A, 2 for the S, C ignored, 6 for the R, 1 for the F). It is not coded A-226.</li>\n</ul>",
      "instructions": "Write a function that takes a string as a parameter and returns the encoded string.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function soundex(s) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function soundex(s) {\n  var a = s.toLowerCase().split('');\n  var f = a.shift(),\n    r = '',\n    codes = {\n      a: '',\n      e: '',\n      i: '',\n      o: '',\n      u: '',\n      b: 1,\n      f: 1,\n      p: 1,\n      v: 1,\n      c: 2,\n      g: 2,\n      j: 2,\n      k: 2,\n      q: 2,\n      s: 2,\n      x: 2,\n      z: 2,\n      d: 3,\n      t: 3,\n      l: 4,\n      m: 5,\n      n: 5,\n      r: 6\n    };\n  r =\n    f +\n    a\n      .map(function(v, i, a) {\n        return codes[v];\n      })\n      .filter(function(v, i, a) {\n        return i === 0 ? v !== codes[f] : v !== a[i - 1];\n      })\n      .join('');\n\n  return (r + '000').slice(0, 4).toUpperCase();\n}"
        }
      ],
      "tests": [
        {
          "text": "`soundex` should be a function.",
          "testCode": "assert(typeof soundex == 'function');"
        },
        {
          "text": "`soundex(\"Soundex\")` should return a string.",
          "testCode": "assert(typeof soundex('Soundex') == 'string');"
        },
        {
          "text": "`soundex(\"Soundex\")` should return `\"S532\"`.",
          "testCode": "assert.equal(soundex('Soundex'), 'S532');"
        },
        {
          "text": "`soundex(\"Example\")` should return `\"E251\"`.",
          "testCode": "assert.equal(soundex('Example'), 'E251');"
        },
        {
          "text": "`soundex(\"Sownteks\")` should return `\"S532\"`.",
          "testCode": "assert.equal(soundex('Sownteks'), 'S532');"
        },
        {
          "text": "`soundex(\"Ekzampul\")` should return `\"E251\"`.",
          "testCode": "assert.equal(soundex('Ekzampul'), 'E251');"
        },
        {
          "text": "`soundex(\"Euler\")` should return `\"E460\"`.",
          "testCode": "assert.equal(soundex('Euler'), 'E460');"
        },
        {
          "text": "`soundex(\"Gauss\")` should return `\"G200\"`.",
          "testCode": "assert.equal(soundex('Gauss'), 'G200');"
        },
        {
          "text": "`soundex(\"Hilbert\")` should return `\"H416\"`.",
          "testCode": "assert.equal(soundex('Hilbert'), 'H416');"
        },
        {
          "text": "`soundex(\"Knuth\")` should return `\"K530\"`.",
          "testCode": "assert.equal(soundex('Knuth'), 'K530');"
        },
        {
          "text": "`soundex(\"Lloyd\")` should return `\"L300\"`.",
          "testCode": "assert.equal(soundex('Lloyd'), 'L300');"
        },
        {
          "text": "`soundex(\"Lukasiewicz\")` should return `\"L222\"`.",
          "testCode": "assert.equal(soundex('Lukasiewicz'), 'L222');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302320,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\soundex.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc801c",
      "title": "Spiral matrix",
      "challengeType": 1,
      "dashedName": "spiral-matrix",
      "description": "Produce a spiral array. A *spiral array* is a square arrangement of the first N<sup>2</sup> natural numbers, where the numbers increase sequentially as you go around the edges of the array spiraling inwards. For example, given **5**, produce this array:\n\n<pre>\n0  1  2  3  4\n15 16 17 18 5\n14 23 24 19 6\n13 22 21 20 7\n12 11 10  9 8\n</pre>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function spiralArray(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function spiralArray(n) {\n  var arr = Array(n),\n    x = 0,\n    y = n,\n    total = n * n--,\n    dx = 1,\n    dy = 0,\n    i = 0,\n    j = 0;\n  while (y) arr[--y] = [];\n  while (i < total) {\n    arr[y][x] = i++;\n    x += dx;\n    y += dy;\n    if (++j == n) {\n      if (dy < 0) {\n        x++;\n        y++;\n        n -= 2;\n      }\n      j = dx;\n      dx = -dy;\n      dy = j;\n      j = 0;\n    }\n  }\n  return arr;\n}"
        }
      ],
      "tests": [
        {
          "text": "`spiralArray` should be a function.",
          "testCode": "assert(typeof spiralArray == 'function');"
        },
        {
          "text": "`spiralArray(3)` should return an array.",
          "testCode": "assert(Array.isArray(spiralArray(3)));"
        },
        {
          "text": "`spiralArray(3)` should return `[[0, 1, 2],[7, 8, 3],[6, 5, 4]]`.",
          "testCode": "assert.deepEqual(spiralArray(3), [\n  [0, 1, 2],\n  [7, 8, 3],\n  [6, 5, 4]\n]);"
        },
        {
          "text": "`spiralArray(4)` should return `[[0, 1, 2, 3],[11, 12, 13, 4],[10, 15, 14, 5],[9, 8, 7, 6]]`.",
          "testCode": "assert.deepEqual(spiralArray(4), [\n  [0, 1, 2, 3],\n  [11, 12, 13, 4],\n  [10, 15, 14, 5],\n  [9, 8, 7, 6]\n]);"
        },
        {
          "text": "`spiralArray(5)` should return `[[0, 1, 2, 3, 4],[15, 16, 17, 18, 5],[14, 23, 24, 19, 6],[13, 22, 21, 20, 7],[12, 11, 10, 9, 8]]`.",
          "testCode": "assert.deepEqual(spiralArray(5), [\n  [0, 1, 2, 3, 4],\n  [15, 16, 17, 18, 5],\n  [14, 23, 24, 19, 6],\n  [13, 22, 21, 20, 7],\n  [12, 11, 10, 9, 8]\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302321,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\spiral-matrix.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc801d",
      "title": "Split a character string based on change of character",
      "challengeType": 1,
      "dashedName": "split-a-character-string-based-on-change-of-character",
      "description": "Split a (character) string into comma (plus a blank) delimited strings based on a change of character (left to right). Blanks should be treated as any other character (except they are problematic to display clearly). The same applies to commas. For instance, the string:\n\n<pre>\n\"gHHH5YY++///\\\\\"\n</pre>\n\nshould be split as:\n\n<pre>\n[\"g\", \"HHH\", \"5\", \"YY\", \"++\", \"///\", \"\\\\\" ];\n</pre>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function split(str) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function split(str) {\n  const concat = xs =>\n    xs.length > 0\n      ? (() => {\n          const unit = typeof xs[0] === 'string' ? '' : [];\n          return unit.concat.apply(unit, xs);\n        })()\n      : [];\n\n  const group = xs => groupBy((a, b) => a === b, xs);\n\n  const groupBy = (f, xs) => {\n    const dct = xs.slice(1).reduce(\n      (a, x) => {\n        const h = a.active.length > 0 ? a.active[0] : undefined,\n          blnGroup = h !== undefined && f(h, x);\n        return {\n          active: blnGroup ? a.active.concat([x]) : [x],\n          sofar: blnGroup ? a.sofar : a.sofar.concat([a.active])\n        };\n      },\n      {\n        active: xs.length > 0 ? [xs[0]] : [],\n        sofar: []\n      }\n    );\n    return dct.sofar.concat(dct.active.length > 0 ? [dct.active] : []);\n  };\n\n  const map = (f, xs) => xs.map(f);\n\n  const stringChars = s => s.split('');\n\n  return map(concat, group(stringChars(str)));\n}"
        }
      ],
      "tests": [
        {
          "text": "`split` should be a function.",
          "testCode": "assert(typeof split == 'function');"
        },
        {
          "text": "`split(\"hello\")` should return an array.",
          "testCode": "assert(Array.isArray(split('hello')));"
        },
        {
          "text": "`split(\"hello\")` should return `[\"h\", \"e\", \"ll\", \"o\"]`.",
          "testCode": "assert.deepEqual(split('hello'), ['h', 'e', 'll', 'o']);"
        },
        {
          "text": "`split(\"commission\")` should return `[\"c\", \"o\", \"mm\", \"i\", \"ss\", \"i\", \"o\", \"n\"]`.",
          "testCode": "assert.deepEqual(split('commission'), [\n  'c',\n  'o',\n  'mm',\n  'i',\n  'ss',\n  'i',\n  'o',\n  'n'\n]);"
        },
        {
          "text": "`split(\"ssss----====llloooo\")` should return `[\"ssss\", \"----\", \"====\", \"lll\", \"oooo\"]`.",
          "testCode": "assert.deepEqual(split('ssss----====llloooo'), [\n  'ssss',\n  '----',\n  '====',\n  'lll',\n  'oooo'\n]);"
        },
        {
          "text": "`split(\"sssmmmaaammmaaat\")` should return `[\"sss\", \"mmm\", \"aaa\", \"mmm\", \"aaa\", \"t\"]`.",
          "testCode": "assert.deepEqual(split('sssmmmaaammmaaat'), [\n  'sss',\n  'mmm',\n  'aaa',\n  'mmm',\n  'aaa',\n  't'\n]);"
        },
        {
          "text": "`split(\"gHHH5YY++///\\\\\")` should return `[\"g\", \"HHH\", \"5\", \"YY\", \"++\", \"///\", \"\\\\\"]`.",
          "testCode": "assert.deepEqual(split('gHHH5YY++///\\\\'), [\n  'g',\n  'HHH',\n  '5',\n  'YY',\n  '++',\n  '///',\n  '\\\\'\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302322,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\split-a-character-string-based-on-change-of-character.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8024",
      "title": "State name puzzle",
      "challengeType": 1,
      "dashedName": "state-name-puzzle",
      "description": "**State name** is a <em>word puzzle</em> in which you take the letters from two U.S. state names and rearrange them to form the names of two different U.S. states.",
      "instructions": "Write a function to solve the challenge for a given array of actual U.S. state names, and for fictional state names.\n\nThe function should return an array. Each element should be an object in this form: `{\"from\":[],\"to\":[]}`. The `from` array should contain the original names and the `to` array should contain the resultant names.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function solve(input) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function solve(input) {\n  var orig = {};\n  input.forEach(function(e) {\n    orig[__helpers.removeWhiteSpace(e).toLowerCase()] = e;\n  });\n\n  input = Object.keys(orig);\n  var map = {};\n  for (var i = 0; i < input.length - 1; i++) {\n    var pair0 = input[i];\n    for (var j = i + 1; j < input.length; j++) {\n      var pair = [pair0, input[j]];\n      var s = pair0 + pair[1];\n      var key = s.split('').sort();\n\n      var val = map[key] ? map[key] : [];\n      val.push(pair);\n      map[key] = val;\n    }\n  }\n\n  var result = [];\n  Object.keys(map).forEach(key => {\n    for (var i = 0; i < map[key].length - 1; i++) {\n      var a = map[key][i];\n      for (var j = i + 1; j < map[key].length; j++) {\n        var b = map[key][j];\n\n        if (new Set([a[0], b[0], a[1], b[1]]).size < 4) continue;\n        var from = [orig[a[0]], orig[a[1]]].sort();\n        var to = [orig[b[0]], orig[b[1]]].sort();\n        result.push({\n          from,\n          to\n        });\n      }\n    }\n  });\n\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`solve` should be a function.",
          "testCode": "assert(typeof solve == 'function');"
        },
        {
          "text": "`solve([\"New Mexico\", \"New York\", \"North Carolina \", \"North Dakota\", \"Ohio\", \"Oklahoma\", \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\", \"South Dakota\"])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    solve([\n      'New Mexico',\n      'New York',\n      'North Carolina ',\n      'North Dakota',\n      'Ohio',\n      'Oklahoma',\n      'Oregon',\n      'Pennsylvania',\n      'Rhode Island',\n      'South Carolina',\n      'South Dakota'\n    ])\n  )\n);"
        },
        {
          "text": "`solve([\"New Mexico\", \"New York\", \"North Carolina \", \"North Dakota\", \"Ohio\", \"Oklahoma\", \"Oregon\", \"Pennsylvania\", \"Rhode Island\", \"South Carolina\", \"South Dakota\"])` should return `[{ from: [\"North Carolina \", \"South Dakota\"], to: [\"North Dakota\", \"South Carolina\"] }]`.",
          "testCode": "assert.deepEqual(\n  solve([\n    'New Mexico',\n    'New York',\n    'North Carolina ',\n    'North Dakota',\n    'Ohio',\n    'Oklahoma',\n    'Oregon',\n    'Pennsylvania',\n    'Rhode Island',\n    'South Carolina',\n    'South Dakota'\n  ]),\n  [\n    {\n      from: ['North Carolina ', 'South Dakota'],\n      to: ['North Dakota', 'South Carolina']\n    }\n  ]\n);"
        },
        {
          "text": "`solve([\"New York\", \"New Kory\", \"Wen Kory\", \"York New\", \"Kory New\", \"New Kory\"])` should return `[{ from: [\"New Kory\", \"New York\"], to: [\"Wen Kory\", \"York New\"] }, { from: [\"New Kory\", \"New York\"], to: [\"Kory New\", \"Wen Kory\"] }, { from: [\"New Kory\", \"New York\"], to: [\"Kory New\", \"York New\"] }, { from: [\"New York\", \"Wen Kory\"], to: [\"New Kory\", \"York New\"] }, { from: [\"New York\", \"Wen Kory\"], to: [\"Kory New\", \"New Kory\"] }, { from: [\"New York\", \"Wen Kory\"], to: [\"Kory New\", \"York New\"] }, { from: [\"New York\", \"York New\"], to: [\"New Kory\", \"Wen Kory\"] }, { from: [\"New York\", \"York New\"], to: [\"Kory New\", \"New Kory\"] }, { from: [\"New York\", \"York New\"], to: [\"Kory New\", \"Wen Kory\"] }, { from: [\"Kory New\", \"New York\"], to: [\"New Kory\", \"Wen Kory\"] }, { from: [\"Kory New\", \"New York\"], to: [\"New Kory\", \"York New\"] }, { from: [\"Kory New\", \"New York\"], to: [\"Wen Kory\", \"York New\"] }, { from: [\"New Kory\", \"Wen Kory\"], to: [\"Kory New\", \"York New\"] }, { from: [\"New Kory\", \"York New\"], to: [\"Kory New\", \"Wen Kory\"] }, { from: [\"Kory New\", \"New Kory\"], to: [\"Wen Kory\", \"York New\"] }]`.",
          "testCode": "assert.deepEqual(\n  solve([\n    'New York',\n    'New Kory',\n    'Wen Kory',\n    'York New',\n    'Kory New',\n    'New Kory'\n  ]),\n  [\n    { from: ['New Kory', 'New York'], to: ['Wen Kory', 'York New'] },\n    { from: ['New Kory', 'New York'], to: ['Kory New', 'Wen Kory'] },\n    { from: ['New Kory', 'New York'], to: ['Kory New', 'York New'] },\n    { from: ['New York', 'Wen Kory'], to: ['New Kory', 'York New'] },\n    { from: ['New York', 'Wen Kory'], to: ['Kory New', 'New Kory'] },\n    { from: ['New York', 'Wen Kory'], to: ['Kory New', 'York New'] },\n    { from: ['New York', 'York New'], to: ['New Kory', 'Wen Kory'] },\n    { from: ['New York', 'York New'], to: ['Kory New', 'New Kory'] },\n    { from: ['New York', 'York New'], to: ['Kory New', 'Wen Kory'] },\n    { from: ['Kory New', 'New York'], to: ['New Kory', 'Wen Kory'] },\n    { from: ['Kory New', 'New York'], to: ['New Kory', 'York New'] },\n    { from: ['Kory New', 'New York'], to: ['Wen Kory', 'York New'] },\n    { from: ['New Kory', 'Wen Kory'], to: ['Kory New', 'York New'] },\n    { from: ['New Kory', 'York New'], to: ['Kory New', 'Wen Kory'] },\n    { from: ['Kory New', 'New Kory'], to: ['Wen Kory', 'York New'] }\n  ]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302323,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\state-name-puzzle.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8028",
      "title": "Stern-Brocot sequence",
      "challengeType": 1,
      "dashedName": "stern-brocot-sequence",
      "description": "For this task, the Stern-Brocot sequence is to be generated by an algorithm similar to that employed in generating the <a href=\"https://rosettacode.org/wiki/Fibonacci_sequence\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">Fibonacci sequence</a>.\n\n<ol>\n  <li>The first and second members of the sequence are both 1:</li>\n    <ul><li>1, 1</li></ul>\n  <li>Start by considering the second member of the sequence</li>\n  <li>Sum the considered member of the sequence and its precedent, (1 + 1) = 2, and append it to the end of the\n    sequence:</li>\n    <ul><li>1, 1, 2</li></ul>\n  <li>Append the considered member of the sequence to the end of the sequence:</li>\n    <ul><li>1, 1, 2, 1</li></ul>\n  <li>Consider the next member of the series, (the third member i.e. 2)</li>\n  <li>GOTO 3 </li>\n    <ul>\n      <li></li>\n      <li> ─── Expanding another loop we get: ───</li>\n      <li></li>\n    </ul>\n  <li>Sum the considered member of the sequence and its precedent, (2 + 1) = 3, and append it to the end of the\n    sequence:</li>\n    <ul><li>1, 1, 2, 1, 3</li></ul>\n  <li>Append the considered member of the sequence to the end of the sequence:</li>\n    <ul><li>1, 1, 2, 1, 3, 2</li></ul>\n  <li>Consider the next member of the series, (the fourth member i.e. 1)</li>\n</ol>",
      "instructions": "Create a function that returns the position in the Stern-Brocot sequence at which $ n $ is first encountered, where the sequence is generated with the method outlined above. Note that this sequence uses 1 based indexing.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sternBrocot(num) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sternBrocot(num) {\n  function f(n) {\n    return n < 2\n      ? n\n      : n & 1\n      ? f(Math.floor(n / 2)) + f(Math.floor(n / 2 + 1))\n      : f(Math.floor(n / 2));\n  }\n\n  function gcd(a, b) {\n    return a ? (a < b ? gcd(b % a, a) : gcd(a % b, b)) : b;\n  }\n  var n;\n  for (n = 1; f(n) != num; n++);\n  return n;\n}"
        }
      ],
      "tests": [
        {
          "text": "`sternBrocot` should be a function.",
          "testCode": "assert(typeof sternBrocot == 'function');"
        },
        {
          "text": "`sternBrocot(2)` should return a number.",
          "testCode": "assert(typeof sternBrocot(2) == 'number');"
        },
        {
          "text": "`sternBrocot(2)` should return `3`.",
          "testCode": "assert.equal(sternBrocot(2), 3);"
        },
        {
          "text": "`sternBrocot(3)` should return `5`.",
          "testCode": "assert.equal(sternBrocot(3), 5);"
        },
        {
          "text": "`sternBrocot(5)` should return `11`.",
          "testCode": "assert.equal(sternBrocot(5), 11);"
        },
        {
          "text": "`sternBrocot(7)` should return `19`.",
          "testCode": "assert.equal(sternBrocot(7), 19);"
        },
        {
          "text": "`sternBrocot(10)` should return `39`.",
          "testCode": "assert.equal(sternBrocot(10), 39);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302324,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\stern-brocot-sequence.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8029",
      "title": "Straddling checkerboard",
      "challengeType": 1,
      "dashedName": "straddling-checkerboard",
      "description": "Implement functions to encrypt and decrypt a message using the **straddling checkerboard** method.\n\nEach function will take two arguments, a `message` string and an `alphabet` array. The `alphabet` array will contain 3 strings representing the 3 rows of the straddling checkerboard.\n\nThe output of the `straddle()` function should be a series of decimal digits. Numbers should be encrypted by inserting the escape character before each digit, then including the digit <em>unencrypted</em>.\n\nThis should be reversed for decryption with the `unstraddle()` function.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function straddle(message, alphabet) {\n\n}\n\nfunction unstraddle(message, alphabet) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function straddle(message, alphabet) {\n  var prefixes = new Array(\n    '',\n    alphabet[0].indexOf(' '),\n    alphabet[0].lastIndexOf(' ')\n  );\n\n  var out = '';\n  message = message.toUpperCase();\n  message = message.replace(/([0-9])/g, '/$1'); // dumb way to escape numbers\n  for (var i = 0; i < message.length; i++) {\n    var chr = message[i];\n    if (chr == ' ') continue;\n    for (var j = 0; j < 3; j++) {\n      var k = alphabet[j].indexOf(chr);\n      if (k < 0) continue;\n      out += prefixes[j].toString() + k;\n    }\n    if (chr == '/') out += message[++i];\n  }\n  return out;\n}\nfunction unstraddle(message, alphabet) {\n  var prefixes = new Array(\n    '',\n    alphabet[0].indexOf(' '),\n    alphabet[0].lastIndexOf(' ')\n  );\n  var out = '';\n  var n, o;\n  for (var i = 0; i < message.length; i++) {\n    n = message[i] * 1;\n    switch (n) {\n      case prefixes[1]:\n        o = alphabet[1][message[++i]];\n        break;\n      case prefixes[2]:\n        o = alphabet[2][message[++i]];\n        break;\n      default:\n        o = alphabet[0][n];\n    }\n    o == '/' ? (out += message[++i]) : (out += o);\n  }\n  return out;\n}"
        }
      ],
      "tests": [
        {
          "text": "`straddle` should be a function.",
          "testCode": "assert(typeof straddle == 'function');"
        },
        {
          "text": "`straddle(\"One night-it was on the twentieth of March, 1888-I was returning.\",[\"ESTONIA  R\", \"BCDFGHJKLM\", \"PQUVWXYZ./\"])` should return a string.",
          "testCode": "assert(\n  typeof straddle(\n    'One night-it was on the twentieth of March, 1888-I was returning.',\n    ['ESTONIA  R', 'BCDFGHJKLM', 'PQUVWXYZ./']\n  ) == 'string'\n);"
        },
        {
          "text": "`straddle(\"One night-it was on the twentieth of March, 1888-I was returning.\",[\"ESTONIA  R\", \"BCDFGHJKLM\", \"PQUVWXYZ./\"])` should return `\"34045747525284613427502840425027537379697175891898898898584619028294547488\"`.",
          "testCode": "assert.equal(\n  straddle(\n    'One night-it was on the twentieth of March, 1888-I was returning.',\n    ['ESTONIA  R', 'BCDFGHJKLM', 'PQUVWXYZ./']\n  ),\n  '34045747525284613427502840425027537379697175891898898898584619028294547488'\n);"
        },
        {
          "text": "`straddle(\"One night-it was on the twentieth of March, 1888-I was returning\",[\"HOL MES RT\", \"ABCDFGIJKN\", \"PQUVWXYZ./\"])` should return `\"139539363509369743061399059745399365901344308320791798798798367430685972839363935\"`.",
          "testCode": "assert.equal(\n  straddle('One night-it was on the twentieth of March, 1888-I was returning', [\n    'HOL MES RT',\n    'ABCDFGIJKN',\n    'PQUVWXYZ./'\n  ]),\n  '139539363509369743061399059745399365901344308320791798798798367430685972839363935'\n);"
        },
        {
          "text": "`straddle(\"Thecheckerboardcakerecipespecifies3largeeggsand2.25cupsofflour.\",[\"ET AON RIS\", \"BCDFGHJKLM\", \"PQ/UVWXYZ.\"])` should return `\"125021250212707204372221327070218600960021823809623283724002424935226226962262521636094232328463769\"`.",
          "testCode": "assert.equal(\n  straddle('Thecheckerboardcakerecipespecifies3largeeggsand2.25cupsofflour.', [\n    'ET AON RIS',\n    'BCDFGHJKLM',\n    'PQ/UVWXYZ.'\n  ]),\n  '125021250212707204372221327070218600960021823809623283724002424935226226962262521636094232328463769'\n);"
        },
        {
          "text": "`unstraddle` should be a function.",
          "testCode": "assert(typeof unstraddle == 'function');"
        },
        {
          "text": "`unstraddle(\"34045747525284613427502840425027537379697175891898898898584619028294547488\",[\"ESTONIA  R\", \"BCDFGHJKLM\", \"PQUVWXYZ./\"])` should return a string.",
          "testCode": "assert(\n  typeof unstraddle(\n    '34045747525284613427502840425027537379697175891898898898584619028294547488',\n    ['ESTONIA  R', 'BCDFGHJKLM', 'PQUVWXYZ./']\n  ) == 'string'\n);"
        },
        {
          "text": "`unstraddle(\"34045747525284613427502840425027537379697175891898898898584619028294547488\",[\"ESTONIA  R\", \"BCDFGHJKLM\", \"PQUVWXYZ./\"])` should return `\"ONENIGHTITWASONTHETWENTIETHOFMARCH1888IWASRETURNING.\"`.",
          "testCode": "assert.equal(\n  unstraddle(\n    '34045747525284613427502840425027537379697175891898898898584619028294547488',\n    ['ESTONIA  R', 'BCDFGHJKLM', 'PQUVWXYZ./']\n  ),\n  'ONENIGHTITWASONTHETWENTIETHOFMARCH1888IWASRETURNING.'\n);"
        },
        {
          "text": "`unstraddle(\"139539363509369743061399059745399365901344308320791798798798367430685972839363935\",[\"HOL MES RT\", \"ABCDFGIJKN\", \"PQUVWXYZ./\"])` should return `\"ONENIGHTITWASONTHETWENTIETHOFMARCH1888IWASRETURNING\"`.",
          "testCode": "assert.equal(\n  unstraddle(\n    '139539363509369743061399059745399365901344308320791798798798367430685972839363935',\n    ['HOL MES RT', 'ABCDFGIJKN', 'PQUVWXYZ./']\n  ),\n  'ONENIGHTITWASONTHETWENTIETHOFMARCH1888IWASRETURNING'\n);"
        },
        {
          "text": "`unstraddle(\"125021250212707204372221327070218600960021823809623283724002424935226226962262521636094232328463769\",[\"ET AON RIS\", \"BCDFGHJKLM\", \"PQ/UVWXYZ.\"])` should return `\"THECHECKERBOARDCAKERECIPESPECIFIES3LARGEEGGSAND2.25CUPSOFFLOUR.\"`.",
          "testCode": "assert.equal(\n  unstraddle(\n    '125021250212707204372221327070218600960021823809623283724002424935226226962262521636094232328463769',\n    ['ET AON RIS', 'BCDFGHJKLM', 'PQ/UVWXYZ.']\n  ),\n  'THECHECKERBOARDCAKERECIPESPECIFIES3LARGEEGGSAND2.25CUPSOFFLOUR.'\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302325,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\straddling-checkerboard.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc802a",
      "title": "Stream Merge",
      "challengeType": 1,
      "dashedName": "stream-merge",
      "description": "Write a function that takes multiple sorted arrays of items, and returns one array of sorted items.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function mergeLists(lists) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function mergeLists(lists) {\n  function merge(l1, l2) {\n    var result = [],\n      i = 0,\n      j = 0;\n    while (l1.length && l2.length) {\n      if (l1[i] <= l2[j]) {\n        result.push(l1.shift());\n      } else {\n        result.push(l2.shift());\n      }\n    }\n\n    result.push.apply(result, l1);\n    result.push.apply(result, l2);\n    return result;\n  }\n\n  var result = lists[0];\n  for (var i = 1; i < lists.length; i++) {\n    result = merge(result, lists[i]);\n  }\n\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`mergeLists` should be a function.",
          "testCode": "assert(typeof mergeLists == 'function');"
        },
        {
          "text": "`mergeLists([[1, 3, 5, 9, 10], [2, 4, 6, 7, 8]])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    mergeLists([\n      [1, 3, 5, 9, 10],\n      [2, 4, 6, 7, 8]\n    ])\n  )\n);"
        },
        {
          "text": "`mergeLists([[1, 3, 5, 9, 10], [2, 4, 6, 7, 8]])` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10]`.",
          "testCode": "assert.deepEqual(\n  mergeLists([\n    [1, 3, 5, 9, 10],\n    [2, 4, 6, 7, 8]\n  ]),\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n);"
        },
        {
          "text": "`mergeLists([[1, 4, 7, 10], [2, 5, 8, 11], [3, 6, 9, 12]])` should return `[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]`.",
          "testCode": "assert.deepEqual(\n  mergeLists([\n    [1, 4, 7, 10],\n    [2, 5, 8, 11],\n    [3, 6, 9, 12]\n  ]),\n  [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\n);"
        },
        {
          "text": "`mergeLists([[1, 3, 9, 14, 15, 17, 28], [7, 8, 14, 14, 23, 26, 28, 29, 30], [9, 23, 25, 29]])` should return `[1, 3, 7, 8, 9, 9, 14, 14, 14, 15, 17, 23, 23, 25, 26, 28, 28, 29, 29, 30]`.",
          "testCode": "assert.deepEqual(\n  mergeLists([\n    [1, 3, 9, 14, 15, 17, 28],\n    [7, 8, 14, 14, 23, 26, 28, 29, 30],\n    [9, 23, 25, 29]\n  ]),\n  [1, 3, 7, 8, 9, 9, 14, 14, 14, 15, 17, 23, 23, 25, 26, 28, 28, 29, 29, 30]\n);"
        },
        {
          "text": "`mergeLists([[3, 14, 15], [2, 17, 18], [], [2, 3, 5, 7]])` should return `[2, 2, 3, 3, 5, 7, 14, 15, 17, 18]`.",
          "testCode": "assert.deepEqual(mergeLists([[3, 14, 15], [2, 17, 18], [], [2, 3, 5, 7]]), [\n  2,\n  2,\n  3,\n  3,\n  5,\n  7,\n  14,\n  15,\n  17,\n  18\n]);"
        },
        {
          "text": "`mergeLists([[1, 19, 1999], [17, 33, 2999, 3000], [8, 500, 3999]])` should return `[1, 8, 17, 19, 33, 500, 1999, 2999, 3000, 3999]`.",
          "testCode": "assert.deepEqual(\n  mergeLists([\n    [1, 19, 1999],\n    [17, 33, 2999, 3000],\n    [8, 500, 3999]\n  ]),\n  [1, 8, 17, 19, 33, 500, 1999, 2999, 3000, 3999]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302326,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\stream-merge.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8036",
      "title": "Strip control codes and extended characters from a string",
      "challengeType": 1,
      "dashedName": "strip-control-codes-and-extended-characters-from-a-string",
      "description": "The task is to strip control codes and extended characters from a string. The solution should demonstrate how to achieve each of the following results: A string with control codes and extended characters stripped. In ASCII, the control codes have decimal codes 0 through to 31 and 127. On an ASCII based system, if the control codes are stripped, the resultant string would have all of its characters within the range of 32 to 126 decimal on the ASCII table. On a non-ASCII based system, we consider characters that do not have a corresponding glyph on the ASCII table (within the ASCII range of 32 to 126 decimal) to be an extended character for the purpose of this task.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function strip(s) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function strip(s) {\n  return s\n    .split('')\n    .filter(function(x) {\n      var n = x.charCodeAt(0);\n\n      return 31 < n && 127 > n;\n    })\n    .join('');\n}"
        }
      ],
      "tests": [
        {
          "text": "`strip` should be a function.",
          "testCode": "assert(typeof strip == 'function');"
        },
        {
          "text": "`strip(\"abc\")` should return a string.",
          "testCode": "assert(typeof strip('abc') == 'string');"
        },
        {
          "text": "`strip(\"\\ba\\x00b\\n\\rc\\fd\\xc3\")` should return `\"abcd\"`.",
          "testCode": "assert.equal(strip('\\ba\\x00b\\n\\rc\\fd\\xc3'), 'abcd');"
        },
        {
          "text": "`strip(\"\\u0000\\n abc\\u00E9def\\u007F\")` should return `\" abcdef\"`.",
          "testCode": "assert.equal(strip('\\u0000\\n abc\\u00E9def\\u007F'), ' abcdef');"
        },
        {
          "text": "`strip(\"a\\n\\tb\\u2102d\\u2147f\")` should return `\"abdf\"`.",
          "testCode": "assert.equal(strip('a\\n\\tb\\u2102d\\u2147f'), 'abdf');"
        },
        {
          "text": "`strip(\"Français.\")` should return `\"Franais.\"`.",
          "testCode": "assert.equal(strip('Français.'), 'Franais.');"
        },
        {
          "text": "`strip(\"123\\tabc\\u0007DEF\\u007F+-*/€æŧðłþ\")` should return `\"123abcDEF+-*/\"`.",
          "testCode": "assert.equal(strip('123\\tabc\\u0007DEF\\u007F+-*/€æŧðłþ'), '123abcDEF+-*/');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302327,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\strip-control-codes-and-extended-characters-from-a-string.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8038",
      "title": "Subleq",
      "challengeType": 1,
      "dashedName": "subleq",
      "description": "Subleq is an example of a One-Instruction Set Computer (OISC).\n\nIt is named after its only instruction, which is **SU**btract and **B**ranch if **L**ess than or **EQ**ual to zero.\n\nYour task is to create an interpreter which emulates such a machine.\n\nThe machine's memory consists of an array of signed integers. Any reasonable word size is fine, but the memory must be able to hold negative as well as positive numbers.\n\nExecution begins with the instruction pointer aimed at the first word, which is address 0. It proceeds as follows:\n\n<ol>\n  <li>Let A, B, and C be the value stored in the three consecutive words in memory starting at the instruction pointer.</li>\n  <li>Advance the instruction pointer 3 words to point at the address after the one containing C.</li>\n  <li>If A is -1, then a character is read from standard input and its code point stored in the address given by B. C is unused.</li>\n  <li>If B is -1, then the number contained in the address given by A is interpreted as a code point and the corresponding character output. C is again unused.</li>\n  <li>Otherwise, both A and B are treated as the addresses of memory locations. The number contained in the address given by A is subtracted from the number at the address given by B (and the result stored back in address B). If the result is zero or negative, the value C becomes the new instruction pointer.</li>\n  <li>If the instruction pointer becomes negative, execution halts.</li>\n</ol>\n\nOther negative addresses besides -1 may be treated as equivalent to -1, or generate an error, as you see fit.\n\nYour solution should accept a program to execute on the machine, separately from the input fed to the program itself.\n\nThis program should be in raw subleq \"machine code\" - whitespace-separated decimal numbers, with no symbolic names or other assembly-level extensions, to be loaded into memory starting at address 0. Show the output of your solution when fed this \"Hello, world!\" program. (Note that the example assumes ASCII or a superset of it, such as any of the Latin-N character sets or Unicode. You may translate it into another character set if your implementation is on a non-ASCiI-compatible environment.)\n\n<pre>15 17 -1 17 -1 -1 16 1 -1 16 3 -1 15 15 0 0 -1 72 101 108 108 111 44 32 119 111 114 108 100 33 10 0</pre>\n\nWhich corresponds to something like this in a hypothetical assembler language:\n\n<pre>start:\n    zero, message, -1\n    message, -1, -1\n    neg1, start+1, -1\n    neg1, start+3, -1\n    zero, zero, start\nzero: 0\nneg1: -1\nmessage: \"Hello, world!\\n\\0\"\n</pre>",
      "instructions": "Write a function that takes an array of integers as a parameter. This represents the memory elements. The function should interpret the sequence and return the output string. For this task, assume that there is no standard input.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function Subleq(mem) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function Subleq(mem) {\n  var out = '';\n  var instructionPointer = 0;\n  do {\n    var a = mem[instructionPointer];\n    var b = mem[instructionPointer + 1];\n    if (a === -1) {\n    } else if (b === -1) {\n      out += String.fromCharCode(mem[a]);\n    } else {\n      mem[b] -= mem[a];\n      if (mem[b] < 1) {\n        instructionPointer = mem[instructionPointer + 2];\n        continue;\n      }\n    }\n    instructionPointer += 3;\n  } while (instructionPointer >= 0);\n\n  return out;\n}"
        }
      ],
      "tests": [
        {
          "text": "`Subleq` should be a function.",
          "testCode": "assert(typeof Subleq == 'function');"
        },
        {
          "text": "`Subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 0])` should return a string.",
          "testCode": "assert(\n  typeof Subleq([\n    15,\n    17,\n    -1,\n    17,\n    -1,\n    -1,\n    16,\n    1,\n    -1,\n    16,\n    3,\n    -1,\n    15,\n    15,\n    0,\n    0,\n    -1,\n    72,\n    101,\n    108,\n    108,\n    111,\n    44,\n    32,\n    119,\n    111,\n    114,\n    108,\n    100,\n    33,\n    0\n  ]) == 'string'\n);"
        },
        {
          "text": "`Subleq([15, 17, -1, 17, -1, -1, 16, 1, -1, 16, 3, -1, 15, 15, 0, 0, -1, 72, 101, 108, 108, 111, 44, 32, 119, 111, 114, 108, 100, 33, 0])` should return `\"Hello, world!\"`.",
          "testCode": "assert.equal(\n  Subleq([\n    15,\n    17,\n    -1,\n    17,\n    -1,\n    -1,\n    16,\n    1,\n    -1,\n    16,\n    3,\n    -1,\n    15,\n    15,\n    0,\n    0,\n    -1,\n    72,\n    101,\n    108,\n    108,\n    111,\n    44,\n    32,\n    119,\n    111,\n    114,\n    108,\n    100,\n    33,\n    0\n  ]),\n  'Hello, world!'\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302328,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\subleq.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc803c",
      "title": "Sudoku",
      "challengeType": 1,
      "dashedName": "sudoku",
      "description": "Write a function to solve a partially filled-in normal 9x9 Sudoku grid and return the result. The blank fields are represented by `-1`.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function solveSudoku(puzzle) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function solveSudoku(puzzle) {\n  var solution;\n\n  class DoX {\n    constructor(V, H) {\n      this.V = V;\n      this.L = this;\n      this.R = this;\n      this.U = this;\n      this.D = this;\n      this.S = 1;\n      this.H = H || this;\n      H && (H.S += 1);\n    }\n  }\n\n  const addRight = (e, n) => {\n    n.R = e.R;\n    n.L = e;\n    e.R.L = n;\n    return (e.R = n);\n  };\n\n  const addBelow = (e, n) => {\n    n.D = e.D;\n    n.U = e;\n    e.D.U = n;\n    return (e.D = n);\n  };\n\n  const search = function(h, s) {\n    if (h.R == h) {\n      printSol(s);\n    } else {\n      let c = chooseColumn(h);\n      cover(c);\n      for (let r = c.D; r != c; r = r.D) {\n        s.push(r);\n        for (let j = r.R; r != j; j = j.R) {\n          cover(j.H);\n        }\n        search(h, s);\n        r = s.pop();\n        for (let j = r.R; j != r; j = j.R) {\n          uncover(j.H);\n        }\n      }\n      uncover(c);\n    }\n  };\n\n  const chooseColumn = h => {\n    let s = Number.POSITIVE_INFINITY;\n    let c = h;\n    for (let j = h.R; j != h; j = j.R) {\n      if (j.S < s) {\n        c = j;\n        s = j.S;\n      }\n    }\n    return c;\n  };\n\n  const cover = c => {\n    c.L.R = c.R;\n    c.R.L = c.L;\n    for (let i = c.D; i != c; i = i.D) {\n      for (let j = i.R; j != i; j = j.R) {\n        j.U.D = j.D;\n        j.D.U = j.U;\n        j.H.S = j.H.S - 1;\n      }\n    }\n  };\n\n  const uncover = c => {\n    for (let i = c.U; i != c; i = i.U) {\n      for (let j = i.L; i != j; j = j.L) {\n        j.H.S = j.H.S + 1;\n        j.U.D = j;\n        j.D.U = j;\n      }\n    }\n    c.L.R = c;\n    c.R.L = c;\n  };\n\n  const printSol = a => {\n    solution = a.reduce((p, c) => {\n      let [i, v] = c.V.split(':');\n      p[i * 1] = v;\n      return p;\n    }, new Array(a.length).fill('.'));\n  };\n\n  const gridMeta = s => {\n    const g = s.split('');\n    const cellCount = g.length;\n    const tokenCount = Math.sqrt(cellCount);\n    const N = Math.sqrt(tokenCount);\n    const g2D = g.map(e =>\n      isNaN(e * 1)\n        ? new Array(tokenCount).fill(1).map((_, i) => i + 1)\n        : [e * 1]\n    );\n    return [cellCount, N, tokenCount, g2D];\n  };\n\n  const indexesN = n => i => {\n    let c = Math.floor(i / (n * n));\n    i %= n * n;\n    return [c, i, Math.floor(c / n) * n + Math.floor(i / n)];\n  };\n\n  const reduceGrid = puzString => {\n    const [\n      numCells, // The total number of cells in a grid (81 for a 9x9 grid)\n      N, // the 'n' value of the grid. (3 for a 9x9 grid)\n      U, // The total number of unique tokens to be placed.\n      g2D // A 2D array representation of the grid, with each element\n      // being an array of candidates for a cell. Known cells are\n      // single element arrays.\n    ] = gridMeta(puzString);\n\n    const getIndex = indexesN(N);\n\n    const headRow = new Array(4 * numCells)\n      .fill('')\n      .map((_, i) => new DoX(`H${i}`));\n\n    let H = new DoX('ROOT');\n    headRow.reduce((p, c) => addRight(p, c), H);\n\n    for (let i = 0; i < numCells; i++) {\n      const [ri, ci, bi] = getIndex(i);\n      g2D[i].forEach(num => {\n        let id = `${i}:${num}`;\n        let candIdx = num - 1;\n\n        // The 4 columns that we will populate.\n        const A = headRow[i];\n        const B = headRow[numCells + candIdx + ri * U];\n        const C = headRow[numCells * 2 + candIdx + ci * U];\n        const D = headRow[numCells * 3 + candIdx + bi * U];\n\n        // The Row-Column Constraint\n        let rcc = addBelow(A.U, new DoX(id, A));\n\n        // The Row-Number Constraint\n        let rnc = addBelow(B.U, addRight(rcc, new DoX(id, B)));\n\n        // The Column-Number Constraint\n        let cnc = addBelow(C.U, addRight(rnc, new DoX(id, C)));\n\n        // The Block-Number Constraint\n        addBelow(D.U, addRight(cnc, new DoX(id, D)));\n      });\n    }\n    search(H, []);\n  };\n\n  var stringPuzzle = '';\n\n  for (var i = 0; i < puzzle.length; i++) {\n    puzzle[i].forEach(function(e) {\n      if (e == -1) stringPuzzle += '.';\n      else stringPuzzle += e;\n    });\n  }\n\n  reduceGrid(stringPuzzle);\n\n  var result = [];\n\n  for (var i = 0; i < 9; i++) {\n    result.push(solution.slice(i * 9, (i + 1) * 9).map(e => parseInt(e)));\n  }\n\n  return result;\n}"
        }
      ],
      "tests": [
        {
          "text": "`solveSudoku` should be a function.",
          "testCode": "assert(typeof solveSudoku == 'function');"
        },
        {
          "text": "`solveSudoku([[8, 1, 9, -1, -1, 5, -1, -1, -1],[-1, -1, 2, -1, -1, -1, 7, 5, -1],[-1, 3, 7, 1, -1, 4, -1, 6, -1],[4, -1, -1, 5, 9, -1, 1, -1, -1],[7, -1, -1, 3, -1, 8, -1, -1, 2],[-1, -1, 3, -1, 6, 2, -1, -1, 7],[-1, 5, -1, 7, -1, 9, 2, 1, -1],[-1, 6, 4, -1, -1, -1, 9, -1, -1],[-1, -1, -1, 2, -1, -1, 4, 3, 8]])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    solveSudoku([\n      [8, 1, 9, -1, -1, 5, -1, -1, -1],\n      [-1, -1, 2, -1, -1, -1, 7, 5, -1],\n      [-1, 3, 7, 1, -1, 4, -1, 6, -1],\n      [4, -1, -1, 5, 9, -1, 1, -1, -1],\n      [7, -1, -1, 3, -1, 8, -1, -1, 2],\n      [-1, -1, 3, -1, 6, 2, -1, -1, 7],\n      [-1, 5, -1, 7, -1, 9, 2, 1, -1],\n      [-1, 6, 4, -1, -1, -1, 9, -1, -1],\n      [-1, -1, -1, 2, -1, -1, 4, 3, 8]\n    ])\n  )\n);"
        },
        {
          "text": "`solveSudoku([[8, 1, 9, -1, -1, 5, -1, -1, -1],[-1, -1, 2, -1, -1, -1, 7, 5, -1],[-1, 3, 7, 1, -1, 4, -1, 6, -1],[4, -1, -1, 5, 9, -1, 1, -1, -1],[7, -1, -1, 3, -1, 8, -1, -1, 2],[-1, -1, 3, -1, 6, 2, -1, -1, 7],[-1, 5, -1, 7, -1, 9, 2, 1, -1],[-1, 6, 4, -1, -1, -1, 9, -1, -1],[-1, -1, -1, 2, -1, -1, 4, 3, 8]])` should return `[[8, 1, 9, 6, 7, 5, 3, 2, 4],[6, 4, 2, 9, 8, 3, 7, 5, 1],[5, 3, 7, 1, 2, 4, 8, 6, 9],[4, 2, 6, 5, 9, 7, 1, 8, 3],[7, 9, 5, 3, 1, 8, 6, 4, 2],[1, 8, 3, 4, 6, 2, 5, 9, 7],[3, 5, 8, 7, 4, 9, 2, 1, 6],[2, 6, 4, 8, 3, 1, 9, 7, 5],[9, 7, 1, 2, 5, 6, 4, 3, 8]]`.",
          "testCode": "assert.deepEqual(\n  solveSudoku([\n    [8, 1, 9, -1, -1, 5, -1, -1, -1],\n    [-1, -1, 2, -1, -1, -1, 7, 5, -1],\n    [-1, 3, 7, 1, -1, 4, -1, 6, -1],\n    [4, -1, -1, 5, 9, -1, 1, -1, -1],\n    [7, -1, -1, 3, -1, 8, -1, -1, 2],\n    [-1, -1, 3, -1, 6, 2, -1, -1, 7],\n    [-1, 5, -1, 7, -1, 9, 2, 1, -1],\n    [-1, 6, 4, -1, -1, -1, 9, -1, -1],\n    [-1, -1, -1, 2, -1, -1, 4, 3, 8]\n  ]),\n  [\n    [8, 1, 9, 6, 7, 5, 3, 2, 4],\n    [6, 4, 2, 9, 8, 3, 7, 5, 1],\n    [5, 3, 7, 1, 2, 4, 8, 6, 9],\n    [4, 2, 6, 5, 9, 7, 1, 8, 3],\n    [7, 9, 5, 3, 1, 8, 6, 4, 2],\n    [1, 8, 3, 4, 6, 2, 5, 9, 7],\n    [3, 5, 8, 7, 4, 9, 2, 1, 6],\n    [2, 6, 4, 8, 3, 1, 9, 7, 5],\n    [9, 7, 1, 2, 5, 6, 4, 3, 8]\n  ]\n);"
        },
        {
          "text": "`solveSudoku([[5, 3, -1, -1, 2, 4, 7, -1, -1],[-1, -1, 2, -1, -1, -1, 8, -1, -1],[1, -1, -1, 7, -1, 3, 9, -1, 2],[-1, -1, 8, -1, 7, 2, -1, 4, 9],[-1, 2, -1, 9, 8, -1, -1, 7, -1],[7, 9, -1, -1, -1, -1, -1, 8, -1],[-1, -1, -1, -1, 3, -1, 5, -1, 6],[9, 6, -1, -1, 1, -1, 3, -1, -1],[-1, 5, -1, 6, 9, -1, -1, 1, -1]])` should return `[[5, 3, 9, 8, 2, 4, 7, 6, 1],[6, 7, 2, 1, 5, 9, 8, 3, 4],[1, 8, 4, 7, 6, 3, 9, 5, 2],[3, 1, 8, 5, 7, 2, 6, 4, 9],[4, 2, 5, 9, 8, 6, 1, 7, 3],[7, 9, 6, 3, 4, 1, 2, 8, 5],[8, 4, 1, 2, 3, 7, 5, 9, 6],[9, 6, 7, 4, 1, 5, 3, 2, 8],[2, 5, 3, 6, 9, 8, 4, 1, 7]]`.",
          "testCode": "assert.deepEqual(\n  solveSudoku([\n    [5, 3, -1, -1, 2, 4, 7, -1, -1],\n    [-1, -1, 2, -1, -1, -1, 8, -1, -1],\n    [1, -1, -1, 7, -1, 3, 9, -1, 2],\n    [-1, -1, 8, -1, 7, 2, -1, 4, 9],\n    [-1, 2, -1, 9, 8, -1, -1, 7, -1],\n    [7, 9, -1, -1, -1, -1, -1, 8, -1],\n    [-1, -1, -1, -1, 3, -1, 5, -1, 6],\n    [9, 6, -1, -1, 1, -1, 3, -1, -1],\n    [-1, 5, -1, 6, 9, -1, -1, 1, -1]\n  ]),\n  [\n    [5, 3, 9, 8, 2, 4, 7, 6, 1],\n    [6, 7, 2, 1, 5, 9, 8, 3, 4],\n    [1, 8, 4, 7, 6, 3, 9, 5, 2],\n    [3, 1, 8, 5, 7, 2, 6, 4, 9],\n    [4, 2, 5, 9, 8, 6, 1, 7, 3],\n    [7, 9, 6, 3, 4, 1, 2, 8, 5],\n    [8, 4, 1, 2, 3, 7, 5, 9, 6],\n    [9, 6, 7, 4, 1, 5, 3, 2, 8],\n    [2, 5, 3, 6, 9, 8, 4, 1, 7]\n  ]\n);"
        },
        {
          "text": "`solveSudoku([[-1, -1, 3, -1, 2, -1, 6, -1, -1],[9, -1, -1, 3, -1, 5, -1, -1, 1],[-1, -1, 1, 8, -1, 6, 4, -1, -1],[-1, -1, 8, 1, -1, 2, 9, -1, -1],[7, -1, -1, -1, -1, -1, -1, -1, 8],[-1, -1, 6, 7, -1, 8, 2, -1, -1],[-1, -1, 2, 6, -1, 9, 5, -1, -1],[8, -1, -1, 2, -1, 3, -1, -1, 9],[-1, -1, 5, -1, 1, -1, 3, -1, -1]])` should return `[[4, 8, 3, 9, 2, 1, 6, 5, 7],[9, 6, 7, 3, 4, 5, 8, 2, 1],[2, 5, 1, 8, 7, 6, 4, 9, 3],[5, 4, 8, 1, 3, 2, 9, 7, 6],[7, 2, 9, 5, 6, 4, 1, 3, 8],[1, 3, 6, 7, 9, 8, 2, 4, 5],[3, 7, 2, 6, 8, 9, 5, 1, 4],[8, 1, 4, 2, 5, 3, 7, 6, 9],[6, 9, 5, 4, 1, 7, 3, 8, 2]]`.",
          "testCode": "assert.deepEqual(\n  solveSudoku([\n    [-1, -1, 3, -1, 2, -1, 6, -1, -1],\n    [9, -1, -1, 3, -1, 5, -1, -1, 1],\n    [-1, -1, 1, 8, -1, 6, 4, -1, -1],\n    [-1, -1, 8, 1, -1, 2, 9, -1, -1],\n    [7, -1, -1, -1, -1, -1, -1, -1, 8],\n    [-1, -1, 6, 7, -1, 8, 2, -1, -1],\n    [-1, -1, 2, 6, -1, 9, 5, -1, -1],\n    [8, -1, -1, 2, -1, 3, -1, -1, 9],\n    [-1, -1, 5, -1, 1, -1, 3, -1, -1]\n  ]),\n  [\n    [4, 8, 3, 9, 2, 1, 6, 5, 7],\n    [9, 6, 7, 3, 4, 5, 8, 2, 1],\n    [2, 5, 1, 8, 7, 6, 4, 9, 3],\n    [5, 4, 8, 1, 3, 2, 9, 7, 6],\n    [7, 2, 9, 5, 6, 4, 1, 3, 8],\n    [1, 3, 6, 7, 9, 8, 2, 4, 5],\n    [3, 7, 2, 6, 8, 9, 5, 1, 4],\n    [8, 1, 4, 2, 5, 3, 7, 6, 9],\n    [6, 9, 5, 4, 1, 7, 3, 8, 2]\n  ]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302329,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sudoku.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc803f",
      "title": "Sum digits of an integer",
      "challengeType": 1,
      "dashedName": "sum-digits-of-an-integer",
      "description": "Write a function that takes a string as a parameter. This string represents a number that can be in any base (less than 37) and return the sum of its digits.\n\n<ul>\n  <li><b>1</b><sub>10</sub> sums to <b>1</b></li>\n  <li><b>1234</b><sub>10</sub> sums to <b>10</b></li>\n  <li><b>fe</b><sub>16</sub> sums to <b>29</b></li>\n  <li><b>f0e</b><sub>16</sub> sums to <b>29</b></li>\n</ul>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sumDigits(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sumDigits(n) {\n  n += '';\n  for (var s = 0, i = 0, e = n.length; i < e; i += 1)\n    s += parseInt(n.charAt(i), 36);\n  return s;\n}"
        }
      ],
      "tests": [
        {
          "text": "`sumDigits` should be a function.",
          "testCode": "assert(typeof sumDigits == 'function');"
        },
        {
          "text": "`sumDigits(\"1\")` should return a number.",
          "testCode": "assert(typeof sumDigits('1') == 'number');"
        },
        {
          "text": "`sumDigits(\"1\")` should return `1`.",
          "testCode": "assert.equal(sumDigits('1'), 1);"
        },
        {
          "text": "`sumDigits(\"12345\")` should return `15`.",
          "testCode": "assert.equal(sumDigits('12345'), 15);"
        },
        {
          "text": "`sumDigits(\"254\")` should return `11`.",
          "testCode": "assert.equal(sumDigits('254'), 11);"
        },
        {
          "text": "`sumDigits(\"fe\")` should return `29`.",
          "testCode": "assert.equal(sumDigits('fe'), 29);"
        },
        {
          "text": "`sumDigits(\"f0e\")` should return `29`.",
          "testCode": "assert.equal(sumDigits('f0e'), 29);"
        },
        {
          "text": "`sumDigits(\"999ABCXYZ\")` should return `162`.",
          "testCode": "assert.equal(sumDigits('999ABCXYZ'), 162);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302331,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sum-digits-of-an-integer.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8040",
      "title": "Sum multiples of 3 and 5",
      "challengeType": 1,
      "dashedName": "sum-multiples-of-3-and-5",
      "description": "The objective is to write a function that finds the sum of all positive multiples of 3 or 5 below *n*.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sumMults(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sumMults(n) {\n  var sum = 0;\n  for (var i = 1; i < n; i++) {\n    if (i % 3 == 0 || i % 5 == 0) sum += i;\n  }\n  return sum;\n}"
        }
      ],
      "tests": [
        {
          "text": "`sumMults` should be a function.",
          "testCode": "assert(typeof sumMults == 'function');"
        },
        {
          "text": "`sumMults(10)` should return a number.",
          "testCode": "assert(typeof sumMults(10) == 'number');"
        },
        {
          "text": "`sumMults(10)` should return `23`.",
          "testCode": "assert.equal(sumMults(10), 23);"
        },
        {
          "text": "`sumMults(100)` should return `2318`.",
          "testCode": "assert.equal(sumMults(100), 2318);"
        },
        {
          "text": "`sumMults(1000)` should return `233168`.",
          "testCode": "assert.equal(sumMults(1000), 233168);"
        },
        {
          "text": "`sumMults(10000)` should return `23331668`.",
          "testCode": "assert.equal(sumMults(10000), 23331668);"
        },
        {
          "text": "`sumMults(100000)` should return `2333316668`.",
          "testCode": "assert.equal(sumMults(100000), 2333316668);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302332,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sum-multiples-of-3-and-5.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8041",
      "title": "Sum of a series",
      "challengeType": 1,
      "dashedName": "sum-of-a-series",
      "description": "Compute the **n**<sup>th</sup> term of a <em>series</em>, i.e. the sum of the **n** first terms of the corresponding <em>sequence</em>. Informally this value, or its limit when **n** tends to infinity, is also called the *sum of the series*, thus the title of this task. For this task, use: $S_n = \\displaystyle\\sum_{k=1}^n \\frac{1}{k^2}$.",
      "instructions": "Write a function that take $a$ and $b$ as parameters and returns the sum of $a^{th}$ to $b^{th}$ members of the sequence.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sum(a, b) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sum(a, b) {\n  function fn(x) {\n    return 1 / (x * x);\n  }\n  var s = 0;\n  for (; a <= b; a++) s += fn(a);\n  return s;\n}"
        }
      ],
      "tests": [
        {
          "text": "`sum` should be a function.",
          "testCode": "assert(typeof sum == 'function');"
        },
        {
          "text": "`sum(1, 100)` should return a number.",
          "testCode": "assert(typeof sum(1, 100) == 'number');"
        },
        {
          "text": "`sum(1, 100)` should return `1.6349839001848923`.",
          "testCode": "assert.equal(sum(1, 100), 1.6349839001848923);"
        },
        {
          "text": "`sum(33, 46)` should return `0.009262256361481223`.",
          "testCode": "assert.equal(sum(33, 46), 0.009262256361481223);"
        },
        {
          "text": "`sum(21, 213)` should return `0.044086990748706555`.",
          "testCode": "assert.equal(sum(21, 213), 0.044086990748706555);"
        },
        {
          "text": "`sum(11, 111)` should return `0.08619778593108679`.",
          "testCode": "assert.equal(sum(11, 111), 0.08619778593108679);"
        },
        {
          "text": "`sum(1, 10)` should return `1.5497677311665408`.",
          "testCode": "assert.equal(sum(1, 10), 1.5497677311665408);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302333,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sum-of-a-series.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8042",
      "title": "Sum of squares",
      "challengeType": 1,
      "dashedName": "sum-of-squares",
      "description": "Write a function to find the sum of squares of an array of integers.",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sumsq(array) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sumsq(array) {\n  var sum = 0;\n  var i, iLen;\n\n  for (i = 0, iLen = array.length; i < iLen; i++) {\n    sum += array[i] * array[i];\n  }\n  return sum;\n}"
        }
      ],
      "tests": [
        {
          "text": "`sumsq` should be a function.",
          "testCode": "assert(typeof sumsq == 'function');"
        },
        {
          "text": "`sumsq([1, 2, 3, 4, 5])` should return a number.",
          "testCode": "assert(typeof sumsq([1, 2, 3, 4, 5]) == 'number');"
        },
        {
          "text": "`sumsq([1, 2, 3, 4, 5])` should return `55`.",
          "testCode": "assert.equal(sumsq([1, 2, 3, 4, 5]), 55);"
        },
        {
          "text": "`sumsq([25, 32, 12, 7, 20])` should return `2242`.",
          "testCode": "assert.equal(sumsq([25, 32, 12, 7, 20]), 2242);"
        },
        {
          "text": "`sumsq([38, 45, 35, 8, 13])` should return `4927`.",
          "testCode": "assert.equal(sumsq([38, 45, 35, 8, 13]), 4927);"
        },
        {
          "text": "`sumsq([43, 36, 20, 34, 24])` should return `5277`.",
          "testCode": "assert.equal(sumsq([43, 36, 20, 34, 24]), 5277);"
        },
        {
          "text": "`sumsq([12, 33, 26, 18, 1, 16, 3])` should return `2499`.",
          "testCode": "assert.equal(sumsq([12, 33, 26, 18, 1, 16, 3]), 2499);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302334,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sum-of-squares.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8043",
      "title": "Sum to 100",
      "challengeType": 1,
      "dashedName": "sum-to-100",
      "description": "Find solutions to the *sum to one hundred* puzzle.\n\nAdd (insert) the mathematical operators **+** or **─** (plus or minus) before any of the digits in the decimal numeric string **123456789** such that the resulting mathematical expression adds up to a particular sum (in this iconic case, **100**).\n\nExample:\n\n<pre><b>123 + 4 - 5 + 67 - 89   =   100</b></pre>",
      "instructions": "Write a function that takes a number as parameter. The function should return an array containing all solutions for the given number. The solutions should be strings representing the expressions. For example: \"1+23-456+78-9\". Sort the array before returning it.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function sumTo100(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function sumTo100(n) {\n  var permutationsWithRepetition = function(n, as) {\n    return as.length > 0\n      ? foldl1(curry(cartesianProduct)(as), replicate(n, as))\n      : [];\n  };\n\n  var cartesianProduct = function(xs, ys) {\n    return [].concat.apply(\n      [],\n      xs.map(function(x) {\n        return [].concat.apply(\n          [],\n          ys.map(function(y) {\n            return [[x].concat(y)];\n          })\n        );\n      })\n    );\n  };\n\n  var curry = function(f) {\n    return function(a) {\n      return function(b) {\n        return f(a, b);\n      };\n    };\n  };\n\n  var flip = function(f) {\n    return function(a, b) {\n      return f.apply(null, [b, a]);\n    };\n  };\n\n  var foldl1 = function(f, xs) {\n    return xs.length > 0 ? xs.slice(1).reduce(f, xs[0]) : [];\n  };\n\n  var replicate = function(n, a) {\n    var v = [a],\n      o = [];\n    if (n < 1) return o;\n    while (n > 1) {\n      if (n & 1) o = o.concat(v);\n      n >>= 1;\n      v = v.concat(v);\n    }\n    return o.concat(v);\n  };\n\n  var asSum = function(xs) {\n    var dct = xs.reduceRight(\n      function(a, sign, i) {\n        var d = i + 1; //  zero-based index to [1-9] positions\n        if (sign !== 0) {\n          // Sum increased, digits cleared\n          return {\n            digits: [],\n            n: a.n + sign * parseInt([d].concat(a.digits).join(''), 10)\n          };\n        } else\n          return {\n            // Digits extended, sum unchanged\n            digits: [d].concat(a.digits),\n            n: a.n\n          };\n      },\n      {\n        digits: [],\n        n: 0\n      }\n    );\n    return (\n      dct.n + (dct.digits.length > 0 ? parseInt(dct.digits.join(''), 10) : 0)\n    );\n  };\n\n  var asString = function(xs) {\n    var ns = xs.reduce(function(a, sign, i) {\n      var d = (i + 1).toString();\n      return sign === 0 ? a + d : a + (sign > 0 ? '+' : '-') + d;\n    }, '');\n\n    return ns[0] === '+' ? tail(ns) : ns;\n  };\n\n  var universe = permutationsWithRepetition(9, [0, 1, -1])\n    .filter(function(x) {\n      return x[0] !== 1 && asSum(x) === n;\n    })\n    .map(asString);\n  return universe.sort();\n}"
        }
      ],
      "tests": [
        {
          "text": "`sumTo100` should be a function.",
          "testCode": "assert(typeof sumTo100 == 'function');"
        },
        {
          "text": "`sumTo100(199)` should return an array.",
          "testCode": "assert(Array.isArray(sumTo100(199)));"
        },
        {
          "text": "`sumTo100(199)` should return `[\"-1+2-3+45+67+89\", \"123-4+5+6+78-9\", \"123-4+56+7+8+9\"]`.",
          "testCode": "assert.deepEqual(sumTo100(199), [\n  '-1+2-3+45+67+89',\n  '123-4+5+6+78-9',\n  '123-4+56+7+8+9'\n]);"
        },
        {
          "text": "`sumTo100(209)` should return `[\"1+234+56+7-89\"]`.",
          "testCode": "assert.deepEqual(sumTo100(209), ['1+234+56+7-89']);"
        },
        {
          "text": "`sumTo100(243)` should return `[\"-1-234+567-89\", \"-12+345+6-7-89\", \"123+45+6+78-9\"]`.",
          "testCode": "assert.deepEqual(sumTo100(243), [\n  '-1-234+567-89',\n  '-12+345+6-7-89',\n  '123+45+6+78-9'\n]);"
        },
        {
          "text": "`sumTo100(197)` should return `[\"1-2-3+45+67+89\", \"12+34-5+67+89\", \"123+4-5+6+78-9\"]`.",
          "testCode": "assert.deepEqual(sumTo100(197), [\n  '1-2-3+45+67+89',\n  '12+34-5+67+89',\n  '123+4-5+6+78-9'\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302335,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sum-to-100.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8045",
      "title": "Sutherland-Hodgman polygon clipping",
      "challengeType": 1,
      "dashedName": "sutherland-hodgman-polygon-clipping",
      "description": "The Sutherland-Hodgman clipping algorithm finds the polygon that is the intersection between an arbitrary polygon (the \"subject polygon\") and a convex polygon (the \"clip polygon\"). It is used in computer graphics (especially 2D graphics) to reduce the complexity of a scene being displayed by eliminating parts of a polygon that do not need to be displayed. Take the closed polygon defined by the points:\n\n<pre>[(50, 150), (200, 50), (350, 150), (350, 300), (250, 300), (200, 250), (150, 350), (100, 250), (100, 200)]</pre>\n\nand clip it by the rectangle defined by the points:\n\n<pre>[(100, 100), (300, 100), (300, 300), (100, 300)]</pre>",
      "instructions": "Write a function that takes 2 arrays as parameters. The first array contains the points of the subject polygon and the second array contains the points of the clipping polygon. The function should return an array containing the points of the clipped polygon. Each number should be rounded to 3 decimal places.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function clip(subjectPolygon, clipPolygon) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function clip(subjectPolygon, clipPolygon) {\n  var cp1, cp2, s, e, i, j;\n  var inside = function(p) {\n    return (\n      (cp2[0] - cp1[0]) * (p[1] - cp1[1]) > (cp2[1] - cp1[1]) * (p[0] - cp1[0])\n    );\n  };\n  var intersection = function() {\n    var dc = [cp1[0] - cp2[0], cp1[1] - cp2[1]],\n      dp = [s[0] - e[0], s[1] - e[1]],\n      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\n      n2 = s[0] * e[1] - s[1] * e[0],\n      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\n    return [(n1 * dp[0] - n2 * dc[0]) * n3, (n1 * dp[1] - n2 * dc[1]) * n3];\n  };\n  var outputList = subjectPolygon;\n  cp1 = clipPolygon[clipPolygon.length - 1];\n  for (j in clipPolygon) {\n    var cp2 = clipPolygon[j];\n    var inputList = outputList;\n    outputList = [];\n    s = inputList[inputList.length - 1]; //last on the input list\n    for (i in inputList) {\n      var e = inputList[i];\n      if (inside(e)) {\n        if (!inside(s)) {\n          outputList.push(intersection());\n        }\n        outputList.push(e);\n      } else if (inside(s)) {\n        outputList.push(intersection());\n      }\n      s = e;\n    }\n    cp1 = cp2;\n  }\n  return outputList.map(e => e.map(f => Math.round(f * 1000) / 1000));\n}"
        }
      ],
      "tests": [
        {
          "text": "`clip` should be a function.",
          "testCode": "assert(typeof clip == 'function');"
        },
        {
          "text": "`clip([[50, 150], [200, 50], [350, 150], [350, 300], [250, 300], [200, 250], [150, 350], [100, 250], [100, 200]], [[100, 100], [300, 100], [300, 300], [100, 300]])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    clip(\n      [\n        [50, 150],\n        [200, 50],\n        [350, 150],\n        [350, 300],\n        [250, 300],\n        [200, 250],\n        [150, 350],\n        [100, 250],\n        [100, 200]\n      ],\n      [\n        [100, 100],\n        [300, 100],\n        [300, 300],\n        [100, 300]\n      ]\n    )\n  )\n);"
        },
        {
          "text": "`clip([[50, 150], [200, 50], [350, 150], [350, 300], [250, 300], [200, 250], [150, 350], [100, 250], [100, 200]], [[100, 100], [300, 100], [300, 300], [100, 300]])` should return `[[100, 116.667], [125, 100], [275, 100], [300, 116.667], [300, 300], [250, 300], [200, 250], [175, 300], [125, 300], [100, 250]]`.",
          "testCode": "assert.deepEqual(\n  clip(\n    [\n      [50, 150],\n      [200, 50],\n      [350, 150],\n      [350, 300],\n      [250, 300],\n      [200, 250],\n      [150, 350],\n      [100, 250],\n      [100, 200]\n    ],\n    [\n      [100, 100],\n      [300, 100],\n      [300, 300],\n      [100, 300]\n    ]\n  ),\n  [\n    [100, 116.667],\n    [125, 100],\n    [275, 100],\n    [300, 116.667],\n    [300, 300],\n    [250, 300],\n    [200, 250],\n    [175, 300],\n    [125, 300],\n    [100, 250]\n  ]\n);"
        },
        {
          "text": "`clip([[150, 200], [400, 450], [30, 50]], [[10, 10], [300, 200], [400, 600], [100, 300]])` should return `[[150, 200], [350, 400], [348.611, 394.444], [30, 50]]`.",
          "testCode": "assert.deepEqual(\n  clip(\n    [\n      [150, 200],\n      [400, 450],\n      [30, 50]\n    ],\n    [\n      [10, 10],\n      [300, 200],\n      [400, 600],\n      [100, 300]\n    ]\n  ),\n  [\n    [150, 200],\n    [350, 400],\n    [348.611, 394.444],\n    [30, 50]\n  ]\n);"
        },
        {
          "text": "`clip([[250, 200], [100, 450], [130, 250]], [[50, 60], [100, 230], [400, 600], [100, 300]])` should return `[[129.167, 329.167], [119.565, 319.565], [121.854, 304.305]]`.",
          "testCode": "assert.deepEqual(\n  clip(\n    [\n      [250, 200],\n      [100, 450],\n      [130, 250]\n    ],\n    [\n      [50, 60],\n      [100, 230],\n      [400, 600],\n      [100, 300]\n    ]\n  ),\n  [\n    [129.167, 329.167],\n    [119.565, 319.565],\n    [121.854, 304.305]\n  ]\n);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302336,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\sutherland-hodgman-polygon-clipping.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5a23c84252665b21eecc8046",
      "title": "Symmetric difference",
      "challengeType": 1,
      "dashedName": "symmetric-difference",
      "description": "Given two sets *A* and *B*, compute $(A \\\\setminus B) \\\\cup (B \\\\setminus A).$ That is, enumerate the items that are in *A* or *B* but not both. This set is called the symmetric difference of *A* and *B*. In other words: $(A \\\\cup B) \\\\setminus (A \\\\cap B)$ (the set of items that are in at least one of *A* or *B* minus the set of items that are in both *A* and *B*).\n\nExample:\n\nFor sets `A = [1, 2, 3]`, and `B = [1, 3, 4]`, the symmetric difference of *A* and *B* is `[2, 4]`.",
      "instructions": "Write a function that takes two arrays as parameters and returns the symmetric difference. Sort the resultant array before returning it.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function symmetricDifference(A, B) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function symmetricDifference(A, B) {\n  function relative_complement(A, B) {\n    return A.filter(function(elem) {\n      return B.indexOf(elem) == -1;\n    });\n  }\n\n  function unique(ary) {\n    var u = ary.concat().sort();\n    for (var i = 1; i < u.length; ) {\n      if (u[i - 1] === u[i]) u.splice(i, 1);\n      else i++;\n    }\n    return u;\n  }\n\n  return unique(\n    relative_complement(A, B).concat(relative_complement(B, A))\n  ).sort();\n}"
        }
      ],
      "tests": [
        {
          "text": "`symmetricDifference` should be a function.",
          "testCode": "assert(typeof symmetricDifference == 'function');"
        },
        {
          "text": "`symmetricDifference([\"John\", \"Bob\", \"Mary\", \"Serena\"], [\"Jim\", \"Mary\", \"John\", \"Bob\"])` should return an array.",
          "testCode": "assert(\n  Array.isArray(\n    symmetricDifference(\n      ['John', 'Bob', 'Mary', 'Serena'],\n      ['Jim', 'Mary', 'John', 'Bob']\n    )\n  )\n);"
        },
        {
          "text": "`symmetricDifference([\"John\", \"Bob\", \"Mary\", \"Serena\"], [\"Jim\", \"Mary\", \"John\", \"Bob\"])` should return `[\"Jim\", \"Serena\"]`.",
          "testCode": "assert.deepEqual(\n  symmetricDifference(\n    ['John', 'Bob', 'Mary', 'Serena'],\n    ['Jim', 'Mary', 'John', 'Bob']\n  ),\n  ['Jim', 'Serena']\n);"
        },
        {
          "text": "`symmetricDifference([1, 2, 3], [3, 4])` should return `[1, 2, 4]`.",
          "testCode": "assert.deepEqual(symmetricDifference([1, 2, 3], [3, 4]), [1, 2, 4]);"
        },
        {
          "text": "`symmetricDifference([1, 2, 3, 4, 5], [3, 4, 8, 7])` should return `[1, 2, 5, 7, 8]`.",
          "testCode": "assert.deepEqual(symmetricDifference([1, 2, 3, 4, 5], [3, 4, 8, 7]), [\n  1,\n  2,\n  5,\n  7,\n  8\n]);"
        },
        {
          "text": "`symmetricDifference([1, 2, 3, 4, 5, 6, 7, 8], [1, 3, 5, 6, 7, 8, 9])` should return `[2, 4, 9]`.",
          "testCode": "assert.deepEqual(\n  symmetricDifference([1, 2, 3, 4, 5, 6, 7, 8], [1, 3, 5, 6, 7, 8, 9]),\n  [2, 4, 9]\n);"
        },
        {
          "text": "`symmetricDifference([1, 2, 4, 7, 9], [2, 3, 7, 8, 9])` should return `[1, 3, 4, 8]`.",
          "testCode": "assert.deepEqual(symmetricDifference([1, 2, 4, 7, 9], [2, 3, 7, 8, 9]), [\n  1,\n  3,\n  4,\n  8\n]);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 16086,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\symmetric-difference.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594ecc0d9a8cf816e3340187",
      "title": "Taxicab numbers",
      "challengeType": 1,
      "dashedName": "taxicab-numbers",
      "description": "A taxicab number (the definition that is being used here) is a positive integer that can be expressed as the sum of two positive cubes in more than one way.\n\nThe first taxicab number is `1729`, which is:\n\n1<sup>3</sup> + 12<sup>3</sup> and\n\n9<sup>3</sup> + 10<sup>3</sup>.\n\nTaxicab numbers are also known as:\n\n<ul>\n  <li>taxi numbers</li>\n  <li>taxi-cab numbers</li>\n  <li>taxi cab numbers</li>\n  <li>Hardy-Ramanujan numbers</li>\n</ul>",
      "instructions": "Write a function that returns the lowest `n` taxicab numbers. For each of the taxicab numbers, show the number as well as its constituent cubes.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function taxicabNumbers(n) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function taxicabNumbers(nNumbers) {\n  const cubeN = [];\n  const s3s = {};\n\n  const e = 100;\n  for (let n = 1; n < e; n += 1) {\n    cubeN[n] = n * n * n;\n  }\n\n  for (let a = 1; a < e - 1; a += 1) {\n    const a3 = cubeN[a];\n    for (let b = a; b < e; b += 1) {\n      const b3 = cubeN[b];\n      const s3 = a3 + b3;\n\n      let abs = s3s[s3];\n      if (!abs) {\n        s3s[s3] = abs = [];\n      }\n      abs.push([a, b]);\n    }\n  }\n\n  let i = 0;\n  const res = [];\n  Object.keys(s3s).forEach(s3 => {\n    const abs = s3s[s3];\n    if (abs.length >= 2) { // No two cube pairs found\n      i += 1;\n      if (i <= nNumbers) {\n        res.push(s3);\n      }\n    }\n  });\n  return res.map(item => parseInt(item, 10));\n}"
        }
      ],
      "tests": [
        {
          "text": "`taxicabNumbers` should be a function.",
          "testCode": "assert(typeof taxicabNumbers === 'function');"
        },
        {
          "text": "`taxicabNumbers` should return an array.",
          "testCode": "assert(typeof taxicabNumbers(2) === 'object');"
        },
        {
          "text": "`taxicabNumbers` should return an array of numbers.",
          "testCode": "assert(typeof taxicabNumbers(100)[0] === 'number');"
        },
        {
          "text": "`taxicabNumbers(4)` should return [1729, 4104, 13832, 20683].",
          "testCode": "assert.deepEqual(taxicabNumbers(4), res4);"
        },
        {
          "text": "`taxicabNumbers(25)` should return [1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656, 110808, 134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763, 373464, 402597]",
          "testCode": "assert.deepEqual(taxicabNumbers(25), res25);"
        },
        {
          "text": "`taxicabNumbers(39)` resulting numbers from 20 - 29 should be [314496,320264,327763,373464,402597,439101,443889,513000,513856].",
          "testCode": "assert.deepEqual(taxicabNumbers(39).slice(20, 29), res39From20To29);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302337,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\taxicab-numbers.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const res4 = [1729, 4104, 13832, 20683];\nconst res25 = [\n  1729, 4104, 13832, 20683, 32832, 39312, 40033, 46683, 64232, 65728, 110656,\n  110808, 134379, 149389, 165464, 171288, 195841, 216027, 216125, 262656, 314496, 320264, 327763,\n  373464, 402597\n];\n\nconst res39From20To29 = [314496, 320264, 327763, 373464, 402597, 439101, 443889, 513000, 513856];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594faaab4e2a8626833e9c3d",
      "title": "Tokenize a string with escaping",
      "challengeType": 1,
      "dashedName": "tokenize-a-string-with-escaping",
      "description": "Write a function or program that can split a string at each non-escaped occurrence of a separator character.\n\nIt should accept three input parameters:\n\n<ul>\n  <li>The <strong>string</strong></li>\n  <li>The <strong>separator character</strong></li>\n  <li>The <strong>escape character</strong></li>\n</ul>\n\nIt should output a list of strings.\n\nRules for splitting:\n\n<ul>\n  <li>The fields that were separated by the separators, become the elements of the output list.</li>\n  <li>Empty fields should be preserved, even at the start and end.</li>\n</ul>\n\nRules for escaping:\n\n<ul>\n  <li>\"Escaped\" means preceded by an occurrence of the escape character that is not already escaped itself.</li>\n  <li>When the escape character precedes a character that has no special meaning, it still counts as an escape (but does not do anything special).</li>\n  <li>Each occurrences of the escape character that was used to escape something, should not become part of the output.</li>\n</ul>\n\nDemonstrate that your function satisfies the following test-case:\n\nGiven the string\n\n<pre>one^|uno||three^^^^|four^^^|^cuatro|</pre>\n\nand using `|` as a separator and `^` as escape character, your function should output the following array:\n\n<pre>  ['one|uno', '', 'three^^', 'four^|cuatro', '']\n</pre>",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function tokenize(str, sep, esc) {\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// tokenize :: String -> Character -> Character -> [String]\nfunction tokenize(str, charDelim, charEsc) {\n  const dctParse = str.split('')\n    .reduce((a, x) => {\n      const blnEsc = a.esc;\n      const blnBreak = !blnEsc && x === charDelim;\n      const blnEscChar = !blnEsc && x === charEsc;\n\n      return {\n        esc: blnEscChar,\n        token: blnBreak ? '' : (\n          a.token + (blnEscChar ? '' : x)\n        ),\n        list: a.list.concat(blnBreak ? a.token : [])\n      };\n    }, {\n      esc: false,\n      token: '',\n      list: []\n    });\n\n  return dctParse.list.concat(\n    dctParse.token\n  );\n}"
        }
      ],
      "tests": [
        {
          "text": "`tokenize` should be a function.",
          "testCode": "assert(typeof tokenize === 'function');"
        },
        {
          "text": "`tokenize` should return an array.",
          "testCode": "assert(typeof tokenize('a', 'b', 'c') === 'object');"
        },
        {
          "text": "`tokenize('one^|uno||three^^^^|four^^^|^cuatro|', '|', '^')` should return `['one|uno', '', 'three^^', 'four^|cuatro', '']`",
          "testCode": "assert.deepEqual(tokenize(testStr1, '|', '^'), res1);"
        },
        {
          "text": "`tokenize('a@&bcd&ef&&@@hi', '&', '@')` should return `['a&bcd', 'ef', '', '@hi']`",
          "testCode": "assert.deepEqual(tokenize(testStr2, '&', '@'), res2);"
        },
        {
          "text": "`tokenize('hello^|world|how^are^you^|', '|', '^')` should return `['hello|world', 'howareyou|']`",
          "testCode": "assert.deepEqual(tokenize(testStr3, '|', '^'), res3);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302338,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\tokenize-a-string-with-escaping.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testStr1 = 'one^|uno||three^^^^|four^^^|^cuatro|';\nconst res1 = ['one|uno', '', 'three^^', 'four^|cuatro', ''];\n\nconst testStr2 = 'a@&bcd&ef&&@@hi';\nconst res2 = ['a&bcd', 'ef', '', '@hi'];\n\nconst testStr3 = 'hello^|world|how^are^you^|';\nconst res3 = ['hello|world', 'howareyou|'];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "595011cba5a81735713873bd",
      "title": "Top rank per group",
      "challengeType": 1,
      "dashedName": "top-rank-per-group",
      "description": "Find the top `n` ranked data in each group, where `n` is provided as a parameter. Name of the rank and the group are also provided as parameter.\n\nGiven the following data:\n\n```js\ntestData1 = [\n  { name: 'Tyler Bennett', id: 'E10297', salary: 32000, dept: 'D101' },\n  { name: 'John Rappl', id: 'E21437', salary: 47000, dept: 'D050' },\n  { name: 'George Woltman', id: 'E00127', salary: 53500, dept: 'D101' },\n  { name: 'Adam Smith', id: 'E63535', salary: 18000, dept: 'D202' },\n  { name: 'Claire Buckman', id: 'E39876', salary: 27800, dept: 'D202' },\n  { name: 'David McClellan', id: 'E04242', salary: 41500, dept: 'D101' },\n  { name: 'Rich Holcomb', id: 'E01234', salary: 49500, dept: 'D202' },\n  { name: 'Nathan Adams', id: 'E41298', salary: 21900, dept: 'D050' },\n  { name: 'Richard Potter', id: 'E43128', salary: 15900, dept: 'D101' },\n  { name: 'David Motsinger', id: 'E27002', salary: 19250, dept: 'D202' },\n  { name: 'Tim Sampair', id: 'E03033', salary: 27000, dept: 'D101' },\n  { name: 'Kim Arlich', id: 'E10001', salary: 57000, dept: 'D190' },\n  { name: 'Timothy Grove', id: 'E16398', salary: 29900, dept: 'D190' }\n];\n```\n\nOne could rank top 10 employees in each department by calling:\n\n```js\ntopRankPerGroup(10, testData1, 'dept', 'salary')\n```\n\nGiven the following data:\n\n```js\ntestData2 = [\n  { name: 'Friday 13th', genre: 'horror', rating: 9.9 },\n  { name: \"Nightmare on Elm's Street\", genre: 'horror', rating: 5.7 },\n  { name: 'Titanic', genre: 'drama', rating: 7.3 },\n  { name: 'Maze Runner', genre: 'scifi', rating: 7.1 },\n  { name: 'Blade runner', genre: 'scifi', rating: 8.9 }\n];\n```\n\nOne could rank the top-rated movie in each genre by calling:\n\n```js\ntopRankPerGroup(1, testData2, 'genre', 'rating')\n```\n\nThe function should return an array with an array for each group containing the top `n` objects.\n\nFor example, given data:\n\n```js\n[\n  { name: 'Claire Buckman', id: 'E39876', salary: 27800, dept: 'D101' },\n  { name: 'Rich Holcomb', id: 'E01234', salary: 49500, dept: 'D050' },\n  { name: 'David Motsinger', id: 'E27002', salary: 19250, dept: 'D050' },\n  { name: 'Tim Sampair', id: 'E03033', salary: 27000, dept: 'D101' },\n  { name: 'Kim Arlich', id: 'E10001', salary: 57000, dept: 'D050' },\n  { name: 'Timothy Grove', id: 'E16398', salary: 29900, dept: 'D101' }\n];\n```\n\nTop two ranking employees in each department by salary would be:\n\n```js\n[ [ { name: 'Kim Arlich', id: 'E10001', salary: 57000, dept: 'D050' },\n    { name: 'Rich Holcomb', id: 'E01234', salary: 49500, dept: 'D050' } ],\n  [ { name: 'Timothy Grove', id: 'E16398', salary: 29900, dept: 'D101' },\n    { name: 'Claire Buckman', id: 'E39876', salary: 27800, dept: 'D101' } ] ]\n```",
      "instructions": "",
      "boilerplate": [
        {
          "language": "js",
          "code": "function topRankPerGroup(n, data, groupName, rankName) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "const collectDept = function (arrOfObj, groupName) {\n  const collect = arrOfObj.reduce((rtnObj, obj) => {\n    if (rtnObj[obj[groupName]] === undefined) {\n      rtnObj[obj[groupName]] = [];\n    }\n    rtnObj[obj[groupName]].push(obj);\n    return rtnObj;\n  }, {} // initial value to reduce\n  );\n\n  return Object.keys(collect).sort().map(key => collect[key]);\n};\n\nconst sortRank = function (arrOfRankArrs, rankName) {\n  return arrOfRankArrs.map(item => item.sort((a, b) => {\n    if (a[rankName] > b[rankName]) { return -1; }\n    if (a[rankName] < b[rankName]) { return 1; }\n    return 0;\n  }));\n};\n\nfunction topRankPerGroup(n, data, groupName, rankName) {\n  if (n < 0) { return; }\n  return sortRank(collectDept(data, groupName),\n    rankName).map(list => list.slice(0, n));\n}"
        }
      ],
      "tests": [
        {
          "text": "`topRankPerGroup` should be a function.",
          "testCode": "assert(typeof topRankPerGroup === 'function');"
        },
        {
          "text": "`topRankPerGroup` should return undefined on negative n values.",
          "testCode": "assert(typeof topRankPerGroup(-1, []) === 'undefined');"
        },
        {
          "text": "For `topRankPerGroup(10, testData1, 'dept', 'salary')`, the first result in the first group should be `{ name: 'John Rappl', id: 'E21437', salary: 47000, dept: 'D050'}`.",
          "testCode": "assert.deepEqual(res1[0][0], { name: 'John Rappl', id: 'E21437', salary: 47000, dept: 'D050'});"
        },
        {
          "text": "For `topRankPerGroup(10, testData1, 'dept', 'salary')`, the last result in the last group should be `{ name: 'Adam Smith', id: 'E63535', salary: 18000, dept: 'D202' }`.",
          "testCode": "assert.deepEqual(res1[3][3], { name: 'Adam Smith', id: 'E63535', salary: 18000, dept: 'D202' });"
        },
        {
          "text": "`topRankPerGroup(1, ...)` should return only top ranking result per group.",
          "testCode": "assert.equal(res2[2].length, 1);"
        },
        {
          "text": "`topRankPerGroup(2, ...)` should return two ranking results per group.",
          "testCode": "assert.equal(res3[2][1].name, 'Maze Runner');"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302339,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\top-rank-per-group.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const testData1 = [\n  { name: 'Tyler Bennett', id: 'E10297', salary: 32000, dept: 'D101' },\n  { name: 'John Rappl', id: 'E21437', salary: 47000, dept: 'D050' },\n  { name: 'George Woltman', id: 'E00127', salary: 53500, dept: 'D101' },\n  { name: 'Adam Smith', id: 'E63535', salary: 18000, dept: 'D202' },\n  { name: 'Claire Buckman', id: 'E39876', salary: 27800, dept: 'D202' },\n  { name: 'David McClellan', id: 'E04242', salary: 41500, dept: 'D101' },\n  { name: 'Rich Holcomb', id: 'E01234', salary: 49500, dept: 'D202' },\n  { name: 'Nathan Adams', id: 'E41298', salary: 21900, dept: 'D050' },\n  { name: 'Richard Potter', id: 'E43128', salary: 15900, dept: 'D101' },\n  { name: 'David Motsinger', id: 'E27002', salary: 19250, dept: 'D202' },\n  { name: 'Tim Sampair', id: 'E03033', salary: 27000, dept: 'D101' },\n  { name: 'Kim Arlich', id: 'E10001', salary: 57000, dept: 'D190' },\n  { name: 'Timothy Grove', id: 'E16398', salary: 29900, dept: 'D190' }\n];\n\nconst res1 = topRankPerGroup(10, testData1, 'dept', 'salary');\n\nconst testData2 = [\n  { name: 'Friday 13th', genre: 'horror', rating: 9.9 },\n  { name: \"Nightmare on Elm's Street\", genre: 'horror', rating: 5.7 },\n  { name: 'Titanic', genre: 'drama', rating: 7.3 },\n  { name: 'Maze Runner', genre: 'scifi', rating: 7.1 },\n  { name: 'Blade runner', genre: 'scifi', rating: 8.9 }\n];\n\nconst res2 = topRankPerGroup(1, testData2, 'genre', 'rating');\nconst res3 = topRankPerGroup(2, testData2, 'genre', 'rating');"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594fa2746886f41f7d8bf225",
      "title": "Topological sort",
      "challengeType": 1,
      "dashedName": "topological-sort",
      "description": "Given a mapping between items, and items they depend on, a topological sort orders items so that no item precedes an item it depends upon. There are two popular algorithms for topological sorting: Kahn's (1962) topological sort and depth-first search.",
      "instructions": "Write a function that will return a list with valid compile order of libraries from their dependencies.\n\n- Assume library names are single words.\n- Items mentioned as only dependents have no dependents of their own, but their order of compiling must be given.\n- Any self dependencies should be ignored.\n- Any un-orderable dependencies should be ignored.\n\nUse the following data as an example:\n\n<pre>\nLIBRARY          LIBRARY DEPENDENCIES\n=======          ====================\ndes_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01             ieee dw01 dware gtech\ndw02             ieee dw02 dware\ndw03             std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04             dw04 ieee dw01 dware gtech\ndw05             dw05 ieee dware\ndw06             dw06 ieee dware\ndw07             ieee dware\ndware            ieee dware\ngtech            ieee gtech\nramlib           std ieee\nstd_cell_lib     ieee std_cell_lib\nsynopsys\n</pre>\n\nThe compiling of a library in the VHDL language has the constraint that a library must be compiled after any library it depends on. The above data would be un-orderable if, for example, `dw04` is added to the list of dependencies of `dw01`.\n\nThe input of the function will be a multiline string, each line will consist of the name of the library, followed by its dependencies (if exist).\n\nFor example:\n\n```js\nconst libsSimple =\n  `aaa bbb\n  bbb`;\n```",
      "boilerplate": [
        {
          "language": "js",
          "code": "function topologicalSort(libs) {\n\n  return true;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function topologicalSort(libs) {\n  // A map of the input data, with the keys as the packages, and the values as\n  // and array of packages on which it depends.\n  const D = libs\n    .split('\\n')\n    .map(e => e.split(' ').filter(ep => ep !== ''))\n    .reduce((p, c) =>\n      p.set(c[0], c.filter((e, i) => (i > 0 && e !== c[0] ? e : null))), new Map());\n  [].concat(...D.values()).forEach(e => {\n    D.set(e, D.get(e) || []);\n  });\n\n  // The above map rotated so that it represents a DAG of the form\n  // Map {\n  //    A => [ A, B, C],\n  //    B => [C],\n  //    C => []\n  // }\n  // where each key represents a node, and the array contains the edges.\n  const G = [...D.keys()].reduce((p, c) =>\n    p.set(\n      c,\n      [...D.keys()].filter(e => D.get(e).includes(c))),\n    new Map()\n  );\n\n  // An array of leaf nodes; nodes with 0 in degrees.\n  const Q = [...D.keys()].filter(e => D.get(e).length === 0);\n\n  // The result array.\n  const S = [];\n  while (Q.length) {\n    const u = Q.pop();\n    S.push(u);\n    G.get(u).forEach(v => {\n      D.set(v, D.get(v).filter(e => e !== u));\n      if (D.get(v).length === 0) {\n        Q.push(v);\n      }\n    });\n  }\n\n  return S;\n}"
        }
      ],
      "tests": [
        {
          "text": "`topologicalSort` should be a function.",
          "testCode": "assert(typeof topologicalSort === 'function');"
        },
        {
          "text": "`topologicalSort(libsSimple)` should return an array.",
          "testCode": "assert(Array.isArray(topologicalSort(libsSimple)));"
        },
        {
          "text": "`topologicalSort(libsSimple)` should return `['bbb', 'aaa']`.",
          "testCode": "assert.deepEqual(topologicalSort(libsSimple), ['bbb', 'aaa']);"
        },
        {
          "text": "`topologicalSort(libsVHDL)` should return `['ieee', 'std_cell_lib', 'gtech', 'dware', 'dw07', 'dw06', 'dw05', 'dw02', 'dw01', 'dw04', 'std', 'ramlib', 'synopsys', 'dw03', 'des_system_lib']`.",
          "testCode": "assert.deepEqual(topologicalSort(libsVHDL), ['ieee', 'std_cell_lib', 'gtech', 'dware', 'dw07', 'dw06', 'dw05', 'dw02', 'dw01', 'dw04', 'std', 'ramlib', 'synopsys', 'dw03', 'des_system_lib']);"
        },
        {
          "text": "`topologicalSort(libsCustom)` should return `['base', 'c', 'd', 'b', 'a']`.",
          "testCode": "assert.deepEqual(topologicalSort(libsCustom), ['base', 'c', 'd', 'b', 'a']);"
        },
        {
          "text": "`topologicalSort` should ignore unorderable dependencies.",
          "testCode": "assert.deepEqual(topologicalSort(libsUnorderable), ['Base']);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302340,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\topological-sort.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const libsSimple =\n  `aaa bbb\n  bbb`;\n\nconst libsVHDL =\n  `des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\n  dw01             ieee dw01 dware gtech\n  dw02             ieee dw02 dware\n  dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\n  dw04             dw04 ieee dw01 dware gtech\n  dw05             dw05 ieee dware\n  dw06             dw06 ieee dware\n  dw07             ieee dware\n  dware            ieee dware\n  gtech            ieee gtech\n  ramlib           std ieee\n  std_cell_lib     ieee std_cell_lib\n  synopsys`;\n\nconst libsCustom =\n  `a b c d\n  b c d\n  d c\n  c base\n  base`;\n\nconst libsUnorderable =\n  `TestLib Base MainLib\n  MainLib TestLib\n  Base`;"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5951ed8945deab770972ae56",
      "title": "Towers of Hanoi",
      "challengeType": 1,
      "dashedName": "towers-of-hanoi",
      "description": "Solve the Towers of Hanoi problem. The number of objects will be given as the first parameter, followed by the strings used to identify each stack of objects. Create a nested array containing the list of moves, `[\"source\", \"destination\"]`.\n \nFor example, the parameters `(4, 'A', 'B', 'C')`, will result in nested array of moves `[['A', 'C'], ['B', 'A']]`, indicating that the 1st move was to move an object from stack `A` to `C` and the 2nd move was to move an object from stack `B` to `A`.",
      "instructions": "Write a function that returns the moves to stack the objects in a nested array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function towerOfHanoi(n, a, b, c) {\n\n  return [[]];\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function towerOfHanoi(n, a, b, c) {\n  const res = [];\n  towerOfHanoiHelper(n, a, c, b, res);\n  return res;\n}\n\nfunction towerOfHanoiHelper(n, a, b, c, res) {\n  if (n > 0) {\n    towerOfHanoiHelper(n - 1, a, c, b, res);\n    res.push([a, c]);\n    towerOfHanoiHelper(n - 1, b, a, c, res);\n  }\n}"
        }
      ],
      "tests": [
        {
          "text": "`towerOfHanoi` should be a function.",
          "testCode": "assert(typeof towerOfHanoi === 'function');"
        },
        {
          "text": "`towerOfHanoi(3, ...)` should return 7 moves.",
          "testCode": "assert(res3.length === 7);"
        },
        {
          "text": "`towerOfHanoi(3, 'A', 'B', 'C')` should return `[['A','B'], ['A','C'], ['B','C'], ['A','B'], ['C','A'], ['C','B'], ['A','B']]`.",
          "testCode": "assert.deepEqual(towerOfHanoi(3, 'A', 'B', 'C'), res3Moves);"
        },
        {
          "text": "`towerOfHanoi(5, \"X\", \"Y\", \"Z\")` 10th move should be Y -> X.",
          "testCode": "assert.deepEqual(res5[9], ['Y', 'X']);"
        },
        {
          "text": "`towerOfHanoi(7, 'A', 'B', 'C')` first ten moves should be `[['A','B'], ['A','C'], ['B','C'], ['A','B'], ['C','A'], ['C','B'], ['A','B'], ['A','C'], ['B','C'], ['B','A']]`",
          "testCode": "assert.deepEqual(towerOfHanoi(7, 'A', 'B', 'C').slice(0, 10), res7First10Moves);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302341,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\towers-of-hanoi.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const res3 = towerOfHanoi(3, 'A', 'B', 'C');\nconst res3Moves = [['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B']];\nconst res5 = towerOfHanoi(5, 'X', 'Y', 'Z');\nconst res7First10Moves = [['A', 'B'], ['A', 'C'], ['B', 'C'], ['A', 'B'], ['C', 'A'], ['C', 'B'], ['A', 'B'], ['A', 'C'], ['B', 'C'], ['B', 'A']];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad2",
      "title": "Vector cross product",
      "challengeType": 1,
      "dashedName": "vector-cross-product",
      "description": "A vector is defined as having three dimensions as being represented by an ordered collection of three numbers: (X, Y, Z).",
      "instructions": "Write a function that takes two vectors (arrays) as input and computes their cross product. Your function should return `null` on invalid inputs such as vectors of different lengths.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function crossProduct(a, b) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function crossProduct(a, b) {\n  if (!a || !b) {\n    return null;\n  }\n\n  // Check lengths\n  if (a.length !== 3 || b.length !== 3) {\n    return null;\n  }\n\n  return [\n    (a[1] * b[2]) - (a[2] * b[1]),\n    (a[2] * b[0]) - (a[0] * b[2]),\n    (a[0] * b[1]) - (a[1] * b[0])\n  ];\n}"
        }
      ],
      "tests": [
        {
          "text": "`crossProduct` should be a function.",
          "testCode": "assert.equal(typeof crossProduct, 'function');"
        },
        {
          "text": "`crossProduct()` should return null.",
          "testCode": "assert.equal(crossProduct(), null);"
        },
        {
          "text": "`crossProduct([1, 2, 3], [4, 5, 6])` should return `[-3, 6, -3]`.",
          "testCode": "assert.deepEqual(res12, exp12);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302342,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\vector-cross-product.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const tv1 = [1, 2, 3];\nconst tv2 = [4, 5, 6];\nconst res12 = crossProduct(tv1, tv2);\nconst exp12 = [-3, 6, -3];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad3",
      "title": "Vector dot product",
      "challengeType": 1,
      "dashedName": "vector-dot-product",
      "description": "A vector can have one or more values represented by an ordered collection. Examples could be (x), (x, y), or (x, y, z).",
      "instructions": "Write a function that takes two vectors (represented as one-dimensional arrays) as input and computes their dot product. Your function should return `null` on invalid inputs such as vectors of different lengths or passing anything other than two vectors.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function dotProduct(...vectors) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function dotProduct(...vectors) {\n  if (!vectors || !vectors.length || vectors.length > 2 || vectors[0].length !== vectors[1].length) {\n    return null;\n  }\n  const vectorLen = vectors[0].length;\n\n  let prod = 0;\n  let sum = 0;\n  let j = vectorLen;\n  let i = 2;\n  // Sum terms\n  while (j--) {\n    i = 2;\n    prod = 1;\n\n    while (i--) {\n      prod *= vectors[i][j];\n    }\n    sum += prod;\n  }\n  return sum;\n}"
        }
      ],
      "tests": [
        {
          "text": "`dotProduct` should be a function.",
          "testCode": "assert.equal(typeof dotProduct, 'function');"
        },
        {
          "text": "`dotProduct()` should return `null`.",
          "testCode": "assert.equal(dotProduct(), null);"
        },
        {
          "text": "`dotProduct([1], [1])` should return `1`.",
          "testCode": "assert.equal(dotProduct([1], [1]), 1);"
        },
        {
          "text": "`dotProduct([1], [1, 2])` should return `null`.",
          "testCode": "assert.equal(dotProduct([1], [1, 2]), null);"
        },
        {
          "text": "`dotProduct([1, 3, -5], [4, -2, -1])` should return `3`.",
          "testCode": "assert.equal(dotProduct([1, 3, -5], [4, -2, -1]), 3);"
        },
        {
          "text": "`dotProduct([3, 2, 1], [2, 4, 2], [5, 3, 1])` should return `null`.",
          "testCode": "assert.equal(dotProduct([3, 2, 1], [2, 4, 2], [5, 3, 1]), null);"
        },
        {
          "text": "`dotProduct([ 0, 3, 6, 9, 12 ], [ 0, 4, 8, 12, 16 ])` should return `360`.",
          "testCode": "assert.equal(dotProduct([ 0, 3, 6, 9, 12 ], [ 0, 4, 8, 12, 16 ]), 360);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302343,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\vector-dot-product.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "5e94a54cc7b022105bf0fd2c",
      "title": "Word frequency",
      "challengeType": 1,
      "dashedName": "word-frequency",
      "description": "Given a text string and an integer n, return the n most common words in the file (and the number of their occurrences) in decreasing frequency.",
      "instructions": "Write a function to count the occurrences of each word and return the n most commons words along with the number of their occurrences in decreasing frequency.\n\nThe function should return a 2D array with each of the elements in the following form: `[word, freq]`. `word` should be the lowercase version of the word and `freq` the number denoting the count.\n\nThe function should return an empty array, if no string is provided.\n\nThe function should be case insensitive, for example, the strings \"Hello\" and \"hello\" should be treated the same.\n\nYou can treat words that have special characters such as underscores, dashes, apostrophes, commas, etc., as distinct words.\n\nFor example, given the string \"Hello hello goodbye\", your function should return `[['hello', 2], ['goodbye', 1]]`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function wordFrequency(txt, n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function wordFrequency(txt, n) {\n  var words = txt.split(/\\s+/);\n  var wordCount = {};\n  words.forEach(word => {\n    if (word == '') {\n      return;\n    }\n    const lowerWord = word.toLowerCase();\n    wordCount[lowerWord] =\n      lowerWord in wordCount ? wordCount[lowerWord] + 1 : 1;\n  });\n\n  var wordsArray = [];\n  for (let [word, count] of Object.entries(wordCount)) {\n    wordsArray.push([word, count]);\n  }\n\n  wordsArray.sort((a, b) => {\n    if (a[1] !== b[1]) {\n      return b[1] - a[1];\n    } else if (a[0] !== b[0]) {\n      return a[0] < b[0] ? -1 : 1;\n    }\n    return 0;\n  });\n  return wordsArray.slice(0, n);\n}"
        }
      ],
      "tests": [
        {
          "text": "`wordFrequency` should be a function.",
          "testCode": "assert.isFunction(wordFrequency);"
        },
        {
          "text": "`wordFrequency` should return an array.",
          "testCode": "assert.isArray(wordFrequency('test'));"
        },
        {
          "text": "`wordFrequency(\"Hello hello world\", 2)` should return `[['hello', 2], ['world', 1]]`\n\n```js\nconst example_1 = 'Hello hello world';\nconst example_1_solution = [['hello', 2], ['world', 1]];\n\nassert.deepEqual(wordFrequency(example_1, 2), example_1_solution);\n```\n\n`wordFrequency(\"The quick brown fox jumped over the lazy dog\", 1)` should return `[['the', 2]]`\n\n```js\nconst example_2 = 'The quick brown fox jumped over the lazy dog';\nconst example_2_solution = [['the', 2]];\n\nassert.deepEqual(wordFrequency(example_2, 1), example_2_solution);\n```\n\n`wordFrequency(\"Opensource opensource open-source open source\", 1)` should return `[['opensource', 2]]`\n\n```js\nconst example_3 = 'Opensource opensource open-source open source';\nconst example_3_solution = [['opensource', 2]];\n\nassert.deepEqual(wordFrequency(example_3, 1), example_3_solution);\n```\n\n`wordFrequency(\"Apple App apply aPP aPPlE\", 3)` should return `[['app', 2], ['apple', 2], ['apply', 1]]` or `[['apple', 2], ['app', 2], ['apply', 1]]`\n\n```js\nconst example_4 = 'Apple App apply aPP aPPlE';\nconst example_4_solution = [[\"app\", 2],[\"apple\", 2],[\"apply\", 1]];\n\nconst arr = wordFrequency(example_4, 3);\nassert.includeDeepMembers(arr, example_4_solution);\n```\n\n`wordFrequency(\"c d a d c a b d d c\", 4)` should return `[['d', 4], ['c', 3], ['a', 2], ['b', 1]]`\n\n```js\nconst example_5 = 'c d a d c a b d d c';\nconst example_5_solution = [['d', 4], ['c', 3], ['a', 2], ['b', 1]];\n\nassert.deepEqual(wordFrequency(example_5, 4), example_5_solution);\n```\n\n`wordFrequency(\"\", 5)` should return `[]`\n\n```js\nconst example_6 = '';\nconst example_6_solution = [];\n\nassert.deepEqual(wordFrequency(example_6, 5), example_6_solution);\n```",
          "testCode": ""
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 393913,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\word-frequency.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad4",
      "title": "Word wrap",
      "challengeType": 1,
      "dashedName": "word-wrap",
      "description": "Even today, with proportional fonts and complex layouts, there are still cases where you need to wrap text at a specified column. The basic task is to wrap a paragraph of text in a simple way.",
      "instructions": "Write a function that can wrap this text to any number of characters. Note that the input text already contains line breaks, which your function should handle appropriately. As an example, the text wrapped to 80 characters should look like the following:\n\n<pre>\nWrap text using a more sophisticated algorithm such as the Knuth and Plass TeX\nalgorithm. If your language provides this, you get easy extra credit, but you\nmust reference documentation indicating that the algorithm is something better\nthan a simple minimum length algorithm.\n</pre>",
      "boilerplate": [
        {
          "language": "js",
          "code": "function wrap(text, limit) {\n  return text;\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function wrap(text, limit) {\n  const noNewlines = text.replace('\\n', '');\n  if (noNewlines.length > limit) {\n    // find the last space within limit\n    const edge = noNewlines.slice(0, limit).lastIndexOf(' ');\n    if (edge > 0) {\n      const line = noNewlines.slice(0, edge);\n      const remainder = noNewlines.slice(edge + 1);\n      return line + '\\n' + wrap(remainder, limit);\n    }\n  }\n  return text;\n}"
        }
      ],
      "tests": [
        {
          "text": "`wrap` should be a function.",
          "testCode": "assert.equal(typeof wrap, 'function');"
        },
        {
          "text": "`wrap` should return a string.",
          "testCode": "assert.equal(typeof wrap('abc', 10), 'string');"
        },
        {
          "text": "`wrap(text,80)` should return 4 lines.",
          "testCode": "assert(wrapped80.split('\\n').length === 4);"
        },
        {
          "text": "Your `wrap` function should return the expected text.",
          "testCode": "assert.equal(wrapped80.split('\\n')[0], firstRow80);"
        },
        {
          "text": "`wrap(text,42)` should return 7 lines.",
          "testCode": "assert(wrapped42.split('\\n').length === 7);"
        },
        {
          "text": "Your `wrap` function should return the expected text.",
          "testCode": "assert.equal(wrapped42.split('\\n')[0], firstRow42);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302344,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\word-wrap.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const text =\n`Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX algorithm.\nIf your language provides this, you get easy extra credit,\nbut you ''must reference documentation'' indicating that the algorithm\nis something better than a simple minimum length algorithm.`;\n\nconst wrapped80 = wrap(text, 80);\nconst wrapped42 = wrap(text, 42);\n\nconst firstRow80 =\n    'Wrap text using a more sophisticated algorithm such as the Knuth and Plass TeX';\n\nconst firstRow42 = 'Wrap text using a more sophisticated';"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad5",
      "title": "Y combinator",
      "challengeType": 1,
      "dashedName": "y-combinator",
      "description": "In strict <a href=\"https://www.freecodecamp.org/news/the-principles-of-functional-programming/\" target=\"_blank\" rel=\"noopener noreferrer nofollow\">functional programming</a> and the lambda calculus, functions (lambda expressions) don't have state and are only allowed to refer to arguments of enclosing functions. This rules out the usual definition of a recursive function wherein a function is associated with the state of a variable and this variable's state is used in the body of the function.\n\nThe Y combinator is itself a stateless function that, when applied to another stateless function, returns a recursive version of the function. The Y combinator is the simplest of the class of such functions, called fixed-point combinators.",
      "instructions": "Define the stateless Y combinator function and use it to compute the factorials. The `factorial(N)` function is already given to you.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function Y(f) {\n  return function() {\n\n  };\n}\n\nvar factorial = Y(function(f) {\n  return function (n) {\n    return n > 1 ? n * f(n - 1) : 1;\n  };\n});"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "var Y = f => (x => x(x))(y => f(x => y(y)(x)));"
        }
      ],
      "tests": [
        {
          "text": "Y should return a function.",
          "testCode": "assert.equal(typeof Y((f) => (n) => n), 'function');"
        },
        {
          "text": "factorial(1) should return 1.",
          "testCode": "assert.equal(factorial(1), 1);"
        },
        {
          "text": "factorial(2) should return 2.",
          "testCode": "assert.equal(factorial(2), 2);"
        },
        {
          "text": "factorial(3) should return 6.",
          "testCode": "assert.equal(factorial(3), 6);"
        },
        {
          "text": "factorial(4) should return 24.",
          "testCode": "assert.equal(factorial(4), 24);"
        },
        {
          "text": "factorial(10) should return 3628800.",
          "testCode": "assert.equal(factorial(10), 3628800);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302345,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\y-combinator.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "var factorial = Y(f => n => (n > 1 ? n * f(n - 1) : 1));"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad6",
      "title": "Zeckendorf number representation",
      "challengeType": 1,
      "dashedName": "zeckendorf-number-representation",
      "description": "Just as numbers can be represented in a positional notation as sums of multiples of the powers of ten (decimal) or two (binary); all the positive integers can be represented as the sum of one or zero times the distinct members of the Fibonacci series. Recall that the first six distinct Fibonacci numbers are: `1, 2, 3, 5, 8, 13`.\n\nThe decimal number eleven can be written as `0*13 + 1*8 + 0*5 + 1*3 + 0*2 + 0*1` or `010100` in positional notation where the columns represent multiplication by a particular member of the sequence. Leading zeroes are dropped so that 11 decimal becomes `10100`. 10100 is not the only way to make 11 from the Fibonacci numbers however `0*13 + 1*8 + 0*5 + 0*3 + 1*2 + 1*1` or 010011 would also represent decimal 11. For a true Zeckendorf number there is the added restriction that *no two consecutive Fibonacci numbers can be used* which leads to the former unique solution.",
      "instructions": "Write a function that generates and returns the Zeckendorf number representation of `n`.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function zeckendorf(n) {\n\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "// zeckendorf :: Int -> Int\nfunction zeckendorf(n) {\n  const f = (m, x) => (m < x ? [m, 0] : [m - x, 1]);\n  return parseInt((n === 0 ? ([0]) :\n    mapAccumL(f, n, reverse(\n      tail(fibUntil(n))\n    ))[1]).join(''));\n}\n\n// fibUntil :: Int -> [Int]\nlet fibUntil = n => {\n  const xs = [];\n  until(\n      ([a]) => a > n,\n      ([a, b]) => (xs.push(a), [b, a + b]), [1, 1]\n  );\n  return xs;\n};\n\nlet mapAccumL = (f, acc, xs) => (\n  xs.reduce((a, x) => {\n    const pair = f(a[0], x);\n\n    return [pair[0], a[1].concat(pair[1])];\n  }, [acc, []])\n);\n\nlet until = (p, f, x) => {\n  let v = x;\n  while (!p(v)) v = f(v);\n  return v;\n};\n\nconst tail = xs => (\n   xs.length ? xs.slice(1) : undefined\n);\n\nconst reverse = xs => xs.slice(0).reverse();"
        }
      ],
      "tests": [
        {
          "text": "`zeckendorf` should be a function.",
          "testCode": "assert.equal(typeof zeckendorf, 'function');"
        },
        {
          "text": "`zeckendorf(0)` should return `0`.\n\n```js\nassert.equal(zeckendorf(0), 0);\n\n```\n\n`zeckendorf(1)` should return `1`.",
          "testCode": "assert.equal(zeckendorf(1), 1);"
        },
        {
          "text": "`zeckendorf(2)` should return `10`.",
          "testCode": "assert.equal(zeckendorf(2), 10);"
        },
        {
          "text": "`zeckendorf(3)` should return `100`.",
          "testCode": "assert.equal(zeckendorf(3), 100);"
        },
        {
          "text": "`zeckendorf(4)` should return `101`.",
          "testCode": "assert.equal(zeckendorf(4), 101);"
        },
        {
          "text": "`zeckendorf(5)` should return `1000`.",
          "testCode": "assert.equal(zeckendorf(5), 1000);"
        },
        {
          "text": "`zeckendorf(6)` should return `1001`.",
          "testCode": "assert.equal(zeckendorf(6), 1001);"
        },
        {
          "text": "`zeckendorf(7)` should return `1010`.",
          "testCode": "assert.equal(zeckendorf(7), 1010);"
        },
        {
          "text": "`zeckendorf(8)` should return `10000`.",
          "testCode": "assert.equal(zeckendorf(8), 10000);"
        },
        {
          "text": "`zeckendorf(9)` should return `10001`.",
          "testCode": "assert.equal(zeckendorf(9), 10001);"
        },
        {
          "text": "`zeckendorf(10)` should return `10010`.",
          "testCode": "assert.equal(zeckendorf(10), 10010);"
        },
        {
          "text": "`zeckendorf(11)` should return `10100`.",
          "testCode": "assert.equal(zeckendorf(11), 10100);"
        },
        {
          "text": "`zeckendorf(12)` should return `10101`.",
          "testCode": "assert.equal(zeckendorf(12), 10101);"
        },
        {
          "text": "`zeckendorf(13)` should return `100000`.",
          "testCode": "assert.equal(zeckendorf(13), 100000);"
        },
        {
          "text": "`zeckendorf(14)` should return `100001`.",
          "testCode": "assert.equal(zeckendorf(14), 100001);"
        },
        {
          "text": "`zeckendorf(15)` should return `100010`.",
          "testCode": "assert.equal(zeckendorf(15), 100010);"
        },
        {
          "text": "`zeckendorf(16)` should return `100100`.",
          "testCode": "assert.equal(zeckendorf(16), 100100);"
        },
        {
          "text": "`zeckendorf(17)` should return `100101`.",
          "testCode": "assert.equal(zeckendorf(17), 100101);"
        },
        {
          "text": "`zeckendorf(18)` should return `101000`.",
          "testCode": "assert.equal(zeckendorf(18), 101000);"
        },
        {
          "text": "`zeckendorf(19)` should return `101001`.",
          "testCode": "assert.equal(zeckendorf(19), 101001);"
        },
        {
          "text": "`zeckendorf(20)` should return `101010`.",
          "testCode": "assert.equal(zeckendorf(20), 101010);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302346,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\zeckendorf-number-representation.md"
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad7",
      "title": "Zhang-Suen thinning algorithm",
      "challengeType": 1,
      "dashedName": "zhang-suen-thinning-algorithm",
      "description": "This is an algorithm used to thin a black and white i.e. one bit per pixel images. For example, with an input image of:\n\n```js\nconst testImage1 = [\n '                               ',\n '#########       ########       ',\n '###   ####     ####  ####      ',\n '###    ###     ###    ###      ',\n '###   ####     ###             ',\n '#########      ###             ',\n '### ####       ###    ###      ',\n '###  ####  ### ####  #### ###  ',\n '###   #### ###  ########  ###  ',\n '                               '\n];\n```\n\nIt produces the thinned output:\n\n```js\n[ '                               ',\n  '########         ######        ',\n  '#      #        ##             ',\n  '#       #       #              ',\n  '#      #        #              ',\n  '###### #        #              ',\n  '#     ##        #              ',\n  '#      #    #   ##    ##   #   ',\n  '#       #         ####         ',\n  '                               ' ];\n```\n\n## Algorithm\n\nAssume black pixels are one and white pixels zero, and that the input image is a rectangular N by M array of ones and zeroes. The algorithm operates on all black pixels P1 that can have eight neighbors. The neighbors are, in order, arranged as:\n\n$$\\begin{array}{|c|c|c|}\n  \\\\hline\n  P9 & P2              & P3\\\\\\\\ \\\\hline\n  P8 & \\boldsymbol{P1} & P4\\\\\\\\ \\\\hline\n  P7 & P6              & P5\\\\\\\\ \\\\hline\n\\end{array}$$\n\nObviously the boundary pixels of the image cannot have the full eight neighbors.\n\n- Define $A(P1)$ = the number of transitions from white to black, ($0 \\to 1$) in the sequence P2, P3, P4, P5, P6, P7, P8, P9, P2. (Note the extra P2 at the end - it is circular).\n- Define $B(P1)$ = the number of black pixel neighbors of P1. ($= \\\\sum(P2 \\ldots P9)$)\n\n**Step 1:**\n\nAll pixels are tested and pixels satisfying all the following conditions (simultaneously) are just noted at this stage.\n\n1. The pixel is black and has eight neighbors\n2. $2 \\le B(P1) \\le 6$\n3. $A(P1) = 1$\n4. At least one of $P2$, $P4$ and $P6$ is white\n5. At least one of $P4$, $P6$ and $P8$ is white\n\nAfter iterating over the image and collecting all the pixels satisfying all step 1 conditions, all these condition satisfying pixels are set to white.\n\n**Step 2:**\n\nAll pixels are again tested and pixels satisfying all the following conditions are just noted at this stage.\n\n1. The pixel is black and has eight neighbors\n2. $2 \\le B(P1) \\le 6$\n3. $A(P1) = 1$\n4. At least one of $P2$, $P4$ and $P8$ is white\n5. At least one of $P2$, $P6$ and $P8$ is white\n\nAfter iterating over the image and collecting all the pixels satisfying all step 2 conditions, all these condition satisfying pixels are again set to white.\n\n**Iteration:**\n\nIf any pixels were set in this round of either step 1 or step 2 then all steps are repeated until no image pixels are so changed.",
      "instructions": "Write a routine to perform Zhang-Suen thinning on the provided `image`, an array of strings, where each string represents single line of the image. In the string, `#` represents black pixel, and whitespace represents white pixel. Function should return thinned image, using the same representation.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function thinImage(image) {\n\n}\n\nconst testImage1 = [\n  '                               ',\n  '#########       ########       ',\n  '###   ####     ####  ####      ',\n  '###    ###     ###    ###      ',\n  '###   ####     ###             ',\n  '#########      ###             ',\n  '### ####       ###    ###      ',\n  '###  ####  ### ####  #### ###  ',\n  '###   #### ###  ########  ###  ',\n  '                               '\n];"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function Point(x, y) {\n  this.x = x;\n  this.y = y;\n}\n\nconst ZhangSuen = (function () {\n  function ZhangSuen() {\n  }\n\n  ZhangSuen.nbrs = [[0, -1], [1, -1], [1, 0], [1, 1], [0, 1], [-1, 1], [-1, 0], [-1, -1], [0, -1]];\n\n  ZhangSuen.nbrGroups = [[[0, 2, 4], [2, 4, 6]], [[0, 2, 6], [0, 4, 6]]];\n\n  ZhangSuen.toWhite = [];\n\n  ZhangSuen.main = function (image) {\n    ZhangSuen.grid = new Array(image);\n    for (let r = 0; r < image.length; r++) {\n      ZhangSuen.grid[r] = image[r].split('');\n    }\n    ZhangSuen.thinImage();\n    return ZhangSuen.getResult();\n  };\n\n  ZhangSuen.thinImage = function () {\n    let firstStep = false;\n    let hasChanged;\n    do {\n      hasChanged = false;\n      firstStep = !firstStep;\n      for (let r = 1; r < ZhangSuen.grid.length - 1; r++) {\n        for (let c = 1; c < ZhangSuen.grid[0].length - 1; c++) {\n          if (ZhangSuen.grid[r][c] !== '#') {\n            continue;\n          }\n          const nn = ZhangSuen.numNeighbors(r, c);\n          if (nn < 2 || nn > 6) {\n            continue;\n          }\n          if (ZhangSuen.numTransitions(r, c) !== 1) {\n            continue;\n          }\n          if (!ZhangSuen.atLeastOneIsWhite(r, c, firstStep ? 0 : 1)) {\n            continue;\n          }\n          ZhangSuen.toWhite.push(new Point(c, r));\n          hasChanged = true;\n        }\n      }\n      for (let i = 0; i < ZhangSuen.toWhite.length; i++) {\n        const p = ZhangSuen.toWhite[i];\n        ZhangSuen.grid[p.y][p.x] = ' ';\n      }\n      ZhangSuen.toWhite = [];\n    } while ((firstStep || hasChanged));\n  };\n\n  ZhangSuen.numNeighbors = function (r, c) {\n    let count = 0;\n    for (let i = 0; i < ZhangSuen.nbrs.length - 1; i++) {\n      if (ZhangSuen.grid[r + ZhangSuen.nbrs[i][1]][c + ZhangSuen.nbrs[i][0]] === '#') {\n        count++;\n      }\n    }\n    return count;\n  };\n\n  ZhangSuen.numTransitions = function (r, c) {\n    let count = 0;\n    for (let i = 0; i < ZhangSuen.nbrs.length - 1; i++) {\n      if (ZhangSuen.grid[r + ZhangSuen.nbrs[i][1]][c + ZhangSuen.nbrs[i][0]] === ' ') {\n        if (ZhangSuen.grid[r + ZhangSuen.nbrs[i + 1][1]][c + ZhangSuen.nbrs[i + 1][0]] === '#') {\n          count++;\n        }\n      }\n    }\n    return count;\n  };\n\n  ZhangSuen.atLeastOneIsWhite = function (r, c, step) {\n    let count = 0;\n    const group = ZhangSuen.nbrGroups[step];\n    for (let i = 0; i < 2; i++) {\n      for (let j = 0; j < group[i].length; j++) {\n        const nbr = ZhangSuen.nbrs[group[i][j]];\n        if (ZhangSuen.grid[r + nbr[1]][c + nbr[0]] === ' ') {\n          count++;\n          break;\n        }\n      }\n    }\n    return count > 1;\n  };\n\n  ZhangSuen.getResult = function () {\n    const result = [];\n    for (let i = 0; i < ZhangSuen.grid.length; i++) {\n      const row = ZhangSuen.grid[i].join('');\n      result.push(row);\n    }\n    return result;\n  };\n  return ZhangSuen;\n}());\n\nfunction thinImage(image) {\n  return ZhangSuen.main(image);\n}"
        }
      ],
      "tests": [
        {
          "text": "`thinImage` should be a function.",
          "testCode": "assert.equal(typeof thinImage, 'function');"
        },
        {
          "text": "`thinImage` should return an array.",
          "testCode": "assert(Array.isArray(thinImage(_testImage1)));"
        },
        {
          "text": "`thinImage` should return an array of strings.",
          "testCode": "assert.equal(typeof thinImage(_testImage1)[0], 'string');"
        },
        {
          "text": "`thinImage(testImage1)` should return a thinned image as in the example.",
          "testCode": "assert.deepEqual(thinImage(_testImage1), expected1);"
        },
        {
          "text": "`thinImage(testImage2)` should return a thinned image.",
          "testCode": "assert.deepEqual(thinImage(_testImage2), expected2);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302347,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\zhang-suen-thinning-algorithm.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const _testImage1 = [\n  '                               ',\n  '#########       ########       ',\n  '###   ####     ####  ####      ',\n  '###    ###     ###    ###      ',\n  '###   ####     ###             ',\n  '#########      ###             ',\n  '### ####       ###    ###      ',\n  '###  ####  ### ####  #### ###  ',\n  '###   #### ###  ########  ###  ',\n  '                               '\n];\nconst expected1 = [\n  '                               ',\n  '########         ######        ',\n  '#      #        ##             ',\n  '#       #       #              ',\n  '#      #        #              ',\n  '###### #        #              ',\n  '#     ##        #              ',\n  '#      #    #   ##    ##   #   ',\n  '#       #         ####         ',\n  '                               '\n];\nconst _testImage2 = [\n  '                                                          ',\n  ' #################                   #############        ',\n  ' ##################               ################        ',\n  ' ###################            ##################        ',\n  ' ########     #######          ###################        ',\n  '   ######     #######         #######       ######        ',\n  '   ######     #######        #######                      ',\n  '   #################         #######                      ',\n  '   ################          #######                      ',\n  '   #################         #######                      ',\n  '   ######     #######        #######                      ',\n  '   ######     #######        #######                      ',\n  '   ######     #######         #######       ######        ',\n  ' ########     #######          ###################        ',\n  ' ########     ####### ######    ################## ###### ',\n  ' ########     ####### ######      ################ ###### ',\n  ' ########     ####### ######         ############# ###### ',\n  '                                                          '];\nconst expected2 = [\n  '                                                          ',\n  '                                                          ',\n  '    # ##########                       #######            ',\n  '     ##        #                   ####       #           ',\n  '     #          #                 ##                      ',\n  '     #          #                #                        ',\n  '     #          #                #                        ',\n  '     #          #                #                        ',\n  '     ############               #                         ',\n  '     #          #               #                         ',\n  '     #          #                #                        ',\n  '     #          #                #                        ',\n  '     #          #                #                        ',\n  '     #                            ##                      ',\n  '     #                             ############           ',\n  '                       ###                          ###   ',\n  '                                                          ',\n  '                                                          '\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    },
    {
      "id": "594810f028c0303b75339ad8",
      "title": "Zig-zag matrix",
      "challengeType": 1,
      "dashedName": "zig-zag-matrix",
      "description": "A 'zig-zag' array is a square arrangement of the first $N^2$ integers, where the numbers increase sequentially as you zig-zag along the array's anti-diagonals.\n\nFor example, for the input `5`, the following result should be produced:\n\n<pre>\n 0  1  5  6 14\n 2  4  7 13 15\n 3  8 12 16 21\n 9 11 17 20 22\n10 18 19 23 24\n</pre>",
      "instructions": "Write a function that takes the size of the zig-zag matrix, and returns the corresponding matrix as two-dimensional array.",
      "boilerplate": [
        {
          "language": "js",
          "code": "function ZigZagMatrix(n) {\n\n  return [[], []];\n}"
        }
      ],
      "solution": [
        {
          "language": "js",
          "code": "function ZigZagMatrix(n) {\n  const mtx = [];\n  for (let i = 0; i < n; i++) {\n    mtx[i] = [];\n  }\n\n  let i = 1;\n  let j = 1;\n  for (let e = 0; e < n * n; e++) {\n    mtx[i - 1][j - 1] = e;\n    if ((i + j) % 2 === 0) {\n      // Even stripes\n      if (j < n) j++;\n      else i += 2;\n      if (i > 1) i--;\n    } else {\n      // Odd stripes\n      if (i < n) i++;\n      else j += 2;\n      if (j > 1) j--;\n    }\n  }\n  return mtx;\n}"
        }
      ],
      "tests": [
        {
          "text": "ZigZagMatrix should be a function.",
          "testCode": "assert.equal(typeof ZigZagMatrix, 'function');"
        },
        {
          "text": "ZigZagMatrix should return array.",
          "testCode": "assert.equal(typeof ZigZagMatrix(1), 'object');"
        },
        {
          "text": "ZigZagMatrix should return an array of nested arrays.",
          "testCode": "assert.equal(typeof ZigZagMatrix(1)[0], 'object');"
        },
        {
          "text": "ZigZagMatrix(1) should return \\[[0]].",
          "testCode": "assert.deepEqual(ZigZagMatrix(1), zm1);"
        },
        {
          "text": "ZigZagMatrix(2) should return \\[[0, 1], [2, 3]].",
          "testCode": "assert.deepEqual(ZigZagMatrix(2), zm2);"
        },
        {
          "text": "ZigZagMatrix(5) should return specified matrix.",
          "testCode": "assert.deepEqual(ZigZagMatrix(5), zm5);"
        }
      ],
      "metadata": {
        "videoUrl": "",
        "forumTopicId": 302348,
        "filePath": "freeCodeCamp\\curriculum\\challenges\\english\\22-rosetta-code\\rosetta-code-challenges\\zig-zag-matrix.md"
      },
      "additionalCode": {
        "afterUserCode": [
          {
            "language": "js",
            "code": "const zm1 = [[0]];\nconst zm2 = [[0, 1], [2, 3]];\nconst zm5 = [\n  [0, 1, 5, 6, 14],\n  [2, 4, 7, 13, 15],\n  [3, 8, 12, 16, 21],\n  [9, 11, 17, 20, 22],\n  [10, 18, 19, 23, 24]\n];"
          }
        ]
      },
      "section": {
        "id": "22-rosetta-code",
        "name": "22-rosetta-code"
      },
      "lesson": {
        "id": "rosetta-code-challenges",
        "name": "Rosetta Code Challenges"
      }
    }
  ],
  "metadata": {
    "total_challenges": 160,
    "challenges_with_content": 160
  }
}